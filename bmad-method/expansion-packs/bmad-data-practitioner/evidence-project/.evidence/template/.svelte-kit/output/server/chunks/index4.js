import * as $4S4dR$path1 from "path";
import $4S4dR$path1__default from "path";
import fs, { readFileSync } from "fs";
import $4S4dR$util from "util";
import { URL as URL$1 } from "url";
import { release } from "os";
import { isatty } from "tty";
var $parcel$global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, { get: v, set: s, enumerable: true, configurable: true });
}
function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
var $parcel$modules = {};
var $parcel$inits = {};
var parcelRequire = $parcel$global["parcelRequire94c2"];
if (parcelRequire == null) {
  parcelRequire = function(id) {
    if (id in $parcel$modules) {
      return $parcel$modules[id].exports;
    }
    if (id in $parcel$inits) {
      var init = $parcel$inits[id];
      delete $parcel$inits[id];
      var module = { id, exports: {} };
      $parcel$modules[id] = module;
      init.call(module.exports, module, module.exports);
      return module.exports;
    }
    var err = new Error("Cannot find module '" + id + "'");
    err.code = "MODULE_NOT_FOUND";
    throw err;
  };
  parcelRequire.register = function register(id, init) {
    $parcel$inits[id] = init;
  };
  $parcel$global["parcelRequire94c2"] = parcelRequire;
}
parcelRequire.register("4bc8D", function(module, exports) {
  module.exports = JSON.parse(`{"core":{"meta":{"path":"components/prism-core.js","option":"mandatory"},"core":"Core"},"themes":{"meta":{"path":"themes/{id}.css","link":"index.html?theme={id}","exclusive":true},"prism":{"title":"Default","option":"default"},"prism-dark":"Dark","prism-funky":"Funky","prism-okaidia":{"title":"Okaidia","owner":"ocodia"},"prism-twilight":{"title":"Twilight","owner":"remybach"},"prism-coy":{"title":"Coy","owner":"tshedor"},"prism-solarizedlight":{"title":"Solarized Light","owner":"hectormatos2011 "},"prism-tomorrow":{"title":"Tomorrow Night","owner":"Rosey"}},"languages":{"meta":{"path":"components/prism-{id}","noCSS":true,"examplesPath":"examples/prism-{id}","addCheckAll":true},"markup":{"title":"Markup","alias":["html","xml","svg","mathml","ssml","atom","rss"],"aliasTitles":{"html":"HTML","xml":"XML","svg":"SVG","mathml":"MathML","ssml":"SSML","atom":"Atom","rss":"RSS"},"option":"default"},"css":{"title":"CSS","option":"default","modify":"markup"},"clike":{"title":"C-like","option":"default"},"javascript":{"title":"JavaScript","require":"clike","modify":"markup","optional":"regex","alias":"js","option":"default"},"abap":{"title":"ABAP","owner":"dellagustin"},"abnf":{"title":"ABNF","owner":"RunDevelopment"},"actionscript":{"title":"ActionScript","require":"javascript","modify":"markup","owner":"Golmote"},"ada":{"title":"Ada","owner":"Lucretia"},"agda":{"title":"Agda","owner":"xy-ren"},"al":{"title":"AL","owner":"RunDevelopment"},"antlr4":{"title":"ANTLR4","alias":"g4","owner":"RunDevelopment"},"apacheconf":{"title":"Apache Configuration","owner":"GuiTeK"},"apex":{"title":"Apex","require":["clike","sql"],"owner":"RunDevelopment"},"apl":{"title":"APL","owner":"ngn"},"applescript":{"title":"AppleScript","owner":"Golmote"},"aql":{"title":"AQL","owner":"RunDevelopment"},"arduino":{"title":"Arduino","require":"cpp","alias":"ino","owner":"dkern"},"arff":{"title":"ARFF","owner":"Golmote"},"armasm":{"title":"ARM Assembly","alias":"arm-asm","owner":"RunDevelopment"},"arturo":{"title":"Arturo","alias":"art","optional":["bash","css","javascript","markup","markdown","sql"],"owner":"drkameleon"},"asciidoc":{"alias":"adoc","title":"AsciiDoc","owner":"Golmote"},"aspnet":{"title":"ASP.NET (C#)","require":["markup","csharp"],"owner":"nauzilus"},"asm6502":{"title":"6502 Assembly","owner":"kzurawel"},"asmatmel":{"title":"Atmel AVR Assembly","owner":"cerkit"},"autohotkey":{"title":"AutoHotkey","owner":"aviaryan"},"autoit":{"title":"AutoIt","owner":"Golmote"},"avisynth":{"title":"AviSynth","alias":"avs","owner":"Zinfidel"},"avro-idl":{"title":"Avro IDL","alias":"avdl","owner":"RunDevelopment"},"awk":{"title":"AWK","alias":"gawk","aliasTitles":{"gawk":"GAWK"},"owner":"RunDevelopment"},"bash":{"title":"Bash","alias":["sh","shell"],"aliasTitles":{"sh":"Shell","shell":"Shell"},"owner":"zeitgeist87"},"basic":{"title":"BASIC","owner":"Golmote"},"batch":{"title":"Batch","owner":"Golmote"},"bbcode":{"title":"BBcode","alias":"shortcode","aliasTitles":{"shortcode":"Shortcode"},"owner":"RunDevelopment"},"bbj":{"title":"BBj","owner":"hyyan"},"bicep":{"title":"Bicep","owner":"johnnyreilly"},"birb":{"title":"Birb","require":"clike","owner":"Calamity210"},"bison":{"title":"Bison","require":"c","owner":"Golmote"},"bnf":{"title":"BNF","alias":"rbnf","aliasTitles":{"rbnf":"RBNF"},"owner":"RunDevelopment"},"bqn":{"title":"BQN","owner":"yewscion"},"brainfuck":{"title":"Brainfuck","owner":"Golmote"},"brightscript":{"title":"BrightScript","owner":"RunDevelopment"},"bro":{"title":"Bro","owner":"wayward710"},"bsl":{"title":"BSL (1C:Enterprise)","alias":"oscript","aliasTitles":{"oscript":"OneScript"},"owner":"Diversus23"},"c":{"title":"C","require":"clike","owner":"zeitgeist87"},"csharp":{"title":"C#","require":"clike","alias":["cs","dotnet"],"owner":"mvalipour"},"cpp":{"title":"C++","require":"c","owner":"zeitgeist87"},"cfscript":{"title":"CFScript","require":"clike","alias":"cfc","owner":"mjclemente"},"chaiscript":{"title":"ChaiScript","require":["clike","cpp"],"owner":"RunDevelopment"},"cil":{"title":"CIL","owner":"sbrl"},"cilkc":{"title":"Cilk/C","require":"c","alias":"cilk-c","owner":"OpenCilk"},"cilkcpp":{"title":"Cilk/C++","require":"cpp","alias":["cilk-cpp","cilk"],"owner":"OpenCilk"},"clojure":{"title":"Clojure","owner":"troglotit"},"cmake":{"title":"CMake","owner":"mjrogozinski"},"cobol":{"title":"COBOL","owner":"RunDevelopment"},"coffeescript":{"title":"CoffeeScript","require":"javascript","alias":"coffee","owner":"R-osey"},"concurnas":{"title":"Concurnas","alias":"conc","owner":"jasontatton"},"csp":{"title":"Content-Security-Policy","owner":"ScottHelme"},"cooklang":{"title":"Cooklang","owner":"ahue"},"coq":{"title":"Coq","owner":"RunDevelopment"},"crystal":{"title":"Crystal","require":"ruby","owner":"MakeNowJust"},"css-extras":{"title":"CSS Extras","require":"css","modify":"css","owner":"milesj"},"csv":{"title":"CSV","owner":"RunDevelopment"},"cue":{"title":"CUE","owner":"RunDevelopment"},"cypher":{"title":"Cypher","owner":"RunDevelopment"},"d":{"title":"D","require":"clike","owner":"Golmote"},"dart":{"title":"Dart","require":"clike","owner":"Golmote"},"dataweave":{"title":"DataWeave","owner":"machaval"},"dax":{"title":"DAX","owner":"peterbud"},"dhall":{"title":"Dhall","owner":"RunDevelopment"},"diff":{"title":"Diff","owner":"uranusjr"},"django":{"title":"Django/Jinja2","require":"markup-templating","alias":"jinja2","owner":"romanvm"},"dns-zone-file":{"title":"DNS zone file","owner":"RunDevelopment","alias":"dns-zone"},"docker":{"title":"Docker","alias":"dockerfile","owner":"JustinBeckwith"},"dot":{"title":"DOT (Graphviz)","alias":"gv","optional":"markup","owner":"RunDevelopment"},"ebnf":{"title":"EBNF","owner":"RunDevelopment"},"editorconfig":{"title":"EditorConfig","owner":"osipxd"},"eiffel":{"title":"Eiffel","owner":"Conaclos"},"ejs":{"title":"EJS","require":["javascript","markup-templating"],"owner":"RunDevelopment","alias":"eta","aliasTitles":{"eta":"Eta"}},"elixir":{"title":"Elixir","owner":"Golmote"},"elm":{"title":"Elm","owner":"zwilias"},"etlua":{"title":"Embedded Lua templating","require":["lua","markup-templating"],"owner":"RunDevelopment"},"erb":{"title":"ERB","require":["ruby","markup-templating"],"owner":"Golmote"},"erlang":{"title":"Erlang","owner":"Golmote"},"excel-formula":{"title":"Excel Formula","alias":["xlsx","xls"],"owner":"RunDevelopment"},"fsharp":{"title":"F#","require":"clike","owner":"simonreynolds7"},"factor":{"title":"Factor","owner":"catb0t"},"false":{"title":"False","owner":"edukisto"},"firestore-security-rules":{"title":"Firestore security rules","require":"clike","owner":"RunDevelopment"},"flow":{"title":"Flow","require":"javascript","owner":"Golmote"},"fortran":{"title":"Fortran","owner":"Golmote"},"ftl":{"title":"FreeMarker Template Language","require":"markup-templating","owner":"RunDevelopment"},"gml":{"title":"GameMaker Language","alias":"gamemakerlanguage","require":"clike","owner":"LiarOnce"},"gap":{"title":"GAP (CAS)","owner":"RunDevelopment"},"gcode":{"title":"G-code","owner":"RunDevelopment"},"gdscript":{"title":"GDScript","owner":"RunDevelopment"},"gedcom":{"title":"GEDCOM","owner":"Golmote"},"gettext":{"title":"gettext","alias":"po","owner":"RunDevelopment"},"gherkin":{"title":"Gherkin","owner":"hason"},"git":{"title":"Git","owner":"lgiraudel"},"glsl":{"title":"GLSL","require":"c","owner":"Golmote"},"gn":{"title":"GN","alias":"gni","owner":"RunDevelopment"},"linker-script":{"title":"GNU Linker Script","alias":"ld","owner":"RunDevelopment"},"go":{"title":"Go","require":"clike","owner":"arnehormann"},"go-module":{"title":"Go module","alias":"go-mod","owner":"RunDevelopment"},"gradle":{"title":"Gradle","require":"clike","owner":"zeabdelkhalek-badido18"},"graphql":{"title":"GraphQL","optional":"markdown","owner":"Golmote"},"groovy":{"title":"Groovy","require":"clike","owner":"robfletcher"},"haml":{"title":"Haml","require":"ruby","optional":["css","css-extras","coffeescript","erb","javascript","less","markdown","scss","textile"],"owner":"Golmote"},"handlebars":{"title":"Handlebars","require":"markup-templating","alias":["hbs","mustache"],"aliasTitles":{"mustache":"Mustache"},"owner":"Golmote"},"haskell":{"title":"Haskell","alias":"hs","owner":"bholst"},"haxe":{"title":"Haxe","require":"clike","optional":"regex","owner":"Golmote"},"hcl":{"title":"HCL","owner":"outsideris"},"hlsl":{"title":"HLSL","require":"c","owner":"RunDevelopment"},"hoon":{"title":"Hoon","owner":"matildepark"},"http":{"title":"HTTP","optional":["csp","css","hpkp","hsts","javascript","json","markup","uri"],"owner":"danielgtaylor"},"hpkp":{"title":"HTTP Public-Key-Pins","owner":"ScottHelme"},"hsts":{"title":"HTTP Strict-Transport-Security","owner":"ScottHelme"},"ichigojam":{"title":"IchigoJam","owner":"BlueCocoa"},"icon":{"title":"Icon","owner":"Golmote"},"icu-message-format":{"title":"ICU Message Format","owner":"RunDevelopment"},"idris":{"title":"Idris","alias":"idr","owner":"KeenS","require":"haskell"},"ignore":{"title":".ignore","owner":"osipxd","alias":["gitignore","hgignore","npmignore"],"aliasTitles":{"gitignore":".gitignore","hgignore":".hgignore","npmignore":".npmignore"}},"inform7":{"title":"Inform 7","owner":"Golmote"},"ini":{"title":"Ini","owner":"aviaryan"},"io":{"title":"Io","owner":"AlesTsurko"},"j":{"title":"J","owner":"Golmote"},"java":{"title":"Java","require":"clike","owner":"sherblot"},"javadoc":{"title":"JavaDoc","require":["markup","java","javadoclike"],"modify":"java","optional":"scala","owner":"RunDevelopment"},"javadoclike":{"title":"JavaDoc-like","modify":["java","javascript","php"],"owner":"RunDevelopment"},"javastacktrace":{"title":"Java stack trace","owner":"RunDevelopment"},"jexl":{"title":"Jexl","owner":"czosel"},"jolie":{"title":"Jolie","require":"clike","owner":"thesave"},"jq":{"title":"JQ","owner":"RunDevelopment"},"jsdoc":{"title":"JSDoc","require":["javascript","javadoclike","typescript"],"modify":"javascript","optional":["actionscript","coffeescript"],"owner":"RunDevelopment"},"js-extras":{"title":"JS Extras","require":"javascript","modify":"javascript","optional":["actionscript","coffeescript","flow","n4js","typescript"],"owner":"RunDevelopment"},"json":{"title":"JSON","alias":"webmanifest","aliasTitles":{"webmanifest":"Web App Manifest"},"owner":"CupOfTea696"},"json5":{"title":"JSON5","require":"json","owner":"RunDevelopment"},"jsonp":{"title":"JSONP","require":"json","owner":"RunDevelopment"},"jsstacktrace":{"title":"JS stack trace","owner":"sbrl"},"js-templates":{"title":"JS Templates","require":"javascript","modify":"javascript","optional":["css","css-extras","graphql","markdown","markup","sql"],"owner":"RunDevelopment"},"julia":{"title":"Julia","owner":"cdagnino"},"keepalived":{"title":"Keepalived Configure","owner":"dev-itsheng"},"keyman":{"title":"Keyman","owner":"mcdurdin"},"kotlin":{"title":"Kotlin","alias":["kt","kts"],"aliasTitles":{"kts":"Kotlin Script"},"require":"clike","owner":"Golmote"},"kumir":{"title":"KuMir (КуМир)","alias":"kum","owner":"edukisto"},"kusto":{"title":"Kusto","owner":"RunDevelopment"},"latex":{"title":"LaTeX","alias":["tex","context"],"aliasTitles":{"tex":"TeX","context":"ConTeXt"},"owner":"japborst"},"latte":{"title":"Latte","require":["clike","markup-templating","php"],"owner":"nette"},"less":{"title":"Less","require":"css","optional":"css-extras","owner":"Golmote"},"lilypond":{"title":"LilyPond","require":"scheme","alias":"ly","owner":"RunDevelopment"},"liquid":{"title":"Liquid","require":"markup-templating","owner":"cinhtau"},"lisp":{"title":"Lisp","alias":["emacs","elisp","emacs-lisp"],"owner":"JuanCaicedo"},"livescript":{"title":"LiveScript","owner":"Golmote"},"llvm":{"title":"LLVM IR","owner":"porglezomp"},"log":{"title":"Log file","optional":"javastacktrace","owner":"RunDevelopment"},"lolcode":{"title":"LOLCODE","owner":"Golmote"},"lua":{"title":"Lua","owner":"Golmote"},"magma":{"title":"Magma (CAS)","owner":"RunDevelopment"},"makefile":{"title":"Makefile","owner":"Golmote"},"markdown":{"title":"Markdown","require":"markup","optional":"yaml","alias":"md","owner":"Golmote"},"markup-templating":{"title":"Markup templating","require":"markup","owner":"Golmote"},"mata":{"title":"Mata","owner":"RunDevelopment"},"matlab":{"title":"MATLAB","owner":"Golmote"},"maxscript":{"title":"MAXScript","owner":"RunDevelopment"},"mel":{"title":"MEL","owner":"Golmote"},"mermaid":{"title":"Mermaid","owner":"RunDevelopment"},"metafont":{"title":"METAFONT","owner":"LaeriExNihilo"},"mizar":{"title":"Mizar","owner":"Golmote"},"mongodb":{"title":"MongoDB","owner":"airs0urce","require":"javascript"},"monkey":{"title":"Monkey","owner":"Golmote"},"moonscript":{"title":"MoonScript","alias":"moon","owner":"RunDevelopment"},"n1ql":{"title":"N1QL","owner":"TMWilds"},"n4js":{"title":"N4JS","require":"javascript","optional":"jsdoc","alias":"n4jsd","owner":"bsmith-n4"},"nand2tetris-hdl":{"title":"Nand To Tetris HDL","owner":"stephanmax"},"naniscript":{"title":"Naninovel Script","owner":"Elringus","alias":"nani"},"nasm":{"title":"NASM","owner":"rbmj"},"neon":{"title":"NEON","owner":"nette"},"nevod":{"title":"Nevod","owner":"nezaboodka"},"nginx":{"title":"nginx","owner":"volado"},"nim":{"title":"Nim","owner":"Golmote"},"nix":{"title":"Nix","owner":"Golmote"},"nsis":{"title":"NSIS","owner":"idleberg"},"objectivec":{"title":"Objective-C","require":"c","alias":"objc","owner":"uranusjr"},"ocaml":{"title":"OCaml","owner":"Golmote"},"odin":{"title":"Odin","owner":"edukisto"},"opencl":{"title":"OpenCL","require":"c","modify":["c","cpp"],"owner":"Milania1"},"openqasm":{"title":"OpenQasm","alias":"qasm","owner":"RunDevelopment"},"oz":{"title":"Oz","owner":"Golmote"},"parigp":{"title":"PARI/GP","owner":"Golmote"},"parser":{"title":"Parser","require":"markup","owner":"Golmote"},"pascal":{"title":"Pascal","alias":"objectpascal","aliasTitles":{"objectpascal":"Object Pascal"},"owner":"Golmote"},"pascaligo":{"title":"Pascaligo","owner":"DefinitelyNotAGoat"},"psl":{"title":"PATROL Scripting Language","owner":"bertysentry"},"pcaxis":{"title":"PC-Axis","alias":"px","owner":"RunDevelopment"},"peoplecode":{"title":"PeopleCode","alias":"pcode","owner":"RunDevelopment"},"perl":{"title":"Perl","owner":"Golmote"},"php":{"title":"PHP","require":"markup-templating","owner":"milesj"},"phpdoc":{"title":"PHPDoc","require":["php","javadoclike"],"modify":"php","owner":"RunDevelopment"},"php-extras":{"title":"PHP Extras","require":"php","modify":"php","owner":"milesj"},"plant-uml":{"title":"PlantUML","alias":"plantuml","owner":"RunDevelopment"},"plsql":{"title":"PL/SQL","require":"sql","owner":"Golmote"},"powerquery":{"title":"PowerQuery","alias":["pq","mscript"],"owner":"peterbud"},"powershell":{"title":"PowerShell","owner":"nauzilus"},"processing":{"title":"Processing","require":"clike","owner":"Golmote"},"prolog":{"title":"Prolog","owner":"Golmote"},"promql":{"title":"PromQL","owner":"arendjr"},"properties":{"title":".properties","owner":"Golmote"},"protobuf":{"title":"Protocol Buffers","require":"clike","owner":"just-boris"},"pug":{"title":"Pug","require":["markup","javascript"],"optional":["coffeescript","ejs","handlebars","less","livescript","markdown","scss","stylus","twig"],"owner":"Golmote"},"puppet":{"title":"Puppet","owner":"Golmote"},"pure":{"title":"Pure","optional":["c","cpp","fortran"],"owner":"Golmote"},"purebasic":{"title":"PureBasic","require":"clike","alias":"pbfasm","owner":"HeX0R101"},"purescript":{"title":"PureScript","require":"haskell","alias":"purs","owner":"sriharshachilakapati"},"python":{"title":"Python","alias":"py","owner":"multipetros"},"qsharp":{"title":"Q#","require":"clike","alias":"qs","owner":"fedonman"},"q":{"title":"Q (kdb+ database)","owner":"Golmote"},"qml":{"title":"QML","require":"javascript","owner":"RunDevelopment"},"qore":{"title":"Qore","require":"clike","owner":"temnroegg"},"r":{"title":"R","owner":"Golmote"},"racket":{"title":"Racket","require":"scheme","alias":"rkt","owner":"RunDevelopment"},"cshtml":{"title":"Razor C#","alias":"razor","require":["markup","csharp"],"optional":["css","css-extras","javascript","js-extras"],"owner":"RunDevelopment"},"jsx":{"title":"React JSX","require":["markup","javascript"],"optional":["jsdoc","js-extras","js-templates"],"owner":"vkbansal"},"tsx":{"title":"React TSX","require":["jsx","typescript"]},"reason":{"title":"Reason","require":"clike","owner":"Golmote"},"regex":{"title":"Regex","owner":"RunDevelopment"},"rego":{"title":"Rego","owner":"JordanSh"},"renpy":{"title":"Ren'py","alias":"rpy","owner":"HyuchiaDiego"},"rescript":{"title":"ReScript","alias":"res","owner":"vmarcosp"},"rest":{"title":"reST (reStructuredText)","owner":"Golmote"},"rip":{"title":"Rip","owner":"ravinggenius"},"roboconf":{"title":"Roboconf","owner":"Golmote"},"robotframework":{"title":"Robot Framework","alias":"robot","owner":"RunDevelopment"},"ruby":{"title":"Ruby","require":"clike","alias":"rb","owner":"samflores"},"rust":{"title":"Rust","owner":"Golmote"},"sas":{"title":"SAS","optional":["groovy","lua","sql"],"owner":"Golmote"},"sass":{"title":"Sass (Sass)","require":"css","optional":"css-extras","owner":"Golmote"},"scss":{"title":"Sass (SCSS)","require":"css","optional":"css-extras","owner":"MoOx"},"scala":{"title":"Scala","require":"java","owner":"jozic"},"scheme":{"title":"Scheme","owner":"bacchus123"},"shell-session":{"title":"Shell session","require":"bash","alias":["sh-session","shellsession"],"owner":"RunDevelopment"},"smali":{"title":"Smali","owner":"RunDevelopment"},"smalltalk":{"title":"Smalltalk","owner":"Golmote"},"smarty":{"title":"Smarty","require":"markup-templating","optional":"php","owner":"Golmote"},"sml":{"title":"SML","alias":"smlnj","aliasTitles":{"smlnj":"SML/NJ"},"owner":"RunDevelopment"},"solidity":{"title":"Solidity (Ethereum)","alias":"sol","require":"clike","owner":"glachaud"},"solution-file":{"title":"Solution file","alias":"sln","owner":"RunDevelopment"},"soy":{"title":"Soy (Closure Template)","require":"markup-templating","owner":"Golmote"},"sparql":{"title":"SPARQL","require":"turtle","owner":"Triply-Dev","alias":"rq"},"splunk-spl":{"title":"Splunk SPL","owner":"RunDevelopment"},"sqf":{"title":"SQF: Status Quo Function (Arma 3)","require":"clike","owner":"RunDevelopment"},"sql":{"title":"SQL","owner":"multipetros"},"squirrel":{"title":"Squirrel","require":"clike","owner":"RunDevelopment"},"stan":{"title":"Stan","owner":"RunDevelopment"},"stata":{"title":"Stata Ado","require":["mata","java","python"],"owner":"RunDevelopment"},"iecst":{"title":"Structured Text (IEC 61131-3)","owner":"serhioromano"},"stylus":{"title":"Stylus","owner":"vkbansal"},"supercollider":{"title":"SuperCollider","alias":"sclang","owner":"RunDevelopment"},"swift":{"title":"Swift","owner":"chrischares"},"systemd":{"title":"Systemd configuration file","owner":"RunDevelopment"},"t4-templating":{"title":"T4 templating","owner":"RunDevelopment"},"t4-cs":{"title":"T4 Text Templates (C#)","require":["t4-templating","csharp"],"alias":"t4","owner":"RunDevelopment"},"t4-vb":{"title":"T4 Text Templates (VB)","require":["t4-templating","vbnet"],"owner":"RunDevelopment"},"tap":{"title":"TAP","owner":"isaacs","require":"yaml"},"tcl":{"title":"Tcl","owner":"PeterChaplin"},"tt2":{"title":"Template Toolkit 2","require":["clike","markup-templating"],"owner":"gflohr"},"textile":{"title":"Textile","require":"markup","optional":"css","owner":"Golmote"},"toml":{"title":"TOML","owner":"RunDevelopment"},"tremor":{"title":"Tremor","alias":["trickle","troy"],"owner":"darach","aliasTitles":{"trickle":"trickle","troy":"troy"}},"turtle":{"title":"Turtle","alias":"trig","aliasTitles":{"trig":"TriG"},"owner":"jakubklimek"},"twig":{"title":"Twig","require":"markup-templating","owner":"brandonkelly"},"typescript":{"title":"TypeScript","require":"javascript","optional":"js-templates","alias":"ts","owner":"vkbansal"},"typoscript":{"title":"TypoScript","alias":"tsconfig","aliasTitles":{"tsconfig":"TSConfig"},"owner":"dkern"},"unrealscript":{"title":"UnrealScript","alias":["uscript","uc"],"owner":"RunDevelopment"},"uorazor":{"title":"UO Razor Script","owner":"jaseowns"},"uri":{"title":"URI","alias":"url","aliasTitles":{"url":"URL"},"owner":"RunDevelopment"},"v":{"title":"V","require":"clike","owner":"taggon"},"vala":{"title":"Vala","require":"clike","optional":"regex","owner":"TemplarVolk"},"vbnet":{"title":"VB.Net","require":"basic","owner":"Bigsby"},"velocity":{"title":"Velocity","require":"markup","owner":"Golmote"},"verilog":{"title":"Verilog","owner":"a-rey"},"vhdl":{"title":"VHDL","owner":"a-rey"},"vim":{"title":"vim","owner":"westonganger"},"visual-basic":{"title":"Visual Basic","alias":["vb","vba"],"aliasTitles":{"vba":"VBA"},"owner":"Golmote"},"warpscript":{"title":"WarpScript","owner":"RunDevelopment"},"wasm":{"title":"WebAssembly","owner":"Golmote"},"web-idl":{"title":"Web IDL","alias":"webidl","owner":"RunDevelopment"},"wgsl":{"title":"WGSL","owner":"Dr4gonthree"},"wiki":{"title":"Wiki markup","require":"markup","owner":"Golmote"},"wolfram":{"title":"Wolfram language","alias":["mathematica","nb","wl"],"aliasTitles":{"mathematica":"Mathematica","nb":"Mathematica Notebook"},"owner":"msollami"},"wren":{"title":"Wren","owner":"clsource"},"xeora":{"title":"Xeora","require":"markup","alias":"xeoracube","aliasTitles":{"xeoracube":"XeoraCube"},"owner":"freakmaxi"},"xml-doc":{"title":"XML doc (.net)","require":"markup","modify":["csharp","fsharp","vbnet"],"owner":"RunDevelopment"},"xojo":{"title":"Xojo (REALbasic)","owner":"Golmote"},"xquery":{"title":"XQuery","require":"markup","owner":"Golmote"},"yaml":{"title":"YAML","alias":"yml","owner":"hason"},"yang":{"title":"YANG","owner":"RunDevelopment"},"zig":{"title":"Zig","owner":"RunDevelopment"}},"plugins":{"meta":{"path":"plugins/{id}/prism-{id}","link":"plugins/{id}/"},"line-highlight":{"title":"Line Highlight","description":"Highlights specific lines and/or line ranges."},"line-numbers":{"title":"Line Numbers","description":"Line number at the beginning of code lines.","owner":"kuba-kubula"},"show-invisibles":{"title":"Show Invisibles","description":"Show hidden characters such as tabs and line breaks.","optional":["autolinker","data-uri-highlight"]},"autolinker":{"title":"Autolinker","description":"Converts URLs and emails in code to clickable links. Parses Markdown links in comments."},"wpd":{"title":"WebPlatform Docs","description":"Makes tokens link to <a href=\\"https://webplatform.github.io/docs/\\">WebPlatform.org documentation</a>. The links open in a new tab."},"custom-class":{"title":"Custom Class","description":"This plugin allows you to prefix Prism's default classes (<code>.comment</code> can become <code>.namespace--comment</code>) or replace them with your defined ones (like <code>.editor__comment</code>). You can even add new classes.","owner":"dvkndn","noCSS":true},"file-highlight":{"title":"File Highlight","description":"Fetch external files and highlight them with Prism. Used on the Prism website itself.","noCSS":true},"show-language":{"title":"Show Language","description":"Display the highlighted language in code blocks (inline code does not show the label).","owner":"nauzilus","noCSS":true,"require":"toolbar"},"jsonp-highlight":{"title":"JSONP Highlight","description":"Fetch content with JSONP and highlight some interesting content (e.g. GitHub/Gists or Bitbucket API).","noCSS":true,"owner":"nauzilus"},"highlight-keywords":{"title":"Highlight Keywords","description":"Adds special CSS classes for each keyword for fine-grained highlighting.","owner":"vkbansal","noCSS":true},"remove-initial-line-feed":{"title":"Remove initial line feed","description":"Removes the initial line feed in code blocks.","owner":"Golmote","noCSS":true},"inline-color":{"title":"Inline color","description":"Adds a small inline preview for colors in style sheets.","require":"css-extras","owner":"RunDevelopment"},"previewers":{"title":"Previewers","description":"Previewers for angles, colors, gradients, easing and time.","require":"css-extras","owner":"Golmote"},"autoloader":{"title":"Autoloader","description":"Automatically loads the needed languages to highlight the code blocks.","owner":"Golmote","noCSS":true},"keep-markup":{"title":"Keep Markup","description":"Prevents custom markup from being dropped out during highlighting.","owner":"Golmote","optional":"normalize-whitespace","noCSS":true},"command-line":{"title":"Command Line","description":"Display a command line with a prompt and, optionally, the output/response from the commands.","owner":"chriswells0"},"unescaped-markup":{"title":"Unescaped Markup","description":"Write markup without having to escape anything."},"normalize-whitespace":{"title":"Normalize Whitespace","description":"Supports multiple operations to normalize whitespace in code blocks.","owner":"zeitgeist87","optional":"unescaped-markup","noCSS":true},"data-uri-highlight":{"title":"Data-URI Highlight","description":"Highlights data-URI contents.","owner":"Golmote","noCSS":true},"toolbar":{"title":"Toolbar","description":"Attach a toolbar for plugins to easily register buttons on the top of a code block.","owner":"mAAdhaTTah"},"copy-to-clipboard":{"title":"Copy to Clipboard Button","description":"Add a button that copies the code block to the clipboard when clicked.","owner":"mAAdhaTTah","require":"toolbar","noCSS":true},"download-button":{"title":"Download Button","description":"A button in the toolbar of a code block adding a convenient way to download a code file.","owner":"Golmote","require":"toolbar","noCSS":true},"match-braces":{"title":"Match braces","description":"Highlights matching braces.","owner":"RunDevelopment"},"diff-highlight":{"title":"Diff Highlight","description":"Highlights the code inside diff blocks.","owner":"RunDevelopment","require":"diff"},"filter-highlight-all":{"title":"Filter highlightAll","description":"Filters the elements the <code>highlightAll</code> and <code>highlightAllUnder</code> methods actually highlight.","owner":"RunDevelopment","noCSS":true},"treeview":{"title":"Treeview","description":"A language with special styles to highlight file system tree structures.","owner":"Golmote"}}}`);
});
parcelRequire.register("4wAom", function(module, exports) {
  var $34b6613fd50afc6a$var$_self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var $34b6613fd50afc6a$var$Prism = function(_self) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _ = {
      /**
      * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
      * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
      * additional languages or plugins yourself.
      *
      * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
      *
      * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
      * empty Prism object into the global scope before loading the Prism script like this:
      *
      * ```js
      * window.Prism = window.Prism || {};
      * Prism.manual = true;
      * // add a new <script> to load Prism's script
      * ```
      *
      * @default false
      * @type {boolean}
      * @memberof Prism
      * @public
      */
      manual: _self.Prism && _self.Prism.manual,
      /**
      * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
      * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
      * own worker, you don't want it to do this.
      *
      * By setting this value to `true`, Prism will not add its own listeners to the worker.
      *
      * You obviously have to change this value before Prism executes. To do this, you can add an
      * empty Prism object into the global scope before loading the Prism script like this:
      *
      * ```js
      * window.Prism = window.Prism || {};
      * Prism.disableWorkerMessageHandler = true;
      * // Load Prism's script
      * ```
      *
      * @default false
      * @type {boolean}
      * @memberof Prism
      * @public
      */
      disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,
      /**
      * A namespace for utility methods.
      *
      * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
      * change or disappear at any time.
      *
      * @namespace
      * @memberof Prism
      */
      util: {
        encode: function encode(tokens) {
          if (tokens instanceof Token)
            return new Token(tokens.type, encode(tokens.content), tokens.alias);
          else if (Array.isArray(tokens))
            return tokens.map(encode);
          else
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
        * Returns the name of the type of the given value.
        *
        * @param {any} o
        * @returns {string}
        * @example
        * type(null)      === 'Null'
        * type(undefined) === 'Undefined'
        * type(123)       === 'Number'
        * type('foo')     === 'String'
        * type(true)      === 'Boolean'
        * type([1, 2])    === 'Array'
        * type({})        === 'Object'
        * type(String)    === 'Function'
        * type(/abc+/)    === 'RegExp'
        */
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        /**
        * Returns a unique number for the given object. Later calls will still return the same number.
        *
        * @param {Object} obj
        * @returns {number}
        */
        objId: function(obj) {
          if (!obj["__id"])
            Object.defineProperty(obj, "__id", {
              value: ++uniqueId
            });
          return obj["__id"];
        },
        /**
        * Creates a deep clone of the given object.
        *
        * The main intended use of this function is to clone language definitions.
        *
        * @param {T} o
        * @param {Record<number, any>} [visited]
        * @returns {T}
        * @template T
        */
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone;
          var id;
          switch (_.util.type(o)) {
            case "Object":
              id = _.util.objId(o);
              if (visited[id])
                return visited[id];
              clone = /** @type {Record<string, any>} */
              {};
              visited[id] = clone;
              for (var key in o)
                if (o.hasOwnProperty(key))
                  clone[key] = deepClone(o[key], visited);
              return (
                /** @type {any} */
                clone
              );
            case "Array":
              id = _.util.objId(o);
              if (visited[id])
                return visited[id];
              clone = [];
              visited[id] = clone;
              o.forEach(function(v, i) {
                clone[i] = deepClone(v, visited);
              });
              return (
                /** @type {any} */
                clone
              );
            default:
              return o;
          }
        },
        /**
        * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
        *
        * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
        *
        * @param {Element} element
        * @returns {string}
        */
        getLanguage: function(element) {
          while (element) {
            var m = lang.exec(element.className);
            if (m)
              return m[1].toLowerCase();
            element = element.parentElement;
          }
          return "none";
        },
        /**
        * Sets the Prism `language-xxxx` class of the given element.
        *
        * @param {Element} element
        * @param {string} language
        * @returns {void}
        */
        setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), "");
          element.classList.add("language-" + language);
        },
        /**
        * Returns the script element that is currently executing.
        *
        * This does __not__ work for line script element.
        *
        * @returns {HTMLScriptElement | null}
        */
        currentScript: function() {
          if (typeof document === "undefined")
            return null;
          if ("currentScript" in document && true)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts) {
                if (scripts[i].src == src)
                  return scripts[i];
              }
            }
            return null;
          }
        },
        /**
        * Returns whether a given class is active for `element`.
        *
        * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
        * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
        * given class is just the given class with a `no-` prefix.
        *
        * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
        * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
        * ancestors have the given class or the negated version of it, then the default activation will be returned.
        *
        * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
        * version of it, the class is considered active.
        *
        * @param {Element} element
        * @param {string} className
        * @param {boolean} [defaultActivation=false]
        * @returns {boolean}
        */
        isActive: function(element, className, defaultActivation) {
          var no = "no-" + className;
          while (element) {
            var classList = element.classList;
            if (classList.contains(className))
              return true;
            if (classList.contains(no))
              return false;
            element = element.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
      * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
      *
      * @namespace
      * @memberof Prism
      * @public
      */
      languages: {
        /**
        * The grammar for plain, unformatted text.
        */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
        * Creates a deep copy of the language with the given id and appends the given tokens.
        *
        * If a token in `redef` also appears in the copied language, then the existing token in the copied language
        * will be overwritten at its original position.
        *
        * ## Best practices
        *
        * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
        * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
        * understand the language definition because, normally, the order of tokens matters in Prism grammars.
        *
        * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
        * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
        *
        * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
        * @param {Grammar} redef The new tokens to append.
        * @returns {Grammar} The new language created.
        * @public
        * @example
        * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
        *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
        *     // at its original position
        *     'comment': { ... },
        *     // CSS doesn't have a 'color' token, so this token will be appended
        *     'color': /\b(?:red|green|blue)\b/
        * });
        */
        extend: function(id, redef) {
          var lang2 = _.util.clone(_.languages[id]);
          for (var key in redef)
            lang2[key] = redef[key];
          return lang2;
        },
        /**
        * Inserts tokens _before_ another token in a language definition or any other grammar.
        *
        * ## Usage
        *
        * This helper method makes it easy to modify existing languages. For example, the CSS language definition
        * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
        * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
        * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
        * this:
        *
        * ```js
        * Prism.languages.markup.style = {
        *     // token
        * };
        * ```
        *
        * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
        * before existing tokens. For the CSS example above, you would use it like this:
        *
        * ```js
        * Prism.languages.insertBefore('markup', 'cdata', {
        *     'style': {
        *         // token
        *     }
        * });
        * ```
        *
        * ## Special cases
        *
        * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
        * will be ignored.
        *
        * This behavior can be used to insert tokens after `before`:
        *
        * ```js
        * Prism.languages.insertBefore('markup', 'comment', {
        *     'comment': Prism.languages.markup.comment,
        *     // tokens after 'comment'
        * });
        * ```
        *
        * ## Limitations
        *
        * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
        * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
        * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
        * deleting properties which is necessary to insert at arbitrary positions.
        *
        * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
        * Instead, it will create a new object and replace all references to the target object with the new one. This
        * can be done without temporarily deleting properties, so the iteration order is well-defined.
        *
        * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
        * you hold the target object in a variable, then the value of the variable will not change.
        *
        * ```js
        * var oldMarkup = Prism.languages.markup;
        * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
        *
        * assert(oldMarkup !== Prism.languages.markup);
        * assert(newMarkup === Prism.languages.markup);
        * ```
        *
        * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
        * object to be modified.
        * @param {string} before The key to insert before.
        * @param {Grammar} insert An object containing the key-value pairs to be inserted.
        * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
        * object to be modified.
        *
        * Defaults to `Prism.languages`.
        * @returns {Grammar} The new grammar object.
        * @public
        */
        insertBefore: function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _.languages;
          var grammar = root[inside];
          var ret = {};
          for (var token in grammar)
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (var newToken in insert)
                  if (insert.hasOwnProperty(newToken))
                    ret[newToken] = insert[newToken];
              }
              if (!insert.hasOwnProperty(token))
                ret[token] = grammar[token];
            }
          var old = root[inside];
          root[inside] = ret;
          _.languages.DFS(_.languages, function(key, value) {
            if (value === old && key != inside)
              this[key] = ret;
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i in o)
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              var property = o[i];
              var propertyType = _.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
        }
      },
      plugins: {},
      /**
      * This is the most high-level function in Prism’s API.
      * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
      * each one of them.
      *
      * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
      *
      * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
      * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
      * @memberof Prism
      * @public
      */
      highlightAll: function(async, callback) {
        _.highlightAllUnder(document, async, callback);
      },
      /**
      * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
      * {@link Prism.highlightElement} on each one of them.
      *
      * The following hooks will be run:
      * 1. `before-highlightall`
      * 2. `before-all-elements-highlight`
      * 3. All hooks of {@link Prism.highlightElement} for each element.
      *
      * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
      * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
      * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
      * @memberof Prism
      * @public
      */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element; element = env.elements[i++]; )
          _.highlightElement(element, async === true, env.callback);
      },
      /**
      * Highlights the code inside a single element.
      *
      * The following hooks will be run:
      * 1. `before-sanity-check`
      * 2. `before-highlight`
      * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
      * 4. `before-insert`
      * 5. `after-highlight`
      * 6. `complete`
      *
      * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
      * the element's language.
      *
      * @param {Element} element The element containing the code.
      * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
      * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
      * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
      * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
      *
      * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
      * asynchronous highlighting to work. You can build your own bundle on the
      * [Download page](https://prismjs.com/download.html).
      * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
      * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
      * @memberof Prism
      * @public
      */
      highlightElement: function(element, async, callback) {
        var language = _.util.getLanguage(element);
        var grammar = _.languages[language];
        _.util.setLanguage(element, language);
        var parent = element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre")
          _.util.setLanguage(parent, language);
        var code = element.textContent;
        var env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _.hooks.run("after-highlight", env);
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex"))
          parent.setAttribute("tabindex", "0");
        if (!env.code) {
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_.util.encode(env.code));
          return;
        }
        if (async && _self.Worker) {
          var worker = new Worker(_.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else
          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
      },
      /**
      * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
      * and the language definitions to use, and returns a string with the HTML produced.
      *
      * The following hooks will be run:
      * 1. `before-tokenize`
      * 2. `after-tokenize`
      * 3. `wrap`: On each {@link Token}.
      *
      * @param {string} text A string with the code to be highlighted.
      * @param {Grammar} grammar An object containing the tokens to use.
      *
      * Usually a language definition like `Prism.languages.markup`.
      * @param {string} language The name of the language definition passed to `grammar`.
      * @returns {string} The highlighted HTML.
      * @memberof Prism
      * @public
      * @example
      * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
      */
      highlight: function(text, grammar, language) {
        var env = {
          code: text,
          grammar,
          language
        };
        _.hooks.run("before-tokenize", env);
        if (!env.grammar)
          throw new Error('The language "' + env.language + '" has no grammar.');
        env.tokens = _.tokenize(env.code, env.grammar);
        _.hooks.run("after-tokenize", env);
        return Token.stringify(_.util.encode(env.tokens), env.language);
      },
      /**
      * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
      * and the language definitions to use, and returns an array with the tokenized code.
      *
      * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
      *
      * This method could be useful in other contexts as well, as a very crude parser.
      *
      * @param {string} text A string with the code to be highlighted.
      * @param {Grammar} grammar An object containing the tokens to use.
      *
      * Usually a language definition like `Prism.languages.markup`.
      * @returns {TokenStream} An array of strings and tokens, a token stream.
      * @memberof Prism
      * @public
      * @example
      * let code = `var foo = 0;`;
      * let tokens = Prism.tokenize(code, Prism.languages.javascript);
      * tokens.forEach(token => {
      *     if (token instanceof Prism.Token && token.type === 'number') {
      *         console.log(`Found numeric literal: ${token.content}`);
      *     }
      * });
      */
      tokenize: function(text, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token in rest)
            grammar[token] = rest[token];
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text);
        matchGrammar(text, tokenList, grammar, tokenList.head, 0);
        return toArray(tokenList);
      },
      /**
      * @namespace
      * @memberof Prism
      * @public
      */
      hooks: {
        all: {},
        /**
        * Adds the given callback to the list of callbacks for the given hook.
        *
        * The callback will be invoked when the hook it is registered for is run.
        * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
        *
        * One callback function can be registered to multiple hooks and the same hook multiple times.
        *
        * @param {string} name The name of the hook.
        * @param {HookCallback} callback The callback function which is given environment variables.
        * @public
        */
        add: function(name, callback) {
          var hooks = _.hooks.all;
          hooks[name] = hooks[name] || [];
          hooks[name].push(callback);
        },
        /**
        * Runs a hook invoking all registered callbacks with the given environment variables.
        *
        * Callbacks will be invoked synchronously and in the order in which they were registered.
        *
        * @param {string} name The name of the hook.
        * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
        * @public
        */
        run: function(name, env) {
          var callbacks = _.hooks.all[name];
          if (!callbacks || !callbacks.length)
            return;
          for (var i = 0, callback; callback = callbacks[i++]; )
            callback(env);
        }
      },
      Token
    };
    _self.Prism = _;
    function Token(type, content, alias, matchedStr) {
      this.type = type;
      this.content = content;
      this.alias = alias;
      this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify(o, language) {
      if (typeof o == "string")
        return o;
      if (Array.isArray(o)) {
        var s = "";
        o.forEach(function(e) {
          s += stringify(e, language);
        });
        return s;
      }
      var env = {
        type: o.type,
        content: stringify(o.content, language),
        tag: "span",
        classes: [
          "token",
          o.type
        ],
        attributes: {},
        language
      };
      var aliases = o.alias;
      if (aliases) {
        if (Array.isArray(aliases))
          Array.prototype.push.apply(env.classes, aliases);
        else
          env.classes.push(aliases);
      }
      _.hooks.run("wrap", env);
      var attributes = "";
      for (var name in env.attributes)
        attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text, lookbehind) {
      pattern.lastIndex = pos;
      var match = pattern.exec(text);
      if (match && lookbehind && match[1]) {
        var lookbehindLength = match[1].length;
        match.index += lookbehindLength;
        match[0] = match[0].slice(lookbehindLength);
      }
      return match;
    }
    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token])
          continue;
        var patterns = grammar[token];
        patterns = Array.isArray(patterns) ? patterns : [
          patterns
        ];
        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token + "," + j)
            return;
          var patternObj = patterns[j];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach)
              break;
            var str = currentNode.value;
            if (tokenList.length > text.length)
              return;
            if (str instanceof Token)
              continue;
            var removeCount = 1;
            var match;
            if (greedy) {
              match = matchPattern(pattern, pos, text, lookbehind);
              if (!match || match.index >= text.length)
                break;
              var from = match.index;
              var to = match.index + match[0].length;
              var p = pos;
              p += currentNode.value.length;
              while (from >= p) {
                currentNode = currentNode.next;
                p += currentNode.value.length;
              }
              p -= currentNode.value.length;
              pos = p;
              if (currentNode.value instanceof Token)
                continue;
              for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                removeCount++;
                p += k.value.length;
              }
              removeCount--;
              str = text.slice(pos, p);
              match.index -= pos;
            } else {
              match = matchPattern(pattern, 0, str, lookbehind);
              if (!match)
                continue;
            }
            var from = match.index;
            var matchStr = match[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach)
              rematch.reach = reach;
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after)
              addAfter(tokenList, currentNode, after);
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token + "," + j,
                reach
              };
              matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach)
                rematch.reach = nestedRematch.reach;
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = {
        value: null,
        prev: null,
        next: null
      };
      var tail = {
        value: null,
        prev: head,
        next: null
      };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list, node, value) {
      var next = node.next;
      var newNode = {
        value,
        prev: node,
        next
      };
      node.next = newNode;
      next.prev = newNode;
      list.length++;
      return newNode;
    }
    function removeRange(list, node, count) {
      var next = node.next;
      for (var i = 0; i < count && next !== list.tail; i++)
        next = next.next;
      node.next = next;
      next.prev = node;
      list.length -= i;
    }
    function toArray(list) {
      var array = [];
      var node = list.head.next;
      while (node !== list.tail) {
        array.push(node.value);
        node = node.next;
      }
      return array;
    }
    if (!_self.document) {
      if (!_self.addEventListener)
        return _;
      if (!_.disableWorkerMessageHandler)
        _self.addEventListener("message", function(evt) {
          var message = JSON.parse(evt.data);
          var lang2 = message.language;
          var code = message.code;
          var immediateClose = message.immediateClose;
          _self.postMessage(_.highlight(code, _.languages[lang2], lang2));
          if (immediateClose)
            _self.close();
        }, false);
      return _;
    }
    var script = _.util.currentScript();
    if (script) {
      _.filename = script.src;
      if (script.hasAttribute("data-manual"))
        _.manual = true;
    }
    function highlightAutomaticallyCallback() {
      if (!_.manual)
        _.highlightAll();
    }
    if (!_.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer)
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      else if (window.requestAnimationFrame)
        window.requestAnimationFrame(highlightAutomaticallyCallback);
      else
        window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _;
  }($34b6613fd50afc6a$var$_self);
  if (module.exports)
    module.exports = $34b6613fd50afc6a$var$Prism;
  if (typeof $parcel$global !== "undefined")
    $parcel$global.Prism = $34b6613fd50afc6a$var$Prism;
  $34b6613fd50afc6a$var$Prism.languages.markup = {
    "comment": {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    "prolog": {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    "doctype": {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
          // see below
        },
        "string": {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        "punctuation": /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        "name": /[^\s<>'"]+/
      }
    },
    "cdata": {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    "tag": {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        "tag": {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            "punctuation": /^<\/?/,
            "namespace": /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            "punctuation": [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: true
              }
            ]
          }
        },
        "punctuation": /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            "namespace": /^[^\s>\/:]+:/
          }
        }
      }
    },
    "entity": [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  $34b6613fd50afc6a$var$Prism.languages.markup["tag"].inside["attr-value"].inside["entity"] = $34b6613fd50afc6a$var$Prism.languages.markup["entity"];
  $34b6613fd50afc6a$var$Prism.languages.markup["doctype"].inside["internal-subset"].inside = $34b6613fd50afc6a$var$Prism.languages.markup;
  $34b6613fd50afc6a$var$Prism.hooks.add("wrap", function(env) {
    if (env.type === "entity")
      env.attributes["title"] = env.content.replace(/&amp;/, "&");
  });
  Object.defineProperty($34b6613fd50afc6a$var$Prism.languages.markup.tag, "addInlined", {
    /**
    * Adds an inlined language to markup.
    *
    * An example of an inlined language is CSS with `<style>` tags.
    *
    * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
    * case insensitive.
    * @param {string} lang The language key.
    * @example
    * addInlined('style', 'css');
    */
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: $34b6613fd50afc6a$var$Prism.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: $34b6613fd50afc6a$var$Prism.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      $34b6613fd50afc6a$var$Prism.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty($34b6613fd50afc6a$var$Prism.languages.markup.tag, "addAttribute", {
    /**
    * Adds an pattern to highlight languages embedded in HTML attributes.
    *
    * An example of an inlined language is CSS with `style` attributes.
    *
    * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
    * case insensitive.
    * @param {string} lang The language key.
    * @example
    * addAttribute('style', 'css');
    */
    value: function(attrName, lang) {
      $34b6613fd50afc6a$var$Prism.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              "value": {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [
                  lang,
                  "language-" + lang
                ],
                inside: $34b6613fd50afc6a$var$Prism.languages[lang]
              },
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  $34b6613fd50afc6a$var$Prism.languages.html = $34b6613fd50afc6a$var$Prism.languages.markup;
  $34b6613fd50afc6a$var$Prism.languages.mathml = $34b6613fd50afc6a$var$Prism.languages.markup;
  $34b6613fd50afc6a$var$Prism.languages.svg = $34b6613fd50afc6a$var$Prism.languages.markup;
  $34b6613fd50afc6a$var$Prism.languages.xml = $34b6613fd50afc6a$var$Prism.languages.extend("markup", {});
  $34b6613fd50afc6a$var$Prism.languages.ssml = $34b6613fd50afc6a$var$Prism.languages.xml;
  $34b6613fd50afc6a$var$Prism.languages.atom = $34b6613fd50afc6a$var$Prism.languages.xml;
  $34b6613fd50afc6a$var$Prism.languages.rss = $34b6613fd50afc6a$var$Prism.languages.xml;
  (function(Prism) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism.languages.css = {
      "comment": /\/\*[\s\S]*?\*\//,
      "atrule": {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          "rule": /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          "keyword": {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
        }
      },
      "url": {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          "function": /^url/i,
          "punctuation": /^\(|\)$/,
          "string": {
            pattern: RegExp("^" + string.source + "$"),
            alias: "url"
          }
        }
      },
      "selector": {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      "string": {
        pattern: string,
        greedy: true
      },
      "property": {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      "important": /!important\b/i,
      "function": {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      "punctuation": /[(){};:,]/
    };
    Prism.languages.css["atrule"].inside.rest = Prism.languages.css;
    var markup = Prism.languages.markup;
    if (markup) {
      markup.tag.addInlined("style", "css");
      markup.tag.addAttribute("style", "css");
    }
  })($34b6613fd50afc6a$var$Prism);
  $34b6613fd50afc6a$var$Prism.languages.clike = {
    "comment": [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    "string": {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    "boolean": /\b(?:false|true)\b/,
    "function": /\b\w+(?=\()/,
    "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    "punctuation": /[{}[\];(),.:]/
  };
  $34b6613fd50afc6a$var$Prism.languages.javascript = $34b6613fd50afc6a$var$Prism.languages.extend("clike", {
    "class-name": [
      $34b6613fd50afc6a$var$Prism.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    "keyword": [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    "number": {
      pattern: RegExp(/(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
      lookbehind: true
    },
    "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  $34b6613fd50afc6a$var$Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  $34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "keyword", {
    "regex": {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: $34b6613fd50afc6a$var$Prism.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    "parameter": [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: $34b6613fd50afc6a$var$Prism.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: $34b6613fd50afc6a$var$Prism.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: $34b6613fd50afc6a$var$Prism.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: $34b6613fd50afc6a$var$Prism.languages.javascript
      }
    ],
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  $34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "string", {
    "hashbang": {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: $34b6613fd50afc6a$var$Prism.languages.javascript
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  $34b6613fd50afc6a$var$Prism.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if ($34b6613fd50afc6a$var$Prism.languages.markup) {
    $34b6613fd50afc6a$var$Prism.languages.markup.tag.addInlined("script", "javascript");
    $34b6613fd50afc6a$var$Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
  }
  $34b6613fd50afc6a$var$Prism.languages.js = $34b6613fd50afc6a$var$Prism.languages.javascript;
  (function() {
    if (typeof $34b6613fd50afc6a$var$Prism === "undefined" || typeof document === "undefined")
      return;
    if (!Element.prototype.matches)
      Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var LOADING_MESSAGE = "Loading…";
    var FAILURE_MESSAGE = function(status, message) {
      return "✖ Error " + status + " while fetching file: " + message;
    };
    var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
    var EXTENSIONS = {
      "js": "javascript",
      "py": "python",
      "rb": "ruby",
      "ps1": "powershell",
      "psm1": "powershell",
      "sh": "bash",
      "bat": "batch",
      "h": "c",
      "tex": "latex"
    };
    var STATUS_ATTR = "data-src-status";
    var STATUS_LOADING = "loading";
    var STATUS_LOADED = "loaded";
    var STATUS_FAILED = "failed";
    var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
    function loadFile(src, success, error) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", src, true);
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          if (xhr.status < 400 && xhr.responseText)
            success(xhr.responseText);
          else if (xhr.status >= 400)
            error(FAILURE_MESSAGE(xhr.status, xhr.statusText));
          else
            error(FAILURE_EMPTY_MESSAGE);
        }
      };
      xhr.send(null);
    }
    function parseRange(range) {
      var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
      if (m) {
        var start = Number(m[1]);
        var comma = m[2];
        var end = m[3];
        if (!comma)
          return [
            start,
            start
          ];
        if (!end)
          return [
            start,
            void 0
          ];
        return [
          start,
          Number(end)
        ];
      }
      return void 0;
    }
    $34b6613fd50afc6a$var$Prism.hooks.add("before-highlightall", function(env) {
      env.selector += ", " + SELECTOR;
    });
    $34b6613fd50afc6a$var$Prism.hooks.add("before-sanity-check", function(env) {
      var pre = (
        /** @type {HTMLPreElement} */
        env.element
      );
      if (pre.matches(SELECTOR)) {
        env.code = "";
        pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
        var code = pre.appendChild(document.createElement("CODE"));
        code.textContent = LOADING_MESSAGE;
        var src = pre.getAttribute("data-src");
        var language = env.language;
        if (language === "none") {
          var extension = (/\.(\w+)$/.exec(src) || [
            ,
            "none"
          ])[1];
          language = EXTENSIONS[extension] || extension;
        }
        $34b6613fd50afc6a$var$Prism.util.setLanguage(code, language);
        $34b6613fd50afc6a$var$Prism.util.setLanguage(pre, language);
        var autoloader = $34b6613fd50afc6a$var$Prism.plugins.autoloader;
        if (autoloader)
          autoloader.loadLanguages(language);
        loadFile(src, function(text) {
          pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
          var range = parseRange(pre.getAttribute("data-range"));
          if (range) {
            var lines = text.split(/\r\n?|\n/g);
            var start = range[0];
            var end = range[1] == null ? lines.length : range[1];
            if (start < 0)
              start += lines.length;
            start = Math.max(0, Math.min(start - 1, lines.length));
            if (end < 0)
              end += lines.length;
            end = Math.max(0, Math.min(end, lines.length));
            text = lines.slice(start, end).join("\n");
            if (!pre.hasAttribute("data-start"))
              pre.setAttribute("data-start", String(start + 1));
          }
          code.textContent = text;
          $34b6613fd50afc6a$var$Prism.highlightElement(code);
        }, function(error) {
          pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
          code.textContent = error;
        });
      }
    });
    $34b6613fd50afc6a$var$Prism.plugins.fileHighlight = {
      /**
      * Executes the File Highlight plugin for all matching `pre` elements under the given container.
      *
      * Note: Elements which are already loaded or currently loading will not be touched by this method.
      *
      * @param {ParentNode} [container=document]
      */
      highlight: function highlight(container) {
        var elements = (container || document).querySelectorAll(SELECTOR);
        for (var i = 0, element; element = elements[i++]; )
          $34b6613fd50afc6a$var$Prism.highlightElement(element);
      }
    };
    var logged = false;
    $34b6613fd50afc6a$var$Prism.fileHighlight = function() {
      if (!logged) {
        console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
        logged = true;
      }
      $34b6613fd50afc6a$var$Prism.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  })();
});
parcelRequire.register("i3bOO", function(module, exports) {
  var $7KTOy = parcelRequire("7KTOy");
  var $hVG8h = parcelRequire("hVG8h");
  module.exports = $hVG8h;
  $hVG8h.prototype.message = $d241acb5acf024fe$var$message;
  $hVG8h.prototype.info = $d241acb5acf024fe$var$info;
  $hVG8h.prototype.fail = $d241acb5acf024fe$var$fail;
  function $d241acb5acf024fe$var$message(reason, position, origin) {
    var message = new $7KTOy(reason, position, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  function $d241acb5acf024fe$var$fail() {
    var message = this.message.apply(this, arguments);
    message.fatal = true;
    throw message;
  }
  function $d241acb5acf024fe$var$info() {
    var message = this.message.apply(this, arguments);
    message.fatal = null;
    return message;
  }
});
parcelRequire.register("7KTOy", function(module, exports) {
  var $h6R6u = parcelRequire("h6R6u");
  module.exports = $017508c5821aacc0$var$VMessage;
  function $017508c5821aacc0$var$VMessagePrototype() {
  }
  $017508c5821aacc0$var$VMessagePrototype.prototype = Error.prototype;
  $017508c5821aacc0$var$VMessage.prototype = new $017508c5821aacc0$var$VMessagePrototype();
  var $017508c5821aacc0$var$proto = $017508c5821aacc0$var$VMessage.prototype;
  $017508c5821aacc0$var$proto.file = "";
  $017508c5821aacc0$var$proto.name = "";
  $017508c5821aacc0$var$proto.reason = "";
  $017508c5821aacc0$var$proto.message = "";
  $017508c5821aacc0$var$proto.stack = "";
  $017508c5821aacc0$var$proto.fatal = null;
  $017508c5821aacc0$var$proto.column = null;
  $017508c5821aacc0$var$proto.line = null;
  function $017508c5821aacc0$var$VMessage(reason, position, origin) {
    var parts;
    var range;
    var location;
    if (typeof position === "string") {
      origin = position;
      position = null;
    }
    parts = $017508c5821aacc0$var$parseOrigin(origin);
    range = $h6R6u(position) || "1:1";
    location = {
      start: {
        line: null,
        column: null
      },
      end: {
        line: null,
        column: null
      }
    };
    if (position && position.position)
      position = position.position;
    if (position) {
      if (position.start) {
        location = position;
        position = position.start;
      } else
        location.start = position;
    }
    if (reason.stack) {
      this.stack = reason.stack;
      reason = reason.message;
    }
    this.message = reason;
    this.name = range;
    this.reason = reason;
    this.line = position ? position.line : null;
    this.column = position ? position.column : null;
    this.location = location;
    this.source = parts[0];
    this.ruleId = parts[1];
  }
  function $017508c5821aacc0$var$parseOrigin(origin) {
    var result = [
      null,
      null
    ];
    var index;
    if (typeof origin === "string") {
      index = origin.indexOf(":");
      if (index === -1)
        result[1] = origin;
      else {
        result[0] = origin.slice(0, index);
        result[1] = origin.slice(index + 1);
      }
    }
    return result;
  }
});
parcelRequire.register("h6R6u", function(module, exports) {
  var $c74c307ec7a099f3$var$own = {}.hasOwnProperty;
  module.exports = $c74c307ec7a099f3$var$stringify;
  function $c74c307ec7a099f3$var$stringify(value) {
    if (!value || typeof value !== "object")
      return "";
    if ($c74c307ec7a099f3$var$own.call(value, "position") || $c74c307ec7a099f3$var$own.call(value, "type"))
      return $c74c307ec7a099f3$var$position(value.position);
    if ($c74c307ec7a099f3$var$own.call(value, "start") || $c74c307ec7a099f3$var$own.call(value, "end"))
      return $c74c307ec7a099f3$var$position(value);
    if ($c74c307ec7a099f3$var$own.call(value, "line") || $c74c307ec7a099f3$var$own.call(value, "column"))
      return $c74c307ec7a099f3$var$point(value);
    return "";
  }
  function $c74c307ec7a099f3$var$point(point) {
    if (!point || typeof point !== "object")
      point = {};
    return $c74c307ec7a099f3$var$index(point.line) + ":" + $c74c307ec7a099f3$var$index(point.column);
  }
  function $c74c307ec7a099f3$var$position(pos) {
    if (!pos || typeof pos !== "object")
      pos = {};
    return $c74c307ec7a099f3$var$point(pos.start) + "-" + $c74c307ec7a099f3$var$point(pos.end);
  }
  function $c74c307ec7a099f3$var$index(value) {
    return value && typeof value === "number" ? value : 1;
  }
});
parcelRequire.register("hVG8h", function(module, exports) {
  var $dxIWx = parcelRequire("dxIWx");
  var $4FYWM = parcelRequire("4FYWM");
  var $9POxA2 = parcelRequire("9POxA");
  module.exports = $d0d871292c0df40d$var$VFile;
  var $d0d871292c0df40d$var$own = {}.hasOwnProperty;
  var $d0d871292c0df40d$var$order = [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ];
  $d0d871292c0df40d$var$VFile.prototype.toString = $d0d871292c0df40d$var$toString;
  Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "path", {
    get: $d0d871292c0df40d$var$getPath,
    set: $d0d871292c0df40d$var$setPath
  });
  Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "dirname", {
    get: $d0d871292c0df40d$var$getDirname,
    set: $d0d871292c0df40d$var$setDirname
  });
  Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "basename", {
    get: $d0d871292c0df40d$var$getBasename,
    set: $d0d871292c0df40d$var$setBasename
  });
  Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "extname", {
    get: $d0d871292c0df40d$var$getExtname,
    set: $d0d871292c0df40d$var$setExtname
  });
  Object.defineProperty($d0d871292c0df40d$var$VFile.prototype, "stem", {
    get: $d0d871292c0df40d$var$getStem,
    set: $d0d871292c0df40d$var$setStem
  });
  function $d0d871292c0df40d$var$VFile(options) {
    var prop;
    var index;
    if (!options)
      options = {};
    else if (typeof options === "string" || $9POxA2(options))
      options = {
        contents: options
      };
    else if ("message" in options && "messages" in options)
      return options;
    if (!(this instanceof $d0d871292c0df40d$var$VFile))
      return new $d0d871292c0df40d$var$VFile(options);
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = $4FYWM.cwd();
    index = -1;
    while (++index < $d0d871292c0df40d$var$order.length) {
      prop = $d0d871292c0df40d$var$order[index];
      if ($d0d871292c0df40d$var$own.call(options, prop))
        this[prop] = options[prop];
    }
    for (prop in options)
      if ($d0d871292c0df40d$var$order.indexOf(prop) < 0)
        this[prop] = options[prop];
  }
  function $d0d871292c0df40d$var$getPath() {
    return this.history[this.history.length - 1];
  }
  function $d0d871292c0df40d$var$setPath(path) {
    $d0d871292c0df40d$var$assertNonEmpty(path, "path");
    if (this.path !== path)
      this.history.push(path);
  }
  function $d0d871292c0df40d$var$getDirname() {
    return typeof this.path === "string" ? $dxIWx.dirname(this.path) : void 0;
  }
  function $d0d871292c0df40d$var$setDirname(dirname) {
    $d0d871292c0df40d$var$assertPath(this.path, "dirname");
    this.path = $dxIWx.join(dirname || "", this.basename);
  }
  function $d0d871292c0df40d$var$getBasename() {
    return typeof this.path === "string" ? $dxIWx.basename(this.path) : void 0;
  }
  function $d0d871292c0df40d$var$setBasename(basename) {
    $d0d871292c0df40d$var$assertNonEmpty(basename, "basename");
    $d0d871292c0df40d$var$assertPart(basename, "basename");
    this.path = $dxIWx.join(this.dirname || "", basename);
  }
  function $d0d871292c0df40d$var$getExtname() {
    return typeof this.path === "string" ? $dxIWx.extname(this.path) : void 0;
  }
  function $d0d871292c0df40d$var$setExtname(extname) {
    $d0d871292c0df40d$var$assertPart(extname, "extname");
    $d0d871292c0df40d$var$assertPath(this.path, "extname");
    if (extname) {
      if (extname.charCodeAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (extname.indexOf(".", 1) > -1)
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $dxIWx.join(this.dirname, this.stem + (extname || ""));
  }
  function $d0d871292c0df40d$var$getStem() {
    return typeof this.path === "string" ? $dxIWx.basename(this.path, this.extname) : void 0;
  }
  function $d0d871292c0df40d$var$setStem(stem) {
    $d0d871292c0df40d$var$assertNonEmpty(stem, "stem");
    $d0d871292c0df40d$var$assertPart(stem, "stem");
    this.path = $dxIWx.join(this.dirname || "", stem + (this.extname || ""));
  }
  function $d0d871292c0df40d$var$toString(encoding) {
    return (this.contents || "").toString(encoding);
  }
  function $d0d871292c0df40d$var$assertPart(part, name) {
    if (part && part.indexOf($dxIWx.sep) > -1)
      throw new Error("`" + name + "` cannot be a path: did not expect `" + $dxIWx.sep + "`");
  }
  function $d0d871292c0df40d$var$assertNonEmpty(part, name) {
    if (!part)
      throw new Error("`" + name + "` cannot be empty");
  }
  function $d0d871292c0df40d$var$assertPath(path, name) {
    if (!path)
      throw new Error("Setting `" + name + "` requires `path` to be set too");
  }
});
parcelRequire.register("dxIWx", function(module, exports) {
  module.exports = $4S4dR$path1;
});
parcelRequire.register("4FYWM", function(module, exports) {
  module.exports = process;
});
parcelRequire.register("9POxA", function(module, exports) {
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module.exports = function isBuffer2(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
});
parcelRequire.register("cSDDS", function(module, exports) {
  if (typeof Object.create === "function")
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  else
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
});
parcelRequire.register("fh61I", function(module, exports) {
  var $gqx3p2 = parcelRequire("gqx3p");
  var $62RH5 = parcelRequire("62RH5");
  var $c0y3C = parcelRequire("c0y3C");
  module.exports = $b1ed1e5730f8b37a$var$setOptions;
  function $b1ed1e5730f8b37a$var$setOptions(options) {
    var self2 = this;
    var current = self2.options;
    var key;
    var value;
    if (options == null)
      options = {};
    else if (typeof options === "object")
      options = $gqx3p2(options);
    else
      throw new Error("Invalid value `" + options + "` for setting `options`");
    for (key in $c0y3C) {
      value = options[key];
      if (value == null)
        value = current[key];
      if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object")
        throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
      options[key] = value;
    }
    self2.options = options;
    self2.escape = $62RH5(options);
    return self2;
  }
});
parcelRequire.register("gqx3p", function(module, exports) {
  module.exports = $bf58b6e1a1bad1ce$var$extend;
  var $bf58b6e1a1bad1ce$var$hasOwnProperty = Object.prototype.hasOwnProperty;
  function $bf58b6e1a1bad1ce$var$extend() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        if ($bf58b6e1a1bad1ce$var$hasOwnProperty.call(source, key))
          target[key] = source[key];
    }
    return target;
  }
});
parcelRequire.register("62RH5", function(module, exports) {
  module.exports = $466c9474c0358230$var$escapes;
  var $466c9474c0358230$var$defaults = [
    "\\",
    "`",
    "*",
    "{",
    "}",
    "[",
    "]",
    "(",
    ")",
    "#",
    "+",
    "-",
    ".",
    "!",
    "_",
    ">"
  ];
  var $466c9474c0358230$var$gfm = $466c9474c0358230$var$defaults.concat([
    "~",
    "|"
  ]);
  var $466c9474c0358230$var$commonmark = $466c9474c0358230$var$gfm.concat([
    "\n",
    '"',
    "$",
    "%",
    "&",
    "'",
    ",",
    "/",
    ":",
    ";",
    "<",
    "=",
    "?",
    "@",
    "^"
  ]);
  $466c9474c0358230$var$escapes.default = $466c9474c0358230$var$defaults;
  $466c9474c0358230$var$escapes.gfm = $466c9474c0358230$var$gfm;
  $466c9474c0358230$var$escapes.commonmark = $466c9474c0358230$var$commonmark;
  function $466c9474c0358230$var$escapes(options) {
    var settings = options || {};
    if (settings.commonmark)
      return $466c9474c0358230$var$commonmark;
    return settings.gfm ? $466c9474c0358230$var$gfm : $466c9474c0358230$var$defaults;
  }
});
parcelRequire.register("c0y3C", function(module, exports) {
  module.exports = {
    position: true,
    gfm: true,
    commonmark: false,
    pedantic: false,
    blocks: parcelRequire("4Xmw9")
  };
});
parcelRequire.register("4Xmw9", function(module, exports) {
  module.exports = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "meta",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "pre",
    "section",
    "source",
    "title",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ];
});
parcelRequire.register("jPzk9", function(module, exports) {
  var $gqx3p2 = parcelRequire("gqx3p");
  var $55478 = parcelRequire("55478");
  module.exports = $e6fe2e5def165bbb$var$parse;
  var $e6fe2e5def165bbb$var$lineFeed = "\n";
  var $e6fe2e5def165bbb$var$lineBreaksExpression = /\r\n|\r/g;
  function $e6fe2e5def165bbb$var$parse() {
    var self2 = this;
    var value = String(self2.file);
    var start = {
      line: 1,
      column: 1,
      offset: 0
    };
    var content = $gqx3p2(start);
    var node;
    value = value.replace($e6fe2e5def165bbb$var$lineBreaksExpression, $e6fe2e5def165bbb$var$lineFeed);
    if (value.charCodeAt(0) === 65279) {
      value = value.slice(1);
      content.column++;
      content.offset++;
    }
    node = {
      type: "root",
      children: self2.tokenizeBlock(value, content),
      position: {
        start,
        end: self2.eof || $gqx3p2(start)
      }
    };
    if (!self2.options.position)
      $55478(node, true);
    return node;
  }
});
parcelRequire.register("55478", function(module, exports) {
  var $5cnuX2 = parcelRequire("5cnuX");
  module.exports = $3b309c60545c5649$var$removePosition;
  function $3b309c60545c5649$var$removePosition(node, force) {
    $5cnuX2(node, force ? $3b309c60545c5649$var$hard : $3b309c60545c5649$var$soft);
    return node;
  }
  function $3b309c60545c5649$var$hard(node) {
    delete node.position;
  }
  function $3b309c60545c5649$var$soft(node) {
    node.position = void 0;
  }
});
parcelRequire.register("5cnuX", function(module, exports) {
  module.exports = $3c904d00d8fa4e41$var$visit;
  var $hvmII = parcelRequire("hvmII");
  var $3c904d00d8fa4e41$var$CONTINUE = $hvmII.CONTINUE;
  var $3c904d00d8fa4e41$var$SKIP = $hvmII.SKIP;
  var $3c904d00d8fa4e41$var$EXIT = $hvmII.EXIT;
  $3c904d00d8fa4e41$var$visit.CONTINUE = $3c904d00d8fa4e41$var$CONTINUE;
  $3c904d00d8fa4e41$var$visit.SKIP = $3c904d00d8fa4e41$var$SKIP;
  $3c904d00d8fa4e41$var$visit.EXIT = $3c904d00d8fa4e41$var$EXIT;
  function $3c904d00d8fa4e41$var$visit(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    $hvmII(tree, test, overload, reverse);
    function overload(node, parents) {
      var parent = parents[parents.length - 1];
      var index = parent ? parent.children.indexOf(node) : null;
      return visitor(node, index, parent);
    }
  }
});
parcelRequire.register("hvmII", function(module, exports) {
  module.exports = $cbe6f4b3cca59231$var$visitParents;
  var $5MHnZ = parcelRequire("5MHnZ");
  var $lMJbn = parcelRequire("lMJbn");
  var $cbe6f4b3cca59231$var$CONTINUE = true;
  var $cbe6f4b3cca59231$var$SKIP = "skip";
  var $cbe6f4b3cca59231$var$EXIT = false;
  $cbe6f4b3cca59231$var$visitParents.CONTINUE = $cbe6f4b3cca59231$var$CONTINUE;
  $cbe6f4b3cca59231$var$visitParents.SKIP = $cbe6f4b3cca59231$var$SKIP;
  $cbe6f4b3cca59231$var$visitParents.EXIT = $cbe6f4b3cca59231$var$EXIT;
  function $cbe6f4b3cca59231$var$visitParents(tree, test, visitor, reverse) {
    var step;
    var is;
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    is = $5MHnZ(test);
    step = reverse ? -1 : 1;
    factory(tree, null, [])();
    function factory(node, index, parents) {
      var value = typeof node === "object" && node !== null ? node : {};
      var name;
      if (typeof value.type === "string") {
        name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
        visit.displayName = "node (" + $lMJbn(value.type + (name ? "<" + name + ">" : "")) + ")";
      }
      return visit;
      function visit() {
        var grandparents = parents.concat(node);
        var result = [];
        var subresult;
        var offset;
        if (!test || is(node, index, parents[parents.length - 1] || null)) {
          result = $cbe6f4b3cca59231$var$toResult(visitor(node, parents));
          if (result[0] === $cbe6f4b3cca59231$var$EXIT)
            return result;
        }
        if (node.children && result[0] !== $cbe6f4b3cca59231$var$SKIP) {
          offset = (reverse ? node.children.length : -1) + step;
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === $cbe6f4b3cca59231$var$EXIT)
              return subresult;
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
  function $cbe6f4b3cca59231$var$toResult(value) {
    if (value !== null && typeof value === "object" && "length" in value)
      return value;
    if (typeof value === "number")
      return [
        $cbe6f4b3cca59231$var$CONTINUE,
        value
      ];
    return [
      value
    ];
  }
});
parcelRequire.register("5MHnZ", function(module, exports) {
  module.exports = $436316f9d154723a$var$convert;
  function $436316f9d154723a$var$convert(test) {
    if (test == null)
      return $436316f9d154723a$var$ok;
    if (typeof test === "string")
      return $436316f9d154723a$var$typeFactory(test);
    if (typeof test === "object")
      return "length" in test ? $436316f9d154723a$var$anyFactory(test) : $436316f9d154723a$var$allFactory(test);
    if (typeof test === "function")
      return test;
    throw new Error("Expected function, string, or object as test");
  }
  function $436316f9d154723a$var$allFactory(test) {
    return all;
    function all(node) {
      var key;
      for (key in test) {
        if (node[key] !== test[key])
          return false;
      }
      return true;
    }
  }
  function $436316f9d154723a$var$anyFactory(tests) {
    var checks = [];
    var index = -1;
    while (++index < tests.length)
      checks[index] = $436316f9d154723a$var$convert(tests[index]);
    return any;
    function any() {
      var index2 = -1;
      while (++index2 < checks.length) {
        if (checks[index2].apply(this, arguments))
          return true;
      }
      return false;
    }
  }
  function $436316f9d154723a$var$typeFactory(test) {
    return type;
    function type(node) {
      return Boolean(node && node.type === test);
    }
  }
  function $436316f9d154723a$var$ok() {
    return true;
  }
});
parcelRequire.register("lMJbn", function(module, exports) {
  module.exports = $fdc120fed48dcdfd$var$color;
  function $fdc120fed48dcdfd$var$color(d) {
    return "\x1B[33m" + d + "\x1B[39m";
  }
});
parcelRequire.register("6MCKT", function(module, exports) {
  var $4f0549c3e762a5f7$var$reBlankLine = /^[ \t]*(\n|$)/;
  module.exports = $4f0549c3e762a5f7$var$blankLine;
  function $4f0549c3e762a5f7$var$blankLine(eat, value, silent) {
    var match;
    var subvalue = "";
    var index = 0;
    var length = value.length;
    while (index < length) {
      match = $4f0549c3e762a5f7$var$reBlankLine.exec(value.slice(index));
      if (match == null)
        break;
      index += match[0].length;
      subvalue += match[0];
    }
    if (subvalue === "")
      return;
    if (silent)
      return true;
    eat(subvalue);
  }
});
parcelRequire.register("eRBEg", function(module, exports) {
  var $iolzW = parcelRequire("iolzW");
  var $dM9W3 = parcelRequire("dM9W3");
  module.exports = $ad23382468445acd$var$indentedCode;
  var $ad23382468445acd$var$lineFeed = "\n";
  var $ad23382468445acd$var$tab = "	";
  var $ad23382468445acd$var$space = " ";
  var $ad23382468445acd$var$tabSize = 4;
  var $ad23382468445acd$var$codeIndent = $iolzW($ad23382468445acd$var$space, $ad23382468445acd$var$tabSize);
  function $ad23382468445acd$var$indentedCode(eat, value, silent) {
    var index = -1;
    var length = value.length;
    var subvalue = "";
    var content = "";
    var subvalueQueue = "";
    var contentQueue = "";
    var character;
    var blankQueue;
    var indent;
    while (++index < length) {
      character = value.charAt(index);
      if (indent) {
        indent = false;
        subvalue += subvalueQueue;
        content += contentQueue;
        subvalueQueue = "";
        contentQueue = "";
        if (character === $ad23382468445acd$var$lineFeed) {
          subvalueQueue = character;
          contentQueue = character;
        } else {
          subvalue += character;
          content += character;
          while (++index < length) {
            character = value.charAt(index);
            if (!character || character === $ad23382468445acd$var$lineFeed) {
              contentQueue = character;
              subvalueQueue = character;
              break;
            }
            subvalue += character;
            content += character;
          }
        }
      } else if (character === $ad23382468445acd$var$space && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
        subvalueQueue += $ad23382468445acd$var$codeIndent;
        index += 3;
        indent = true;
      } else if (character === $ad23382468445acd$var$tab) {
        subvalueQueue += character;
        indent = true;
      } else {
        blankQueue = "";
        while (character === $ad23382468445acd$var$tab || character === $ad23382468445acd$var$space) {
          blankQueue += character;
          character = value.charAt(++index);
        }
        if (character !== $ad23382468445acd$var$lineFeed)
          break;
        subvalueQueue += blankQueue + character;
        contentQueue += character;
      }
    }
    if (content) {
      if (silent)
        return true;
      return eat(subvalue)({
        type: "code",
        lang: null,
        meta: null,
        value: $dM9W3(content)
      });
    }
  }
});
parcelRequire.register("iolzW", function(module, exports) {
  var $d63b34f53feb40f2$var$res = "";
  var $d63b34f53feb40f2$var$cache;
  module.exports = $d63b34f53feb40f2$var$repeat;
  function $d63b34f53feb40f2$var$repeat(str, num) {
    if (typeof str !== "string")
      throw new TypeError("expected a string");
    if (num === 1)
      return str;
    if (num === 2)
      return str + str;
    var max = str.length * num;
    if ($d63b34f53feb40f2$var$cache !== str || typeof $d63b34f53feb40f2$var$cache === "undefined") {
      $d63b34f53feb40f2$var$cache = str;
      $d63b34f53feb40f2$var$res = "";
    } else if ($d63b34f53feb40f2$var$res.length >= max)
      return $d63b34f53feb40f2$var$res.substr(0, max);
    while (max > $d63b34f53feb40f2$var$res.length && num > 1) {
      if (num & 1)
        $d63b34f53feb40f2$var$res += str;
      num >>= 1;
      str += str;
    }
    $d63b34f53feb40f2$var$res += str;
    $d63b34f53feb40f2$var$res = $d63b34f53feb40f2$var$res.substr(0, max);
    return $d63b34f53feb40f2$var$res;
  }
});
parcelRequire.register("dM9W3", function(module, exports) {
  module.exports = $a0777706fddb1f22$var$trimTrailingLines;
  function $a0777706fddb1f22$var$trimTrailingLines(value) {
    return String(value).replace(/\n+$/, "");
  }
});
parcelRequire.register("1dZOZ", function(module, exports) {
  module.exports = $0e46f5cf904b3e03$var$fencedCode;
  var $0e46f5cf904b3e03$var$lineFeed = "\n";
  var $0e46f5cf904b3e03$var$tab = "	";
  var $0e46f5cf904b3e03$var$space = " ";
  var $0e46f5cf904b3e03$var$tilde = "~";
  var $0e46f5cf904b3e03$var$graveAccent = "`";
  var $0e46f5cf904b3e03$var$minFenceCount = 3;
  var $0e46f5cf904b3e03$var$tabSize = 4;
  function $0e46f5cf904b3e03$var$fencedCode(eat, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var length = value.length + 1;
    var index = 0;
    var subvalue = "";
    var fenceCount;
    var marker;
    var character;
    var flag;
    var lang;
    var meta;
    var queue;
    var content;
    var exdentedContent;
    var closing;
    var exdentedClosing;
    var indent;
    var now;
    if (!gfm)
      return;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab)
        break;
      subvalue += character;
      index++;
    }
    indent = index;
    character = value.charAt(index);
    if (character !== $0e46f5cf904b3e03$var$tilde && character !== $0e46f5cf904b3e03$var$graveAccent)
      return;
    index++;
    marker = character;
    fenceCount = 1;
    subvalue += character;
    while (index < length) {
      character = value.charAt(index);
      if (character !== marker)
        break;
      subvalue += character;
      fenceCount++;
      index++;
    }
    if (fenceCount < $0e46f5cf904b3e03$var$minFenceCount)
      return;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab)
        break;
      subvalue += character;
      index++;
    }
    flag = "";
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character === $0e46f5cf904b3e03$var$lineFeed || marker === $0e46f5cf904b3e03$var$graveAccent && character === marker)
        break;
      if (character === $0e46f5cf904b3e03$var$space || character === $0e46f5cf904b3e03$var$tab)
        queue += character;
      else {
        flag += queue + character;
        queue = "";
      }
      index++;
    }
    character = value.charAt(index);
    if (character && character !== $0e46f5cf904b3e03$var$lineFeed)
      return;
    if (silent)
      return true;
    now = eat.now();
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += flag;
    flag = self2.decode.raw(self2.unescape(flag), now);
    if (queue)
      subvalue += queue;
    queue = "";
    closing = "";
    exdentedClosing = "";
    content = "";
    exdentedContent = "";
    var skip = true;
    while (index < length) {
      character = value.charAt(index);
      content += closing;
      exdentedContent += exdentedClosing;
      closing = "";
      exdentedClosing = "";
      if (character !== $0e46f5cf904b3e03$var$lineFeed) {
        content += character;
        exdentedClosing += character;
        index++;
        continue;
      }
      if (skip) {
        subvalue += character;
        skip = false;
      } else {
        closing += character;
        exdentedClosing += character;
      }
      queue = "";
      index++;
      while (index < length) {
        character = value.charAt(index);
        if (character !== $0e46f5cf904b3e03$var$space)
          break;
        queue += character;
        index++;
      }
      closing += queue;
      exdentedClosing += queue.slice(indent);
      if (queue.length >= $0e46f5cf904b3e03$var$tabSize)
        continue;
      queue = "";
      while (index < length) {
        character = value.charAt(index);
        if (character !== marker)
          break;
        queue += character;
        index++;
      }
      closing += queue;
      exdentedClosing += queue;
      if (queue.length < fenceCount)
        continue;
      queue = "";
      while (index < length) {
        character = value.charAt(index);
        if (character !== $0e46f5cf904b3e03$var$space && character !== $0e46f5cf904b3e03$var$tab)
          break;
        closing += character;
        exdentedClosing += character;
        index++;
      }
      if (!character || character === $0e46f5cf904b3e03$var$lineFeed)
        break;
    }
    subvalue += content + closing;
    index = -1;
    length = flag.length;
    while (++index < length) {
      character = flag.charAt(index);
      if (character === $0e46f5cf904b3e03$var$space || character === $0e46f5cf904b3e03$var$tab) {
        if (!lang)
          lang = flag.slice(0, index);
      } else if (lang) {
        meta = flag.slice(index);
        break;
      }
    }
    return eat(subvalue)({
      type: "code",
      lang: lang || flag || null,
      meta: meta || null,
      value: exdentedContent
    });
  }
});
parcelRequire.register("1lYit", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $ibWU2 = parcelRequire("ibWU2");
  module.exports = $0fc68654454540bd$var$blockquote;
  var $0fc68654454540bd$var$lineFeed = "\n";
  var $0fc68654454540bd$var$tab = "	";
  var $0fc68654454540bd$var$space = " ";
  var $0fc68654454540bd$var$greaterThan = ">";
  function $0fc68654454540bd$var$blockquote(eat, value, silent) {
    var self2 = this;
    var offsets = self2.offset;
    var tokenizers = self2.blockTokenizers;
    var interruptors = self2.interruptBlockquote;
    var now = eat.now();
    var currentLine = now.line;
    var length = value.length;
    var values = [];
    var contents = [];
    var indents = [];
    var add;
    var index = 0;
    var character;
    var rest;
    var nextIndex;
    var content;
    var line;
    var startIndex;
    var prefixed;
    var exit;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $0fc68654454540bd$var$space && character !== $0fc68654454540bd$var$tab)
        break;
      index++;
    }
    if (value.charAt(index) !== $0fc68654454540bd$var$greaterThan)
      return;
    if (silent)
      return true;
    index = 0;
    while (index < length) {
      nextIndex = value.indexOf($0fc68654454540bd$var$lineFeed, index);
      startIndex = index;
      prefixed = false;
      if (nextIndex === -1)
        nextIndex = length;
      while (index < length) {
        character = value.charAt(index);
        if (character !== $0fc68654454540bd$var$space && character !== $0fc68654454540bd$var$tab)
          break;
        index++;
      }
      if (value.charAt(index) === $0fc68654454540bd$var$greaterThan) {
        index++;
        prefixed = true;
        if (value.charAt(index) === $0fc68654454540bd$var$space)
          index++;
      } else
        index = startIndex;
      content = value.slice(index, nextIndex);
      if (!prefixed && !$lSPH2(content)) {
        index = startIndex;
        break;
      }
      if (!prefixed) {
        rest = value.slice(index);
        if ($ibWU2(interruptors, tokenizers, self2, [
          eat,
          rest,
          true
        ]))
          break;
      }
      line = startIndex === index ? content : value.slice(startIndex, nextIndex);
      indents.push(index - startIndex);
      values.push(line);
      contents.push(content);
      index = nextIndex + 1;
    }
    index = -1;
    length = indents.length;
    add = eat(values.join($0fc68654454540bd$var$lineFeed));
    while (++index < length) {
      offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
      currentLine++;
    }
    exit = self2.enterBlock();
    contents = self2.tokenizeBlock(contents.join($0fc68654454540bd$var$lineFeed), now);
    exit();
    return add({
      type: "blockquote",
      children: contents
    });
  }
});
parcelRequire.register("lSPH2", function(module, exports) {
  exports = module.exports = trim;
  function trim(str) {
    if (str.trim)
      return str.trim();
    return exports.right(exports.left(str));
  }
  exports.left = function(str) {
    if (str.trimLeft)
      return str.trimLeft();
    return str.replace(/^\s\s*/, "");
  };
  exports.right = function(str) {
    if (str.trimRight)
      return str.trimRight();
    var whitespace_pattern = /\s/, i = str.length;
    while (whitespace_pattern.test(str.charAt(--i)))
      ;
    return str.slice(0, i + 1);
  };
});
parcelRequire.register("ibWU2", function(module, exports) {
  module.exports = $d3e6f1f8c40cdcc3$var$interrupt;
  function $d3e6f1f8c40cdcc3$var$interrupt(interruptors, tokenizers, ctx, parameters) {
    var length = interruptors.length;
    var index = -1;
    var interruptor;
    var config;
    while (++index < length) {
      interruptor = interruptors[index];
      config = interruptor[1] || {};
      if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic)
        continue;
      if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark)
        continue;
      if (tokenizers[interruptor[0]].apply(ctx, parameters))
        return true;
    }
    return false;
  }
});
parcelRequire.register("dbuo7", function(module, exports) {
  module.exports = $9993dfe192d1f70f$var$atxHeading;
  var $9993dfe192d1f70f$var$lineFeed = "\n";
  var $9993dfe192d1f70f$var$tab = "	";
  var $9993dfe192d1f70f$var$space = " ";
  var $9993dfe192d1f70f$var$numberSign = "#";
  var $9993dfe192d1f70f$var$maxFenceCount = 6;
  function $9993dfe192d1f70f$var$atxHeading(eat, value, silent) {
    var self2 = this;
    var pedantic = self2.options.pedantic;
    var length = value.length + 1;
    var index = -1;
    var now = eat.now();
    var subvalue = "";
    var content = "";
    var character;
    var queue;
    var depth;
    while (++index < length) {
      character = value.charAt(index);
      if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab) {
        index--;
        break;
      }
      subvalue += character;
    }
    depth = 0;
    while (++index <= length) {
      character = value.charAt(index);
      if (character !== $9993dfe192d1f70f$var$numberSign) {
        index--;
        break;
      }
      subvalue += character;
      depth++;
    }
    if (depth > $9993dfe192d1f70f$var$maxFenceCount)
      return;
    if (!depth || !pedantic && value.charAt(index + 1) === $9993dfe192d1f70f$var$numberSign)
      return;
    length = value.length + 1;
    queue = "";
    while (++index < length) {
      character = value.charAt(index);
      if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab) {
        index--;
        break;
      }
      queue += character;
    }
    if (!pedantic && queue.length === 0 && character && character !== $9993dfe192d1f70f$var$lineFeed)
      return;
    if (silent)
      return true;
    subvalue += queue;
    queue = "";
    content = "";
    while (++index < length) {
      character = value.charAt(index);
      if (!character || character === $9993dfe192d1f70f$var$lineFeed)
        break;
      if (character !== $9993dfe192d1f70f$var$space && character !== $9993dfe192d1f70f$var$tab && character !== $9993dfe192d1f70f$var$numberSign) {
        content += queue + character;
        queue = "";
        continue;
      }
      while (character === $9993dfe192d1f70f$var$space || character === $9993dfe192d1f70f$var$tab) {
        queue += character;
        character = value.charAt(++index);
      }
      if (!pedantic && content && !queue && character === $9993dfe192d1f70f$var$numberSign) {
        content += character;
        continue;
      }
      while (character === $9993dfe192d1f70f$var$numberSign) {
        queue += character;
        character = value.charAt(++index);
      }
      while (character === $9993dfe192d1f70f$var$space || character === $9993dfe192d1f70f$var$tab) {
        queue += character;
        character = value.charAt(++index);
      }
      index--;
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    return eat(subvalue)({
      type: "heading",
      depth,
      children: self2.tokenizeInline(content, now)
    });
  }
});
parcelRequire.register("etWp6", function(module, exports) {
  module.exports = $a8b113e4bd1e7a93$var$thematicBreak;
  var $a8b113e4bd1e7a93$var$tab = "	";
  var $a8b113e4bd1e7a93$var$lineFeed = "\n";
  var $a8b113e4bd1e7a93$var$space = " ";
  var $a8b113e4bd1e7a93$var$asterisk = "*";
  var $a8b113e4bd1e7a93$var$dash = "-";
  var $a8b113e4bd1e7a93$var$underscore = "_";
  var $a8b113e4bd1e7a93$var$maxCount = 3;
  function $a8b113e4bd1e7a93$var$thematicBreak(eat, value, silent) {
    var index = -1;
    var length = value.length + 1;
    var subvalue = "";
    var character;
    var marker;
    var markerCount;
    var queue;
    while (++index < length) {
      character = value.charAt(index);
      if (character !== $a8b113e4bd1e7a93$var$tab && character !== $a8b113e4bd1e7a93$var$space)
        break;
      subvalue += character;
    }
    if (character !== $a8b113e4bd1e7a93$var$asterisk && character !== $a8b113e4bd1e7a93$var$dash && character !== $a8b113e4bd1e7a93$var$underscore)
      return;
    marker = character;
    subvalue += character;
    markerCount = 1;
    queue = "";
    while (++index < length) {
      character = value.charAt(index);
      if (character === marker) {
        markerCount++;
        subvalue += queue + marker;
        queue = "";
      } else if (character === $a8b113e4bd1e7a93$var$space)
        queue += character;
      else if (markerCount >= $a8b113e4bd1e7a93$var$maxCount && (!character || character === $a8b113e4bd1e7a93$var$lineFeed)) {
        subvalue += queue;
        if (silent)
          return true;
        return eat(subvalue)({
          type: "thematicBreak"
        });
      } else
        return;
    }
  }
});
parcelRequire.register("2nv9J", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $iolzW = parcelRequire("iolzW");
  var $9cn3E = parcelRequire("9cn3E");
  var $6I3kJ = parcelRequire("6I3kJ");
  var $2ARjj = parcelRequire("2ARjj");
  var $ibWU2 = parcelRequire("ibWU2");
  module.exports = $1bb5e5b3cce06068$var$list;
  var $1bb5e5b3cce06068$var$asterisk = "*";
  var $1bb5e5b3cce06068$var$underscore = "_";
  var $1bb5e5b3cce06068$var$plusSign = "+";
  var $1bb5e5b3cce06068$var$dash = "-";
  var $1bb5e5b3cce06068$var$dot = ".";
  var $1bb5e5b3cce06068$var$space = " ";
  var $1bb5e5b3cce06068$var$lineFeed = "\n";
  var $1bb5e5b3cce06068$var$tab = "	";
  var $1bb5e5b3cce06068$var$rightParenthesis = ")";
  var $1bb5e5b3cce06068$var$lowercaseX = "x";
  var $1bb5e5b3cce06068$var$tabSize = 4;
  var $1bb5e5b3cce06068$var$looseListItemExpression = /\n\n(?!\s*$)/;
  var $1bb5e5b3cce06068$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
  var $1bb5e5b3cce06068$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
  var $1bb5e5b3cce06068$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
  var $1bb5e5b3cce06068$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
  function $1bb5e5b3cce06068$var$list(eat, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var pedantic = self2.options.pedantic;
    var tokenizers = self2.blockTokenizers;
    var interuptors = self2.interruptList;
    var index = 0;
    var length = value.length;
    var start = null;
    var size;
    var queue;
    var ordered;
    var character;
    var marker;
    var nextIndex;
    var startIndex;
    var prefixed;
    var currentMarker;
    var content;
    var line;
    var previousEmpty;
    var empty;
    var items;
    var allLines;
    var emptyLines;
    var item;
    var enterTop;
    var exitBlockquote;
    var spread = false;
    var node;
    var now;
    var end;
    var indented;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $1bb5e5b3cce06068$var$tab && character !== $1bb5e5b3cce06068$var$space)
        break;
      index++;
    }
    character = value.charAt(index);
    if (character === $1bb5e5b3cce06068$var$asterisk || character === $1bb5e5b3cce06068$var$plusSign || character === $1bb5e5b3cce06068$var$dash) {
      marker = character;
      ordered = false;
    } else {
      ordered = true;
      queue = "";
      while (index < length) {
        character = value.charAt(index);
        if (!$9cn3E(character))
          break;
        queue += character;
        index++;
      }
      character = value.charAt(index);
      if (!queue || !(character === $1bb5e5b3cce06068$var$dot || commonmark && character === $1bb5e5b3cce06068$var$rightParenthesis))
        return;
      if (silent && queue !== "1")
        return;
      start = parseInt(queue, 10);
      marker = character;
    }
    character = value.charAt(++index);
    if (character !== $1bb5e5b3cce06068$var$space && character !== $1bb5e5b3cce06068$var$tab && (pedantic || character !== $1bb5e5b3cce06068$var$lineFeed && character !== ""))
      return;
    if (silent)
      return true;
    index = 0;
    items = [];
    allLines = [];
    emptyLines = [];
    while (index < length) {
      nextIndex = value.indexOf($1bb5e5b3cce06068$var$lineFeed, index);
      startIndex = index;
      prefixed = false;
      indented = false;
      if (nextIndex === -1)
        nextIndex = length;
      size = 0;
      while (index < length) {
        character = value.charAt(index);
        if (character === $1bb5e5b3cce06068$var$tab)
          size += $1bb5e5b3cce06068$var$tabSize - size % $1bb5e5b3cce06068$var$tabSize;
        else if (character === $1bb5e5b3cce06068$var$space)
          size++;
        else
          break;
        index++;
      }
      if (item && size >= item.indent)
        indented = true;
      character = value.charAt(index);
      currentMarker = null;
      if (!indented) {
        if (character === $1bb5e5b3cce06068$var$asterisk || character === $1bb5e5b3cce06068$var$plusSign || character === $1bb5e5b3cce06068$var$dash) {
          currentMarker = character;
          index++;
          size++;
        } else {
          queue = "";
          while (index < length) {
            character = value.charAt(index);
            if (!$9cn3E(character))
              break;
            queue += character;
            index++;
          }
          character = value.charAt(index);
          index++;
          if (queue && (character === $1bb5e5b3cce06068$var$dot || commonmark && character === $1bb5e5b3cce06068$var$rightParenthesis)) {
            currentMarker = character;
            size += queue.length + 1;
          }
        }
        if (currentMarker) {
          character = value.charAt(index);
          if (character === $1bb5e5b3cce06068$var$tab) {
            size += $1bb5e5b3cce06068$var$tabSize - size % $1bb5e5b3cce06068$var$tabSize;
            index++;
          } else if (character === $1bb5e5b3cce06068$var$space) {
            end = index + $1bb5e5b3cce06068$var$tabSize;
            while (index < end) {
              if (value.charAt(index) !== $1bb5e5b3cce06068$var$space)
                break;
              index++;
              size++;
            }
            if (index === end && value.charAt(index) === $1bb5e5b3cce06068$var$space) {
              index -= $1bb5e5b3cce06068$var$tabSize - 1;
              size -= $1bb5e5b3cce06068$var$tabSize - 1;
            }
          } else if (character !== $1bb5e5b3cce06068$var$lineFeed && character !== "")
            currentMarker = null;
        }
      }
      if (currentMarker) {
        if (!pedantic && marker !== currentMarker)
          break;
        prefixed = true;
      } else {
        if (!commonmark && !indented && value.charAt(startIndex) === $1bb5e5b3cce06068$var$space)
          indented = true;
        else if (commonmark && item)
          indented = size >= item.indent || size > $1bb5e5b3cce06068$var$tabSize;
        prefixed = false;
        index = startIndex;
      }
      line = value.slice(startIndex, nextIndex);
      content = startIndex === index ? line : value.slice(index, nextIndex);
      if (currentMarker === $1bb5e5b3cce06068$var$asterisk || currentMarker === $1bb5e5b3cce06068$var$underscore || currentMarker === $1bb5e5b3cce06068$var$dash) {
        if (tokenizers.thematicBreak.call(self2, eat, line, true))
          break;
      }
      previousEmpty = empty;
      empty = !prefixed && !$lSPH2(content).length;
      if (indented && item) {
        item.value = item.value.concat(emptyLines, line);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (prefixed) {
        if (emptyLines.length !== 0) {
          spread = true;
          item.value.push("");
          item.trail = emptyLines.concat();
        }
        item = {
          value: [
            line
          ],
          indent: size,
          trail: []
        };
        items.push(item);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      } else if (empty) {
        if (previousEmpty && !commonmark)
          break;
        emptyLines.push(line);
      } else {
        if (previousEmpty)
          break;
        if ($ibWU2(interuptors, tokenizers, self2, [
          eat,
          line,
          true
        ]))
          break;
        item.value = item.value.concat(emptyLines, line);
        allLines = allLines.concat(emptyLines, line);
        emptyLines = [];
      }
      index = nextIndex + 1;
    }
    node = eat(allLines.join($1bb5e5b3cce06068$var$lineFeed)).reset({
      type: "list",
      ordered,
      start,
      spread,
      children: []
    });
    enterTop = self2.enterList();
    exitBlockquote = self2.enterBlock();
    index = -1;
    length = items.length;
    while (++index < length) {
      item = items[index].value.join($1bb5e5b3cce06068$var$lineFeed);
      now = eat.now();
      eat(item)($1bb5e5b3cce06068$var$listItem(self2, item, now), node);
      item = items[index].trail.join($1bb5e5b3cce06068$var$lineFeed);
      if (index !== length - 1)
        item += $1bb5e5b3cce06068$var$lineFeed;
      eat(item);
    }
    enterTop();
    exitBlockquote();
    return node;
  }
  function $1bb5e5b3cce06068$var$listItem(ctx, value, position) {
    var offsets = ctx.offset;
    var fn = ctx.options.pedantic ? $1bb5e5b3cce06068$var$pedanticListItem : $1bb5e5b3cce06068$var$normalListItem;
    var checked = null;
    var task;
    var indent;
    value = fn.apply(null, arguments);
    if (ctx.options.gfm) {
      task = value.match($1bb5e5b3cce06068$var$taskItemExpression);
      if (task) {
        indent = task[0].length;
        checked = task[1].toLowerCase() === $1bb5e5b3cce06068$var$lowercaseX;
        offsets[position.line] += indent;
        value = value.slice(indent);
      }
    }
    return {
      type: "listItem",
      spread: $1bb5e5b3cce06068$var$looseListItemExpression.test(value),
      checked,
      children: ctx.tokenizeBlock(value, position)
    };
  }
  function $1bb5e5b3cce06068$var$pedanticListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    value = value.replace($1bb5e5b3cce06068$var$pedanticBulletExpression, replacer);
    line = position.line;
    return value.replace($1bb5e5b3cce06068$var$initialIndentExpression, replacer);
    function replacer($0) {
      offsets[line] = (offsets[line] || 0) + $0.length;
      line++;
      return "";
    }
  }
  function $1bb5e5b3cce06068$var$normalListItem(ctx, value, position) {
    var offsets = ctx.offset;
    var line = position.line;
    var max;
    var bullet;
    var rest;
    var lines;
    var trimmedLines;
    var index;
    var length;
    value = value.replace($1bb5e5b3cce06068$var$bulletExpression, replacer);
    lines = value.split($1bb5e5b3cce06068$var$lineFeed);
    trimmedLines = $2ARjj(value, $6I3kJ(max).indent).split($1bb5e5b3cce06068$var$lineFeed);
    trimmedLines[0] = rest;
    offsets[line] = (offsets[line] || 0) + bullet.length;
    line++;
    index = 0;
    length = lines.length;
    while (++index < length) {
      offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
      line++;
    }
    return trimmedLines.join($1bb5e5b3cce06068$var$lineFeed);
    function replacer($0, $1, $2, $3, $4) {
      bullet = $1 + $2 + $3;
      rest = $4;
      if (Number($2) < 10 && bullet.length % 2 === 1)
        $2 = $1bb5e5b3cce06068$var$space + $2;
      max = $1 + $iolzW($1bb5e5b3cce06068$var$space, $2.length) + $3;
      return max + rest;
    }
  }
});
parcelRequire.register("9cn3E", function(module, exports) {
  module.exports = $6b271edc473bdd9b$var$decimal;
  function $6b271edc473bdd9b$var$decimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 48 && code <= 57;
  }
});
parcelRequire.register("6I3kJ", function(module, exports) {
  module.exports = $4e297013b392cffd$var$indentation;
  var $4e297013b392cffd$var$tab = "	";
  var $4e297013b392cffd$var$space = " ";
  var $4e297013b392cffd$var$spaceSize = 1;
  var $4e297013b392cffd$var$tabSize = 4;
  function $4e297013b392cffd$var$indentation(value) {
    var index = 0;
    var indent = 0;
    var character = value.charAt(index);
    var stops = {};
    var size;
    var lastIndent = 0;
    while (character === $4e297013b392cffd$var$tab || character === $4e297013b392cffd$var$space) {
      size = character === $4e297013b392cffd$var$tab ? $4e297013b392cffd$var$tabSize : $4e297013b392cffd$var$spaceSize;
      indent += size;
      if (size > 1)
        indent = Math.floor(indent / size) * size;
      while (lastIndent < indent)
        stops[++lastIndent] = index;
      character = value.charAt(++index);
    }
    return {
      indent,
      stops
    };
  }
});
parcelRequire.register("2ARjj", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $iolzW = parcelRequire("iolzW");
  var $6I3kJ = parcelRequire("6I3kJ");
  module.exports = $1e384bea36573dc1$var$indentation;
  var $1e384bea36573dc1$var$lineFeed = "\n";
  var $1e384bea36573dc1$var$space = " ";
  var $1e384bea36573dc1$var$exclamationMark = "!";
  function $1e384bea36573dc1$var$indentation(value, maximum) {
    var values = value.split($1e384bea36573dc1$var$lineFeed);
    var position = values.length + 1;
    var minIndent = Infinity;
    var matrix = [];
    var index;
    var indentation;
    var stops;
    values.unshift($iolzW($1e384bea36573dc1$var$space, maximum) + $1e384bea36573dc1$var$exclamationMark);
    while (position--) {
      indentation = $6I3kJ(values[position]);
      matrix[position] = indentation.stops;
      if ($lSPH2(values[position]).length === 0)
        continue;
      if (indentation.indent) {
        if (indentation.indent > 0 && indentation.indent < minIndent)
          minIndent = indentation.indent;
      } else {
        minIndent = Infinity;
        break;
      }
    }
    if (minIndent !== Infinity) {
      position = values.length;
      while (position--) {
        stops = matrix[position];
        index = minIndent;
        while (index && !(index in stops))
          index--;
        values[position] = values[position].slice(stops[index] + 1);
      }
    }
    values.shift();
    return values.join($1e384bea36573dc1$var$lineFeed);
  }
});
parcelRequire.register("igoS1", function(module, exports) {
  module.exports = $d4bd0357c1035059$var$setextHeading;
  var $d4bd0357c1035059$var$lineFeed = "\n";
  var $d4bd0357c1035059$var$tab = "	";
  var $d4bd0357c1035059$var$space = " ";
  var $d4bd0357c1035059$var$equalsTo = "=";
  var $d4bd0357c1035059$var$dash = "-";
  var $d4bd0357c1035059$var$maxIndent = 3;
  var $d4bd0357c1035059$var$equalsToDepth = 1;
  var $d4bd0357c1035059$var$dashDepth = 2;
  function $d4bd0357c1035059$var$setextHeading(eat, value, silent) {
    var self2 = this;
    var now = eat.now();
    var length = value.length;
    var index = -1;
    var subvalue = "";
    var content;
    var queue;
    var character;
    var marker;
    var depth;
    while (++index < length) {
      character = value.charAt(index);
      if (character !== $d4bd0357c1035059$var$space || index >= $d4bd0357c1035059$var$maxIndent) {
        index--;
        break;
      }
      subvalue += character;
    }
    content = "";
    queue = "";
    while (++index < length) {
      character = value.charAt(index);
      if (character === $d4bd0357c1035059$var$lineFeed) {
        index--;
        break;
      }
      if (character === $d4bd0357c1035059$var$space || character === $d4bd0357c1035059$var$tab)
        queue += character;
      else {
        content += queue + character;
        queue = "";
      }
    }
    now.column += subvalue.length;
    now.offset += subvalue.length;
    subvalue += content + queue;
    character = value.charAt(++index);
    marker = value.charAt(++index);
    if (character !== $d4bd0357c1035059$var$lineFeed || marker !== $d4bd0357c1035059$var$equalsTo && marker !== $d4bd0357c1035059$var$dash)
      return;
    subvalue += character;
    queue = marker;
    depth = marker === $d4bd0357c1035059$var$equalsTo ? $d4bd0357c1035059$var$equalsToDepth : $d4bd0357c1035059$var$dashDepth;
    while (++index < length) {
      character = value.charAt(index);
      if (character !== marker) {
        if (character !== $d4bd0357c1035059$var$lineFeed)
          return;
        index--;
        break;
      }
      queue += character;
    }
    if (silent)
      return true;
    return eat(subvalue + queue)({
      type: "heading",
      depth,
      children: self2.tokenizeInline(content, now)
    });
  }
});
parcelRequire.register("5mJ60", function(module, exports) {
  var $fjSMD = parcelRequire("fjSMD");
  var $3e81fceca342c5e2$require$openCloseTag = $fjSMD.openCloseTag;
  module.exports = $3e81fceca342c5e2$var$blockHtml;
  var $3e81fceca342c5e2$var$tab = "	";
  var $3e81fceca342c5e2$var$space = " ";
  var $3e81fceca342c5e2$var$lineFeed = "\n";
  var $3e81fceca342c5e2$var$lessThan = "<";
  var $3e81fceca342c5e2$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
  var $3e81fceca342c5e2$var$rawCloseExpression = /<\/(script|pre|style)>/i;
  var $3e81fceca342c5e2$var$commentOpenExpression = /^<!--/;
  var $3e81fceca342c5e2$var$commentCloseExpression = /-->/;
  var $3e81fceca342c5e2$var$instructionOpenExpression = /^<\?/;
  var $3e81fceca342c5e2$var$instructionCloseExpression = /\?>/;
  var $3e81fceca342c5e2$var$directiveOpenExpression = /^<![A-Za-z]/;
  var $3e81fceca342c5e2$var$directiveCloseExpression = />/;
  var $3e81fceca342c5e2$var$cdataOpenExpression = /^<!\[CDATA\[/;
  var $3e81fceca342c5e2$var$cdataCloseExpression = /]]>/;
  var $3e81fceca342c5e2$var$elementCloseExpression = /^$/;
  var $3e81fceca342c5e2$var$otherElementOpenExpression = new RegExp($3e81fceca342c5e2$require$openCloseTag.source + "\\s*$");
  function $3e81fceca342c5e2$var$blockHtml(eat, value, silent) {
    var self2 = this;
    var blocks = self2.options.blocks.join("|");
    var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
    var length = value.length;
    var index = 0;
    var next;
    var line;
    var offset;
    var character;
    var count;
    var sequence;
    var subvalue;
    var sequences = [
      [
        $3e81fceca342c5e2$var$rawOpenExpression,
        $3e81fceca342c5e2$var$rawCloseExpression,
        true
      ],
      [
        $3e81fceca342c5e2$var$commentOpenExpression,
        $3e81fceca342c5e2$var$commentCloseExpression,
        true
      ],
      [
        $3e81fceca342c5e2$var$instructionOpenExpression,
        $3e81fceca342c5e2$var$instructionCloseExpression,
        true
      ],
      [
        $3e81fceca342c5e2$var$directiveOpenExpression,
        $3e81fceca342c5e2$var$directiveCloseExpression,
        true
      ],
      [
        $3e81fceca342c5e2$var$cdataOpenExpression,
        $3e81fceca342c5e2$var$cdataCloseExpression,
        true
      ],
      [
        elementOpenExpression,
        $3e81fceca342c5e2$var$elementCloseExpression,
        true
      ],
      [
        $3e81fceca342c5e2$var$otherElementOpenExpression,
        $3e81fceca342c5e2$var$elementCloseExpression,
        false
      ]
    ];
    while (index < length) {
      character = value.charAt(index);
      if (character !== $3e81fceca342c5e2$var$tab && character !== $3e81fceca342c5e2$var$space)
        break;
      index++;
    }
    if (value.charAt(index) !== $3e81fceca342c5e2$var$lessThan)
      return;
    next = value.indexOf($3e81fceca342c5e2$var$lineFeed, index + 1);
    next = next === -1 ? length : next;
    line = value.slice(index, next);
    offset = -1;
    count = sequences.length;
    while (++offset < count)
      if (sequences[offset][0].test(line)) {
        sequence = sequences[offset];
        break;
      }
    if (!sequence)
      return;
    if (silent)
      return sequence[2];
    index = next;
    if (!sequence[1].test(line))
      while (index < length) {
        next = value.indexOf($3e81fceca342c5e2$var$lineFeed, index + 1);
        next = next === -1 ? length : next;
        line = value.slice(index + 1, next);
        if (sequence[1].test(line)) {
          if (line)
            index = next;
          break;
        }
        index = next;
      }
    subvalue = value.slice(0, index);
    return eat(subvalue)({
      type: "html",
      value: subvalue
    });
  }
});
parcelRequire.register("fjSMD", function(module, exports) {
  $parcel$export(module.exports, "openCloseTag", () => $b273203b5dbc1f7d$export$a33a5d2984e0051b, (v) => $b273203b5dbc1f7d$export$a33a5d2984e0051b = v);
  $parcel$export(module.exports, "tag", () => $b273203b5dbc1f7d$export$2b067c6666111485, (v) => $b273203b5dbc1f7d$export$2b067c6666111485 = v);
  var $b273203b5dbc1f7d$export$a33a5d2984e0051b;
  var $b273203b5dbc1f7d$export$2b067c6666111485;
  var $b273203b5dbc1f7d$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
  var $b273203b5dbc1f7d$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
  var $b273203b5dbc1f7d$var$singleQuoted = "'[^']*'";
  var $b273203b5dbc1f7d$var$doubleQuoted = '"[^"]*"';
  var $b273203b5dbc1f7d$var$attributeValue = "(?:" + $b273203b5dbc1f7d$var$unquoted + "|" + $b273203b5dbc1f7d$var$singleQuoted + "|" + $b273203b5dbc1f7d$var$doubleQuoted + ")";
  var $b273203b5dbc1f7d$var$attribute = "(?:\\s+" + $b273203b5dbc1f7d$var$attributeName + "(?:\\s*=\\s*" + $b273203b5dbc1f7d$var$attributeValue + ")?)";
  var $b273203b5dbc1f7d$var$openTag = "<[A-Za-z][A-Za-z0-9\\-]*" + $b273203b5dbc1f7d$var$attribute + "*\\s*\\/?>";
  var $b273203b5dbc1f7d$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
  var $b273203b5dbc1f7d$var$comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
  var $b273203b5dbc1f7d$var$processing = "<[?].*?[?]>";
  var $b273203b5dbc1f7d$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
  var $b273203b5dbc1f7d$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
  $b273203b5dbc1f7d$export$a33a5d2984e0051b = new RegExp("^(?:" + $b273203b5dbc1f7d$var$openTag + "|" + $b273203b5dbc1f7d$var$closeTag + ")");
  $b273203b5dbc1f7d$export$2b067c6666111485 = new RegExp("^(?:" + $b273203b5dbc1f7d$var$openTag + "|" + $b273203b5dbc1f7d$var$closeTag + "|" + $b273203b5dbc1f7d$var$comment + "|" + $b273203b5dbc1f7d$var$processing + "|" + $b273203b5dbc1f7d$var$declaration + "|" + $b273203b5dbc1f7d$var$cdata + ")");
});
parcelRequire.register("iUyeb", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  var $4Zypr = parcelRequire("4Zypr");
  module.exports = $dc4801de94817cd5$var$definition;
  var $dc4801de94817cd5$var$quotationMark = '"';
  var $dc4801de94817cd5$var$apostrophe = "'";
  var $dc4801de94817cd5$var$backslash = "\\";
  var $dc4801de94817cd5$var$lineFeed = "\n";
  var $dc4801de94817cd5$var$tab = "	";
  var $dc4801de94817cd5$var$space = " ";
  var $dc4801de94817cd5$var$leftSquareBracket = "[";
  var $dc4801de94817cd5$var$rightSquareBracket = "]";
  var $dc4801de94817cd5$var$leftParenthesis = "(";
  var $dc4801de94817cd5$var$rightParenthesis = ")";
  var $dc4801de94817cd5$var$colon = ":";
  var $dc4801de94817cd5$var$lessThan = "<";
  var $dc4801de94817cd5$var$greaterThan = ">";
  function $dc4801de94817cd5$var$definition(eat, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var beforeURL;
    var beforeTitle;
    var queue;
    var character;
    var test;
    var identifier;
    var url;
    var title;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$tab)
        break;
      subvalue += character;
      index++;
    }
    character = value.charAt(index);
    if (character !== $dc4801de94817cd5$var$leftSquareBracket)
      return;
    index++;
    subvalue += character;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character === $dc4801de94817cd5$var$rightSquareBracket)
        break;
      else if (character === $dc4801de94817cd5$var$backslash) {
        queue += character;
        index++;
        character = value.charAt(index);
      }
      queue += character;
      index++;
    }
    if (!queue || value.charAt(index) !== $dc4801de94817cd5$var$rightSquareBracket || value.charAt(index + 1) !== $dc4801de94817cd5$var$colon)
      return;
    identifier = queue;
    subvalue += queue + $dc4801de94817cd5$var$rightSquareBracket + $dc4801de94817cd5$var$colon;
    index = subvalue.length;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$lineFeed)
        break;
      subvalue += character;
      index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $dc4801de94817cd5$var$lessThan) {
      index++;
      while (index < length) {
        character = value.charAt(index);
        if (!$dc4801de94817cd5$var$isEnclosedURLCharacter(character))
          break;
        queue += character;
        index++;
      }
      character = value.charAt(index);
      if (character === $dc4801de94817cd5$var$isEnclosedURLCharacter.delimiter) {
        subvalue += $dc4801de94817cd5$var$lessThan + queue + character;
        index++;
      } else {
        if (commonmark)
          return;
        index -= queue.length + 1;
        queue = "";
      }
    }
    if (!queue) {
      while (index < length) {
        character = value.charAt(index);
        if (!$dc4801de94817cd5$var$isUnclosedURLCharacter(character))
          break;
        queue += character;
        index++;
      }
      subvalue += queue;
    }
    if (!queue)
      return;
    url = queue;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space && character !== $dc4801de94817cd5$var$lineFeed)
        break;
      queue += character;
      index++;
    }
    character = value.charAt(index);
    test = null;
    if (character === $dc4801de94817cd5$var$quotationMark)
      test = $dc4801de94817cd5$var$quotationMark;
    else if (character === $dc4801de94817cd5$var$apostrophe)
      test = $dc4801de94817cd5$var$apostrophe;
    else if (character === $dc4801de94817cd5$var$leftParenthesis)
      test = $dc4801de94817cd5$var$rightParenthesis;
    if (!test) {
      queue = "";
      index = subvalue.length;
    } else if (queue) {
      subvalue += queue + character;
      index = subvalue.length;
      queue = "";
      while (index < length) {
        character = value.charAt(index);
        if (character === test)
          break;
        if (character === $dc4801de94817cd5$var$lineFeed) {
          index++;
          character = value.charAt(index);
          if (character === $dc4801de94817cd5$var$lineFeed || character === test)
            return;
          queue += $dc4801de94817cd5$var$lineFeed;
        }
        queue += character;
        index++;
      }
      character = value.charAt(index);
      if (character !== test)
        return;
      beforeTitle = subvalue;
      subvalue += queue + character;
      index++;
      title = queue;
      queue = "";
    } else
      return;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $dc4801de94817cd5$var$tab && character !== $dc4801de94817cd5$var$space)
        break;
      subvalue += character;
      index++;
    }
    character = value.charAt(index);
    if (!character || character === $dc4801de94817cd5$var$lineFeed) {
      if (silent)
        return true;
      beforeURL = eat(beforeURL).test().end;
      url = self2.decode.raw(self2.unescape(url), beforeURL, {
        nonTerminated: false
      });
      if (title) {
        beforeTitle = eat(beforeTitle).test().end;
        title = self2.decode.raw(self2.unescape(title), beforeTitle);
      }
      return eat(subvalue)({
        type: "definition",
        identifier: $4Zypr(identifier),
        label: identifier,
        title: title || null,
        url
      });
    }
  }
  function $dc4801de94817cd5$var$isEnclosedURLCharacter(character) {
    return character !== $dc4801de94817cd5$var$greaterThan && character !== $dc4801de94817cd5$var$leftSquareBracket && character !== $dc4801de94817cd5$var$rightSquareBracket;
  }
  $dc4801de94817cd5$var$isEnclosedURLCharacter.delimiter = $dc4801de94817cd5$var$greaterThan;
  function $dc4801de94817cd5$var$isUnclosedURLCharacter(character) {
    return character !== $dc4801de94817cd5$var$leftSquareBracket && character !== $dc4801de94817cd5$var$rightSquareBracket && !$6qoLm(character);
  }
});
parcelRequire.register("6qoLm", function(module, exports) {
  module.exports = $4ad8612833b06372$var$whitespace;
  var $4ad8612833b06372$var$fromCode = String.fromCharCode;
  var $4ad8612833b06372$var$re = /\s/;
  function $4ad8612833b06372$var$whitespace(character) {
    return $4ad8612833b06372$var$re.test(typeof character === "number" ? $4ad8612833b06372$var$fromCode(character) : character.charAt(0));
  }
});
parcelRequire.register("4Zypr", function(module, exports) {
  var $jmMQ2 = parcelRequire("jmMQ2");
  module.exports = $3a278ce95e904ed3$var$normalize;
  function $3a278ce95e904ed3$var$normalize(value) {
    return $jmMQ2(value).toLowerCase();
  }
});
parcelRequire.register("jmMQ2", function(module, exports) {
  module.exports = $e195f4a9fe2fbe26$var$collapse;
  function $e195f4a9fe2fbe26$var$collapse(value) {
    return String(value).replace(/\s+/g, " ");
  }
});
parcelRequire.register("jvhub", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  module.exports = $e32e79e1c4c5fc3b$var$table;
  var $e32e79e1c4c5fc3b$var$tab = "	";
  var $e32e79e1c4c5fc3b$var$lineFeed = "\n";
  var $e32e79e1c4c5fc3b$var$space = " ";
  var $e32e79e1c4c5fc3b$var$dash = "-";
  var $e32e79e1c4c5fc3b$var$colon = ":";
  var $e32e79e1c4c5fc3b$var$backslash = "\\";
  var $e32e79e1c4c5fc3b$var$verticalBar = "|";
  var $e32e79e1c4c5fc3b$var$minColumns = 1;
  var $e32e79e1c4c5fc3b$var$minRows = 2;
  var $e32e79e1c4c5fc3b$var$left = "left";
  var $e32e79e1c4c5fc3b$var$center = "center";
  var $e32e79e1c4c5fc3b$var$right = "right";
  function $e32e79e1c4c5fc3b$var$table(eat, value, silent) {
    var self2 = this;
    var index;
    var alignments;
    var alignment;
    var subvalue;
    var row;
    var length;
    var lines;
    var queue;
    var character;
    var hasDash;
    var align;
    var cell;
    var preamble;
    var now;
    var position;
    var lineCount;
    var line;
    var rows;
    var table;
    var lineIndex;
    var pipeIndex;
    var first;
    if (!self2.options.gfm)
      return;
    index = 0;
    lineCount = 0;
    length = value.length + 1;
    lines = [];
    while (index < length) {
      lineIndex = value.indexOf($e32e79e1c4c5fc3b$var$lineFeed, index);
      pipeIndex = value.indexOf($e32e79e1c4c5fc3b$var$verticalBar, index + 1);
      if (lineIndex === -1)
        lineIndex = value.length;
      if (pipeIndex === -1 || pipeIndex > lineIndex) {
        if (lineCount < $e32e79e1c4c5fc3b$var$minRows)
          return;
        break;
      }
      lines.push(value.slice(index, lineIndex));
      lineCount++;
      index = lineIndex + 1;
    }
    subvalue = lines.join($e32e79e1c4c5fc3b$var$lineFeed);
    alignments = lines.splice(1, 1)[0] || [];
    index = 0;
    length = alignments.length;
    lineCount--;
    alignment = false;
    align = [];
    while (index < length) {
      character = alignments.charAt(index);
      if (character === $e32e79e1c4c5fc3b$var$verticalBar) {
        hasDash = null;
        if (alignment === false) {
          if (first === false)
            return;
        } else {
          align.push(alignment);
          alignment = false;
        }
        first = false;
      } else if (character === $e32e79e1c4c5fc3b$var$dash) {
        hasDash = true;
        alignment = alignment || null;
      } else if (character === $e32e79e1c4c5fc3b$var$colon) {
        if (alignment === $e32e79e1c4c5fc3b$var$left)
          alignment = $e32e79e1c4c5fc3b$var$center;
        else if (hasDash && alignment === null)
          alignment = $e32e79e1c4c5fc3b$var$right;
        else
          alignment = $e32e79e1c4c5fc3b$var$left;
      } else if (!$6qoLm(character))
        return;
      index++;
    }
    if (alignment !== false)
      align.push(alignment);
    if (align.length < $e32e79e1c4c5fc3b$var$minColumns)
      return;
    if (silent)
      return true;
    position = -1;
    rows = [];
    table = eat(subvalue).reset({
      type: "table",
      align,
      children: rows
    });
    while (++position < lineCount) {
      line = lines[position];
      row = {
        type: "tableRow",
        children: []
      };
      if (position)
        eat($e32e79e1c4c5fc3b$var$lineFeed);
      eat(line).reset(row, table);
      length = line.length + 1;
      index = 0;
      queue = "";
      cell = "";
      preamble = true;
      while (index < length) {
        character = line.charAt(index);
        if (character === $e32e79e1c4c5fc3b$var$tab || character === $e32e79e1c4c5fc3b$var$space) {
          if (cell)
            queue += character;
          else
            eat(character);
          index++;
          continue;
        }
        if (character === "" || character === $e32e79e1c4c5fc3b$var$verticalBar) {
          if (preamble)
            eat(character);
          else {
            if ((cell || character) && !preamble) {
              subvalue = cell;
              if (queue.length > 1) {
                if (character) {
                  subvalue += queue.slice(0, -1);
                  queue = queue.charAt(queue.length - 1);
                } else {
                  subvalue += queue;
                  queue = "";
                }
              }
              now = eat.now();
              eat(subvalue)({
                type: "tableCell",
                children: self2.tokenizeInline(cell, now)
              }, row);
            }
            eat(queue + character);
            queue = "";
            cell = "";
          }
        } else {
          if (queue) {
            cell += queue;
            queue = "";
          }
          cell += character;
          if (character === $e32e79e1c4c5fc3b$var$backslash && index !== length - 2) {
            cell += line.charAt(index + 1);
            index++;
          }
        }
        preamble = false;
        index++;
      }
      if (!position)
        eat($e32e79e1c4c5fc3b$var$lineFeed + alignments);
    }
    return table;
  }
});
parcelRequire.register("fkexf", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $dM9W3 = parcelRequire("dM9W3");
  var $ibWU2 = parcelRequire("ibWU2");
  module.exports = $b283ffa679ad5953$var$paragraph;
  var $b283ffa679ad5953$var$tab = "	";
  var $b283ffa679ad5953$var$lineFeed = "\n";
  var $b283ffa679ad5953$var$space = " ";
  var $b283ffa679ad5953$var$tabSize = 4;
  function $b283ffa679ad5953$var$paragraph(eat, value, silent) {
    var self2 = this;
    var settings = self2.options;
    var commonmark = settings.commonmark;
    var tokenizers = self2.blockTokenizers;
    var interruptors = self2.interruptParagraph;
    var index = value.indexOf($b283ffa679ad5953$var$lineFeed);
    var length = value.length;
    var position;
    var subvalue;
    var character;
    var size;
    var now;
    while (index < length) {
      if (index === -1) {
        index = length;
        break;
      }
      if (value.charAt(index + 1) === $b283ffa679ad5953$var$lineFeed)
        break;
      if (commonmark) {
        size = 0;
        position = index + 1;
        while (position < length) {
          character = value.charAt(position);
          if (character === $b283ffa679ad5953$var$tab) {
            size = $b283ffa679ad5953$var$tabSize;
            break;
          } else if (character === $b283ffa679ad5953$var$space)
            size++;
          else
            break;
          position++;
        }
        if (size >= $b283ffa679ad5953$var$tabSize && character !== $b283ffa679ad5953$var$lineFeed) {
          index = value.indexOf($b283ffa679ad5953$var$lineFeed, index + 1);
          continue;
        }
      }
      subvalue = value.slice(index + 1);
      if ($ibWU2(interruptors, tokenizers, self2, [
        eat,
        subvalue,
        true
      ]))
        break;
      position = index;
      index = value.indexOf($b283ffa679ad5953$var$lineFeed, index + 1);
      if (index !== -1 && $lSPH2(value.slice(position, index)) === "") {
        index = position;
        break;
      }
    }
    subvalue = value.slice(0, index);
    if (silent)
      return true;
    now = eat.now();
    subvalue = $dM9W3(subvalue);
    return eat(subvalue)({
      type: "paragraph",
      children: self2.tokenizeInline(subvalue, now)
    });
  }
});
parcelRequire.register("jGxnv", function(module, exports) {
  var $4DogI = parcelRequire("4DogI");
  module.exports = $e54bd4c139e2be15$var$escape;
  $e54bd4c139e2be15$var$escape.locator = $4DogI;
  var $e54bd4c139e2be15$var$lineFeed = "\n";
  var $e54bd4c139e2be15$var$backslash = "\\";
  function $e54bd4c139e2be15$var$escape(eat, value, silent) {
    var self2 = this;
    var character;
    var node;
    if (value.charAt(0) === $e54bd4c139e2be15$var$backslash) {
      character = value.charAt(1);
      if (self2.escape.indexOf(character) !== -1) {
        if (silent)
          return true;
        if (character === $e54bd4c139e2be15$var$lineFeed)
          node = {
            type: "break"
          };
        else
          node = {
            type: "text",
            value: character
          };
        return eat($e54bd4c139e2be15$var$backslash + character)(node);
      }
    }
  }
});
parcelRequire.register("4DogI", function(module, exports) {
  module.exports = $35fda13454910b20$var$locate;
  function $35fda13454910b20$var$locate(value, fromIndex) {
    return value.indexOf("\\", fromIndex);
  }
});
parcelRequire.register("aoJGq", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  var $3qZkh2 = parcelRequire("3qZkh");
  var $gQ52E = parcelRequire("gQ52E");
  module.exports = $791f950ae947bccc$var$autoLink;
  $791f950ae947bccc$var$autoLink.locator = $gQ52E;
  $791f950ae947bccc$var$autoLink.notInLink = true;
  var $791f950ae947bccc$var$lessThan = "<";
  var $791f950ae947bccc$var$greaterThan = ">";
  var $791f950ae947bccc$var$atSign = "@";
  var $791f950ae947bccc$var$slash = "/";
  var $791f950ae947bccc$var$mailto = "mailto:";
  var $791f950ae947bccc$var$mailtoLength = $791f950ae947bccc$var$mailto.length;
  function $791f950ae947bccc$var$autoLink(eat, value, silent) {
    var self2 = this;
    var subvalue = "";
    var length = value.length;
    var index = 0;
    var queue = "";
    var hasAtCharacter = false;
    var link = "";
    var character;
    var now;
    var content;
    var tokenizers;
    var exit;
    if (value.charAt(0) !== $791f950ae947bccc$var$lessThan)
      return;
    index++;
    subvalue = $791f950ae947bccc$var$lessThan;
    while (index < length) {
      character = value.charAt(index);
      if ($6qoLm(character) || character === $791f950ae947bccc$var$greaterThan || character === $791f950ae947bccc$var$atSign || character === ":" && value.charAt(index + 1) === $791f950ae947bccc$var$slash)
        break;
      queue += character;
      index++;
    }
    if (!queue)
      return;
    link += queue;
    queue = "";
    character = value.charAt(index);
    link += character;
    index++;
    if (character === $791f950ae947bccc$var$atSign)
      hasAtCharacter = true;
    else {
      if (character !== ":" || value.charAt(index + 1) !== $791f950ae947bccc$var$slash)
        return;
      link += $791f950ae947bccc$var$slash;
      index++;
    }
    while (index < length) {
      character = value.charAt(index);
      if ($6qoLm(character) || character === $791f950ae947bccc$var$greaterThan)
        break;
      queue += character;
      index++;
    }
    character = value.charAt(index);
    if (!queue || character !== $791f950ae947bccc$var$greaterThan)
      return;
    if (silent)
      return true;
    link += queue;
    content = link;
    subvalue += link + character;
    now = eat.now();
    now.column++;
    now.offset++;
    if (hasAtCharacter) {
      if (link.slice(0, $791f950ae947bccc$var$mailtoLength).toLowerCase() === $791f950ae947bccc$var$mailto) {
        content = content.slice($791f950ae947bccc$var$mailtoLength);
        now.column += $791f950ae947bccc$var$mailtoLength;
        now.offset += $791f950ae947bccc$var$mailtoLength;
      } else
        link = $791f950ae947bccc$var$mailto + link;
    }
    tokenizers = self2.inlineTokenizers;
    self2.inlineTokenizers = {
      text: tokenizers.text
    };
    exit = self2.enterLink();
    content = self2.tokenizeInline(content, now);
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat(subvalue)({
      type: "link",
      title: null,
      url: $3qZkh2(link, {
        nonTerminated: false
      }),
      children: content
    });
  }
});
parcelRequire.register("3qZkh", function(module, exports) {
  var $1qIcT = parcelRequire("1qIcT");
  var $17Ogq = parcelRequire("17Ogq");
  var $9cn3E = parcelRequire("9cn3E");
  var $lGwCQ = parcelRequire("lGwCQ");
  var $435e3 = parcelRequire("435e3");
  var $Cj6UP = parcelRequire("Cj6UP");
  module.exports = $28035edfc2d3de7e$var$parseEntities;
  var $28035edfc2d3de7e$var$own = {}.hasOwnProperty;
  var $28035edfc2d3de7e$var$fromCharCode = String.fromCharCode;
  var $28035edfc2d3de7e$var$noop = Function.prototype;
  var $28035edfc2d3de7e$var$defaults = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: false,
    nonTerminated: true
  };
  var $28035edfc2d3de7e$var$tab = 9;
  var $28035edfc2d3de7e$var$lineFeed = 10;
  var $28035edfc2d3de7e$var$formFeed = 12;
  var $28035edfc2d3de7e$var$space = 32;
  var $28035edfc2d3de7e$var$ampersand = 38;
  var $28035edfc2d3de7e$var$semicolon = 59;
  var $28035edfc2d3de7e$var$lessThan = 60;
  var $28035edfc2d3de7e$var$equalsTo = 61;
  var $28035edfc2d3de7e$var$numberSign = 35;
  var $28035edfc2d3de7e$var$uppercaseX = 88;
  var $28035edfc2d3de7e$var$lowercaseX = 120;
  var $28035edfc2d3de7e$var$replacementCharacter = 65533;
  var $28035edfc2d3de7e$var$name = "named";
  var $28035edfc2d3de7e$var$hexa = "hexadecimal";
  var $28035edfc2d3de7e$var$deci = "decimal";
  var $28035edfc2d3de7e$var$bases = {};
  $28035edfc2d3de7e$var$bases[$28035edfc2d3de7e$var$hexa] = 16;
  $28035edfc2d3de7e$var$bases[$28035edfc2d3de7e$var$deci] = 10;
  var $28035edfc2d3de7e$var$tests = {};
  $28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$name] = $435e3;
  $28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$deci] = $9cn3E;
  $28035edfc2d3de7e$var$tests[$28035edfc2d3de7e$var$hexa] = $lGwCQ;
  var $28035edfc2d3de7e$var$namedNotTerminated = 1;
  var $28035edfc2d3de7e$var$numericNotTerminated = 2;
  var $28035edfc2d3de7e$var$namedEmpty = 3;
  var $28035edfc2d3de7e$var$numericEmpty = 4;
  var $28035edfc2d3de7e$var$namedUnknown = 5;
  var $28035edfc2d3de7e$var$numericDisallowed = 6;
  var $28035edfc2d3de7e$var$numericProhibited = 7;
  var $28035edfc2d3de7e$var$messages = {};
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedEmpty] = "Named character references cannot be empty";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericEmpty] = "Numeric character references cannot be empty";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$namedUnknown] = "Named character references must be known";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericDisallowed] = "Numeric character references cannot be disallowed";
  $28035edfc2d3de7e$var$messages[$28035edfc2d3de7e$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
  function $28035edfc2d3de7e$var$parseEntities(value, options) {
    var settings = {};
    var option;
    var key;
    if (!options)
      options = {};
    for (key in $28035edfc2d3de7e$var$defaults) {
      option = options[key];
      settings[key] = option === null || option === void 0 ? $28035edfc2d3de7e$var$defaults[key] : option;
    }
    if (settings.position.indent || settings.position.start) {
      settings.indent = settings.position.indent || [];
      settings.position = settings.position.start;
    }
    return $28035edfc2d3de7e$var$parse(value, settings);
  }
  function $28035edfc2d3de7e$var$parse(value, settings) {
    var additional = settings.additional;
    var nonTerminated = settings.nonTerminated;
    var handleText = settings.text;
    var handleReference = settings.reference;
    var handleWarning = settings.warning;
    var textContext = settings.textContext;
    var referenceContext = settings.referenceContext;
    var warningContext = settings.warningContext;
    var pos = settings.position;
    var indent = settings.indent || [];
    var length = value.length;
    var index = 0;
    var lines = -1;
    var column = pos.column || 1;
    var line = pos.line || 1;
    var queue = "";
    var result = [];
    var entityCharacters;
    var namedEntity;
    var terminated;
    var characters;
    var character;
    var reference;
    var following;
    var warning;
    var reason;
    var output;
    var entity;
    var begin;
    var start;
    var type;
    var test;
    var prev;
    var next;
    var diff;
    var end;
    if (typeof additional === "string")
      additional = additional.charCodeAt(0);
    prev = now();
    warning = handleWarning ? parseError : $28035edfc2d3de7e$var$noop;
    index--;
    length++;
    while (++index < length) {
      if (character === $28035edfc2d3de7e$var$lineFeed)
        column = indent[lines] || 1;
      character = value.charCodeAt(index);
      if (character === $28035edfc2d3de7e$var$ampersand) {
        following = value.charCodeAt(index + 1);
        if (following === $28035edfc2d3de7e$var$tab || following === $28035edfc2d3de7e$var$lineFeed || following === $28035edfc2d3de7e$var$formFeed || following === $28035edfc2d3de7e$var$space || following === $28035edfc2d3de7e$var$ampersand || following === $28035edfc2d3de7e$var$lessThan || following !== following || additional && following === additional) {
          queue += $28035edfc2d3de7e$var$fromCharCode(character);
          column++;
          continue;
        }
        start = index + 1;
        begin = start;
        end = start;
        if (following === $28035edfc2d3de7e$var$numberSign) {
          end = ++begin;
          following = value.charCodeAt(end);
          if (following === $28035edfc2d3de7e$var$uppercaseX || following === $28035edfc2d3de7e$var$lowercaseX) {
            type = $28035edfc2d3de7e$var$hexa;
            end = ++begin;
          } else
            type = $28035edfc2d3de7e$var$deci;
        } else
          type = $28035edfc2d3de7e$var$name;
        entityCharacters = "";
        entity = "";
        characters = "";
        test = $28035edfc2d3de7e$var$tests[type];
        end--;
        while (++end < length) {
          following = value.charCodeAt(end);
          if (!test(following))
            break;
          characters += $28035edfc2d3de7e$var$fromCharCode(following);
          if (type === $28035edfc2d3de7e$var$name && $28035edfc2d3de7e$var$own.call($1qIcT, characters)) {
            entityCharacters = characters;
            entity = $1qIcT[characters];
          }
        }
        terminated = value.charCodeAt(end) === $28035edfc2d3de7e$var$semicolon;
        if (terminated) {
          end++;
          namedEntity = type === $28035edfc2d3de7e$var$name ? $Cj6UP(characters) : false;
          if (namedEntity) {
            entityCharacters = characters;
            entity = namedEntity;
          }
        }
        diff = 1 + end - start;
        if (!terminated && !nonTerminated)
          ;
        else if (!characters) {
          if (type !== $28035edfc2d3de7e$var$name)
            warning($28035edfc2d3de7e$var$numericEmpty, diff);
        } else if (type === $28035edfc2d3de7e$var$name) {
          if (terminated && !entity)
            warning($28035edfc2d3de7e$var$namedUnknown, 1);
          else {
            if (entityCharacters !== characters) {
              end = begin + entityCharacters.length;
              diff = 1 + end - begin;
              terminated = false;
            }
            if (!terminated) {
              reason = entityCharacters ? $28035edfc2d3de7e$var$namedNotTerminated : $28035edfc2d3de7e$var$namedEmpty;
              if (settings.attribute) {
                following = value.charCodeAt(end);
                if (following === $28035edfc2d3de7e$var$equalsTo) {
                  warning(reason, diff);
                  entity = null;
                } else if ($435e3(following))
                  entity = null;
                else
                  warning(reason, diff);
              } else
                warning(reason, diff);
            }
          }
          reference = entity;
        } else {
          if (!terminated)
            warning($28035edfc2d3de7e$var$numericNotTerminated, diff);
          reference = parseInt(characters, $28035edfc2d3de7e$var$bases[type]);
          if ($28035edfc2d3de7e$var$prohibited(reference)) {
            warning($28035edfc2d3de7e$var$numericProhibited, diff);
            reference = $28035edfc2d3de7e$var$fromCharCode($28035edfc2d3de7e$var$replacementCharacter);
          } else if (reference in $17Ogq) {
            warning($28035edfc2d3de7e$var$numericDisallowed, diff);
            reference = $17Ogq[reference];
          } else {
            output = "";
            if ($28035edfc2d3de7e$var$disallowed(reference))
              warning($28035edfc2d3de7e$var$numericDisallowed, diff);
            if (reference > 65535) {
              reference -= 65536;
              output += $28035edfc2d3de7e$var$fromCharCode(reference >>> 10 | 55296);
              reference = 56320 | reference & 1023;
            }
            reference = output + $28035edfc2d3de7e$var$fromCharCode(reference);
          }
        }
        if (reference) {
          flush();
          prev = now();
          index = end - 1;
          column += end - start + 1;
          result.push(reference);
          next = now();
          next.offset++;
          if (handleReference)
            handleReference.call(referenceContext, reference, {
              start: prev,
              end: next
            }, value.slice(start - 1, end));
          prev = next;
        } else {
          characters = value.slice(start - 1, end);
          queue += characters;
          column += characters.length;
          index = end - 1;
        }
      } else {
        if (character === 10) {
          line++;
          lines++;
          column = 0;
        }
        if (character === character) {
          queue += $28035edfc2d3de7e$var$fromCharCode(character);
          column++;
        } else
          flush();
      }
    }
    return result.join("");
    function now() {
      return {
        line,
        column,
        offset: index + (pos.offset || 0)
      };
    }
    function parseError(code, offset) {
      var position = now();
      position.column += offset;
      position.offset += offset;
      handleWarning.call(warningContext, $28035edfc2d3de7e$var$messages[code], position, code);
    }
    function flush() {
      if (queue) {
        result.push(queue);
        if (handleText)
          handleText.call(textContext, queue, {
            start: prev,
            end: now()
          });
        queue = "";
      }
    }
  }
  function $28035edfc2d3de7e$var$prohibited(code) {
    return code >= 55296 && code <= 57343 || code > 1114111;
  }
  function $28035edfc2d3de7e$var$disallowed(code) {
    return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
  }
});
parcelRequire.register("1qIcT", function(module, exports) {
  module.exports = JSON.parse('{"AElig":"Æ","AMP":"&","Aacute":"Á","Acirc":"Â","Agrave":"À","Aring":"Å","Atilde":"Ã","Auml":"Ä","COPY":"©","Ccedil":"Ç","ETH":"Ð","Eacute":"É","Ecirc":"Ê","Egrave":"È","Euml":"Ë","GT":">","Iacute":"Í","Icirc":"Î","Igrave":"Ì","Iuml":"Ï","LT":"<","Ntilde":"Ñ","Oacute":"Ó","Ocirc":"Ô","Ograve":"Ò","Oslash":"Ø","Otilde":"Õ","Ouml":"Ö","QUOT":"\\"","REG":"®","THORN":"Þ","Uacute":"Ú","Ucirc":"Û","Ugrave":"Ù","Uuml":"Ü","Yacute":"Ý","aacute":"á","acirc":"â","acute":"´","aelig":"æ","agrave":"à","amp":"&","aring":"å","atilde":"ã","auml":"ä","brvbar":"¦","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","curren":"¤","deg":"°","divide":"÷","eacute":"é","ecirc":"ê","egrave":"è","eth":"ð","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","iacute":"í","icirc":"î","iexcl":"¡","igrave":"ì","iquest":"¿","iuml":"ï","laquo":"«","lt":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","ntilde":"ñ","oacute":"ó","ocirc":"ô","ograve":"ò","ordf":"ª","ordm":"º","oslash":"ø","otilde":"õ","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","raquo":"»","reg":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","thorn":"þ","times":"×","uacute":"ú","ucirc":"û","ugrave":"ù","uml":"¨","uuml":"ü","yacute":"ý","yen":"¥","yuml":"ÿ"}');
});
parcelRequire.register("17Ogq", function(module, exports) {
  module.exports = JSON.parse('{"0":"�","128":"€","130":"‚","131":"ƒ","132":"„","133":"…","134":"†","135":"‡","136":"ˆ","137":"‰","138":"Š","139":"‹","140":"Œ","142":"Ž","145":"‘","146":"’","147":"“","148":"”","149":"•","150":"–","151":"—","152":"˜","153":"™","154":"š","155":"›","156":"œ","158":"ž","159":"Ÿ"}');
});
parcelRequire.register("lGwCQ", function(module, exports) {
  module.exports = $fc96d3f76b074740$var$hexadecimal;
  function $fc96d3f76b074740$var$hexadecimal(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
  }
});
parcelRequire.register("435e3", function(module, exports) {
  var $jQpNp = parcelRequire("jQpNp");
  var $9cn3E = parcelRequire("9cn3E");
  module.exports = $2f2b7eeef6f58bd4$var$alphanumerical;
  function $2f2b7eeef6f58bd4$var$alphanumerical(character) {
    return $jQpNp(character) || $9cn3E(character);
  }
});
parcelRequire.register("jQpNp", function(module, exports) {
  module.exports = $e726e2348600cb26$var$alphabetical;
  function $e726e2348600cb26$var$alphabetical(character) {
    var code = typeof character === "string" ? character.charCodeAt(0) : character;
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
  }
});
parcelRequire.register("Cj6UP", function(module, exports) {
  var $5jBAm = parcelRequire("5jBAm");
  module.exports = $07325fae06a93008$var$decodeEntity;
  var $07325fae06a93008$var$own = {}.hasOwnProperty;
  function $07325fae06a93008$var$decodeEntity(characters) {
    return $07325fae06a93008$var$own.call($5jBAm, characters) ? $5jBAm[characters] : false;
  }
});
parcelRequire.register("5jBAm", function(module, exports) {
  module.exports = JSON.parse('{"AEli":"Æ","AElig":"Æ","AM":"&","AMP":"&","Aacut":"Á","Aacute":"Á","Abreve":"Ă","Acir":"Â","Acirc":"Â","Acy":"А","Afr":"𝔄","Agrav":"À","Agrave":"À","Alpha":"Α","Amacr":"Ā","And":"⩓","Aogon":"Ą","Aopf":"𝔸","ApplyFunction":"⁡","Arin":"Å","Aring":"Å","Ascr":"𝒜","Assign":"≔","Atild":"Ã","Atilde":"Ã","Aum":"Ä","Auml":"Ä","Backslash":"∖","Barv":"⫧","Barwed":"⌆","Bcy":"Б","Because":"∵","Bernoullis":"ℬ","Beta":"Β","Bfr":"𝔅","Bopf":"𝔹","Breve":"˘","Bscr":"ℬ","Bumpeq":"≎","CHcy":"Ч","COP":"©","COPY":"©","Cacute":"Ć","Cap":"⋒","CapitalDifferentialD":"ⅅ","Cayleys":"ℭ","Ccaron":"Č","Ccedi":"Ç","Ccedil":"Ç","Ccirc":"Ĉ","Cconint":"∰","Cdot":"Ċ","Cedilla":"¸","CenterDot":"·","Cfr":"ℭ","Chi":"Χ","CircleDot":"⊙","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","Colon":"∷","Colone":"⩴","Congruent":"≡","Conint":"∯","ContourIntegral":"∮","Copf":"ℂ","Coproduct":"∐","CounterClockwiseContourIntegral":"∳","Cross":"⨯","Cscr":"𝒞","Cup":"⋓","CupCap":"≍","DD":"ⅅ","DDotrahd":"⤑","DJcy":"Ђ","DScy":"Ѕ","DZcy":"Џ","Dagger":"‡","Darr":"↡","Dashv":"⫤","Dcaron":"Ď","Dcy":"Д","Del":"∇","Delta":"Δ","Dfr":"𝔇","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","Diamond":"⋄","DifferentialD":"ⅆ","Dopf":"𝔻","Dot":"¨","DotDot":"⃜","DotEqual":"≐","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrow":"↓","DownArrowBar":"⤓","DownArrowUpArrow":"⇵","DownBreve":"̑","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVector":"↽","DownLeftVectorBar":"⥖","DownRightTeeVector":"⥟","DownRightVector":"⇁","DownRightVectorBar":"⥗","DownTee":"⊤","DownTeeArrow":"↧","Downarrow":"⇓","Dscr":"𝒟","Dstrok":"Đ","ENG":"Ŋ","ET":"Ð","ETH":"Ð","Eacut":"É","Eacute":"É","Ecaron":"Ě","Ecir":"Ê","Ecirc":"Ê","Ecy":"Э","Edot":"Ė","Efr":"𝔈","Egrav":"È","Egrave":"È","Element":"∈","Emacr":"Ē","EmptySmallSquare":"◻","EmptyVerySmallSquare":"▫","Eogon":"Ę","Eopf":"𝔼","Epsilon":"Ε","Equal":"⩵","EqualTilde":"≂","Equilibrium":"⇌","Escr":"ℰ","Esim":"⩳","Eta":"Η","Eum":"Ë","Euml":"Ë","Exists":"∃","ExponentialE":"ⅇ","Fcy":"Ф","Ffr":"𝔉","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","Fopf":"𝔽","ForAll":"∀","Fouriertrf":"ℱ","Fscr":"ℱ","GJcy":"Ѓ","G":">","GT":">","Gamma":"Γ","Gammad":"Ϝ","Gbreve":"Ğ","Gcedil":"Ģ","Gcirc":"Ĝ","Gcy":"Г","Gdot":"Ġ","Gfr":"𝔊","Gg":"⋙","Gopf":"𝔾","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","Gt":"≫","HARDcy":"Ъ","Hacek":"ˇ","Hat":"^","Hcirc":"Ĥ","Hfr":"ℌ","HilbertSpace":"ℋ","Hopf":"ℍ","HorizontalLine":"─","Hscr":"ℋ","Hstrok":"Ħ","HumpDownHump":"≎","HumpEqual":"≏","IEcy":"Е","IJlig":"Ĳ","IOcy":"Ё","Iacut":"Í","Iacute":"Í","Icir":"Î","Icirc":"Î","Icy":"И","Idot":"İ","Ifr":"ℑ","Igrav":"Ì","Igrave":"Ì","Im":"ℑ","Imacr":"Ī","ImaginaryI":"ⅈ","Implies":"⇒","Int":"∬","Integral":"∫","Intersection":"⋂","InvisibleComma":"⁣","InvisibleTimes":"⁢","Iogon":"Į","Iopf":"𝕀","Iota":"Ι","Iscr":"ℐ","Itilde":"Ĩ","Iukcy":"І","Ium":"Ï","Iuml":"Ï","Jcirc":"Ĵ","Jcy":"Й","Jfr":"𝔍","Jopf":"𝕁","Jscr":"𝒥","Jsercy":"Ј","Jukcy":"Є","KHcy":"Х","KJcy":"Ќ","Kappa":"Κ","Kcedil":"Ķ","Kcy":"К","Kfr":"𝔎","Kopf":"𝕂","Kscr":"𝒦","LJcy":"Љ","L":"<","LT":"<","Lacute":"Ĺ","Lambda":"Λ","Lang":"⟪","Laplacetrf":"ℒ","Larr":"↞","Lcaron":"Ľ","Lcedil":"Ļ","Lcy":"Л","LeftAngleBracket":"⟨","LeftArrow":"←","LeftArrowBar":"⇤","LeftArrowRightArrow":"⇆","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVector":"⇃","LeftDownVectorBar":"⥙","LeftFloor":"⌊","LeftRightArrow":"↔","LeftRightVector":"⥎","LeftTee":"⊣","LeftTeeArrow":"↤","LeftTeeVector":"⥚","LeftTriangle":"⊲","LeftTriangleBar":"⧏","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVector":"↿","LeftUpVectorBar":"⥘","LeftVector":"↼","LeftVectorBar":"⥒","Leftarrow":"⇐","Leftrightarrow":"⇔","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","LessLess":"⪡","LessSlantEqual":"⩽","LessTilde":"≲","Lfr":"𝔏","Ll":"⋘","Lleftarrow":"⇚","Lmidot":"Ŀ","LongLeftArrow":"⟵","LongLeftRightArrow":"⟷","LongRightArrow":"⟶","Longleftarrow":"⟸","Longleftrightarrow":"⟺","Longrightarrow":"⟹","Lopf":"𝕃","LowerLeftArrow":"↙","LowerRightArrow":"↘","Lscr":"ℒ","Lsh":"↰","Lstrok":"Ł","Lt":"≪","Map":"⤅","Mcy":"М","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","MinusPlus":"∓","Mopf":"𝕄","Mscr":"ℳ","Mu":"Μ","NJcy":"Њ","Nacute":"Ń","Ncaron":"Ň","Ncedil":"Ņ","Ncy":"Н","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","Nfr":"𝔑","NoBreak":"⁠","NonBreakingSpace":" ","Nopf":"ℕ","Not":"⫬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","NotLeftTriangle":"⋪","NotLeftTriangleBar":"⧏̸","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangle":"⋫","NotRightTriangleBar":"⧐̸","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","Nscr":"𝒩","Ntild":"Ñ","Ntilde":"Ñ","Nu":"Ν","OElig":"Œ","Oacut":"Ó","Oacute":"Ó","Ocir":"Ô","Ocirc":"Ô","Ocy":"О","Odblac":"Ő","Ofr":"𝔒","Ograv":"Ò","Ograve":"Ò","Omacr":"Ō","Omega":"Ω","Omicron":"Ο","Oopf":"𝕆","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","Or":"⩔","Oscr":"𝒪","Oslas":"Ø","Oslash":"Ø","Otild":"Õ","Otilde":"Õ","Otimes":"⨷","Oum":"Ö","Ouml":"Ö","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","PartialD":"∂","Pcy":"П","Pfr":"𝔓","Phi":"Φ","Pi":"Π","PlusMinus":"±","Poincareplane":"ℌ","Popf":"ℙ","Pr":"⪻","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","Prime":"″","Product":"∏","Proportion":"∷","Proportional":"∝","Pscr":"𝒫","Psi":"Ψ","QUO":"\\"","QUOT":"\\"","Qfr":"𝔔","Qopf":"ℚ","Qscr":"𝒬","RBarr":"⤐","RE":"®","REG":"®","Racute":"Ŕ","Rang":"⟫","Rarr":"↠","Rarrtl":"⤖","Rcaron":"Ř","Rcedil":"Ŗ","Rcy":"Р","Re":"ℜ","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","Rfr":"ℜ","Rho":"Ρ","RightAngleBracket":"⟩","RightArrow":"→","RightArrowBar":"⇥","RightArrowLeftArrow":"⇄","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVector":"⇂","RightDownVectorBar":"⥕","RightFloor":"⌋","RightTee":"⊢","RightTeeArrow":"↦","RightTeeVector":"⥛","RightTriangle":"⊳","RightTriangleBar":"⧐","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVector":"↾","RightUpVectorBar":"⥔","RightVector":"⇀","RightVectorBar":"⥓","Rightarrow":"⇒","Ropf":"ℝ","RoundImplies":"⥰","Rrightarrow":"⇛","Rscr":"ℛ","Rsh":"↱","RuleDelayed":"⧴","SHCHcy":"Щ","SHcy":"Ш","SOFTcy":"Ь","Sacute":"Ś","Sc":"⪼","Scaron":"Š","Scedil":"Ş","Scirc":"Ŝ","Scy":"С","Sfr":"𝔖","ShortDownArrow":"↓","ShortLeftArrow":"←","ShortRightArrow":"→","ShortUpArrow":"↑","Sigma":"Σ","SmallCircle":"∘","Sopf":"𝕊","Sqrt":"√","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","Sscr":"𝒮","Star":"⋆","Sub":"⋐","Subset":"⋐","SubsetEqual":"⊆","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","SuchThat":"∋","Sum":"∑","Sup":"⋑","Superset":"⊃","SupersetEqual":"⊇","Supset":"⋑","THOR":"Þ","THORN":"Þ","TRADE":"™","TSHcy":"Ћ","TScy":"Ц","Tab":"\\t","Tau":"Τ","Tcaron":"Ť","Tcedil":"Ţ","Tcy":"Т","Tfr":"𝔗","Therefore":"∴","Theta":"Θ","ThickSpace":"  ","ThinSpace":" ","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","Topf":"𝕋","TripleDot":"⃛","Tscr":"𝒯","Tstrok":"Ŧ","Uacut":"Ú","Uacute":"Ú","Uarr":"↟","Uarrocir":"⥉","Ubrcy":"Ў","Ubreve":"Ŭ","Ucir":"Û","Ucirc":"Û","Ucy":"У","Udblac":"Ű","Ufr":"𝔘","Ugrav":"Ù","Ugrave":"Ù","Umacr":"Ū","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","Uopf":"𝕌","UpArrow":"↑","UpArrowBar":"⤒","UpArrowDownArrow":"⇅","UpDownArrow":"↕","UpEquilibrium":"⥮","UpTee":"⊥","UpTeeArrow":"↥","Uparrow":"⇑","Updownarrow":"⇕","UpperLeftArrow":"↖","UpperRightArrow":"↗","Upsi":"ϒ","Upsilon":"Υ","Uring":"Ů","Uscr":"𝒰","Utilde":"Ũ","Uum":"Ü","Uuml":"Ü","VDash":"⊫","Vbar":"⫫","Vcy":"В","Vdash":"⊩","Vdashl":"⫦","Vee":"⋁","Verbar":"‖","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","Vopf":"𝕍","Vscr":"𝒱","Vvdash":"⊪","Wcirc":"Ŵ","Wedge":"⋀","Wfr":"𝔚","Wopf":"𝕎","Wscr":"𝒲","Xfr":"𝔛","Xi":"Ξ","Xopf":"𝕏","Xscr":"𝒳","YAcy":"Я","YIcy":"Ї","YUcy":"Ю","Yacut":"Ý","Yacute":"Ý","Ycirc":"Ŷ","Ycy":"Ы","Yfr":"𝔜","Yopf":"𝕐","Yscr":"𝒴","Yuml":"Ÿ","ZHcy":"Ж","Zacute":"Ź","Zcaron":"Ž","Zcy":"З","Zdot":"Ż","ZeroWidthSpace":"​","Zeta":"Ζ","Zfr":"ℨ","Zopf":"ℤ","Zscr":"𝒵","aacut":"á","aacute":"á","abreve":"ă","ac":"∾","acE":"∾̳","acd":"∿","acir":"â","acirc":"â","acut":"´","acute":"´","acy":"а","aeli":"æ","aelig":"æ","af":"⁡","afr":"𝔞","agrav":"à","agrave":"à","alefsym":"ℵ","aleph":"ℵ","alpha":"α","amacr":"ā","amalg":"⨿","am":"&","amp":"&","and":"∧","andand":"⩕","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsd":"∡","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","aogon":"ą","aopf":"𝕒","ap":"≈","apE":"⩰","apacir":"⩯","ape":"≊","apid":"≋","apos":"\'","approx":"≈","approxeq":"≊","arin":"å","aring":"å","ascr":"𝒶","ast":"*","asymp":"≈","asympeq":"≍","atild":"ã","atilde":"ã","aum":"ä","auml":"ä","awconint":"∳","awint":"⨑","bNot":"⫭","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","barvee":"⊽","barwed":"⌅","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","beta":"β","beth":"ℶ","between":"≬","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bnot":"⌐","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxDL":"╗","boxDR":"╔","boxDl":"╖","boxDr":"╓","boxH":"═","boxHD":"╦","boxHU":"╩","boxHd":"╤","boxHu":"╧","boxUL":"╝","boxUR":"╚","boxUl":"╜","boxUr":"╙","boxV":"║","boxVH":"╬","boxVL":"╣","boxVR":"╠","boxVh":"╫","boxVl":"╢","boxVr":"╟","boxbox":"⧉","boxdL":"╕","boxdR":"╒","boxdl":"┐","boxdr":"┌","boxh":"─","boxhD":"╥","boxhU":"╨","boxhd":"┬","boxhu":"┴","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxuL":"╛","boxuR":"╘","boxul":"┘","boxur":"└","boxv":"│","boxvH":"╪","boxvL":"╡","boxvR":"╞","boxvh":"┼","boxvl":"┤","boxvr":"├","bprime":"‵","breve":"˘","brvba":"¦","brvbar":"¦","bscr":"𝒷","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsol":"\\\\","bsolb":"⧅","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","bumpeq":"≏","cacute":"ć","cap":"∩","capand":"⩄","capbrcup":"⩉","capcap":"⩋","capcup":"⩇","capdot":"⩀","caps":"∩︀","caret":"⁁","caron":"ˇ","ccaps":"⩍","ccaron":"č","ccedi":"ç","ccedil":"ç","ccirc":"ĉ","ccups":"⩌","ccupssm":"⩐","cdot":"ċ","cedi":"¸","cedil":"¸","cemptyv":"⦲","cen":"¢","cent":"¢","centerdot":"·","cfr":"𝔠","chcy":"ч","check":"✓","checkmark":"✓","chi":"χ","cir":"○","cirE":"⧃","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledR":"®","circledS":"Ⓢ","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","clubs":"♣","clubsuit":"♣","colon":":","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","conint":"∮","copf":"𝕔","coprod":"∐","cop":"©","copy":"©","copysr":"℗","crarr":"↵","cross":"✗","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cup":"∪","cupbrcap":"⩈","cupcap":"⩆","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curre":"¤","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dArr":"⇓","dHar":"⥥","dagger":"†","daleth":"ℸ","darr":"↓","dash":"‐","dashv":"⊣","dbkarow":"⤏","dblac":"˝","dcaron":"ď","dcy":"д","dd":"ⅆ","ddagger":"‡","ddarr":"⇊","ddotseq":"⩷","de":"°","deg":"°","delta":"δ","demptyv":"⦱","dfisht":"⥿","dfr":"𝔡","dharl":"⇃","dharr":"⇂","diam":"⋄","diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","digamma":"ϝ","disin":"⋲","div":"÷","divid":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","dopf":"𝕕","dot":"˙","doteq":"≐","doteqdot":"≑","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","downarrow":"↓","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","dscr":"𝒹","dscy":"ѕ","dsol":"⧶","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","dzcy":"џ","dzigrarr":"⟿","eDDot":"⩷","eDot":"≑","eacut":"é","eacute":"é","easter":"⩮","ecaron":"ě","ecir":"ê","ecirc":"ê","ecolon":"≕","ecy":"э","edot":"ė","ee":"ⅇ","efDot":"≒","efr":"𝔢","eg":"⪚","egrav":"è","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","emacr":"ē","empty":"∅","emptyset":"∅","emptyv":"∅","emsp13":" ","emsp14":" ","emsp":" ","eng":"ŋ","ensp":" ","eogon":"ę","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","equals":"=","equest":"≟","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erDot":"≓","erarr":"⥱","escr":"ℯ","esdot":"≐","esim":"≂","eta":"η","et":"ð","eth":"ð","eum":"ë","euml":"ë","euro":"€","excl":"!","exist":"∃","expectation":"ℰ","exponentiale":"ⅇ","fallingdotseq":"≒","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","ffr":"𝔣","filig":"ﬁ","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","fopf":"𝕗","forall":"∀","fork":"⋔","forkv":"⫙","fpartint":"⨍","frac1":"¼","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac3":"¾","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","gE":"≧","gEl":"⪌","gacute":"ǵ","gamma":"γ","gammad":"ϝ","gap":"⪆","gbreve":"ğ","gcirc":"ĝ","gcy":"г","gdot":"ġ","ge":"≥","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","ges":"⩾","gescc":"⪩","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","gfr":"𝔤","gg":"≫","ggg":"⋙","gimel":"ℷ","gjcy":"ѓ","gl":"≷","glE":"⪒","gla":"⪥","glj":"⪤","gnE":"≩","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gneq":"⪈","gneqq":"≩","gnsim":"⋧","gopf":"𝕘","grave":"`","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","g":">","gt":">","gtcc":"⪧","gtcir":"⩺","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","hArr":"⇔","hairsp":" ","half":"½","hamilt":"ℋ","hardcy":"ъ","harr":"↔","harrcir":"⥈","harrw":"↭","hbar":"ℏ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","horbar":"―","hscr":"𝒽","hslash":"ℏ","hstrok":"ħ","hybull":"⁃","hyphen":"‐","iacut":"í","iacute":"í","ic":"⁣","icir":"î","icirc":"î","icy":"и","iecy":"е","iexc":"¡","iexcl":"¡","iff":"⇔","ifr":"𝔦","igrav":"ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","ijlig":"ĳ","imacr":"ī","image":"ℑ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","imof":"⊷","imped":"Ƶ","in":"∈","incare":"℅","infin":"∞","infintie":"⧝","inodot":"ı","int":"∫","intcal":"⊺","integers":"ℤ","intercal":"⊺","intlarhk":"⨗","intprod":"⨼","iocy":"ё","iogon":"į","iopf":"𝕚","iota":"ι","iprod":"⨼","iques":"¿","iquest":"¿","iscr":"𝒾","isin":"∈","isinE":"⋹","isindot":"⋵","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","itilde":"ĩ","iukcy":"і","ium":"ï","iuml":"ï","jcirc":"ĵ","jcy":"й","jfr":"𝔧","jmath":"ȷ","jopf":"𝕛","jscr":"𝒿","jsercy":"ј","jukcy":"є","kappa":"κ","kappav":"ϰ","kcedil":"ķ","kcy":"к","kfr":"𝔨","kgreen":"ĸ","khcy":"х","kjcy":"ќ","kopf":"𝕜","kscr":"𝓀","lAarr":"⇚","lArr":"⇐","lAtail":"⤛","lBarr":"⤎","lE":"≦","lEg":"⪋","lHar":"⥢","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","lambda":"λ","lang":"⟨","langd":"⦑","langle":"⟨","lap":"⪅","laqu":"«","laquo":"«","larr":"←","larrb":"⇤","larrbfs":"⤟","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","lat":"⪫","latail":"⤙","late":"⪭","lates":"⪭︀","lbarr":"⤌","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","lcaron":"ľ","lcedil":"ļ","lceil":"⌈","lcub":"{","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","leftarrow":"←","leftarrowtail":"↢","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","leftthreetimes":"⋋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","les":"⩽","lescc":"⪨","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","lessgtr":"≶","lesssim":"≲","lfisht":"⥼","lfloor":"⌊","lfr":"𝔩","lg":"≶","lgE":"⪑","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","ljcy":"љ","ll":"≪","llarr":"⇇","llcorner":"⌞","llhard":"⥫","lltri":"◺","lmidot":"ŀ","lmoust":"⎰","lmoustache":"⎰","lnE":"≨","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","longleftrightarrow":"⟷","longmapsto":"⟼","longrightarrow":"⟶","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","lstrok":"ł","l":"<","lt":"<","ltcc":"⪦","ltcir":"⩹","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltrPar":"⦖","ltri":"◃","ltrie":"⊴","ltrif":"◂","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","mDDot":"∺","mac":"¯","macr":"¯","male":"♂","malt":"✠","maltese":"✠","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","mcy":"м","mdash":"—","measuredangle":"∡","mfr":"𝔪","mho":"℧","micr":"µ","micro":"µ","mid":"∣","midast":"*","midcir":"⫰","middo":"·","middot":"·","minus":"−","minusb":"⊟","minusd":"∸","minusdu":"⨪","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","mopf":"𝕞","mp":"∓","mscr":"𝓂","mstpos":"∾","mu":"μ","multimap":"⊸","mumap":"⊸","nGg":"⋙̸","nGt":"≫⃒","nGtv":"≫̸","nLeftarrow":"⇍","nLeftrightarrow":"⇎","nLl":"⋘̸","nLt":"≪⃒","nLtv":"≪̸","nRightarrow":"⇏","nVDash":"⊯","nVdash":"⊮","nabla":"∇","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natur":"♮","natural":"♮","naturals":"ℕ","nbs":" ","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","ncaron":"ň","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","ncy":"н","ndash":"–","ne":"≠","neArr":"⇗","nearhk":"⤤","nearr":"↗","nearrow":"↗","nedot":"≐̸","nequiv":"≢","nesear":"⤨","nesim":"≂̸","nexist":"∄","nexists":"∄","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","ngsim":"≵","ngt":"≯","ngtr":"≯","nhArr":"⇎","nharr":"↮","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","njcy":"њ","nlArr":"⇍","nlE":"≦̸","nlarr":"↚","nldr":"‥","nle":"≰","nleftarrow":"↚","nleftrightarrow":"↮","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nlsim":"≴","nlt":"≮","nltri":"⋪","nltrie":"⋬","nmid":"∤","nopf":"𝕟","no":"¬","not":"¬","notin":"∉","notinE":"⋹̸","notindot":"⋵̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","npar":"∦","nparallel":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","npre":"⪯̸","nprec":"⊀","npreceq":"⪯̸","nrArr":"⇏","nrarr":"↛","nrarrc":"⤳̸","nrarrw":"↝̸","nrightarrow":"↛","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","ntild":"ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","nu":"ν","num":"#","numero":"№","numsp":" ","nvDash":"⊭","nvHarr":"⤄","nvap":"≍⃒","nvdash":"⊬","nvge":"≥⃒","nvgt":">⃒","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwArr":"⇖","nwarhk":"⤣","nwarr":"↖","nwarrow":"↖","nwnear":"⤧","oS":"Ⓢ","oacut":"ó","oacute":"ó","oast":"⊛","ocir":"ô","ocirc":"ô","ocy":"о","odash":"⊝","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","oelig":"œ","ofcir":"⦿","ofr":"𝔬","ogon":"˛","ograv":"ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","omacr":"ō","omega":"ω","omicron":"ο","omid":"⦶","ominus":"⊖","oopf":"𝕠","opar":"⦷","operp":"⦹","oplus":"⊕","or":"∨","orarr":"↻","ord":"º","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oscr":"ℴ","oslas":"ø","oslash":"ø","osol":"⊘","otild":"õ","otilde":"õ","otimes":"⊗","otimesas":"⨶","oum":"ö","ouml":"ö","ovbar":"⌽","par":"¶","para":"¶","parallel":"∥","parsim":"⫳","parsl":"⫽","part":"∂","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","pfr":"𝔭","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plus":"+","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plusdo":"∔","plusdu":"⨥","pluse":"⩲","plusm":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","pointint":"⨕","popf":"𝕡","poun":"£","pound":"£","pr":"≺","prE":"⪳","prap":"⪷","prcue":"≼","pre":"⪯","prec":"≺","precapprox":"⪷","preccurlyeq":"≼","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","precsim":"≾","prime":"′","primes":"ℙ","prnE":"⪵","prnap":"⪹","prnsim":"⋨","prod":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","propto":"∝","prsim":"≾","prurel":"⊰","pscr":"𝓅","psi":"ψ","puncsp":" ","qfr":"𝔮","qint":"⨌","qopf":"𝕢","qprime":"⁗","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quo":"\\"","quot":"\\"","rAarr":"⇛","rArr":"⇒","rAtail":"⤜","rBarr":"⤏","rHar":"⥤","race":"∽̱","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","rangd":"⦒","range":"⦥","rangle":"⟩","raqu":"»","raquo":"»","rarr":"→","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","rarrtl":"↣","rarrw":"↝","ratail":"⤚","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","rcaron":"ř","rcedil":"ŗ","rceil":"⌉","rcub":"}","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","rect":"▭","re":"®","reg":"®","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","rhard":"⇁","rharu":"⇀","rharul":"⥬","rho":"ρ","rhov":"ϱ","rightarrow":"→","rightarrowtail":"↣","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","rightthreetimes":"⋌","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoust":"⎱","rmoustache":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","roplus":"⨮","rotimes":"⨵","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","rsaquo":"›","rscr":"𝓇","rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","ruluhar":"⥨","rx":"℞","sacute":"ś","sbquo":"‚","sc":"≻","scE":"⪴","scap":"⪸","scaron":"š","sccue":"≽","sce":"⪰","scedil":"ş","scirc":"ŝ","scnE":"⪶","scnap":"⪺","scnsim":"⋩","scpolint":"⨓","scsim":"≿","scy":"с","sdot":"⋅","sdotb":"⊡","sdote":"⩦","seArr":"⇘","searhk":"⤥","searr":"↘","searrow":"↘","sec":"§","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","sfr":"𝔰","sfrown":"⌢","sharp":"♯","shchcy":"щ","shcy":"ш","shortmid":"∣","shortparallel":"∥","sh":"­","shy":"­","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","softcy":"ь","sol":"/","solb":"⧄","solbar":"⌿","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","squ":"□","square":"□","squarf":"▪","squf":"▪","srarr":"→","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","subE":"⫅","subdot":"⪽","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","subseteq":"⊆","subseteqq":"⫅","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succ":"≻","succapprox":"⪸","succcurlyeq":"≽","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","sum":"∑","sung":"♪","sup":"⊃","sup1":"¹","sup2":"²","sup3":"³","supE":"⫆","supdot":"⪾","supdsub":"⫘","supe":"⊇","supedot":"⫄","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swArr":"⇙","swarhk":"⤦","swarr":"↙","swarrow":"↙","swnwar":"⤪","szli":"ß","szlig":"ß","target":"⌖","tau":"τ","tbrk":"⎴","tcaron":"ť","tcedil":"ţ","tcy":"т","tdot":"⃛","telrec":"⌕","tfr":"𝔱","there4":"∴","therefore":"∴","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","thinsp":" ","thkap":"≈","thksim":"∼","thor":"þ","thorn":"þ","tilde":"˜","time":"×","times":"×","timesb":"⊠","timesbar":"⨱","timesd":"⨰","tint":"∭","toea":"⤨","top":"⊤","topbot":"⌶","topcir":"⫱","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","tscr":"𝓉","tscy":"ц","tshcy":"ћ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","uArr":"⇑","uHar":"⥣","uacut":"ú","uacute":"ú","uarr":"↑","ubrcy":"ў","ubreve":"ŭ","ucir":"û","ucirc":"û","ucy":"у","udarr":"⇅","udblac":"ű","udhar":"⥮","ufisht":"⥾","ufr":"𝔲","ugrav":"ù","ugrave":"ù","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","umacr":"ū","um":"¨","uml":"¨","uogon":"ų","uopf":"𝕦","uparrow":"↑","updownarrow":"↕","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","upsi":"υ","upsih":"ϒ","upsilon":"υ","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","uring":"ů","urtri":"◹","uscr":"𝓊","utdot":"⋰","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","uum":"ü","uuml":"ü","uwangle":"⦧","vArr":"⇕","vBar":"⫨","vBarv":"⫩","vDash":"⊨","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vcy":"в","vdash":"⊢","vee":"∨","veebar":"⊻","veeeq":"≚","vellip":"⋮","verbar":"|","vert":"|","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","vopf":"𝕧","vprop":"∝","vrtri":"⊳","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","vzigzag":"⦚","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","wedgeq":"≙","weierp":"℘","wfr":"𝔴","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","xfr":"𝔵","xhArr":"⟺","xharr":"⟷","xi":"ξ","xlArr":"⟸","xlarr":"⟵","xmap":"⟼","xnis":"⋻","xodot":"⨀","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrArr":"⟹","xrarr":"⟶","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","yacut":"ý","yacute":"ý","yacy":"я","ycirc":"ŷ","ycy":"ы","ye":"¥","yen":"¥","yfr":"𝔶","yicy":"ї","yopf":"𝕪","yscr":"𝓎","yucy":"ю","yum":"ÿ","yuml":"ÿ","zacute":"ź","zcaron":"ž","zcy":"з","zdot":"ż","zeetrf":"ℨ","zeta":"ζ","zfr":"𝔷","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","zscr":"𝓏","zwj":"‍","zwnj":"‌"}');
});
parcelRequire.register("gQ52E", function(module, exports) {
  module.exports = $c42569dd8f388be7$var$locate;
  function $c42569dd8f388be7$var$locate(value, fromIndex) {
    return value.indexOf("<", fromIndex);
  }
});
parcelRequire.register("9HIzs", function(module, exports) {
  var $a597o = parcelRequire("a597o");
  var $3qZkh2 = parcelRequire("3qZkh");
  var $9cn3E = parcelRequire("9cn3E");
  var $jQpNp = parcelRequire("jQpNp");
  var $6qoLm = parcelRequire("6qoLm");
  var $eOUs6 = parcelRequire("eOUs6");
  module.exports = $710ab415b4e45c8e$var$url;
  $710ab415b4e45c8e$var$url.locator = $eOUs6;
  $710ab415b4e45c8e$var$url.notInLink = true;
  var $710ab415b4e45c8e$var$exclamationMark = 33;
  var $710ab415b4e45c8e$var$ampersand = 38;
  var $710ab415b4e45c8e$var$rightParenthesis = 41;
  var $710ab415b4e45c8e$var$asterisk = 42;
  var $710ab415b4e45c8e$var$comma = 44;
  var $710ab415b4e45c8e$var$dash = 45;
  var $710ab415b4e45c8e$var$dot = 46;
  var $710ab415b4e45c8e$var$colon = 58;
  var $710ab415b4e45c8e$var$semicolon = 59;
  var $710ab415b4e45c8e$var$questionMark = 63;
  var $710ab415b4e45c8e$var$lessThan = 60;
  var $710ab415b4e45c8e$var$underscore = 95;
  var $710ab415b4e45c8e$var$tilde = 126;
  var $710ab415b4e45c8e$var$leftParenthesisCharacter = "(";
  var $710ab415b4e45c8e$var$rightParenthesisCharacter = ")";
  function $710ab415b4e45c8e$var$url(eat, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var tokenizers = self2.inlineTokenizers;
    var length = value.length;
    var previousDot = -1;
    var protocolless = false;
    var dots;
    var lastTwoPartsStart;
    var start;
    var index;
    var pathStart;
    var path;
    var code;
    var end;
    var leftCount;
    var rightCount;
    var content;
    var children;
    var url;
    var exit;
    if (!gfm)
      return;
    if (value.slice(0, 4) === "www.") {
      protocolless = true;
      index = 4;
    } else if (value.slice(0, 7).toLowerCase() === "http://")
      index = 7;
    else if (value.slice(0, 8).toLowerCase() === "https://")
      index = 8;
    else
      return;
    previousDot = index - 1;
    start = index;
    dots = [];
    while (index < length) {
      code = value.charCodeAt(index);
      if (code === $710ab415b4e45c8e$var$dot) {
        if (previousDot === index - 1)
          break;
        dots.push(index);
        previousDot = index;
        index++;
        continue;
      }
      if ($9cn3E(code) || $jQpNp(code) || code === $710ab415b4e45c8e$var$dash || code === $710ab415b4e45c8e$var$underscore) {
        index++;
        continue;
      }
      break;
    }
    if (code === $710ab415b4e45c8e$var$dot) {
      dots.pop();
      index--;
    }
    if (dots[0] === void 0)
      return;
    lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
    if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1)
      return;
    if (silent)
      return true;
    end = index;
    pathStart = index;
    while (index < length) {
      code = value.charCodeAt(index);
      if ($6qoLm(code) || code === $710ab415b4e45c8e$var$lessThan)
        break;
      index++;
      if (code === $710ab415b4e45c8e$var$exclamationMark || code === $710ab415b4e45c8e$var$asterisk || code === $710ab415b4e45c8e$var$comma || code === $710ab415b4e45c8e$var$dot || code === $710ab415b4e45c8e$var$colon || code === $710ab415b4e45c8e$var$questionMark || code === $710ab415b4e45c8e$var$underscore || code === $710ab415b4e45c8e$var$tilde)
        ;
      else
        end = index;
    }
    index = end;
    if (value.charCodeAt(index - 1) === $710ab415b4e45c8e$var$rightParenthesis) {
      path = value.slice(pathStart, index);
      leftCount = $a597o(path, $710ab415b4e45c8e$var$leftParenthesisCharacter);
      rightCount = $a597o(path, $710ab415b4e45c8e$var$rightParenthesisCharacter);
      while (rightCount > leftCount) {
        index = pathStart + path.lastIndexOf($710ab415b4e45c8e$var$rightParenthesisCharacter);
        path = value.slice(pathStart, index);
        rightCount--;
      }
    }
    if (value.charCodeAt(index - 1) === $710ab415b4e45c8e$var$semicolon) {
      index--;
      if ($jQpNp(value.charCodeAt(index - 1))) {
        end = index - 2;
        while ($jQpNp(value.charCodeAt(end)))
          end--;
        if (value.charCodeAt(end) === $710ab415b4e45c8e$var$ampersand)
          index = end;
      }
    }
    content = value.slice(0, index);
    url = $3qZkh2(content, {
      nonTerminated: false
    });
    if (protocolless)
      url = "http://" + url;
    exit = self2.enterLink();
    self2.inlineTokenizers = {
      text: tokenizers.text
    };
    children = self2.tokenizeInline(content, eat.now());
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
      type: "link",
      title: null,
      url,
      children
    });
  }
});
parcelRequire.register("a597o", function(module, exports) {
  module.exports = $757171bb1de82ed0$var$ccount;
  function $757171bb1de82ed0$var$ccount(source, character) {
    var value = String(source);
    var count = 0;
    var index;
    if (typeof character !== "string")
      throw new Error("Expected character");
    index = value.indexOf(character);
    while (index !== -1) {
      count++;
      index = value.indexOf(character, index + character.length);
    }
    return count;
  }
});
parcelRequire.register("eOUs6", function(module, exports) {
  module.exports = $aca186734f4231e7$var$locate;
  var $aca186734f4231e7$var$values = [
    "www.",
    "http://",
    "https://"
  ];
  function $aca186734f4231e7$var$locate(value, fromIndex) {
    var min = -1;
    var index;
    var length;
    var position;
    if (!this.options.gfm)
      return min;
    length = $aca186734f4231e7$var$values.length;
    index = -1;
    while (++index < length) {
      position = value.indexOf($aca186734f4231e7$var$values[index], fromIndex);
      if (position !== -1 && (min === -1 || position < min))
        min = position;
    }
    return min;
  }
});
parcelRequire.register("dps5A", function(module, exports) {
  var $3qZkh2 = parcelRequire("3qZkh");
  var $9cn3E = parcelRequire("9cn3E");
  var $jQpNp = parcelRequire("jQpNp");
  var $e0hp6 = parcelRequire("e0hp6");
  module.exports = $9c336615c9ac9564$var$email;
  $9c336615c9ac9564$var$email.locator = $e0hp6;
  $9c336615c9ac9564$var$email.notInLink = true;
  var $9c336615c9ac9564$var$plusSign = 43;
  var $9c336615c9ac9564$var$dash = 45;
  var $9c336615c9ac9564$var$dot = 46;
  var $9c336615c9ac9564$var$atSign = 64;
  var $9c336615c9ac9564$var$underscore = 95;
  function $9c336615c9ac9564$var$email(eat, value, silent) {
    var self2 = this;
    var gfm = self2.options.gfm;
    var tokenizers = self2.inlineTokenizers;
    var index = 0;
    var length = value.length;
    var firstDot = -1;
    var code;
    var content;
    var children;
    var exit;
    if (!gfm)
      return;
    code = value.charCodeAt(index);
    while ($9cn3E(code) || $jQpNp(code) || code === $9c336615c9ac9564$var$plusSign || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$dot || code === $9c336615c9ac9564$var$underscore)
      code = value.charCodeAt(++index);
    if (index === 0)
      return;
    if (code !== $9c336615c9ac9564$var$atSign)
      return;
    index++;
    while (index < length) {
      code = value.charCodeAt(index);
      if ($9cn3E(code) || $jQpNp(code) || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$dot || code === $9c336615c9ac9564$var$underscore) {
        index++;
        if (firstDot === -1 && code === $9c336615c9ac9564$var$dot)
          firstDot = index;
        continue;
      }
      break;
    }
    if (firstDot === -1 || firstDot === index || code === $9c336615c9ac9564$var$dash || code === $9c336615c9ac9564$var$underscore)
      return;
    if (code === $9c336615c9ac9564$var$dot)
      index--;
    content = value.slice(0, index);
    if (silent)
      return true;
    exit = self2.enterLink();
    self2.inlineTokenizers = {
      text: tokenizers.text
    };
    children = self2.tokenizeInline(content, eat.now());
    self2.inlineTokenizers = tokenizers;
    exit();
    return eat(content)({
      type: "link",
      title: null,
      url: "mailto:" + $3qZkh2(content, {
        nonTerminated: false
      }),
      children
    });
  }
});
parcelRequire.register("e0hp6", function(module, exports) {
  var $9cn3E = parcelRequire("9cn3E");
  var $jQpNp = parcelRequire("jQpNp");
  var $a31e90cc896b73f2$var$plusSign = 43;
  var $a31e90cc896b73f2$var$dash = 45;
  var $a31e90cc896b73f2$var$dot = 46;
  var $a31e90cc896b73f2$var$underscore = 95;
  module.exports = $a31e90cc896b73f2$var$locate;
  function $a31e90cc896b73f2$var$locate(value, fromIndex) {
    var self2 = this;
    var at;
    var position;
    if (!this.options.gfm)
      return -1;
    at = value.indexOf("@", fromIndex);
    if (at === -1)
      return -1;
    position = at;
    if (position === fromIndex || !$a31e90cc896b73f2$var$isGfmAtext(value.charCodeAt(position - 1)))
      return $a31e90cc896b73f2$var$locate.call(self2, value, at + 1);
    while (position > fromIndex && $a31e90cc896b73f2$var$isGfmAtext(value.charCodeAt(position - 1)))
      position--;
    return position;
  }
  function $a31e90cc896b73f2$var$isGfmAtext(code) {
    return $9cn3E(code) || $jQpNp(code) || code === $a31e90cc896b73f2$var$plusSign || code === $a31e90cc896b73f2$var$dash || code === $a31e90cc896b73f2$var$dot || code === $a31e90cc896b73f2$var$underscore;
  }
});
parcelRequire.register("6NCFJ", function(module, exports) {
  var $jQpNp = parcelRequire("jQpNp");
  var $gQ52E = parcelRequire("gQ52E");
  var $fjSMD = parcelRequire("fjSMD");
  var $4f3551226f982ae4$require$tag = $fjSMD.tag;
  module.exports = $4f3551226f982ae4$var$inlineHTML;
  $4f3551226f982ae4$var$inlineHTML.locator = $gQ52E;
  var $4f3551226f982ae4$var$lessThan = "<";
  var $4f3551226f982ae4$var$questionMark = "?";
  var $4f3551226f982ae4$var$exclamationMark = "!";
  var $4f3551226f982ae4$var$slash = "/";
  var $4f3551226f982ae4$var$htmlLinkOpenExpression = /^<a /i;
  var $4f3551226f982ae4$var$htmlLinkCloseExpression = /^<\/a>/i;
  function $4f3551226f982ae4$var$inlineHTML(eat, value, silent) {
    var self2 = this;
    var length = value.length;
    var character;
    var subvalue;
    if (value.charAt(0) !== $4f3551226f982ae4$var$lessThan || length < 3)
      return;
    character = value.charAt(1);
    if (!$jQpNp(character) && character !== $4f3551226f982ae4$var$questionMark && character !== $4f3551226f982ae4$var$exclamationMark && character !== $4f3551226f982ae4$var$slash)
      return;
    subvalue = value.match($4f3551226f982ae4$require$tag);
    if (!subvalue)
      return;
    if (silent)
      return true;
    subvalue = subvalue[0];
    if (!self2.inLink && $4f3551226f982ae4$var$htmlLinkOpenExpression.test(subvalue))
      self2.inLink = true;
    else if (self2.inLink && $4f3551226f982ae4$var$htmlLinkCloseExpression.test(subvalue))
      self2.inLink = false;
    return eat(subvalue)({
      type: "html",
      value: subvalue
    });
  }
});
parcelRequire.register("8jyKl", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  var $56k0G = parcelRequire("56k0G");
  module.exports = $60db0d060832584b$var$link;
  $60db0d060832584b$var$link.locator = $56k0G;
  var $60db0d060832584b$var$lineFeed = "\n";
  var $60db0d060832584b$var$exclamationMark = "!";
  var $60db0d060832584b$var$quotationMark = '"';
  var $60db0d060832584b$var$apostrophe = "'";
  var $60db0d060832584b$var$leftParenthesis = "(";
  var $60db0d060832584b$var$rightParenthesis = ")";
  var $60db0d060832584b$var$lessThan = "<";
  var $60db0d060832584b$var$greaterThan = ">";
  var $60db0d060832584b$var$leftSquareBracket = "[";
  var $60db0d060832584b$var$backslash = "\\";
  var $60db0d060832584b$var$rightSquareBracket = "]";
  var $60db0d060832584b$var$graveAccent = "`";
  function $60db0d060832584b$var$link(eat, value, silent) {
    var self2 = this;
    var subvalue = "";
    var index = 0;
    var character = value.charAt(0);
    var pedantic = self2.options.pedantic;
    var commonmark = self2.options.commonmark;
    var gfm = self2.options.gfm;
    var closed;
    var count;
    var opening;
    var beforeURL;
    var beforeTitle;
    var subqueue;
    var hasMarker;
    var isImage;
    var content;
    var marker;
    var length;
    var title;
    var depth;
    var queue;
    var url;
    var now;
    var exit;
    var node;
    if (character === $60db0d060832584b$var$exclamationMark) {
      isImage = true;
      subvalue = character;
      character = value.charAt(++index);
    }
    if (character !== $60db0d060832584b$var$leftSquareBracket)
      return;
    if (!isImage && self2.inLink)
      return;
    subvalue += character;
    queue = "";
    index++;
    length = value.length;
    now = eat.now();
    depth = 0;
    now.column += index;
    now.offset += index;
    while (index < length) {
      character = value.charAt(index);
      subqueue = character;
      if (character === $60db0d060832584b$var$graveAccent) {
        count = 1;
        while (value.charAt(index + 1) === $60db0d060832584b$var$graveAccent) {
          subqueue += character;
          index++;
          count++;
        }
        if (!opening)
          opening = count;
        else if (count >= opening)
          opening = 0;
      } else if (character === $60db0d060832584b$var$backslash) {
        index++;
        subqueue += value.charAt(index);
      } else if ((!opening || gfm) && character === $60db0d060832584b$var$leftSquareBracket)
        depth++;
      else if ((!opening || gfm) && character === $60db0d060832584b$var$rightSquareBracket) {
        if (depth)
          depth--;
        else {
          if (value.charAt(index + 1) !== $60db0d060832584b$var$leftParenthesis)
            return;
          subqueue += $60db0d060832584b$var$leftParenthesis;
          closed = true;
          index++;
          break;
        }
      }
      queue += subqueue;
      subqueue = "";
      index++;
    }
    if (!closed)
      return;
    content = queue;
    subvalue += queue + subqueue;
    index++;
    while (index < length) {
      character = value.charAt(index);
      if (!$6qoLm(character))
        break;
      subvalue += character;
      index++;
    }
    character = value.charAt(index);
    queue = "";
    beforeURL = subvalue;
    if (character === $60db0d060832584b$var$lessThan) {
      index++;
      beforeURL += $60db0d060832584b$var$lessThan;
      while (index < length) {
        character = value.charAt(index);
        if (character === $60db0d060832584b$var$greaterThan)
          break;
        if (commonmark && character === $60db0d060832584b$var$lineFeed)
          return;
        queue += character;
        index++;
      }
      if (value.charAt(index) !== $60db0d060832584b$var$greaterThan)
        return;
      subvalue += $60db0d060832584b$var$lessThan + queue + $60db0d060832584b$var$greaterThan;
      url = queue;
      index++;
    } else {
      character = null;
      subqueue = "";
      while (index < length) {
        character = value.charAt(index);
        if (subqueue && (character === $60db0d060832584b$var$quotationMark || character === $60db0d060832584b$var$apostrophe || commonmark && character === $60db0d060832584b$var$leftParenthesis))
          break;
        if ($6qoLm(character)) {
          if (!pedantic)
            break;
          subqueue += character;
        } else {
          if (character === $60db0d060832584b$var$leftParenthesis)
            depth++;
          else if (character === $60db0d060832584b$var$rightParenthesis) {
            if (depth === 0)
              break;
            depth--;
          }
          queue += subqueue;
          subqueue = "";
          if (character === $60db0d060832584b$var$backslash) {
            queue += $60db0d060832584b$var$backslash;
            character = value.charAt(++index);
          }
          queue += character;
        }
        index++;
      }
      subvalue += queue;
      url = queue;
      index = subvalue.length;
    }
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (!$6qoLm(character))
        break;
      queue += character;
      index++;
    }
    character = value.charAt(index);
    subvalue += queue;
    if (queue && (character === $60db0d060832584b$var$quotationMark || character === $60db0d060832584b$var$apostrophe || commonmark && character === $60db0d060832584b$var$leftParenthesis)) {
      index++;
      subvalue += character;
      queue = "";
      marker = character === $60db0d060832584b$var$leftParenthesis ? $60db0d060832584b$var$rightParenthesis : character;
      beforeTitle = subvalue;
      if (commonmark) {
        while (index < length) {
          character = value.charAt(index);
          if (character === marker)
            break;
          if (character === $60db0d060832584b$var$backslash) {
            queue += $60db0d060832584b$var$backslash;
            character = value.charAt(++index);
          }
          index++;
          queue += character;
        }
        character = value.charAt(index);
        if (character !== marker)
          return;
        title = queue;
        subvalue += queue + character;
        index++;
        while (index < length) {
          character = value.charAt(index);
          if (!$6qoLm(character))
            break;
          subvalue += character;
          index++;
        }
      } else {
        subqueue = "";
        while (index < length) {
          character = value.charAt(index);
          if (character === marker) {
            if (hasMarker) {
              queue += marker + subqueue;
              subqueue = "";
            }
            hasMarker = true;
          } else if (!hasMarker)
            queue += character;
          else if (character === $60db0d060832584b$var$rightParenthesis) {
            subvalue += queue + marker + subqueue;
            title = queue;
            break;
          } else if ($6qoLm(character))
            subqueue += character;
          else {
            queue += marker + subqueue + character;
            subqueue = "";
            hasMarker = false;
          }
          index++;
        }
      }
    }
    if (value.charAt(index) !== $60db0d060832584b$var$rightParenthesis)
      return;
    if (silent)
      return true;
    subvalue += $60db0d060832584b$var$rightParenthesis;
    url = self2.decode.raw(self2.unescape(url), eat(beforeURL).test().end, {
      nonTerminated: false
    });
    if (title) {
      beforeTitle = eat(beforeTitle).test().end;
      title = self2.decode.raw(self2.unescape(title), beforeTitle);
    }
    node = {
      type: isImage ? "image" : "link",
      title: title || null,
      url
    };
    if (isImage)
      node.alt = self2.decode.raw(self2.unescape(content), now) || null;
    else {
      exit = self2.enterLink();
      node.children = self2.tokenizeInline(content, now);
      exit();
    }
    return eat(subvalue)(node);
  }
});
parcelRequire.register("56k0G", function(module, exports) {
  module.exports = $3b6d08e06ccc3714$var$locate;
  function $3b6d08e06ccc3714$var$locate(value, fromIndex) {
    var link = value.indexOf("[", fromIndex);
    var image = value.indexOf("![", fromIndex);
    if (image === -1)
      return link;
    return link < image ? link : image;
  }
});
parcelRequire.register("4wSVw", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  var $56k0G = parcelRequire("56k0G");
  var $4Zypr = parcelRequire("4Zypr");
  module.exports = $34c4c1e1c6f87b77$var$reference;
  $34c4c1e1c6f87b77$var$reference.locator = $56k0G;
  var $34c4c1e1c6f87b77$var$link = "link";
  var $34c4c1e1c6f87b77$var$image = "image";
  var $34c4c1e1c6f87b77$var$shortcut = "shortcut";
  var $34c4c1e1c6f87b77$var$collapsed = "collapsed";
  var $34c4c1e1c6f87b77$var$full = "full";
  var $34c4c1e1c6f87b77$var$exclamationMark = "!";
  var $34c4c1e1c6f87b77$var$leftSquareBracket = "[";
  var $34c4c1e1c6f87b77$var$backslash = "\\";
  var $34c4c1e1c6f87b77$var$rightSquareBracket = "]";
  function $34c4c1e1c6f87b77$var$reference(eat, value, silent) {
    var self2 = this;
    var commonmark = self2.options.commonmark;
    var character = value.charAt(0);
    var index = 0;
    var length = value.length;
    var subvalue = "";
    var intro = "";
    var type = $34c4c1e1c6f87b77$var$link;
    var referenceType = $34c4c1e1c6f87b77$var$shortcut;
    var content;
    var identifier;
    var now;
    var node;
    var exit;
    var queue;
    var bracketed;
    var depth;
    if (character === $34c4c1e1c6f87b77$var$exclamationMark) {
      type = $34c4c1e1c6f87b77$var$image;
      intro = character;
      character = value.charAt(++index);
    }
    if (character !== $34c4c1e1c6f87b77$var$leftSquareBracket)
      return;
    index++;
    intro += character;
    queue = "";
    depth = 0;
    while (index < length) {
      character = value.charAt(index);
      if (character === $34c4c1e1c6f87b77$var$leftSquareBracket) {
        bracketed = true;
        depth++;
      } else if (character === $34c4c1e1c6f87b77$var$rightSquareBracket) {
        if (!depth)
          break;
        depth--;
      }
      if (character === $34c4c1e1c6f87b77$var$backslash) {
        queue += $34c4c1e1c6f87b77$var$backslash;
        character = value.charAt(++index);
      }
      queue += character;
      index++;
    }
    subvalue = queue;
    content = queue;
    character = value.charAt(index);
    if (character !== $34c4c1e1c6f87b77$var$rightSquareBracket)
      return;
    index++;
    subvalue += character;
    queue = "";
    if (!commonmark)
      while (index < length) {
        character = value.charAt(index);
        if (!$6qoLm(character))
          break;
        queue += character;
        index++;
      }
    character = value.charAt(index);
    if (character === $34c4c1e1c6f87b77$var$leftSquareBracket) {
      identifier = "";
      queue += character;
      index++;
      while (index < length) {
        character = value.charAt(index);
        if (character === $34c4c1e1c6f87b77$var$leftSquareBracket || character === $34c4c1e1c6f87b77$var$rightSquareBracket)
          break;
        if (character === $34c4c1e1c6f87b77$var$backslash) {
          identifier += $34c4c1e1c6f87b77$var$backslash;
          character = value.charAt(++index);
        }
        identifier += character;
        index++;
      }
      character = value.charAt(index);
      if (character === $34c4c1e1c6f87b77$var$rightSquareBracket) {
        referenceType = identifier ? $34c4c1e1c6f87b77$var$full : $34c4c1e1c6f87b77$var$collapsed;
        queue += identifier + character;
        index++;
      } else
        identifier = "";
      subvalue += queue;
      queue = "";
    } else {
      if (!content)
        return;
      identifier = content;
    }
    if (referenceType !== $34c4c1e1c6f87b77$var$full && bracketed)
      return;
    subvalue = intro + subvalue;
    if (type === $34c4c1e1c6f87b77$var$link && self2.inLink)
      return null;
    if (silent)
      return true;
    now = eat.now();
    now.column += intro.length;
    now.offset += intro.length;
    identifier = referenceType === $34c4c1e1c6f87b77$var$full ? identifier : content;
    node = {
      type: type + "Reference",
      identifier: $4Zypr(identifier),
      label: identifier,
      referenceType
    };
    if (type === $34c4c1e1c6f87b77$var$link) {
      exit = self2.enterLink();
      node.children = self2.tokenizeInline(content, now);
      exit();
    } else
      node.alt = self2.decode.raw(self2.unescape(content), now) || null;
    return eat(subvalue)(node);
  }
});
parcelRequire.register("icpkQ", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $6qoLm = parcelRequire("6qoLm");
  var $hXbwz = parcelRequire("hXbwz");
  module.exports = $d3fd0006fe9bff75$var$strong;
  $d3fd0006fe9bff75$var$strong.locator = $hXbwz;
  var $d3fd0006fe9bff75$var$backslash = "\\";
  var $d3fd0006fe9bff75$var$asterisk = "*";
  var $d3fd0006fe9bff75$var$underscore = "_";
  function $d3fd0006fe9bff75$var$strong(eat, value, silent) {
    var self2 = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $d3fd0006fe9bff75$var$asterisk && character !== $d3fd0006fe9bff75$var$underscore || value.charAt(++index) !== character)
      return;
    pedantic = self2.options.pedantic;
    marker = character;
    subvalue = marker + marker;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $6qoLm(value.charAt(index)))
      return;
    while (index < length) {
      previous = character;
      character = value.charAt(index);
      if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$6qoLm(previous))) {
        character = value.charAt(index + 2);
        if (character !== marker) {
          if (!$lSPH2(queue))
            return;
          if (silent)
            return true;
          now = eat.now();
          now.column += 2;
          now.offset += 2;
          return eat(subvalue + queue + subvalue)({
            type: "strong",
            children: self2.tokenizeInline(queue, now)
          });
        }
      }
      if (!pedantic && character === $d3fd0006fe9bff75$var$backslash) {
        queue += character;
        character = value.charAt(++index);
      }
      queue += character;
      index++;
    }
  }
});
parcelRequire.register("hXbwz", function(module, exports) {
  module.exports = $d120e2dedcddea7d$var$locate;
  function $d120e2dedcddea7d$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("**", fromIndex);
    var underscore = value.indexOf("__", fromIndex);
    if (underscore === -1)
      return asterisk;
    if (asterisk === -1)
      return underscore;
    return underscore < asterisk ? underscore : asterisk;
  }
});
parcelRequire.register("3P2AS", function(module, exports) {
  var $lSPH2 = parcelRequire("lSPH2");
  var $escbs = parcelRequire("escbs");
  var $6qoLm = parcelRequire("6qoLm");
  var $dLzgd = parcelRequire("dLzgd");
  module.exports = $2c882591cf327a57$var$emphasis;
  $2c882591cf327a57$var$emphasis.locator = $dLzgd;
  var $2c882591cf327a57$var$asterisk = "*";
  var $2c882591cf327a57$var$underscore = "_";
  var $2c882591cf327a57$var$backslash = "\\";
  function $2c882591cf327a57$var$emphasis(eat, value, silent) {
    var self2 = this;
    var index = 0;
    var character = value.charAt(index);
    var now;
    var pedantic;
    var marker;
    var queue;
    var subvalue;
    var length;
    var previous;
    if (character !== $2c882591cf327a57$var$asterisk && character !== $2c882591cf327a57$var$underscore)
      return;
    pedantic = self2.options.pedantic;
    subvalue = character;
    marker = character;
    length = value.length;
    index++;
    queue = "";
    character = "";
    if (pedantic && $6qoLm(value.charAt(index)))
      return;
    while (index < length) {
      previous = character;
      character = value.charAt(index);
      if (character === marker && (!pedantic || !$6qoLm(previous))) {
        character = value.charAt(++index);
        if (character !== marker) {
          if (!$lSPH2(queue) || previous === marker)
            return;
          if (!pedantic && marker === $2c882591cf327a57$var$underscore && $escbs(character)) {
            queue += marker;
            continue;
          }
          if (silent)
            return true;
          now = eat.now();
          now.column++;
          now.offset++;
          return eat(subvalue + queue + marker)({
            type: "emphasis",
            children: self2.tokenizeInline(queue, now)
          });
        }
        queue += marker;
      }
      if (!pedantic && character === $2c882591cf327a57$var$backslash) {
        queue += character;
        character = value.charAt(++index);
      }
      queue += character;
      index++;
    }
  }
});
parcelRequire.register("escbs", function(module, exports) {
  module.exports = $a85d21ab5f43d069$var$wordCharacter;
  var $a85d21ab5f43d069$var$fromCode = String.fromCharCode;
  var $a85d21ab5f43d069$var$re = /\w/;
  function $a85d21ab5f43d069$var$wordCharacter(character) {
    return $a85d21ab5f43d069$var$re.test(typeof character === "number" ? $a85d21ab5f43d069$var$fromCode(character) : character.charAt(0));
  }
});
parcelRequire.register("dLzgd", function(module, exports) {
  module.exports = $a05b0423a51622b7$var$locate;
  function $a05b0423a51622b7$var$locate(value, fromIndex) {
    var asterisk = value.indexOf("*", fromIndex);
    var underscore = value.indexOf("_", fromIndex);
    if (underscore === -1)
      return asterisk;
    if (asterisk === -1)
      return underscore;
    return underscore < asterisk ? underscore : asterisk;
  }
});
parcelRequire.register("jUYRO", function(module, exports) {
  var $6qoLm = parcelRequire("6qoLm");
  var $9mumw = parcelRequire("9mumw");
  module.exports = $e80276304304c5e0$var$strikethrough;
  $e80276304304c5e0$var$strikethrough.locator = $9mumw;
  var $e80276304304c5e0$var$tilde = "~";
  var $e80276304304c5e0$var$fence = "~~";
  function $e80276304304c5e0$var$strikethrough(eat, value, silent) {
    var self2 = this;
    var character = "";
    var previous = "";
    var preceding = "";
    var subvalue = "";
    var index;
    var length;
    var now;
    if (!self2.options.gfm || value.charAt(0) !== $e80276304304c5e0$var$tilde || value.charAt(1) !== $e80276304304c5e0$var$tilde || $6qoLm(value.charAt(2)))
      return;
    index = 1;
    length = value.length;
    now = eat.now();
    now.column += 2;
    now.offset += 2;
    while (++index < length) {
      character = value.charAt(index);
      if (character === $e80276304304c5e0$var$tilde && previous === $e80276304304c5e0$var$tilde && (!preceding || !$6qoLm(preceding))) {
        if (silent)
          return true;
        return eat($e80276304304c5e0$var$fence + subvalue + $e80276304304c5e0$var$fence)({
          type: "delete",
          children: self2.tokenizeInline(subvalue, now)
        });
      }
      subvalue += previous;
      preceding = previous;
      previous = character;
    }
  }
});
parcelRequire.register("9mumw", function(module, exports) {
  module.exports = $6d0db875ed18fe9e$var$locate;
  function $6d0db875ed18fe9e$var$locate(value, fromIndex) {
    return value.indexOf("~~", fromIndex);
  }
});
parcelRequire.register("ahmx7", function(module, exports) {
  var $fzlur = parcelRequire("fzlur");
  module.exports = $77bcf88b867a48b1$var$inlineCode;
  $77bcf88b867a48b1$var$inlineCode.locator = $fzlur;
  var $77bcf88b867a48b1$var$lineFeed = 10;
  var $77bcf88b867a48b1$var$space = 32;
  var $77bcf88b867a48b1$var$graveAccent = 96;
  function $77bcf88b867a48b1$var$inlineCode(eat, value, silent) {
    var length = value.length;
    var index = 0;
    var openingFenceEnd;
    var closingFenceStart;
    var closingFenceEnd;
    var code;
    var next;
    var found;
    while (index < length) {
      if (value.charCodeAt(index) !== $77bcf88b867a48b1$var$graveAccent)
        break;
      index++;
    }
    if (index === 0 || index === length)
      return;
    openingFenceEnd = index;
    next = value.charCodeAt(index);
    while (index < length) {
      code = next;
      next = value.charCodeAt(index + 1);
      if (code === $77bcf88b867a48b1$var$graveAccent) {
        if (closingFenceStart === void 0)
          closingFenceStart = index;
        closingFenceEnd = index + 1;
        if (next !== $77bcf88b867a48b1$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
          found = true;
          break;
        }
      } else if (closingFenceStart !== void 0) {
        closingFenceStart = void 0;
        closingFenceEnd = void 0;
      }
      index++;
    }
    if (!found)
      return;
    if (silent)
      return true;
    index = openingFenceEnd;
    length = closingFenceStart;
    code = value.charCodeAt(index);
    next = value.charCodeAt(length - 1);
    found = false;
    if (length - index > 2 && (code === $77bcf88b867a48b1$var$space || code === $77bcf88b867a48b1$var$lineFeed) && (next === $77bcf88b867a48b1$var$space || next === $77bcf88b867a48b1$var$lineFeed)) {
      index++;
      length--;
      while (index < length) {
        code = value.charCodeAt(index);
        if (code !== $77bcf88b867a48b1$var$space && code !== $77bcf88b867a48b1$var$lineFeed) {
          found = true;
          break;
        }
        index++;
      }
      if (found === true) {
        openingFenceEnd++;
        closingFenceStart--;
      }
    }
    return eat(value.slice(0, closingFenceEnd))({
      type: "inlineCode",
      value: value.slice(openingFenceEnd, closingFenceStart)
    });
  }
});
parcelRequire.register("fzlur", function(module, exports) {
  module.exports = $b55acb5d79e00b8e$var$locate;
  function $b55acb5d79e00b8e$var$locate(value, fromIndex) {
    return value.indexOf("`", fromIndex);
  }
});
parcelRequire.register("9AmxP", function(module, exports) {
  var $bLzz2 = parcelRequire("bLzz2");
  module.exports = $6fa8f6ba047a1858$var$hardBreak;
  $6fa8f6ba047a1858$var$hardBreak.locator = $bLzz2;
  var $6fa8f6ba047a1858$var$space = " ";
  var $6fa8f6ba047a1858$var$lineFeed = "\n";
  var $6fa8f6ba047a1858$var$minBreakLength = 2;
  function $6fa8f6ba047a1858$var$hardBreak(eat, value, silent) {
    var length = value.length;
    var index = -1;
    var queue = "";
    var character;
    while (++index < length) {
      character = value.charAt(index);
      if (character === $6fa8f6ba047a1858$var$lineFeed) {
        if (index < $6fa8f6ba047a1858$var$minBreakLength)
          return;
        if (silent)
          return true;
        queue += character;
        return eat(queue)({
          type: "break"
        });
      }
      if (character !== $6fa8f6ba047a1858$var$space)
        return;
      queue += character;
    }
  }
});
parcelRequire.register("bLzz2", function(module, exports) {
  module.exports = $890fabcb91c3fbd5$var$locate;
  function $890fabcb91c3fbd5$var$locate(value, fromIndex) {
    var index = value.indexOf("\n", fromIndex);
    while (index > fromIndex) {
      if (value.charAt(index - 1) !== " ")
        break;
      index--;
    }
    return index;
  }
});
parcelRequire.register("I2hrQ", function(module, exports) {
  module.exports = $0845e104fe9855d1$var$text;
  function $0845e104fe9855d1$var$text(eat, value, silent) {
    var self2 = this;
    var methods;
    var tokenizers;
    var index;
    var length;
    var subvalue;
    var position;
    var tokenizer;
    var name;
    var min;
    var now;
    if (silent)
      return true;
    methods = self2.inlineMethods;
    length = methods.length;
    tokenizers = self2.inlineTokenizers;
    index = -1;
    min = value.length;
    while (++index < length) {
      name = methods[index];
      if (name === "text" || !tokenizers[name])
        continue;
      tokenizer = tokenizers[name].locator;
      if (!tokenizer)
        eat.file.fail("Missing locator: `" + name + "`");
      position = tokenizer.call(self2, value, 1);
      if (position !== -1 && position < min)
        min = position;
    }
    subvalue = value.slice(0, min);
    now = eat.now();
    self2.decode(subvalue, now, handler);
    function handler(content, position2, source) {
      eat(source || content)({
        type: "text",
        value: content
      });
    }
  }
});
parcelRequire.register("ljm8s", function(module, exports) {
  var $cIHCl = parcelRequire("cIHCl");
  var $5xH1P2 = parcelRequire("5xH1P");
  var $87a9ab9859246ada$require$containsFrontmatter = $5xH1P2.containsFrontmatter;
  const $87a9ab9859246ada$var$parseFrontmatter = (content) => {
    const frontmatter = $87a9ab9859246ada$require$containsFrontmatter(content);
    if (frontmatter)
      return $cIHCl.parse(frontmatter) ?? {};
    return void 0;
  };
  module.exports = {
    parseFrontmatter: $87a9ab9859246ada$var$parseFrontmatter
  };
});
parcelRequire.register("cIHCl", function(module, exports) {
  $parcel$export(module.exports, "parse", () => $942b6d975b099ee3$export$98e6a39c04603d36, (v) => $942b6d975b099ee3$export$98e6a39c04603d36 = v);
  var $942b6d975b099ee3$export$98e6a39c04603d36;
  var $fzaOJ = parcelRequire("fzaOJ");
  var $6Ua5a = parcelRequire("6Ua5a");
  var $bnMCR = parcelRequire("bnMCR");
  var $ljAlQ = parcelRequire("ljAlQ");
  var $gdpli = parcelRequire("gdpli");
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $5ID9u = parcelRequire("5ID9u");
  var $fo7V0 = parcelRequire("fo7V0");
  parcelRequire("9gE5L");
  var $1NqhN = parcelRequire("1NqhN");
  var $phAl4 = parcelRequire("phAl4");
  var $fnNcU = parcelRequire("fnNcU");
  var $jHSX9 = parcelRequire("jHSX9");
  var $gHWL8 = parcelRequire("gHWL8");
  $fzaOJ.Composer;
  $6Ua5a.Document;
  $bnMCR.Schema;
  $ljAlQ.YAMLError;
  $ljAlQ.YAMLParseError;
  $ljAlQ.YAMLWarning;
  $gdpli.Alias;
  $trADz.isAlias;
  $trADz.isCollection;
  $trADz.isDocument;
  $trADz.isMap;
  $trADz.isNode;
  $trADz.isPair;
  $trADz.isScalar;
  $trADz.isSeq;
  $cDsIW.Pair;
  $6K3Lx.Scalar;
  $5ID9u.YAMLMap;
  $fo7V0.YAMLSeq;
  $1NqhN.Lexer;
  $phAl4.LineCounter;
  $fnNcU.Parser;
  $942b6d975b099ee3$export$98e6a39c04603d36 = $jHSX9.parse;
  $jHSX9.parseAllDocuments;
  $jHSX9.parseDocument;
  $jHSX9.stringify;
  $gHWL8.visit;
  $gHWL8.visitAsync;
});
parcelRequire.register("fzaOJ", function(module, exports) {
  $parcel$export(module.exports, "Composer", () => $b55283f8a1556d1f$export$57ed0bcea28f97a2, (v) => $b55283f8a1556d1f$export$57ed0bcea28f97a2 = v);
  var $b55283f8a1556d1f$export$57ed0bcea28f97a2;
  var $dZfLp = parcelRequire("dZfLp");
  var $6Ua5a = parcelRequire("6Ua5a");
  var $ljAlQ = parcelRequire("ljAlQ");
  var $trADz = parcelRequire("trADz");
  var $5BAM3 = parcelRequire("5BAM3");
  var $61WSR = parcelRequire("61WSR");
  function $b55283f8a1556d1f$var$getErrorPos(src) {
    if (typeof src === "number")
      return [
        src,
        src + 1
      ];
    if (Array.isArray(src))
      return src.length === 2 ? src : [
        src[0],
        src[1]
      ];
    const { offset, source } = src;
    return [
      offset,
      offset + (typeof source === "string" ? source.length : 1)
    ];
  }
  function $b55283f8a1556d1f$var$parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return {
      comment,
      afterEmptyLine
    };
  }
  class $b55283f8a1556d1f$var$Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = $b55283f8a1556d1f$var$getErrorPos(source);
        if (warning)
          this.warnings.push(new $ljAlQ.YAMLWarning(pos, code, message));
        else
          this.errors.push(new $ljAlQ.YAMLParseError(pos, code, message));
      };
      this.directives = new $dZfLp.Directives({
        version: options.version || "1.2"
      });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = $b55283f8a1556d1f$var$parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc)
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        else if (afterEmptyLine || doc.directives.docStart || !dc)
          doc.commentBefore = comment;
        else if ($trADz.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if ($trADz.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
      return {
        comment: $b55283f8a1556d1f$var$parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
      if (process.env.LOG_STREAM)
        console.dir(token, {
          depth: null
        });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = $b55283f8a1556d1f$var$getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = $5BAM3.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new $ljAlQ.YAMLParseError($b55283f8a1556d1f$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new $ljAlQ.YAMLParseError($b55283f8a1556d1f$var$getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = $61WSR.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new $ljAlQ.YAMLParseError($b55283f8a1556d1f$var$getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({
          _directives: this.directives
        }, this.options);
        const doc = new $6Ua5a.Document(void 0, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [
          0,
          endOffset,
          endOffset
        ];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  $b55283f8a1556d1f$export$57ed0bcea28f97a2 = $b55283f8a1556d1f$var$Composer;
});
parcelRequire.register("dZfLp", function(module, exports) {
  $parcel$export(module.exports, "Directives", () => $a2ed333017309832$export$129646a0e1af8d85, (v) => $a2ed333017309832$export$129646a0e1af8d85 = v);
  var $a2ed333017309832$export$129646a0e1af8d85;
  var $trADz = parcelRequire("trADz");
  var $gHWL8 = parcelRequire("gHWL8");
  const $a2ed333017309832$var$escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  const $a2ed333017309832$var$escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => $a2ed333017309832$var$escapeChars[ch]);
  class $a2ed333017309832$var$Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, $a2ed333017309832$var$Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, $a2ed333017309832$var$Directives.defaultTags, tags);
    }
    clone() {
      const copy = new $a2ed333017309832$var$Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
      const res = new $a2ed333017309832$var$Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: $a2ed333017309832$var$Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, $a2ed333017309832$var$Directives.defaultTags);
          break;
      }
      return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = {
          explicit: $a2ed333017309832$var$Directives.defaultYaml.explicit,
          version: "1.1"
        };
        this.tags = Object.assign({}, $a2ed333017309832$var$Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix)
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + $a2ed333017309832$var$escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [
        `%YAML ${this.yaml.version || "1.2"}`
      ] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && $trADz.isNode(doc.contents)) {
        const tags = {};
        $gHWL8.visit(doc.contents, (_key, node) => {
          if ($trADz.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join("\n");
    }
  }
  $a2ed333017309832$var$Directives.defaultYaml = {
    explicit: false,
    version: "1.2"
  };
  $a2ed333017309832$var$Directives.defaultTags = {
    "!!": "tag:yaml.org,2002:"
  };
  $a2ed333017309832$export$129646a0e1af8d85 = $a2ed333017309832$var$Directives;
});
parcelRequire.register("trADz", function(module, exports) {
  $parcel$export(module.exports, "ALIAS", () => $05881c54f989be11$export$6e16f50e77e6cb4d, (v) => $05881c54f989be11$export$6e16f50e77e6cb4d = v);
  $parcel$export(module.exports, "DOC", () => $05881c54f989be11$export$c41a48f61a15d775, (v) => $05881c54f989be11$export$c41a48f61a15d775 = v);
  $parcel$export(module.exports, "MAP", () => $05881c54f989be11$export$ce970371e0e850bc, (v) => $05881c54f989be11$export$ce970371e0e850bc = v);
  $parcel$export(module.exports, "NODE_TYPE", () => $05881c54f989be11$export$accaa52ddae3fe58, (v) => $05881c54f989be11$export$accaa52ddae3fe58 = v);
  $parcel$export(module.exports, "PAIR", () => $05881c54f989be11$export$c4eb1412cef9eb18, (v) => $05881c54f989be11$export$c4eb1412cef9eb18 = v);
  $parcel$export(module.exports, "SCALAR", () => $05881c54f989be11$export$8dde1211cb7c9d16, (v) => $05881c54f989be11$export$8dde1211cb7c9d16 = v);
  $parcel$export(module.exports, "SEQ", () => $05881c54f989be11$export$200ef2dcd45611c9, (v) => $05881c54f989be11$export$200ef2dcd45611c9 = v);
  $parcel$export(module.exports, "hasAnchor", () => $05881c54f989be11$export$67947a995b37b771, (v) => $05881c54f989be11$export$67947a995b37b771 = v);
  $parcel$export(module.exports, "isAlias", () => $05881c54f989be11$export$c6275352883a2b3e, (v) => $05881c54f989be11$export$c6275352883a2b3e = v);
  $parcel$export(module.exports, "isCollection", () => $05881c54f989be11$export$cea7aa84e978eba5, (v) => $05881c54f989be11$export$cea7aa84e978eba5 = v);
  $parcel$export(module.exports, "isDocument", () => $05881c54f989be11$export$62858bae88b53fd0, (v) => $05881c54f989be11$export$62858bae88b53fd0 = v);
  $parcel$export(module.exports, "isMap", () => $05881c54f989be11$export$5c90113a285f2241, (v) => $05881c54f989be11$export$5c90113a285f2241 = v);
  $parcel$export(module.exports, "isNode", () => $05881c54f989be11$export$8ee0fc9ee280b4ee, (v) => $05881c54f989be11$export$8ee0fc9ee280b4ee = v);
  $parcel$export(module.exports, "isPair", () => $05881c54f989be11$export$7c8d445944656308, (v) => $05881c54f989be11$export$7c8d445944656308 = v);
  $parcel$export(module.exports, "isScalar", () => $05881c54f989be11$export$8f3495e22775e76c, (v) => $05881c54f989be11$export$8f3495e22775e76c = v);
  $parcel$export(module.exports, "isSeq", () => $05881c54f989be11$export$342ac1d101ffe14b, (v) => $05881c54f989be11$export$342ac1d101ffe14b = v);
  var $05881c54f989be11$export$6e16f50e77e6cb4d;
  var $05881c54f989be11$export$c41a48f61a15d775;
  var $05881c54f989be11$export$ce970371e0e850bc;
  var $05881c54f989be11$export$accaa52ddae3fe58;
  var $05881c54f989be11$export$c4eb1412cef9eb18;
  var $05881c54f989be11$export$8dde1211cb7c9d16;
  var $05881c54f989be11$export$200ef2dcd45611c9;
  var $05881c54f989be11$export$67947a995b37b771;
  var $05881c54f989be11$export$c6275352883a2b3e;
  var $05881c54f989be11$export$cea7aa84e978eba5;
  var $05881c54f989be11$export$62858bae88b53fd0;
  var $05881c54f989be11$export$5c90113a285f2241;
  var $05881c54f989be11$export$8ee0fc9ee280b4ee;
  var $05881c54f989be11$export$7c8d445944656308;
  var $05881c54f989be11$export$8f3495e22775e76c;
  var $05881c54f989be11$export$342ac1d101ffe14b;
  const $05881c54f989be11$var$ALIAS = Symbol.for("yaml.alias");
  const $05881c54f989be11$var$DOC = Symbol.for("yaml.document");
  const $05881c54f989be11$var$MAP = Symbol.for("yaml.map");
  const $05881c54f989be11$var$PAIR = Symbol.for("yaml.pair");
  const $05881c54f989be11$var$SCALAR = Symbol.for("yaml.scalar");
  const $05881c54f989be11$var$SEQ = Symbol.for("yaml.seq");
  const $05881c54f989be11$var$NODE_TYPE = Symbol.for("yaml.node.type");
  const $05881c54f989be11$var$isAlias = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$ALIAS;
  const $05881c54f989be11$var$isDocument = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$DOC;
  const $05881c54f989be11$var$isMap = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$MAP;
  const $05881c54f989be11$var$isPair = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$PAIR;
  const $05881c54f989be11$var$isScalar = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$SCALAR;
  const $05881c54f989be11$var$isSeq = (node) => !!node && typeof node === "object" && node[$05881c54f989be11$var$NODE_TYPE] === $05881c54f989be11$var$SEQ;
  function $05881c54f989be11$var$isCollection(node) {
    if (node && typeof node === "object")
      switch (node[$05881c54f989be11$var$NODE_TYPE]) {
        case $05881c54f989be11$var$MAP:
        case $05881c54f989be11$var$SEQ:
          return true;
      }
    return false;
  }
  function $05881c54f989be11$var$isNode(node) {
    if (node && typeof node === "object")
      switch (node[$05881c54f989be11$var$NODE_TYPE]) {
        case $05881c54f989be11$var$ALIAS:
        case $05881c54f989be11$var$MAP:
        case $05881c54f989be11$var$SCALAR:
        case $05881c54f989be11$var$SEQ:
          return true;
      }
    return false;
  }
  const $05881c54f989be11$var$hasAnchor = (node) => ($05881c54f989be11$var$isScalar(node) || $05881c54f989be11$var$isCollection(node)) && !!node.anchor;
  $05881c54f989be11$export$6e16f50e77e6cb4d = $05881c54f989be11$var$ALIAS;
  $05881c54f989be11$export$c41a48f61a15d775 = $05881c54f989be11$var$DOC;
  $05881c54f989be11$export$ce970371e0e850bc = $05881c54f989be11$var$MAP;
  $05881c54f989be11$export$accaa52ddae3fe58 = $05881c54f989be11$var$NODE_TYPE;
  $05881c54f989be11$export$c4eb1412cef9eb18 = $05881c54f989be11$var$PAIR;
  $05881c54f989be11$export$8dde1211cb7c9d16 = $05881c54f989be11$var$SCALAR;
  $05881c54f989be11$export$200ef2dcd45611c9 = $05881c54f989be11$var$SEQ;
  $05881c54f989be11$export$67947a995b37b771 = $05881c54f989be11$var$hasAnchor;
  $05881c54f989be11$export$c6275352883a2b3e = $05881c54f989be11$var$isAlias;
  $05881c54f989be11$export$cea7aa84e978eba5 = $05881c54f989be11$var$isCollection;
  $05881c54f989be11$export$62858bae88b53fd0 = $05881c54f989be11$var$isDocument;
  $05881c54f989be11$export$5c90113a285f2241 = $05881c54f989be11$var$isMap;
  $05881c54f989be11$export$8ee0fc9ee280b4ee = $05881c54f989be11$var$isNode;
  $05881c54f989be11$export$7c8d445944656308 = $05881c54f989be11$var$isPair;
  $05881c54f989be11$export$8f3495e22775e76c = $05881c54f989be11$var$isScalar;
  $05881c54f989be11$export$342ac1d101ffe14b = $05881c54f989be11$var$isSeq;
});
parcelRequire.register("gHWL8", function(module, exports) {
  $parcel$export(module.exports, "visit", () => $c29e3ddaab9b6508$export$bf638b60ea8b89b7, (v) => $c29e3ddaab9b6508$export$bf638b60ea8b89b7 = v);
  $parcel$export(module.exports, "visitAsync", () => $c29e3ddaab9b6508$export$3c4f5d970a5e6a3b, (v) => $c29e3ddaab9b6508$export$3c4f5d970a5e6a3b = v);
  var $c29e3ddaab9b6508$export$bf638b60ea8b89b7;
  var $c29e3ddaab9b6508$export$3c4f5d970a5e6a3b;
  var $trADz = parcelRequire("trADz");
  const $c29e3ddaab9b6508$var$BREAK = Symbol("break visit");
  const $c29e3ddaab9b6508$var$SKIP = Symbol("skip children");
  const $c29e3ddaab9b6508$var$REMOVE = Symbol("remove node");
  function $c29e3ddaab9b6508$var$visit(node, visitor) {
    const visitor_ = $c29e3ddaab9b6508$var$initVisitor(visitor);
    if ($trADz.isDocument(node)) {
      const cd = $c29e3ddaab9b6508$var$visit_(null, node.contents, visitor_, Object.freeze([
        node
      ]));
      if (cd === $c29e3ddaab9b6508$var$REMOVE)
        node.contents = null;
    } else
      $c29e3ddaab9b6508$var$visit_(null, node, visitor_, Object.freeze([]));
  }
  $c29e3ddaab9b6508$var$visit.BREAK = $c29e3ddaab9b6508$var$BREAK;
  $c29e3ddaab9b6508$var$visit.SKIP = $c29e3ddaab9b6508$var$SKIP;
  $c29e3ddaab9b6508$var$visit.REMOVE = $c29e3ddaab9b6508$var$REMOVE;
  function $c29e3ddaab9b6508$var$visit_(key, node, visitor, path) {
    const ctrl = $c29e3ddaab9b6508$var$callVisitor(key, node, visitor, path);
    if ($trADz.isNode(ctrl) || $trADz.isPair(ctrl)) {
      $c29e3ddaab9b6508$var$replaceNode(key, path, ctrl);
      return $c29e3ddaab9b6508$var$visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if ($trADz.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = $c29e3ddaab9b6508$var$visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === $c29e3ddaab9b6508$var$BREAK)
            return $c29e3ddaab9b6508$var$BREAK;
          else if (ci === $c29e3ddaab9b6508$var$REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if ($trADz.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = $c29e3ddaab9b6508$var$visit_("key", node.key, visitor, path);
        if (ck === $c29e3ddaab9b6508$var$BREAK)
          return $c29e3ddaab9b6508$var$BREAK;
        else if (ck === $c29e3ddaab9b6508$var$REMOVE)
          node.key = null;
        const cv = $c29e3ddaab9b6508$var$visit_("value", node.value, visitor, path);
        if (cv === $c29e3ddaab9b6508$var$BREAK)
          return $c29e3ddaab9b6508$var$BREAK;
        else if (cv === $c29e3ddaab9b6508$var$REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function $c29e3ddaab9b6508$var$visitAsync(node, visitor) {
    const visitor_ = $c29e3ddaab9b6508$var$initVisitor(visitor);
    if ($trADz.isDocument(node)) {
      const cd = await $c29e3ddaab9b6508$var$visitAsync_(null, node.contents, visitor_, Object.freeze([
        node
      ]));
      if (cd === $c29e3ddaab9b6508$var$REMOVE)
        node.contents = null;
    } else
      await $c29e3ddaab9b6508$var$visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  $c29e3ddaab9b6508$var$visitAsync.BREAK = $c29e3ddaab9b6508$var$BREAK;
  $c29e3ddaab9b6508$var$visitAsync.SKIP = $c29e3ddaab9b6508$var$SKIP;
  $c29e3ddaab9b6508$var$visitAsync.REMOVE = $c29e3ddaab9b6508$var$REMOVE;
  async function $c29e3ddaab9b6508$var$visitAsync_(key, node, visitor, path) {
    const ctrl = await $c29e3ddaab9b6508$var$callVisitor(key, node, visitor, path);
    if ($trADz.isNode(ctrl) || $trADz.isPair(ctrl)) {
      $c29e3ddaab9b6508$var$replaceNode(key, path, ctrl);
      return $c29e3ddaab9b6508$var$visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if ($trADz.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0; i < node.items.length; ++i) {
          const ci = await $c29e3ddaab9b6508$var$visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === $c29e3ddaab9b6508$var$BREAK)
            return $c29e3ddaab9b6508$var$BREAK;
          else if (ci === $c29e3ddaab9b6508$var$REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if ($trADz.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await $c29e3ddaab9b6508$var$visitAsync_("key", node.key, visitor, path);
        if (ck === $c29e3ddaab9b6508$var$BREAK)
          return $c29e3ddaab9b6508$var$BREAK;
        else if (ck === $c29e3ddaab9b6508$var$REMOVE)
          node.key = null;
        const cv = await $c29e3ddaab9b6508$var$visitAsync_("value", node.value, visitor, path);
        if (cv === $c29e3ddaab9b6508$var$BREAK)
          return $c29e3ddaab9b6508$var$BREAK;
        else if (cv === $c29e3ddaab9b6508$var$REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function $c29e3ddaab9b6508$var$initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value))
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    return visitor;
  }
  function $c29e3ddaab9b6508$var$callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if ($trADz.isMap(node))
      return visitor.Map?.(key, node, path);
    if ($trADz.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if ($trADz.isPair(node))
      return visitor.Pair?.(key, node, path);
    if ($trADz.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if ($trADz.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return void 0;
  }
  function $c29e3ddaab9b6508$var$replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if ($trADz.isCollection(parent))
      parent.items[key] = node;
    else if ($trADz.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if ($trADz.isDocument(parent))
      parent.contents = node;
    else {
      const pt = $trADz.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  $c29e3ddaab9b6508$export$bf638b60ea8b89b7 = $c29e3ddaab9b6508$var$visit;
  $c29e3ddaab9b6508$export$3c4f5d970a5e6a3b = $c29e3ddaab9b6508$var$visitAsync;
});
parcelRequire.register("6Ua5a", function(module, exports) {
  $parcel$export(module.exports, "Document", () => $506fcb2c476b3590$export$b34a105447964f9f, (v) => $506fcb2c476b3590$export$b34a105447964f9f = v);
  var $506fcb2c476b3590$export$b34a105447964f9f;
  var $gdpli = parcelRequire("gdpli");
  var $dG1en = parcelRequire("dG1en");
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $awijv = parcelRequire("awijv");
  var $bnMCR = parcelRequire("bnMCR");
  var $iaeHd = parcelRequire("iaeHd");
  var $zww61 = parcelRequire("zww61");
  var $kjru3 = parcelRequire("kjru3");
  var $lLz1V = parcelRequire("lLz1V");
  var $dZfLp = parcelRequire("dZfLp");
  class $506fcb2c476b3590$var$Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, $trADz.NODE_TYPE, {
        value: $trADz.DOC
      });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer))
        _replacer = replacer;
      else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new $dZfLp.Directives({
          version
        });
      this.setSchema(version, options);
      this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
      const copy = Object.create($506fcb2c476b3590$var$Document.prototype, {
        [$trADz.NODE_TYPE]: {
          value: $trADz.DOC
        }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = $trADz.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** Adds a value to the document. */
    add(value) {
      if ($506fcb2c476b3590$var$assertCollection(this.contents))
        this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
      if ($506fcb2c476b3590$var$assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = $zww61.anchorNames(this);
        node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        !name || prev.has(name) ? $zww61.findNewAnchor(name || "a", prev) : name;
      }
      return new $gdpli.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = void 0;
      if (typeof replacer === "function") {
        value = replacer.call({
          "": value
        }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
        replacer = void 0;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = $zww61.createNodeAnchors(
        this,
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || "a"
      );
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = $lLz1V.createNode(value, tag, ctx);
      if (flow && $trADz.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new $cDsIW.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      return $506fcb2c476b3590$var$assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
      if ($dG1en.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return $506fcb2c476b3590$var$assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
      return $trADz.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
      if ($dG1en.isEmptyPath(path))
        return !keepScalar && $trADz.isScalar(this.contents) ? this.contents.value : this.contents;
      return $trADz.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
      return $trADz.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
      if ($dG1en.isEmptyPath(path))
        return this.contents !== void 0;
      return $trADz.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
      if (this.contents == null)
        this.contents = $dG1en.collectionFromPath(this.schema, [
          key
        ], value);
      else if ($506fcb2c476b3590$var$assertCollection(this.contents))
        this.contents.set(key, value);
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
      if ($dG1en.isEmptyPath(path))
        this.contents = value;
      else if (this.contents == null)
        this.contents = $dG1en.collectionFromPath(this.schema, Array.from(path), value);
      else if ($506fcb2c476b3590$var$assertCollection(this.contents))
        this.contents.setIn(path, value);
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new $dZfLp.Directives({
              version: "1.1"
            });
          opt = {
            merge: true,
            resolveKnownTags: false,
            schema: "yaml-1.1"
          };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new $dZfLp.Directives({
              version
            });
          opt = {
            merge: false,
            resolveKnownTags: true,
            schema: "core"
          };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new $bnMCR.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = $awijv.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? $kjru3.applyReviver(reviver, {
        "": res
      }, "", res) : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
      return this.toJS({
        json: true,
        jsonArg,
        mapAsMap: false,
        onAnchor
      });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return $iaeHd.stringifyDocument(this, options);
    }
  }
  function $506fcb2c476b3590$var$assertCollection(contents) {
    if ($trADz.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  $506fcb2c476b3590$export$b34a105447964f9f = $506fcb2c476b3590$var$Document;
});
parcelRequire.register("gdpli", function(module, exports) {
  $parcel$export(module.exports, "Alias", () => $bce184b5289312eb$export$17b520249a85fe16, (v) => $bce184b5289312eb$export$17b520249a85fe16 = v);
  var $bce184b5289312eb$export$17b520249a85fe16;
  var $zww61 = parcelRequire("zww61");
  var $gHWL8 = parcelRequire("gHWL8");
  var $trADz = parcelRequire("trADz");
  var $hw4x1 = parcelRequire("hw4x1");
  var $awijv = parcelRequire("awijv");
  class $bce184b5289312eb$var$Alias extends $hw4x1.NodeBase {
    constructor(source) {
      super($trADz.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
      let found = void 0;
      $gHWL8.visit(doc, {
        Node: (_key, node) => {
          if (node === this)
            return $gHWL8.visit.BREAK;
          if (node.anchor === this.source)
            found = node;
        }
      });
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return {
          source: this.source
        };
      const { anchors, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors.get(source);
      if (!data) {
        $awijv.toJS(source, null, ctx);
        data = anchors.get(source);
      }
      if (!data || data.res === void 0) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = $bce184b5289312eb$var$getAliasCount(doc, source, anchors);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        $zww61.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function $bce184b5289312eb$var$getAliasCount(doc, node, anchors) {
    if ($trADz.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors && source && anchors.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if ($trADz.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = $bce184b5289312eb$var$getAliasCount(doc, item, anchors);
        if (c > count)
          count = c;
      }
      return count;
    } else if ($trADz.isPair(node)) {
      const kc = $bce184b5289312eb$var$getAliasCount(doc, node.key, anchors);
      const vc = $bce184b5289312eb$var$getAliasCount(doc, node.value, anchors);
      return Math.max(kc, vc);
    }
    return 1;
  }
  $bce184b5289312eb$export$17b520249a85fe16 = $bce184b5289312eb$var$Alias;
});
parcelRequire.register("zww61", function(module, exports) {
  $parcel$export(module.exports, "anchorIsValid", () => $06ac7e225406dd93$export$67b774d238e24409, (v) => $06ac7e225406dd93$export$67b774d238e24409 = v);
  $parcel$export(module.exports, "anchorNames", () => $06ac7e225406dd93$export$402f230d710ffb75, (v) => $06ac7e225406dd93$export$402f230d710ffb75 = v);
  $parcel$export(module.exports, "createNodeAnchors", () => $06ac7e225406dd93$export$5498887d1e6c340c, (v) => $06ac7e225406dd93$export$5498887d1e6c340c = v);
  $parcel$export(module.exports, "findNewAnchor", () => $06ac7e225406dd93$export$1a7f8f45ec43f9e4, (v) => $06ac7e225406dd93$export$1a7f8f45ec43f9e4 = v);
  var $06ac7e225406dd93$export$67b774d238e24409;
  var $06ac7e225406dd93$export$402f230d710ffb75;
  var $06ac7e225406dd93$export$5498887d1e6c340c;
  var $06ac7e225406dd93$export$1a7f8f45ec43f9e4;
  var $trADz = parcelRequire("trADz");
  var $gHWL8 = parcelRequire("gHWL8");
  function $06ac7e225406dd93$var$anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function $06ac7e225406dd93$var$anchorNames(root) {
    const anchors = /* @__PURE__ */ new Set();
    $gHWL8.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function $06ac7e225406dd93$var$findNewAnchor(prefix, exclude) {
    for (let i = 1; ; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function $06ac7e225406dd93$var$createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = /* @__PURE__ */ new Map();
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        if (!prevAnchors)
          prevAnchors = $06ac7e225406dd93$var$anchorNames(doc);
        const anchor = $06ac7e225406dd93$var$findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      /**
       * With circular references, the source node is only resolved after all
       * of its child nodes are. This is why anchors are set only after all of
       * the nodes have been created.
       */
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && ($trADz.isScalar(ref.node) || $trADz.isCollection(ref.node)))
            ref.node.anchor = ref.anchor;
          else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  $06ac7e225406dd93$export$67b774d238e24409 = $06ac7e225406dd93$var$anchorIsValid;
  $06ac7e225406dd93$export$402f230d710ffb75 = $06ac7e225406dd93$var$anchorNames;
  $06ac7e225406dd93$export$5498887d1e6c340c = $06ac7e225406dd93$var$createNodeAnchors;
  $06ac7e225406dd93$export$1a7f8f45ec43f9e4 = $06ac7e225406dd93$var$findNewAnchor;
});
parcelRequire.register("hw4x1", function(module, exports) {
  $parcel$export(module.exports, "NodeBase", () => $cc08f0bbe8ab2a35$export$7cc40ad5cb33f2dc, (v) => $cc08f0bbe8ab2a35$export$7cc40ad5cb33f2dc = v);
  var $cc08f0bbe8ab2a35$export$7cc40ad5cb33f2dc;
  var $kjru3 = parcelRequire("kjru3");
  var $trADz = parcelRequire("trADz");
  var $awijv = parcelRequire("awijv");
  class $cc08f0bbe8ab2a35$var$NodeBase {
    constructor(type) {
      Object.defineProperty(this, $trADz.NODE_TYPE, {
        value: type
      });
    }
    /** Create a copy of this node.  */
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!$trADz.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: /* @__PURE__ */ new Map(),
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = $awijv.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? $kjru3.applyReviver(reviver, {
        "": res
      }, "", res) : res;
    }
  }
  $cc08f0bbe8ab2a35$export$7cc40ad5cb33f2dc = $cc08f0bbe8ab2a35$var$NodeBase;
});
parcelRequire.register("kjru3", function(module, exports) {
  $parcel$export(module.exports, "applyReviver", () => $ec9ae6abf37ca772$export$abc04374ac0ef535, (v) => $ec9ae6abf37ca772$export$abc04374ac0ef535 = v);
  var $ec9ae6abf37ca772$export$abc04374ac0ef535;
  function $ec9ae6abf37ca772$var$applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val))
        for (let i = 0, len = val.length; i < len; ++i) {
          const v0 = val[i];
          const v1 = $ec9ae6abf37ca772$var$applyReviver(reviver, val, String(i), v0);
          if (v1 === void 0)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      else if (val instanceof Map)
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = $ec9ae6abf37ca772$var$applyReviver(reviver, val, k, v0);
          if (v1 === void 0)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      else if (val instanceof Set)
        for (const v0 of Array.from(val)) {
          const v1 = $ec9ae6abf37ca772$var$applyReviver(reviver, val, v0, v0);
          if (v1 === void 0)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      else
        for (const [k, v0] of Object.entries(val)) {
          const v1 = $ec9ae6abf37ca772$var$applyReviver(reviver, val, k, v0);
          if (v1 === void 0)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
    }
    return reviver.call(obj, key, val);
  }
  $ec9ae6abf37ca772$export$abc04374ac0ef535 = $ec9ae6abf37ca772$var$applyReviver;
});
parcelRequire.register("awijv", function(module, exports) {
  $parcel$export(module.exports, "toJS", () => $7a8b193d1a49ce75$export$f08965dd1304d490, (v) => $7a8b193d1a49ce75$export$f08965dd1304d490 = v);
  var $7a8b193d1a49ce75$export$f08965dd1304d490;
  var $trADz = parcelRequire("trADz");
  function $7a8b193d1a49ce75$var$toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => $7a8b193d1a49ce75$var$toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !$trADz.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = {
        aliasCount: 0,
        count: 1,
        res: void 0
      };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  $7a8b193d1a49ce75$export$f08965dd1304d490 = $7a8b193d1a49ce75$var$toJS;
});
parcelRequire.register("dG1en", function(module, exports) {
  $parcel$export(module.exports, "Collection", () => $9f50270da4054290$export$fb8073518f34e6ec, (v) => $9f50270da4054290$export$fb8073518f34e6ec = v);
  $parcel$export(module.exports, "collectionFromPath", () => $9f50270da4054290$export$f5ac8bc6072340dd, (v) => $9f50270da4054290$export$f5ac8bc6072340dd = v);
  $parcel$export(module.exports, "isEmptyPath", () => $9f50270da4054290$export$e3bfca790bd8f9da, (v) => $9f50270da4054290$export$e3bfca790bd8f9da = v);
  var $9f50270da4054290$export$fb8073518f34e6ec;
  var $9f50270da4054290$export$f5ac8bc6072340dd;
  var $9f50270da4054290$export$e3bfca790bd8f9da;
  var $lLz1V = parcelRequire("lLz1V");
  var $trADz = parcelRequire("trADz");
  var $hw4x1 = parcelRequire("hw4x1");
  function $9f50270da4054290$var$collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else
        v = /* @__PURE__ */ new Map([
          [
            k,
            v
          ]
        ]);
    }
    return $lLz1V.createNode(v, void 0, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: /* @__PURE__ */ new Map()
    });
  }
  const $9f50270da4054290$var$isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
  class $9f50270da4054290$var$Collection extends $hw4x1.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => $trADz.isNode(it) || $trADz.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
      if ($9f50270da4054290$var$isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if ($trADz.isCollection(node))
          node.addIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, $9f50270da4054290$var$collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if ($trADz.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && $trADz.isScalar(node) ? node.value : node;
      else
        return $trADz.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!$trADz.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && $trADz.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return $trADz.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        this.set(key, value);
      else {
        const node = this.get(key, true);
        if ($trADz.isCollection(node))
          node.setIn(rest, value);
        else if (node === void 0 && this.schema)
          this.set(key, $9f50270da4054290$var$collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  $9f50270da4054290$var$Collection.maxFlowStringSingleLineLength = 60;
  $9f50270da4054290$export$fb8073518f34e6ec = $9f50270da4054290$var$Collection;
  $9f50270da4054290$export$f5ac8bc6072340dd = $9f50270da4054290$var$collectionFromPath;
  $9f50270da4054290$export$e3bfca790bd8f9da = $9f50270da4054290$var$isEmptyPath;
});
parcelRequire.register("lLz1V", function(module, exports) {
  $parcel$export(module.exports, "createNode", () => $fd8928ff96172a90$export$270e7ba5936d3c48, (v) => $fd8928ff96172a90$export$270e7ba5936d3c48 = v);
  var $fd8928ff96172a90$export$270e7ba5936d3c48;
  var $gdpli = parcelRequire("gdpli");
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  const $fd8928ff96172a90$var$defaultTagPrefix = "tag:yaml.org,2002:";
  function $fd8928ff96172a90$var$findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function $fd8928ff96172a90$var$createNode(value, tagName, ctx) {
    if ($trADz.isDocument(value))
      value = value.contents;
    if ($trADz.isNode(value))
      return value;
    if ($trADz.isPair(value)) {
      const map = ctx.schema[$trADz.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt)
      value = value.valueOf();
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = void 0;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        if (!ref.anchor)
          ref.anchor = onAnchor(value);
        return new $gdpli.Alias(ref.anchor);
      } else {
        ref = {
          anchor: null,
          node: null
        };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = $fd8928ff96172a90$var$defaultTagPrefix + tagName.slice(2);
    let tagObj = $fd8928ff96172a90$var$findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function")
        value = value.toJSON();
      if (!value || typeof value !== "object") {
        const node2 = new $6K3Lx.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[$trADz.MAP] : Symbol.iterator in Object(value) ? schema[$trADz.SEQ] : schema[$trADz.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new $6K3Lx.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  $fd8928ff96172a90$export$270e7ba5936d3c48 = $fd8928ff96172a90$var$createNode;
});
parcelRequire.register("6K3Lx", function(module, exports) {
  $parcel$export(module.exports, "Scalar", () => $4e89f5bef2956f7a$export$595dbf49c602a1f, (v) => $4e89f5bef2956f7a$export$595dbf49c602a1f = v);
  $parcel$export(module.exports, "isScalarValue", () => $4e89f5bef2956f7a$export$dc071f102752d0eb, (v) => $4e89f5bef2956f7a$export$dc071f102752d0eb = v);
  var $4e89f5bef2956f7a$export$595dbf49c602a1f;
  var $4e89f5bef2956f7a$export$dc071f102752d0eb;
  var $trADz = parcelRequire("trADz");
  var $hw4x1 = parcelRequire("hw4x1");
  var $awijv = parcelRequire("awijv");
  const $4e89f5bef2956f7a$var$isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
  class $4e89f5bef2956f7a$var$Scalar extends $hw4x1.NodeBase {
    constructor(value) {
      super($trADz.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : $awijv.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  $4e89f5bef2956f7a$var$Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  $4e89f5bef2956f7a$var$Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  $4e89f5bef2956f7a$var$Scalar.PLAIN = "PLAIN";
  $4e89f5bef2956f7a$var$Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  $4e89f5bef2956f7a$var$Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  $4e89f5bef2956f7a$export$595dbf49c602a1f = $4e89f5bef2956f7a$var$Scalar;
  $4e89f5bef2956f7a$export$dc071f102752d0eb = $4e89f5bef2956f7a$var$isScalarValue;
});
parcelRequire.register("cDsIW", function(module, exports) {
  $parcel$export(module.exports, "Pair", () => $932f68861c4c3e5f$export$d63d7cff08fe4dc9, (v) => $932f68861c4c3e5f$export$d63d7cff08fe4dc9 = v);
  $parcel$export(module.exports, "createPair", () => $932f68861c4c3e5f$export$afe19f123272774, (v) => $932f68861c4c3e5f$export$afe19f123272774 = v);
  var $932f68861c4c3e5f$export$d63d7cff08fe4dc9;
  var $932f68861c4c3e5f$export$afe19f123272774;
  var $lLz1V = parcelRequire("lLz1V");
  var $grjTB = parcelRequire("grjTB");
  var $jOmBV = parcelRequire("jOmBV");
  var $trADz = parcelRequire("trADz");
  function $932f68861c4c3e5f$var$createPair(key, value, ctx) {
    const k = $lLz1V.createNode(key, void 0, ctx);
    const v = $lLz1V.createNode(value, void 0, ctx);
    return new $932f68861c4c3e5f$var$Pair(k, v);
  }
  class $932f68861c4c3e5f$var$Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, $trADz.NODE_TYPE, {
        value: $trADz.PAIR
      });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if ($trADz.isNode(key))
        key = key.clone(schema);
      if ($trADz.isNode(value))
        value = value.clone(schema);
      return new $932f68861c4c3e5f$var$Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return $jOmBV.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? $grjTB.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  $932f68861c4c3e5f$export$d63d7cff08fe4dc9 = $932f68861c4c3e5f$var$Pair;
  $932f68861c4c3e5f$export$afe19f123272774 = $932f68861c4c3e5f$var$createPair;
});
parcelRequire.register("grjTB", function(module, exports) {
  $parcel$export(module.exports, "stringifyPair", () => $bf7e99dfb83aaed8$export$fffacbb893c76683, (v) => $bf7e99dfb83aaed8$export$fffacbb893c76683 = v);
  var $bf7e99dfb83aaed8$export$fffacbb893c76683;
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $cpzR2 = parcelRequire("cpzR2");
  var $7AgmX = parcelRequire("7AgmX");
  function $bf7e99dfb83aaed8$var$stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = $trADz.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment)
        throw new Error("With simple keys, key nodes cannot have comments");
      if ($trADz.isCollection(key)) {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || $trADz.isCollection(key) || ($trADz.isScalar(key) ? key.type === $6K3Lx.Scalar.BLOCK_FOLDED || key.type === $6K3Lx.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = $cpzR2.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone)
        str += $7AgmX.lineComment(str, ctx.indent, commentString(keyComment));
      else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += $7AgmX.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += $7AgmX.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if ($trADz.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && $trADz.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && $trADz.isSeq(value) && !value.flow && !value.tag && !value.anchor)
      ctx.indent = ctx.indent.substring(2);
    let valueCommentDone = false;
    const valueStr = $cpzR2.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? "\n" : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${$7AgmX.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === "\n")
          ws = "\n\n";
      } else
        ws += `
${ctx.indent}`;
    } else if (!explicitKey && $trADz.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf("\n");
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!")
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === "\n")
      ws = "";
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone)
      str += $7AgmX.lineComment(str, ctx.indent, commentString(valueComment));
    else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  $bf7e99dfb83aaed8$export$fffacbb893c76683 = $bf7e99dfb83aaed8$var$stringifyPair;
});
parcelRequire.register("cpzR2", function(module, exports) {
  $parcel$export(module.exports, "createStringifyContext", () => $9093a1c203c9e5f8$export$829faaf53c257c4d, (v) => $9093a1c203c9e5f8$export$829faaf53c257c4d = v);
  $parcel$export(module.exports, "stringify", () => $9093a1c203c9e5f8$export$fac44ee5b035f737, (v) => $9093a1c203c9e5f8$export$fac44ee5b035f737 = v);
  var $9093a1c203c9e5f8$export$829faaf53c257c4d;
  var $9093a1c203c9e5f8$export$fac44ee5b035f737;
  var $zww61 = parcelRequire("zww61");
  var $trADz = parcelRequire("trADz");
  var $7AgmX = parcelRequire("7AgmX");
  var $cz3Ls = parcelRequire("cz3Ls");
  function $9093a1c203c9e5f8$var$createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: $7AgmX.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: /* @__PURE__ */ new Set(),
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function $9093a1c203c9e5f8$var$getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = void 0;
    let obj;
    if ($trADz.isScalar(item)) {
      obj = item.value;
      const match = tags.filter((t) => t.identify?.(obj));
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? typeof obj;
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function $9093a1c203c9e5f8$var$stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = ($trADz.isScalar(node) || $trADz.isCollection(node)) && node.anchor;
    if (anchor && $zww61.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function $9093a1c203c9e5f8$var$stringify(item, ctx, onComment, onChompKeep) {
    if ($trADz.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if ($trADz.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item))
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = /* @__PURE__ */ new Set([
            item
          ]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = void 0;
    const node = $trADz.isNode(item) ? item : ctx.doc.createNode(item, {
      onTagObj: (o) => tagObj = o
    });
    if (!tagObj)
      tagObj = $9093a1c203c9e5f8$var$getTagObject(ctx.doc.schema.tags, node);
    const props = $9093a1c203c9e5f8$var$stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : $trADz.isScalar(node) ? $cz3Ls.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return $trADz.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  $9093a1c203c9e5f8$export$829faaf53c257c4d = $9093a1c203c9e5f8$var$createStringifyContext;
  $9093a1c203c9e5f8$export$fac44ee5b035f737 = $9093a1c203c9e5f8$var$stringify;
});
parcelRequire.register("7AgmX", function(module, exports) {
  $parcel$export(module.exports, "indentComment", () => $585897c6c8003713$export$9933eb161eea191d, (v) => $585897c6c8003713$export$9933eb161eea191d = v);
  $parcel$export(module.exports, "lineComment", () => $585897c6c8003713$export$5d080f5a78d4f5b3, (v) => $585897c6c8003713$export$5d080f5a78d4f5b3 = v);
  $parcel$export(module.exports, "stringifyComment", () => $585897c6c8003713$export$bda2970260483e9e, (v) => $585897c6c8003713$export$bda2970260483e9e = v);
  var $585897c6c8003713$export$9933eb161eea191d;
  var $585897c6c8003713$export$5d080f5a78d4f5b3;
  var $585897c6c8003713$export$bda2970260483e9e;
  const $585897c6c8003713$var$stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function $585897c6c8003713$var$indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  const $585897c6c8003713$var$lineComment = (str, indent, comment) => str.endsWith("\n") ? $585897c6c8003713$var$indentComment(comment, indent) : comment.includes("\n") ? "\n" + $585897c6c8003713$var$indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  $585897c6c8003713$export$9933eb161eea191d = $585897c6c8003713$var$indentComment;
  $585897c6c8003713$export$5d080f5a78d4f5b3 = $585897c6c8003713$var$lineComment;
  $585897c6c8003713$export$bda2970260483e9e = $585897c6c8003713$var$stringifyComment;
});
parcelRequire.register("cz3Ls", function(module, exports) {
  $parcel$export(module.exports, "stringifyString", () => $925bac77f3a928a8$export$3457ffbf9a1af5aa, (v) => $925bac77f3a928a8$export$3457ffbf9a1af5aa = v);
  var $925bac77f3a928a8$export$3457ffbf9a1af5aa;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $8a56K = parcelRequire("8a56K");
  const $925bac77f3a928a8$var$getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  const $925bac77f3a928a8$var$containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function $925bac77f3a928a8$var$lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0; i < strLen; ++i)
      if (str[i] === "\n") {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    return true;
  }
  function $925bac77f3a928a8$var$doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || ($925bac77f3a928a8$var$containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength)
              i += 1;
            else {
              str += json.slice(start, i) + "\n\n";
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += "\n";
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : $8a56K.foldFlowLines(str, indent, $8a56K.FOLD_QUOTED, $925bac77f3a928a8$var$getFoldOptions(ctx, false));
  }
  function $925bac77f3a928a8$var$singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
      return $925bac77f3a928a8$var$doubleQuotedString(value, ctx);
    const indent = ctx.indent || ($925bac77f3a928a8$var$containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : $8a56K.foldFlowLines(res, indent, $8a56K.FOLD_FLOW, $925bac77f3a928a8$var$getFoldOptions(ctx, false));
  }
  function $925bac77f3a928a8$var$quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = $925bac77f3a928a8$var$doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = $925bac77f3a928a8$var$singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = $925bac77f3a928a8$var$doubleQuotedString;
      else
        qs = singleQuote ? $925bac77f3a928a8$var$singleQuotedString : $925bac77f3a928a8$var$doubleQuotedString;
    }
    return qs(value, ctx);
  }
  let $925bac77f3a928a8$var$blockEndNewlines;
  try {
    $925bac77f3a928a8$var$blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
  } catch {
    $925bac77f3a928a8$var$blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function $925bac77f3a928a8$var$blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value))
      return $925bac77f3a928a8$var$quotedString(value, ctx);
    const indent = ctx.indent || (ctx.forceBlockIndent || $925bac77f3a928a8$var$containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === $6K3Lx.Scalar.BLOCK_FOLDED ? false : type === $6K3Lx.Scalar.BLOCK_LITERAL ? true : !$925bac77f3a928a8$var$lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? "|\n" : ">\n";
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== "\n" && ch !== "	" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf("\n");
    if (endNlPos === -1)
      chomp = "-";
    else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else
      chomp = "";
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === "\n")
        end = end.slice(0, -1);
      end = end.replace($925bac77f3a928a8$var$blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === "\n")
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (literal) {
      value = value.replace(/\n+/g, `$&${indent}`);
      return `${header}
${indent}${start}${value}${end}`;
    }
    value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    const body = $8a56K.foldFlowLines(`${start}${value}${end}`, indent, $8a56K.FOLD_BLOCK, $925bac77f3a928a8$var$getFoldOptions(ctx, true));
    return `${header}
${indent}${body}`;
  }
  function $925bac77f3a928a8$var$plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value))
      return $925bac77f3a928a8$var$quotedString(value, ctx);
    if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value))
      return implicitKey || inFlow || !value.includes("\n") ? $925bac77f3a928a8$var$quotedString(value, ctx) : $925bac77f3a928a8$var$blockString(item, ctx, onComment, onChompKeep);
    if (!implicitKey && !inFlow && type !== $6K3Lx.Scalar.PLAIN && value.includes("\n"))
      return $925bac77f3a928a8$var$blockString(item, ctx, onComment, onChompKeep);
    if ($925bac77f3a928a8$var$containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return $925bac77f3a928a8$var$blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep)
        return $925bac77f3a928a8$var$quotedString(value, ctx);
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return $925bac77f3a928a8$var$quotedString(value, ctx);
    }
    return implicitKey ? str : $8a56K.foldFlowLines(str, indent, $8a56K.FOLD_FLOW, $925bac77f3a928a8$var$getFoldOptions(ctx, false));
  }
  function $925bac77f3a928a8$var$stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, {
      value: String(item.value)
    });
    let { type } = item;
    if (type !== $6K3Lx.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = $6K3Lx.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case $6K3Lx.Scalar.BLOCK_FOLDED:
        case $6K3Lx.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? $925bac77f3a928a8$var$quotedString(ss.value, ctx) : $925bac77f3a928a8$var$blockString(ss, ctx, onComment, onChompKeep);
        case $6K3Lx.Scalar.QUOTE_DOUBLE:
          return $925bac77f3a928a8$var$doubleQuotedString(ss.value, ctx);
        case $6K3Lx.Scalar.QUOTE_SINGLE:
          return $925bac77f3a928a8$var$singleQuotedString(ss.value, ctx);
        case $6K3Lx.Scalar.PLAIN:
          return $925bac77f3a928a8$var$plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  $925bac77f3a928a8$export$3457ffbf9a1af5aa = $925bac77f3a928a8$var$stringifyString;
});
parcelRequire.register("8a56K", function(module, exports) {
  $parcel$export(module.exports, "FOLD_BLOCK", () => $5f1338356551bb38$export$609fbd56c8a85825, (v) => $5f1338356551bb38$export$609fbd56c8a85825 = v);
  $parcel$export(module.exports, "FOLD_FLOW", () => $5f1338356551bb38$export$dfafce8168b25546, (v) => $5f1338356551bb38$export$dfafce8168b25546 = v);
  $parcel$export(module.exports, "FOLD_QUOTED", () => $5f1338356551bb38$export$74d9ae4055c4d6cf, (v) => $5f1338356551bb38$export$74d9ae4055c4d6cf = v);
  $parcel$export(module.exports, "foldFlowLines", () => $5f1338356551bb38$export$e82a5ab0b770aa09, (v) => $5f1338356551bb38$export$e82a5ab0b770aa09 = v);
  var $5f1338356551bb38$export$609fbd56c8a85825;
  var $5f1338356551bb38$export$dfafce8168b25546;
  var $5f1338356551bb38$export$74d9ae4055c4d6cf;
  var $5f1338356551bb38$export$e82a5ab0b770aa09;
  const $5f1338356551bb38$var$FOLD_FLOW = "flow";
  const $5f1338356551bb38$var$FOLD_BLOCK = "block";
  const $5f1338356551bb38$var$FOLD_QUOTED = "quoted";
  function $5f1338356551bb38$var$foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = void 0;
    let prev = void 0;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === $5f1338356551bb38$var$FOLD_BLOCK) {
      i = $5f1338356551bb38$var$consumeMoreIndentedLines(text, i);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch; ch = text[i += 1]; ) {
      if (mode === $5f1338356551bb38$var$FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === "\n") {
        if (mode === $5f1338356551bb38$var$FOLD_BLOCK)
          i = $5f1338356551bb38$var$consumeMoreIndentedLines(text, i);
        end = i + endStep;
        split = void 0;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
          const next = text[i + 1];
          if (next && next !== " " && next !== "\n" && next !== "	")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = void 0;
          } else if (mode === $5f1338356551bb38$var$FOLD_QUOTED) {
            while (prev === " " || prev === "	") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = void 0;
          } else
            overflow = true;
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0; i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === $5f1338356551bb38$var$FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function $5f1338356551bb38$var$consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === " " || ch === "	") {
      do
        ch = text[i += 1];
      while (ch && ch !== "\n");
      ch = text[i + 1];
    }
    return i;
  }
  $5f1338356551bb38$export$609fbd56c8a85825 = $5f1338356551bb38$var$FOLD_BLOCK;
  $5f1338356551bb38$export$dfafce8168b25546 = $5f1338356551bb38$var$FOLD_FLOW;
  $5f1338356551bb38$export$74d9ae4055c4d6cf = $5f1338356551bb38$var$FOLD_QUOTED;
  $5f1338356551bb38$export$e82a5ab0b770aa09 = $5f1338356551bb38$var$foldFlowLines;
});
parcelRequire.register("jOmBV", function(module, exports) {
  $parcel$export(module.exports, "addPairToJSMap", () => $e6c439d4dfd0e800$export$fdef4d6a4585851d, (v) => $e6c439d4dfd0e800$export$fdef4d6a4585851d = v);
  var $e6c439d4dfd0e800$export$fdef4d6a4585851d;
  var $5pHPF = parcelRequire("5pHPF");
  var $cpzR2 = parcelRequire("cpzR2");
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $awijv = parcelRequire("awijv");
  const $e6c439d4dfd0e800$var$MERGE_KEY = "<<";
  function $e6c439d4dfd0e800$var$addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && $e6c439d4dfd0e800$var$isMergeKey(key)) {
      value = $trADz.isAlias(value) ? value.resolve(ctx.doc) : value;
      if ($trADz.isSeq(value))
        for (const it of value.items)
          $e6c439d4dfd0e800$var$mergeToJSMap(ctx, map, it);
      else if (Array.isArray(value))
        for (const it of value)
          $e6c439d4dfd0e800$var$mergeToJSMap(ctx, map, it);
      else
        $e6c439d4dfd0e800$var$mergeToJSMap(ctx, map, value);
    } else {
      const jsKey = $awijv.toJS(key, "", ctx);
      if (map instanceof Map)
        map.set(jsKey, $awijv.toJS(value, jsKey, ctx));
      else if (map instanceof Set)
        map.add(jsKey);
      else {
        const stringKey = $e6c439d4dfd0e800$var$stringifyKey(key, jsKey, ctx);
        const jsValue = $awijv.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  const $e6c439d4dfd0e800$var$isMergeKey = (key) => key === $e6c439d4dfd0e800$var$MERGE_KEY || $trADz.isScalar(key) && key.value === $e6c439d4dfd0e800$var$MERGE_KEY && (!key.type || key.type === $6K3Lx.Scalar.PLAIN);
  function $e6c439d4dfd0e800$var$mergeToJSMap(ctx, map, value) {
    const source = ctx && $trADz.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!$trADz.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set)
        map.add(key);
      else if (!Object.prototype.hasOwnProperty.call(map, key))
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
    }
    return map;
  }
  function $e6c439d4dfd0e800$var$stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if ($trADz.isNode(key) && ctx?.doc) {
      const strCtx = $cpzR2.createStringifyContext(ctx.doc, {});
      strCtx.anchors = /* @__PURE__ */ new Set();
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        $5pHPF.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  $e6c439d4dfd0e800$export$fdef4d6a4585851d = $e6c439d4dfd0e800$var$addPairToJSMap;
});
parcelRequire.register("5pHPF", function(module, exports) {
  $parcel$export(module.exports, "warn", () => $3f1149c17269827c$export$c106dd0671a0fc2d, (v) => $3f1149c17269827c$export$c106dd0671a0fc2d = v);
  var $3f1149c17269827c$export$c106dd0671a0fc2d;
  function $3f1149c17269827c$var$warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof process !== "undefined" && process.emitWarning)
        process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  $3f1149c17269827c$export$c106dd0671a0fc2d = $3f1149c17269827c$var$warn;
});
parcelRequire.register("bnMCR", function(module, exports) {
  $parcel$export(module.exports, "Schema", () => $84978fc75525500b$export$19342e026b58ebb7, (v) => $84978fc75525500b$export$19342e026b58ebb7 = v);
  var $84978fc75525500b$export$19342e026b58ebb7;
  var $trADz = parcelRequire("trADz");
  var $jBWkn = parcelRequire("jBWkn");
  var $6QsbA = parcelRequire("6QsbA");
  var $66IKL = parcelRequire("66IKL");
  var $kJ4tW = parcelRequire("kJ4tW");
  const $84978fc75525500b$var$sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
  class $84978fc75525500b$var$Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? $kJ4tW.getTags(compat, "compat") : compat ? $kJ4tW.getTags(null, compat) : null;
      this.merge = !!merge;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? $kJ4tW.coreKnownTags : {};
      this.tags = $kJ4tW.getTags(customTags, this.name);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, $trADz.MAP, {
        value: $jBWkn.map
      });
      Object.defineProperty(this, $trADz.SCALAR, {
        value: $66IKL.string
      });
      Object.defineProperty(this, $trADz.SEQ, {
        value: $6QsbA.seq
      });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? $84978fc75525500b$var$sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create($84978fc75525500b$var$Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  $84978fc75525500b$export$19342e026b58ebb7 = $84978fc75525500b$var$Schema;
});
parcelRequire.register("jBWkn", function(module, exports) {
  $parcel$export(module.exports, "map", () => $e46eb7ab12c39e96$export$871de8747c9eaa88, (v) => $e46eb7ab12c39e96$export$871de8747c9eaa88 = v);
  var $e46eb7ab12c39e96$export$871de8747c9eaa88;
  var $trADz = parcelRequire("trADz");
  var $5ID9u = parcelRequire("5ID9u");
  const $e46eb7ab12c39e96$var$map = {
    collection: "map",
    default: true,
    nodeClass: $5ID9u.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map, onError) {
      if (!$trADz.isMap(map))
        onError("Expected a mapping for this tag");
      return map;
    },
    createNode: (schema, obj, ctx) => $5ID9u.YAMLMap.from(schema, obj, ctx)
  };
  $e46eb7ab12c39e96$export$871de8747c9eaa88 = $e46eb7ab12c39e96$var$map;
});
parcelRequire.register("5ID9u", function(module, exports) {
  $parcel$export(module.exports, "YAMLMap", () => $429f6e99730dbb87$export$eb1691c4b19bb5eb, (v) => $429f6e99730dbb87$export$eb1691c4b19bb5eb = v);
  $parcel$export(module.exports, "findPair", () => $429f6e99730dbb87$export$cb7eebdbb143b550, (v) => $429f6e99730dbb87$export$cb7eebdbb143b550 = v);
  var $429f6e99730dbb87$export$eb1691c4b19bb5eb;
  var $429f6e99730dbb87$export$cb7eebdbb143b550;
  var $1903G = parcelRequire("1903G");
  var $jOmBV = parcelRequire("jOmBV");
  var $dG1en = parcelRequire("dG1en");
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $6K3Lx = parcelRequire("6K3Lx");
  function $429f6e99730dbb87$var$findPair(items, key) {
    const k = $trADz.isScalar(key) ? key.value : key;
    for (const it of items)
      if ($trADz.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if ($trADz.isScalar(it.key) && it.key.value === k)
          return it;
      }
    return void 0;
  }
  class $429f6e99730dbb87$var$YAMLMap extends $dG1en.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super($trADz.MAP, schema);
      this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== void 0 || keepUndefined)
          map.items.push($cDsIW.createPair(key, value, ctx));
      };
      if (obj instanceof Map)
        for (const [key, value] of obj)
          add(key, value);
      else if (obj && typeof obj === "object")
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      if (typeof schema.sortMapEntries === "function")
        map.items.sort(schema.sortMapEntries);
      return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
      let _pair;
      if ($trADz.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair))
        _pair = new $cDsIW.Pair(pair, pair?.value);
      else
        _pair = new $cDsIW.Pair(pair.key, pair.value);
      const prev = $429f6e99730dbb87$var$findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if ($trADz.isScalar(prev.value) && $6K3Lx.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else
        this.items.push(_pair);
    }
    delete(key) {
      const it = $429f6e99730dbb87$var$findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = $429f6e99730dbb87$var$findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && $trADz.isScalar(node) ? node.value : node) ?? void 0;
    }
    has(key) {
      return !!$429f6e99730dbb87$var$findPair(this.items, key);
    }
    set(key, value) {
      this.add(new $cDsIW.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
      const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        $jOmBV.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!$trADz.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, {
          allNullValues: true
        });
      return $1903G.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: {
          start: "{",
          end: "}"
        },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  $429f6e99730dbb87$export$eb1691c4b19bb5eb = $429f6e99730dbb87$var$YAMLMap;
  $429f6e99730dbb87$export$cb7eebdbb143b550 = $429f6e99730dbb87$var$findPair;
});
parcelRequire.register("1903G", function(module, exports) {
  $parcel$export(module.exports, "stringifyCollection", () => $0d56ad4ee4120876$export$b570edac7df98594, (v) => $0d56ad4ee4120876$export$b570edac7df98594 = v);
  var $0d56ad4ee4120876$export$b570edac7df98594;
  var $dG1en = parcelRequire("dG1en");
  var $trADz = parcelRequire("trADz");
  var $cpzR2 = parcelRequire("cpzR2");
  var $7AgmX = parcelRequire("7AgmX");
  function $0d56ad4ee4120876$var$stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? $0d56ad4ee4120876$var$stringifyFlowCollection : $0d56ad4ee4120876$var$stringifyBlockCollection;
    return stringify(collection, ctx, options);
  }
  function $0d56ad4ee4120876$var$stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      type: null
    });
    let chompKeep = false;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if ($trADz.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        $0d56ad4ee4120876$var$addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if ($trADz.isPair(item)) {
        const ik = $trADz.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          $0d56ad4ee4120876$var$addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = $cpzR2.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += $7AgmX.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0)
      str = flowChars.start + flowChars.end;
    else {
      str = lines[0];
      for (let i = 1; i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : "\n";
      }
    }
    if (comment) {
      str += "\n" + $7AgmX.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function $0d56ad4ee4120876$var$stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if ($trADz.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        $0d56ad4ee4120876$var$addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment2 = item.comment;
      } else if ($trADz.isPair(item)) {
        const ik = $trADz.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          $0d56ad4ee4120876$var$addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = $trADz.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment2 = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment)
          comment2 = ik.comment;
      }
      if (comment2)
        reqNewline = true;
      let str2 = $cpzR2.stringify(item, itemCtx, () => comment2 = null);
      if (i < items.length - 1)
        str2 += ",";
      if (comment2)
        str2 += $7AgmX.lineComment(str2, itemIndent, commentString(comment2));
      if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
        reqNewline = true;
      lines.push(str2);
      linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0)
      str = start + end;
    else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = len > $dG1en.Collection.maxFlowStringSingleLineLength;
      }
      if (reqNewline) {
        str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : "\n";
        str += `
${indent}${end}`;
      } else
        str = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
    if (comment) {
      str += $7AgmX.lineComment(str, indent, commentString(comment));
      if (onComment)
        onComment();
    }
    return str;
  }
  function $0d56ad4ee4120876$var$addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = $7AgmX.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  $0d56ad4ee4120876$export$b570edac7df98594 = $0d56ad4ee4120876$var$stringifyCollection;
});
parcelRequire.register("6QsbA", function(module, exports) {
  $parcel$export(module.exports, "seq", () => $4fbd7684157c9232$export$1041d4276c328e4d, (v) => $4fbd7684157c9232$export$1041d4276c328e4d = v);
  var $4fbd7684157c9232$export$1041d4276c328e4d;
  var $trADz = parcelRequire("trADz");
  var $fo7V0 = parcelRequire("fo7V0");
  const $4fbd7684157c9232$var$seq = {
    collection: "seq",
    default: true,
    nodeClass: $fo7V0.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq, onError) {
      if (!$trADz.isSeq(seq))
        onError("Expected a sequence for this tag");
      return seq;
    },
    createNode: (schema, obj, ctx) => $fo7V0.YAMLSeq.from(schema, obj, ctx)
  };
  $4fbd7684157c9232$export$1041d4276c328e4d = $4fbd7684157c9232$var$seq;
});
parcelRequire.register("fo7V0", function(module, exports) {
  $parcel$export(module.exports, "YAMLSeq", () => $b33f3d53de49aab5$export$47adc25f769055b2, (v) => $b33f3d53de49aab5$export$47adc25f769055b2 = v);
  var $b33f3d53de49aab5$export$47adc25f769055b2;
  var $lLz1V = parcelRequire("lLz1V");
  var $1903G = parcelRequire("1903G");
  var $dG1en = parcelRequire("dG1en");
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $awijv = parcelRequire("awijv");
  class $b33f3d53de49aab5$var$YAMLSeq extends $dG1en.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super($trADz.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
      const idx = $b33f3d53de49aab5$var$asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = $b33f3d53de49aab5$var$asItemIndex(key);
      if (typeof idx !== "number")
        return void 0;
      const it = this.items[idx];
      return !keepScalar && $trADz.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
      const idx = $b33f3d53de49aab5$var$asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
      const idx = $b33f3d53de49aab5$var$asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if ($trADz.isScalar(prev) && $6K3Lx.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push($awijv.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return $1903G.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: {
          start: "[",
          end: "]"
        },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push($lLz1V.createNode(it, void 0, ctx));
        }
      }
      return seq;
    }
  }
  function $b33f3d53de49aab5$var$asItemIndex(key) {
    let idx = $trADz.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  $b33f3d53de49aab5$export$47adc25f769055b2 = $b33f3d53de49aab5$var$YAMLSeq;
});
parcelRequire.register("66IKL", function(module, exports) {
  $parcel$export(module.exports, "string", () => $472604ada83140cc$export$22b082955e083ec3, (v) => $472604ada83140cc$export$22b082955e083ec3 = v);
  var $472604ada83140cc$export$22b082955e083ec3;
  var $cz3Ls = parcelRequire("cz3Ls");
  const $472604ada83140cc$var$string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({
        actualString: true
      }, ctx);
      return $cz3Ls.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  $472604ada83140cc$export$22b082955e083ec3 = $472604ada83140cc$var$string;
});
parcelRequire.register("kJ4tW", function(module, exports) {
  $parcel$export(module.exports, "coreKnownTags", () => $f16b7ca7ab29f8db$export$aa155beb708c8cc4, (v) => $f16b7ca7ab29f8db$export$aa155beb708c8cc4 = v);
  $parcel$export(module.exports, "getTags", () => $f16b7ca7ab29f8db$export$af63d7414243dad3, (v) => $f16b7ca7ab29f8db$export$af63d7414243dad3 = v);
  var $f16b7ca7ab29f8db$export$aa155beb708c8cc4;
  var $f16b7ca7ab29f8db$export$af63d7414243dad3;
  var $jBWkn = parcelRequire("jBWkn");
  var $dz7Nd = parcelRequire("dz7Nd");
  var $6QsbA = parcelRequire("6QsbA");
  var $66IKL = parcelRequire("66IKL");
  var $43xGV = parcelRequire("43xGV");
  var $gDyw5 = parcelRequire("gDyw5");
  var $5twm3 = parcelRequire("5twm3");
  var $9Ba8D = parcelRequire("9Ba8D");
  var $b1P56 = parcelRequire("b1P56");
  var $8wh9D = parcelRequire("8wh9D");
  var $4INJ7 = parcelRequire("4INJ7");
  var $5GVFn = parcelRequire("5GVFn");
  var $6qGhZ = parcelRequire("6qGhZ");
  var $jUaa8 = parcelRequire("jUaa8");
  var $fZAyK = parcelRequire("fZAyK");
  const $f16b7ca7ab29f8db$var$schemas = /* @__PURE__ */ new Map([
    [
      "core",
      $9Ba8D.schema
    ],
    [
      "failsafe",
      [
        $jBWkn.map,
        $6QsbA.seq,
        $66IKL.string
      ]
    ],
    [
      "json",
      $b1P56.schema
    ],
    [
      "yaml11",
      $6qGhZ.schema
    ],
    [
      "yaml-1.1",
      $6qGhZ.schema
    ]
  ]);
  const $f16b7ca7ab29f8db$var$tagsByName = {
    binary: $8wh9D.binary,
    bool: $43xGV.boolTag,
    float: $gDyw5.float,
    floatExp: $gDyw5.floatExp,
    floatNaN: $gDyw5.floatNaN,
    floatTime: $fZAyK.floatTime,
    int: $5twm3.int,
    intHex: $5twm3.intHex,
    intOct: $5twm3.intOct,
    intTime: $fZAyK.intTime,
    map: $jBWkn.map,
    null: $dz7Nd.nullTag,
    omap: $4INJ7.omap,
    pairs: $5GVFn.pairs,
    seq: $6QsbA.seq,
    set: $jUaa8.set,
    timestamp: $fZAyK.timestamp
  };
  const $f16b7ca7ab29f8db$var$coreKnownTags = {
    "tag:yaml.org,2002:binary": $8wh9D.binary,
    "tag:yaml.org,2002:omap": $4INJ7.omap,
    "tag:yaml.org,2002:pairs": $5GVFn.pairs,
    "tag:yaml.org,2002:set": $jUaa8.set,
    "tag:yaml.org,2002:timestamp": $fZAyK.timestamp
  };
  function $f16b7ca7ab29f8db$var$getTags(customTags, schemaName) {
    let tags = $f16b7ca7ab29f8db$var$schemas.get(schemaName);
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from($f16b7ca7ab29f8db$var$schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags))
      for (const tag of customTags)
        tags = tags.concat(tag);
    else if (typeof customTags === "function")
      tags = customTags(tags.slice());
    return tags.map((tag) => {
      if (typeof tag !== "string")
        return tag;
      const tagObj = $f16b7ca7ab29f8db$var$tagsByName[tag];
      if (tagObj)
        return tagObj;
      const keys = Object.keys($f16b7ca7ab29f8db$var$tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
  }
  $f16b7ca7ab29f8db$export$aa155beb708c8cc4 = $f16b7ca7ab29f8db$var$coreKnownTags;
  $f16b7ca7ab29f8db$export$af63d7414243dad3 = $f16b7ca7ab29f8db$var$getTags;
});
parcelRequire.register("dz7Nd", function(module, exports) {
  $parcel$export(module.exports, "nullTag", () => $9e0496bd35ba14af$export$a4f9db1e8324ef6b, (v) => $9e0496bd35ba14af$export$a4f9db1e8324ef6b = v);
  var $9e0496bd35ba14af$export$a4f9db1e8324ef6b;
  var $6K3Lx = parcelRequire("6K3Lx");
  const $9e0496bd35ba14af$var$nullTag = {
    identify: (value) => value == null,
    createNode: () => new $6K3Lx.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new $6K3Lx.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && $9e0496bd35ba14af$var$nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  $9e0496bd35ba14af$export$a4f9db1e8324ef6b = $9e0496bd35ba14af$var$nullTag;
});
parcelRequire.register("43xGV", function(module, exports) {
  $parcel$export(module.exports, "boolTag", () => $2f4193a6b730db4f$export$4f52eaca20f174c1, (v) => $2f4193a6b730db4f$export$4f52eaca20f174c1 = v);
  var $2f4193a6b730db4f$export$4f52eaca20f174c1;
  var $6K3Lx = parcelRequire("6K3Lx");
  const $2f4193a6b730db4f$var$boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new $6K3Lx.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && $2f4193a6b730db4f$var$boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  $2f4193a6b730db4f$export$4f52eaca20f174c1 = $2f4193a6b730db4f$var$boolTag;
});
parcelRequire.register("gDyw5", function(module, exports) {
  $parcel$export(module.exports, "float", () => $c1cb10198e043573$export$6b5cd3983e3ee5ab, (v) => $c1cb10198e043573$export$6b5cd3983e3ee5ab = v);
  $parcel$export(module.exports, "floatExp", () => $c1cb10198e043573$export$d62805e4174324af, (v) => $c1cb10198e043573$export$d62805e4174324af = v);
  $parcel$export(module.exports, "floatNaN", () => $c1cb10198e043573$export$37d6b822c496e154, (v) => $c1cb10198e043573$export$37d6b822c496e154 = v);
  var $c1cb10198e043573$export$6b5cd3983e3ee5ab;
  var $c1cb10198e043573$export$d62805e4174324af;
  var $c1cb10198e043573$export$37d6b822c496e154;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $jXDBK = parcelRequire("jXDBK");
  const $c1cb10198e043573$var$floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $jXDBK.stringifyNumber
  };
  const $c1cb10198e043573$var$floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : $jXDBK.stringifyNumber(node);
    }
  };
  const $c1cb10198e043573$var$float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new $6K3Lx.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: $jXDBK.stringifyNumber
  };
  $c1cb10198e043573$export$6b5cd3983e3ee5ab = $c1cb10198e043573$var$float;
  $c1cb10198e043573$export$d62805e4174324af = $c1cb10198e043573$var$floatExp;
  $c1cb10198e043573$export$37d6b822c496e154 = $c1cb10198e043573$var$floatNaN;
});
parcelRequire.register("jXDBK", function(module, exports) {
  $parcel$export(module.exports, "stringifyNumber", () => $e882404e791cfc8c$export$4c03b48e25071796, (v) => $e882404e791cfc8c$export$4c03b48e25071796 = v);
  var $e882404e791cfc8c$export$4c03b48e25071796;
  function $e882404e791cfc8c$var$stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  $e882404e791cfc8c$export$4c03b48e25071796 = $e882404e791cfc8c$var$stringifyNumber;
});
parcelRequire.register("5twm3", function(module, exports) {
  $parcel$export(module.exports, "int", () => $3fc8c22818b1f36f$export$7d260a2a5f8bc19e, (v) => $3fc8c22818b1f36f$export$7d260a2a5f8bc19e = v);
  $parcel$export(module.exports, "intHex", () => $3fc8c22818b1f36f$export$3aff77776319ec6e, (v) => $3fc8c22818b1f36f$export$3aff77776319ec6e = v);
  $parcel$export(module.exports, "intOct", () => $3fc8c22818b1f36f$export$3d3e8b3bce028aae, (v) => $3fc8c22818b1f36f$export$3d3e8b3bce028aae = v);
  var $3fc8c22818b1f36f$export$7d260a2a5f8bc19e;
  var $3fc8c22818b1f36f$export$3aff77776319ec6e;
  var $3fc8c22818b1f36f$export$3d3e8b3bce028aae;
  var $jXDBK = parcelRequire("jXDBK");
  const $3fc8c22818b1f36f$var$intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  const $3fc8c22818b1f36f$var$intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function $3fc8c22818b1f36f$var$intStringify(node, radix, prefix) {
    const { value } = node;
    if ($3fc8c22818b1f36f$var$intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return $jXDBK.stringifyNumber(node);
  }
  const $3fc8c22818b1f36f$var$intOct = {
    identify: (value) => $3fc8c22818b1f36f$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => $3fc8c22818b1f36f$var$intResolve(str, 2, 8, opt),
    stringify: (node) => $3fc8c22818b1f36f$var$intStringify(node, 8, "0o")
  };
  const $3fc8c22818b1f36f$var$int = {
    identify: $3fc8c22818b1f36f$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => $3fc8c22818b1f36f$var$intResolve(str, 0, 10, opt),
    stringify: $jXDBK.stringifyNumber
  };
  const $3fc8c22818b1f36f$var$intHex = {
    identify: (value) => $3fc8c22818b1f36f$var$intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => $3fc8c22818b1f36f$var$intResolve(str, 2, 16, opt),
    stringify: (node) => $3fc8c22818b1f36f$var$intStringify(node, 16, "0x")
  };
  $3fc8c22818b1f36f$export$7d260a2a5f8bc19e = $3fc8c22818b1f36f$var$int;
  $3fc8c22818b1f36f$export$3aff77776319ec6e = $3fc8c22818b1f36f$var$intHex;
  $3fc8c22818b1f36f$export$3d3e8b3bce028aae = $3fc8c22818b1f36f$var$intOct;
});
parcelRequire.register("9Ba8D", function(module, exports) {
  $parcel$export(module.exports, "schema", () => $6fcf6f0088e09cf4$export$4902baddc787debb, (v) => $6fcf6f0088e09cf4$export$4902baddc787debb = v);
  var $6fcf6f0088e09cf4$export$4902baddc787debb;
  var $jBWkn = parcelRequire("jBWkn");
  var $dz7Nd = parcelRequire("dz7Nd");
  var $6QsbA = parcelRequire("6QsbA");
  var $66IKL = parcelRequire("66IKL");
  var $43xGV = parcelRequire("43xGV");
  var $gDyw5 = parcelRequire("gDyw5");
  var $5twm3 = parcelRequire("5twm3");
  const $6fcf6f0088e09cf4$var$schema = [
    $jBWkn.map,
    $6QsbA.seq,
    $66IKL.string,
    $dz7Nd.nullTag,
    $43xGV.boolTag,
    $5twm3.intOct,
    $5twm3.int,
    $5twm3.intHex,
    $gDyw5.floatNaN,
    $gDyw5.floatExp,
    $gDyw5.float
  ];
  $6fcf6f0088e09cf4$export$4902baddc787debb = $6fcf6f0088e09cf4$var$schema;
});
parcelRequire.register("b1P56", function(module, exports) {
  $parcel$export(module.exports, "schema", () => $80776966da5cb74f$export$4902baddc787debb, (v) => $80776966da5cb74f$export$4902baddc787debb = v);
  var $80776966da5cb74f$export$4902baddc787debb;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $jBWkn = parcelRequire("jBWkn");
  var $6QsbA = parcelRequire("6QsbA");
  function $80776966da5cb74f$var$intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  const $80776966da5cb74f$var$stringifyJSON = ({ value }) => JSON.stringify(value);
  const $80776966da5cb74f$var$jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: $80776966da5cb74f$var$stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new $6K3Lx.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: $80776966da5cb74f$var$stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true|false$/,
      resolve: (str) => str === "true",
      stringify: $80776966da5cb74f$var$stringifyJSON
    },
    {
      identify: $80776966da5cb74f$var$intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => $80776966da5cb74f$var$intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: $80776966da5cb74f$var$stringifyJSON
    }
  ];
  const $80776966da5cb74f$var$jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  const $80776966da5cb74f$var$schema = [
    $jBWkn.map,
    $6QsbA.seq
  ].concat($80776966da5cb74f$var$jsonScalars, $80776966da5cb74f$var$jsonError);
  $80776966da5cb74f$export$4902baddc787debb = $80776966da5cb74f$var$schema;
});
parcelRequire.register("8wh9D", function(module, exports) {
  $parcel$export(module.exports, "binary", () => $633e9e6b4581a5ab$export$33902b7329277358, (v) => $633e9e6b4581a5ab$export$33902b7329277358 = v);
  var $633e9e6b4581a5ab$export$33902b7329277358;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $cz3Ls = parcelRequire("cz3Ls");
  const $633e9e6b4581a5ab$var$binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
      if (typeof Buffer === "function")
        return Buffer.from(src, "base64");
      else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0; i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      const buf = value;
      let str;
      if (typeof Buffer === "function")
        str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
      else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0; i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      if (!type)
        type = $6K3Lx.Scalar.BLOCK_LITERAL;
      if (type !== $6K3Lx.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0; i < n; ++i, o += lineWidth)
          lines[i] = str.substr(o, lineWidth);
        str = lines.join(type === $6K3Lx.Scalar.BLOCK_LITERAL ? "\n" : " ");
      }
      return $cz3Ls.stringifyString({
        comment,
        type,
        value: str
      }, ctx, onComment, onChompKeep);
    }
  };
  $633e9e6b4581a5ab$export$33902b7329277358 = $633e9e6b4581a5ab$var$binary;
});
parcelRequire.register("4INJ7", function(module, exports) {
  $parcel$export(module.exports, "omap", () => $3701d82cdef38112$export$5a6b5e3152d599a2, (v) => $3701d82cdef38112$export$5a6b5e3152d599a2 = v);
  var $3701d82cdef38112$export$5a6b5e3152d599a2;
  var $trADz = parcelRequire("trADz");
  var $awijv = parcelRequire("awijv");
  var $5ID9u = parcelRequire("5ID9u");
  var $fo7V0 = parcelRequire("fo7V0");
  var $5GVFn = parcelRequire("5GVFn");
  class $3701d82cdef38112$var$YAMLOMap extends $fo7V0.YAMLSeq {
    constructor() {
      super();
      this.add = $5ID9u.YAMLMap.prototype.add.bind(this);
      this.delete = $5ID9u.YAMLMap.prototype.delete.bind(this);
      this.get = $5ID9u.YAMLMap.prototype.get.bind(this);
      this.has = $5ID9u.YAMLMap.prototype.has.bind(this);
      this.set = $5ID9u.YAMLMap.prototype.set.bind(this);
      this.tag = $3701d82cdef38112$var$YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = /* @__PURE__ */ new Map();
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if ($trADz.isPair(pair)) {
          key = $awijv.toJS(pair.key, "", ctx);
          value = $awijv.toJS(pair.value, key, ctx);
        } else
          key = $awijv.toJS(pair, "", ctx);
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = $5GVFn.createPairs(schema, iterable, ctx);
      const omap = new this();
      omap.items = pairs$1.items;
      return omap;
    }
  }
  $3701d82cdef38112$var$YAMLOMap.tag = "tag:yaml.org,2002:omap";
  const $3701d82cdef38112$var$omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: $3701d82cdef38112$var$YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = $5GVFn.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items)
        if ($trADz.isScalar(key)) {
          if (seenKeys.includes(key.value))
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          else
            seenKeys.push(key.value);
        }
      return Object.assign(new $3701d82cdef38112$var$YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx) => $3701d82cdef38112$var$YAMLOMap.from(schema, iterable, ctx)
  };
  $3701d82cdef38112$export$5a6b5e3152d599a2 = $3701d82cdef38112$var$omap;
});
parcelRequire.register("5GVFn", function(module, exports) {
  $parcel$export(module.exports, "createPairs", () => $424d9b5b7f3ff414$export$27bb6a7978f1f74a, (v) => $424d9b5b7f3ff414$export$27bb6a7978f1f74a = v);
  $parcel$export(module.exports, "pairs", () => $424d9b5b7f3ff414$export$589748d90c221be3, (v) => $424d9b5b7f3ff414$export$589748d90c221be3 = v);
  $parcel$export(module.exports, "resolvePairs", () => $424d9b5b7f3ff414$export$f3d665c6925c05a1, (v) => $424d9b5b7f3ff414$export$f3d665c6925c05a1 = v);
  var $424d9b5b7f3ff414$export$27bb6a7978f1f74a;
  var $424d9b5b7f3ff414$export$589748d90c221be3;
  var $424d9b5b7f3ff414$export$f3d665c6925c05a1;
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $fo7V0 = parcelRequire("fo7V0");
  function $424d9b5b7f3ff414$var$resolvePairs(seq, onError) {
    if ($trADz.isSeq(seq))
      for (let i = 0; i < seq.items.length; ++i) {
        let item = seq.items[i];
        if ($trADz.isPair(item))
          continue;
        else if ($trADz.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new $cDsIW.Pair(new $6K3Lx.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = $trADz.isPair(item) ? item : new $cDsIW.Pair(item);
      }
    else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function $424d9b5b7f3ff414$var$createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new $fo7V0.YAMLSeq(schema);
    pairs.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        } else
          key = it;
        pairs.items.push($cDsIW.createPair(key, value, ctx));
      }
    return pairs;
  }
  const $424d9b5b7f3ff414$var$pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: $424d9b5b7f3ff414$var$resolvePairs,
    createNode: $424d9b5b7f3ff414$var$createPairs
  };
  $424d9b5b7f3ff414$export$27bb6a7978f1f74a = $424d9b5b7f3ff414$var$createPairs;
  $424d9b5b7f3ff414$export$589748d90c221be3 = $424d9b5b7f3ff414$var$pairs;
  $424d9b5b7f3ff414$export$f3d665c6925c05a1 = $424d9b5b7f3ff414$var$resolvePairs;
});
parcelRequire.register("6qGhZ", function(module, exports) {
  $parcel$export(module.exports, "schema", () => $4ae5f9829fe1ea4e$export$4902baddc787debb, (v) => $4ae5f9829fe1ea4e$export$4902baddc787debb = v);
  var $4ae5f9829fe1ea4e$export$4902baddc787debb;
  var $jBWkn = parcelRequire("jBWkn");
  var $dz7Nd = parcelRequire("dz7Nd");
  var $6QsbA = parcelRequire("6QsbA");
  var $66IKL = parcelRequire("66IKL");
  var $8wh9D = parcelRequire("8wh9D");
  var $eJwwF = parcelRequire("eJwwF");
  var $fJcBL = parcelRequire("fJcBL");
  var $11uR6 = parcelRequire("11uR6");
  var $4INJ7 = parcelRequire("4INJ7");
  var $5GVFn = parcelRequire("5GVFn");
  var $jUaa8 = parcelRequire("jUaa8");
  var $fZAyK = parcelRequire("fZAyK");
  const $4ae5f9829fe1ea4e$var$schema = [
    $jBWkn.map,
    $6QsbA.seq,
    $66IKL.string,
    $dz7Nd.nullTag,
    $eJwwF.trueTag,
    $eJwwF.falseTag,
    $11uR6.intBin,
    $11uR6.intOct,
    $11uR6.int,
    $11uR6.intHex,
    $fJcBL.floatNaN,
    $fJcBL.floatExp,
    $fJcBL.float,
    $8wh9D.binary,
    $4INJ7.omap,
    $5GVFn.pairs,
    $jUaa8.set,
    $fZAyK.intTime,
    $fZAyK.floatTime,
    $fZAyK.timestamp
  ];
  $4ae5f9829fe1ea4e$export$4902baddc787debb = $4ae5f9829fe1ea4e$var$schema;
});
parcelRequire.register("eJwwF", function(module, exports) {
  $parcel$export(module.exports, "falseTag", () => $ab9e7fa0f03fc8ff$export$250e1f5a64500a2e, (v) => $ab9e7fa0f03fc8ff$export$250e1f5a64500a2e = v);
  $parcel$export(module.exports, "trueTag", () => $ab9e7fa0f03fc8ff$export$ae6fbb429290d2fa, (v) => $ab9e7fa0f03fc8ff$export$ae6fbb429290d2fa = v);
  var $ab9e7fa0f03fc8ff$export$250e1f5a64500a2e;
  var $ab9e7fa0f03fc8ff$export$ae6fbb429290d2fa;
  var $6K3Lx = parcelRequire("6K3Lx");
  function $ab9e7fa0f03fc8ff$var$boolStringify({ value, source }, ctx) {
    const boolObj = value ? $ab9e7fa0f03fc8ff$var$trueTag : $ab9e7fa0f03fc8ff$var$falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  const $ab9e7fa0f03fc8ff$var$trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new $6K3Lx.Scalar(true),
    stringify: $ab9e7fa0f03fc8ff$var$boolStringify
  };
  const $ab9e7fa0f03fc8ff$var$falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new $6K3Lx.Scalar(false),
    stringify: $ab9e7fa0f03fc8ff$var$boolStringify
  };
  $ab9e7fa0f03fc8ff$export$250e1f5a64500a2e = $ab9e7fa0f03fc8ff$var$falseTag;
  $ab9e7fa0f03fc8ff$export$ae6fbb429290d2fa = $ab9e7fa0f03fc8ff$var$trueTag;
});
parcelRequire.register("fJcBL", function(module, exports) {
  $parcel$export(module.exports, "float", () => $b734d6aa851fc020$export$6b5cd3983e3ee5ab, (v) => $b734d6aa851fc020$export$6b5cd3983e3ee5ab = v);
  $parcel$export(module.exports, "floatExp", () => $b734d6aa851fc020$export$d62805e4174324af, (v) => $b734d6aa851fc020$export$d62805e4174324af = v);
  $parcel$export(module.exports, "floatNaN", () => $b734d6aa851fc020$export$37d6b822c496e154, (v) => $b734d6aa851fc020$export$37d6b822c496e154 = v);
  var $b734d6aa851fc020$export$6b5cd3983e3ee5ab;
  var $b734d6aa851fc020$export$d62805e4174324af;
  var $b734d6aa851fc020$export$37d6b822c496e154;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $jXDBK = parcelRequire("jXDBK");
  const $b734d6aa851fc020$var$floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: $jXDBK.stringifyNumber
  };
  const $b734d6aa851fc020$var$floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : $jXDBK.stringifyNumber(node);
    }
  };
  const $b734d6aa851fc020$var$float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new $6K3Lx.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: $jXDBK.stringifyNumber
  };
  $b734d6aa851fc020$export$6b5cd3983e3ee5ab = $b734d6aa851fc020$var$float;
  $b734d6aa851fc020$export$d62805e4174324af = $b734d6aa851fc020$var$floatExp;
  $b734d6aa851fc020$export$37d6b822c496e154 = $b734d6aa851fc020$var$floatNaN;
});
parcelRequire.register("11uR6", function(module, exports) {
  $parcel$export(module.exports, "int", () => $0bedd1b3ee00d922$export$7d260a2a5f8bc19e, (v) => $0bedd1b3ee00d922$export$7d260a2a5f8bc19e = v);
  $parcel$export(module.exports, "intBin", () => $0bedd1b3ee00d922$export$a0833348c72870ac, (v) => $0bedd1b3ee00d922$export$a0833348c72870ac = v);
  $parcel$export(module.exports, "intHex", () => $0bedd1b3ee00d922$export$3aff77776319ec6e, (v) => $0bedd1b3ee00d922$export$3aff77776319ec6e = v);
  $parcel$export(module.exports, "intOct", () => $0bedd1b3ee00d922$export$3d3e8b3bce028aae, (v) => $0bedd1b3ee00d922$export$3d3e8b3bce028aae = v);
  var $0bedd1b3ee00d922$export$7d260a2a5f8bc19e;
  var $0bedd1b3ee00d922$export$a0833348c72870ac;
  var $0bedd1b3ee00d922$export$3aff77776319ec6e;
  var $0bedd1b3ee00d922$export$3d3e8b3bce028aae;
  var $jXDBK = parcelRequire("jXDBK");
  const $0bedd1b3ee00d922$var$intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function $0bedd1b3ee00d922$var$intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function $0bedd1b3ee00d922$var$intStringify(node, radix, prefix) {
    const { value } = node;
    if ($0bedd1b3ee00d922$var$intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return $jXDBK.stringifyNumber(node);
  }
  const $0bedd1b3ee00d922$var$intBin = {
    identify: $0bedd1b3ee00d922$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => $0bedd1b3ee00d922$var$intResolve(str, 2, 2, opt),
    stringify: (node) => $0bedd1b3ee00d922$var$intStringify(node, 2, "0b")
  };
  const $0bedd1b3ee00d922$var$intOct = {
    identify: $0bedd1b3ee00d922$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => $0bedd1b3ee00d922$var$intResolve(str, 1, 8, opt),
    stringify: (node) => $0bedd1b3ee00d922$var$intStringify(node, 8, "0")
  };
  const $0bedd1b3ee00d922$var$int = {
    identify: $0bedd1b3ee00d922$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => $0bedd1b3ee00d922$var$intResolve(str, 0, 10, opt),
    stringify: $jXDBK.stringifyNumber
  };
  const $0bedd1b3ee00d922$var$intHex = {
    identify: $0bedd1b3ee00d922$var$intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => $0bedd1b3ee00d922$var$intResolve(str, 2, 16, opt),
    stringify: (node) => $0bedd1b3ee00d922$var$intStringify(node, 16, "0x")
  };
  $0bedd1b3ee00d922$export$7d260a2a5f8bc19e = $0bedd1b3ee00d922$var$int;
  $0bedd1b3ee00d922$export$a0833348c72870ac = $0bedd1b3ee00d922$var$intBin;
  $0bedd1b3ee00d922$export$3aff77776319ec6e = $0bedd1b3ee00d922$var$intHex;
  $0bedd1b3ee00d922$export$3d3e8b3bce028aae = $0bedd1b3ee00d922$var$intOct;
});
parcelRequire.register("jUaa8", function(module, exports) {
  $parcel$export(module.exports, "set", () => $e7db21536536e605$export$adaa4cf7ef1b65be, (v) => $e7db21536536e605$export$adaa4cf7ef1b65be = v);
  var $e7db21536536e605$export$adaa4cf7ef1b65be;
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $5ID9u = parcelRequire("5ID9u");
  class $e7db21536536e605$var$YAMLSet extends $5ID9u.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = $e7db21536536e605$var$YAMLSet.tag;
    }
    add(key) {
      let pair;
      if ($trADz.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new $cDsIW.Pair(key.key, null);
      else
        pair = new $cDsIW.Pair(key, null);
      const prev = $5ID9u.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
      const pair = $5ID9u.findPair(this.items, key);
      return !keepPair && $trADz.isPair(pair) ? $trADz.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = $5ID9u.findPair(this.items, key);
      if (prev && !value)
        this.items.splice(this.items.indexOf(prev), 1);
      else if (!prev && value)
        this.items.push(new $cDsIW.Pair(key));
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, {
          allNullValues: true
        }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set.items.push($cDsIW.createPair(value, null, ctx));
        }
      return set;
    }
  }
  $e7db21536536e605$var$YAMLSet.tag = "tag:yaml.org,2002:set";
  const $e7db21536536e605$var$set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: $e7db21536536e605$var$YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => $e7db21536536e605$var$YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if ($trADz.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new $e7db21536536e605$var$YAMLSet(), map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  $e7db21536536e605$export$adaa4cf7ef1b65be = $e7db21536536e605$var$set;
});
parcelRequire.register("fZAyK", function(module, exports) {
  $parcel$export(module.exports, "floatTime", () => $ba48e970bc2c16cc$export$1ca419aed578763e, (v) => $ba48e970bc2c16cc$export$1ca419aed578763e = v);
  $parcel$export(module.exports, "intTime", () => $ba48e970bc2c16cc$export$14aedb0832cb7538, (v) => $ba48e970bc2c16cc$export$14aedb0832cb7538 = v);
  $parcel$export(module.exports, "timestamp", () => $ba48e970bc2c16cc$export$fc00ee57782020aa, (v) => $ba48e970bc2c16cc$export$fc00ee57782020aa = v);
  var $ba48e970bc2c16cc$export$1ca419aed578763e;
  var $ba48e970bc2c16cc$export$14aedb0832cb7538;
  var $ba48e970bc2c16cc$export$fc00ee57782020aa;
  var $jXDBK = parcelRequire("jXDBK");
  function $ba48e970bc2c16cc$var$parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function $ba48e970bc2c16cc$var$stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return $jXDBK.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [
      value % _60
    ];
    if (value < 60)
      parts.unshift(0);
    else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  const $ba48e970bc2c16cc$var$intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => $ba48e970bc2c16cc$var$parseSexagesimal(str, intAsBigInt),
    stringify: $ba48e970bc2c16cc$var$stringifySexagesimal
  };
  const $ba48e970bc2c16cc$var$floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => $ba48e970bc2c16cc$var$parseSexagesimal(str, false),
    stringify: $ba48e970bc2c16cc$var$stringifySexagesimal
  };
  const $ba48e970bc2c16cc$var$timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
    resolve(str) {
      const match = str.match($ba48e970bc2c16cc$var$timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = $ba48e970bc2c16cc$var$parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 6e4 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
  };
  $ba48e970bc2c16cc$export$1ca419aed578763e = $ba48e970bc2c16cc$var$floatTime;
  $ba48e970bc2c16cc$export$14aedb0832cb7538 = $ba48e970bc2c16cc$var$intTime;
  $ba48e970bc2c16cc$export$fc00ee57782020aa = $ba48e970bc2c16cc$var$timestamp;
});
parcelRequire.register("iaeHd", function(module, exports) {
  $parcel$export(module.exports, "stringifyDocument", () => $d3948f833b18faec$export$4ad5e7f5f7ff7493, (v) => $d3948f833b18faec$export$4ad5e7f5f7ff7493 = v);
  var $d3948f833b18faec$export$4ad5e7f5f7ff7493;
  var $trADz = parcelRequire("trADz");
  var $cpzR2 = parcelRequire("cpzR2");
  var $7AgmX = parcelRequire("7AgmX");
  function $d3948f833b18faec$var$stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = $cpzR2.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift($7AgmX.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if ($trADz.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push($7AgmX.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
      let body = $cpzR2.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += $7AgmX.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---")
        lines[lines.length - 1] = `--- ${body}`;
      else
        lines.push(body);
    } else
      lines.push($cpzR2.stringify(doc.contents, ctx));
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes("\n")) {
          lines.push("...");
          lines.push($7AgmX.indentComment(cs, ""));
        } else
          lines.push(`... ${cs}`);
      } else
        lines.push("...");
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push($7AgmX.indentComment(commentString(dc), ""));
      }
    }
    return lines.join("\n") + "\n";
  }
  $d3948f833b18faec$export$4ad5e7f5f7ff7493 = $d3948f833b18faec$var$stringifyDocument;
});
parcelRequire.register("ljAlQ", function(module, exports) {
  $parcel$export(module.exports, "YAMLError", () => $f84791f32b4e66c7$export$699cd54d617b337f, (v) => $f84791f32b4e66c7$export$699cd54d617b337f = v);
  $parcel$export(module.exports, "YAMLParseError", () => $f84791f32b4e66c7$export$c1188aaa49090a5c, (v) => $f84791f32b4e66c7$export$c1188aaa49090a5c = v);
  $parcel$export(module.exports, "YAMLWarning", () => $f84791f32b4e66c7$export$856b463bac79f971, (v) => $f84791f32b4e66c7$export$856b463bac79f971 = v);
  $parcel$export(module.exports, "prettifyError", () => $f84791f32b4e66c7$export$44eaaa72d914fe8c, (v) => $f84791f32b4e66c7$export$44eaaa72d914fe8c = v);
  var $f84791f32b4e66c7$export$699cd54d617b337f;
  var $f84791f32b4e66c7$export$c1188aaa49090a5c;
  var $f84791f32b4e66c7$export$856b463bac79f971;
  var $f84791f32b4e66c7$export$44eaaa72d914fe8c;
  class $f84791f32b4e66c7$var$YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }
  class $f84791f32b4e66c7$var$YAMLParseError extends $f84791f32b4e66c7$var$YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }
  class $f84791f32b4e66c7$var$YAMLWarning extends $f84791f32b4e66c7$var$YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  const $f84791f32b4e66c7$var$prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "…" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "…";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + "…\n";
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col)
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  $f84791f32b4e66c7$export$699cd54d617b337f = $f84791f32b4e66c7$var$YAMLError;
  $f84791f32b4e66c7$export$c1188aaa49090a5c = $f84791f32b4e66c7$var$YAMLParseError;
  $f84791f32b4e66c7$export$856b463bac79f971 = $f84791f32b4e66c7$var$YAMLWarning;
  $f84791f32b4e66c7$export$44eaaa72d914fe8c = $f84791f32b4e66c7$var$prettifyError;
});
parcelRequire.register("5BAM3", function(module, exports) {
  $parcel$export(module.exports, "composeDoc", () => $414ceefef531e971$export$5456c7d031a42a2a, (v) => $414ceefef531e971$export$5456c7d031a42a2a = v);
  var $414ceefef531e971$export$5456c7d031a42a2a;
  var $6Ua5a = parcelRequire("6Ua5a");
  var $5JID4 = parcelRequire("5JID4");
  var $61WSR = parcelRequire("61WSR");
  var $3X1JG = parcelRequire("3X1JG");
  function $414ceefef531e971$var$composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({
      _directives: directives
    }, options);
    const doc = new $6Ua5a.Document(void 0, opts);
    const ctx = {
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = $3X1JG.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? $5JID4.composeNode(ctx, value, props, onError) : $5JID4.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = $61WSR.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [
      offset,
      contentEnd,
      re.offset
    ];
    return doc;
  }
  $414ceefef531e971$export$5456c7d031a42a2a = $414ceefef531e971$var$composeDoc;
});
parcelRequire.register("5JID4", function(module, exports) {
  $parcel$export(module.exports, "composeEmptyNode", () => $42d3c61f09b5f4b9$export$ca2a6312a2caa181, (v) => $42d3c61f09b5f4b9$export$ca2a6312a2caa181 = v);
  $parcel$export(module.exports, "composeNode", () => $42d3c61f09b5f4b9$export$9247f8d3b1b759e0, (v) => $42d3c61f09b5f4b9$export$9247f8d3b1b759e0 = v);
  var $42d3c61f09b5f4b9$export$ca2a6312a2caa181;
  var $42d3c61f09b5f4b9$export$9247f8d3b1b759e0;
  var $gdpli = parcelRequire("gdpli");
  var $8nLHW = parcelRequire("8nLHW");
  var $j24uu = parcelRequire("j24uu");
  var $61WSR = parcelRequire("61WSR");
  var $aRsZT = parcelRequire("aRsZT");
  const $42d3c61f09b5f4b9$var$CN = {
    composeNode: $42d3c61f09b5f4b9$var$composeNode,
    composeEmptyNode: $42d3c61f09b5f4b9$var$composeEmptyNode
  };
  function $42d3c61f09b5f4b9$var$composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = $42d3c61f09b5f4b9$var$composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = $j24uu.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = $8nLHW.composeCollection($42d3c61f09b5f4b9$var$CN, ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = $42d3c61f09b5f4b9$var$composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function $42d3c61f09b5f4b9$var$composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: $aRsZT.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = $j24uu.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function $42d3c61f09b5f4b9$var$composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new $gdpli.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = $61WSR.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [
      offset,
      valueEnd,
      re.offset
    ];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  $42d3c61f09b5f4b9$export$ca2a6312a2caa181 = $42d3c61f09b5f4b9$var$composeEmptyNode;
  $42d3c61f09b5f4b9$export$9247f8d3b1b759e0 = $42d3c61f09b5f4b9$var$composeNode;
});
parcelRequire.register("8nLHW", function(module, exports) {
  $parcel$export(module.exports, "composeCollection", () => $61a57a7526122f9f$export$670d412b724aec43, (v) => $61a57a7526122f9f$export$670d412b724aec43 = v);
  var $61a57a7526122f9f$export$670d412b724aec43;
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $5ID9u = parcelRequire("5ID9u");
  var $fo7V0 = parcelRequire("fo7V0");
  var $ageRp = parcelRequire("ageRp");
  var $apRBI = parcelRequire("apRBI");
  var $23g8f = parcelRequire("23g8f");
  function $61a57a7526122f9f$var$resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? $ageRp.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? $apRBI.resolveBlockSeq(CN, ctx, token, onError, tag) : $23g8f.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function $61a57a7526122f9f$var$composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === $5ID9u.YAMLMap.tagName && expType === "map" || tagName === $fo7V0.YAMLSeq.tagName && expType === "seq" || !expType)
      return $61a57a7526122f9f$var$resolveCollection(CN, ctx, token, onError, tagName);
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, {
          default: false
        }));
        tag = kt;
      } else {
        if (kt?.collection)
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
        else
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        return $61a57a7526122f9f$var$resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = $61a57a7526122f9f$var$resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = $trADz.isNode(res) ? res : new $6K3Lx.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  $61a57a7526122f9f$export$670d412b724aec43 = $61a57a7526122f9f$var$composeCollection;
});
parcelRequire.register("ageRp", function(module, exports) {
  $parcel$export(module.exports, "resolveBlockMap", () => $7786ecfb9c41d24b$export$9c415700b1dbff3b, (v) => $7786ecfb9c41d24b$export$9c415700b1dbff3b = v);
  var $7786ecfb9c41d24b$export$9c415700b1dbff3b;
  var $cDsIW = parcelRequire("cDsIW");
  var $5ID9u = parcelRequire("5ID9u");
  var $3X1JG = parcelRequire("3X1JG");
  var $6AOgs = parcelRequire("6AOgs");
  var $44OBw = parcelRequire("44OBw");
  var $eyuGm = parcelRequire("eyuGm");
  const $7786ecfb9c41d24b$var$startColMsg = "All mapping items must start at the same column";
  function $7786ecfb9c41d24b$var$resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $5ID9u.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = $3X1JG.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", $7786ecfb9c41d24b$var$startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += "\n" + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.hasNewlineAfterProp || $6AOgs.containsNewline(key))
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      } else if (keyProps.found?.indent !== bm.indent)
        onError(offset, "BAD_INDENT", $7786ecfb9c41d24b$var$startColMsg);
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        $44OBw.flowIndentCheck(bm.indent, key, onError);
      if ($eyuGm.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = $3X1JG.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          $44OBw.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new $cDsIW.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new $cDsIW.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [
      bm.offset,
      offset,
      commentEnd ?? offset
    ];
    return map;
  }
  $7786ecfb9c41d24b$export$9c415700b1dbff3b = $7786ecfb9c41d24b$var$resolveBlockMap;
});
parcelRequire.register("3X1JG", function(module, exports) {
  $parcel$export(module.exports, "resolveProps", () => $2e083a7fa799c06b$export$3947d67c7569cd22, (v) => $2e083a7fa799c06b$export$3947d67c7569cd22 = v);
  var $2e083a7fa799c06b$export$3947d67c7569cd22;
  function $2e083a7fa799c06b$var$resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      switch (token.type) {
        case "space":
          if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
            onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            hasNewlineAfterProp = true;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag":
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          if (start === null)
            start = token.offset;
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = false;
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      hasNewlineAfterProp,
      anchor,
      tag,
      end,
      start: start ?? end
    };
  }
  $2e083a7fa799c06b$export$3947d67c7569cd22 = $2e083a7fa799c06b$var$resolveProps;
});
parcelRequire.register("6AOgs", function(module, exports) {
  $parcel$export(module.exports, "containsNewline", () => $4ccd18572ac4aac7$export$72c4c19842d44e03, (v) => $4ccd18572ac4aac7$export$72c4c19842d44e03 = v);
  var $4ccd18572ac4aac7$export$72c4c19842d44e03;
  function $4ccd18572ac4aac7$var$containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes("\n"))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if ($4ccd18572ac4aac7$var$containsNewline(it.key) || $4ccd18572ac4aac7$var$containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  $4ccd18572ac4aac7$export$72c4c19842d44e03 = $4ccd18572ac4aac7$var$containsNewline;
});
parcelRequire.register("44OBw", function(module, exports) {
  $parcel$export(module.exports, "flowIndentCheck", () => $2f7eca1a33e64603$export$6195a21984b7a892, (v) => $2f7eca1a33e64603$export$6195a21984b7a892 = v);
  var $2f7eca1a33e64603$export$6195a21984b7a892;
  var $6AOgs = parcelRequire("6AOgs");
  function $2f7eca1a33e64603$var$flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && $6AOgs.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  $2f7eca1a33e64603$export$6195a21984b7a892 = $2f7eca1a33e64603$var$flowIndentCheck;
});
parcelRequire.register("eyuGm", function(module, exports) {
  $parcel$export(module.exports, "mapIncludes", () => $a98c0a818cfc02be$export$ab8ef54c273a4fc3, (v) => $a98c0a818cfc02be$export$ab8ef54c273a4fc3 = v);
  var $a98c0a818cfc02be$export$ab8ef54c273a4fc3;
  var $trADz = parcelRequire("trADz");
  function $a98c0a818cfc02be$var$mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || $trADz.isScalar(a) && $trADz.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
    return items.some((pair) => isEqual(pair.key, search));
  }
  $a98c0a818cfc02be$export$ab8ef54c273a4fc3 = $a98c0a818cfc02be$var$mapIncludes;
});
parcelRequire.register("apRBI", function(module, exports) {
  $parcel$export(module.exports, "resolveBlockSeq", () => $7955d278ed415463$export$2db6dd42184ff7ac, (v) => $7955d278ed415463$export$2db6dd42184ff7ac = v);
  var $7955d278ed415463$export$2db6dd42184ff7ac;
  var $fo7V0 = parcelRequire("fo7V0");
  var $3X1JG = parcelRequire("3X1JG");
  var $44OBw = parcelRequire("44OBw");
  function $7955d278ed415463$var$resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? $fo7V0.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = $3X1JG.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        $44OBw.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [
      bs.offset,
      offset,
      commentEnd ?? offset
    ];
    return seq;
  }
  $7955d278ed415463$export$2db6dd42184ff7ac = $7955d278ed415463$var$resolveBlockSeq;
});
parcelRequire.register("23g8f", function(module, exports) {
  $parcel$export(module.exports, "resolveFlowCollection", () => $17e86016023cedfb$export$fdd70fe10aa6d63e, (v) => $17e86016023cedfb$export$fdd70fe10aa6d63e = v);
  var $17e86016023cedfb$export$fdd70fe10aa6d63e;
  var $trADz = parcelRequire("trADz");
  var $cDsIW = parcelRequire("cDsIW");
  var $5ID9u = parcelRequire("5ID9u");
  var $fo7V0 = parcelRequire("fo7V0");
  var $61WSR = parcelRequire("61WSR");
  var $3X1JG = parcelRequire("3X1JG");
  var $6AOgs = parcelRequire("6AOgs");
  var $eyuGm = parcelRequire("eyuGm");
  const $17e86016023cedfb$var$blockMsg = "Block collections are not allowed within flow collections";
  const $17e86016023cedfb$var$isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function $17e86016023cedfb$var$resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? $5ID9u.YAMLMap : $fo7V0.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = $3X1JG.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += "\n" + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && $6AOgs.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start)
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if ($trADz.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += "\n" + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if ($17e86016023cedfb$var$isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", $17e86016023cedfb$var$blockMsg);
      } else {
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if ($17e86016023cedfb$var$isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", $17e86016023cedfb$var$blockMsg);
        const valueProps = $3X1JG.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if ($17e86016023cedfb$var$isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", $17e86016023cedfb$var$blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += "\n" + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new $cDsIW.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if ($eyuGm.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new $5ID9u.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = $61WSR.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += "\n" + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [
        fc.offset,
        cePos,
        end.offset
      ];
    } else
      coll.range = [
        fc.offset,
        cePos,
        cePos
      ];
    return coll;
  }
  $17e86016023cedfb$export$fdd70fe10aa6d63e = $17e86016023cedfb$var$resolveFlowCollection;
});
parcelRequire.register("61WSR", function(module, exports) {
  $parcel$export(module.exports, "resolveEnd", () => $46408333692e61a6$export$9be3172c55e482a, (v) => $46408333692e61a6$export$9be3172c55e482a = v);
  var $46408333692e61a6$export$9be3172c55e482a;
  function $46408333692e61a6$var$resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return {
      comment,
      offset
    };
  }
  $46408333692e61a6$export$9be3172c55e482a = $46408333692e61a6$var$resolveEnd;
});
parcelRequire.register("j24uu", function(module, exports) {
  $parcel$export(module.exports, "composeScalar", () => $ddb1b0042619a2c4$export$1fb1e480165041ec, (v) => $ddb1b0042619a2c4$export$1fb1e480165041ec = v);
  var $ddb1b0042619a2c4$export$1fb1e480165041ec;
  var $trADz = parcelRequire("trADz");
  var $6K3Lx = parcelRequire("6K3Lx");
  var $jXuuI = parcelRequire("jXuuI");
  var $7d13l = parcelRequire("7d13l");
  function $ddb1b0042619a2c4$var$composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? $jXuuI.resolveBlockScalar(token, ctx.options.strict, onError) : $7d13l.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    const tag = tagToken && tagName ? $ddb1b0042619a2c4$var$findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? $ddb1b0042619a2c4$var$findScalarTagByTest(ctx, value, token, onError) : ctx.schema[$trADz.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = $trADz.isScalar(res) ? res : new $6K3Lx.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new $6K3Lx.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function $ddb1b0042619a2c4$var$findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[$trADz.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags)
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, {
        default: false,
        test: void 0
      }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[$trADz.SCALAR];
  }
  function $ddb1b0042619a2c4$var$findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => tag2.default && tag2.test?.test(value)) || schema[$trADz.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[$trADz.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  $ddb1b0042619a2c4$export$1fb1e480165041ec = $ddb1b0042619a2c4$var$composeScalar;
});
parcelRequire.register("jXuuI", function(module, exports) {
  $parcel$export(module.exports, "resolveBlockScalar", () => $e87b2e8c889982c5$export$14aaa50a76ee848f, (v) => $e87b2e8c889982c5$export$14aaa50a76ee848f = v);
  var $e87b2e8c889982c5$export$14aaa50a76ee848f;
  var $6K3Lx = parcelRequire("6K3Lx");
  function $e87b2e8c889982c5$var$resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = $e87b2e8c889982c5$var$parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
      return {
        value: "",
        type: null,
        comment: "",
        range: [
          start,
          start,
          start
        ]
      };
    const type = header.mode === ">" ? $6K3Lx.Scalar.BLOCK_FOLDED : $6K3Lx.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? $e87b2e8c889982c5$var$splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return {
        value: value2,
        type,
        comment: header.comment,
        range: [
          start,
          end2,
          end2
        ]
      };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1; i >= chompStart; --i)
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0; i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + "\n";
    for (let i = contentStart; i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === $6K3Lx.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = "\n";
      } else if (indent.length > trimIndent || content[0] === "	") {
        if (sep === " ")
          sep = "\n";
        else if (!prevMoreIndented && sep === "\n")
          sep = "\n\n";
        value += sep + indent.slice(trimIndent) + content;
        sep = "\n";
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === "\n")
          value += "\n";
        else
          sep = "\n";
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart; i < lines.length; ++i)
          value += "\n" + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== "\n")
          value += "\n";
        break;
      default:
        value += "\n";
    }
    const end = start + header.length + scalar.source.length;
    return {
      value,
      type,
      comment: header.comment,
      range: [
        start,
        end,
        end
      ]
    };
  }
  function $e87b2e8c889982c5$var$parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return {
      mode,
      indent,
      chomp,
      comment,
      length
    };
  }
  function $e87b2e8c889982c5$var$splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [
      m[1],
      first.slice(m[1].length)
    ] : [
      "",
      first
    ];
    const lines = [
      line0
    ];
    for (let i = 1; i < split.length; i += 2)
      lines.push([
        split[i],
        split[i + 1]
      ]);
    return lines;
  }
  $e87b2e8c889982c5$export$14aaa50a76ee848f = $e87b2e8c889982c5$var$resolveBlockScalar;
});
parcelRequire.register("7d13l", function(module, exports) {
  $parcel$export(module.exports, "resolveFlowScalar", () => $53fa9062b4699236$export$2f1c3b16290da8c8, (v) => $53fa9062b4699236$export$2f1c3b16290da8c8 = v);
  var $53fa9062b4699236$export$2f1c3b16290da8c8;
  var $6K3Lx = parcelRequire("6K3Lx");
  var $61WSR = parcelRequire("61WSR");
  function $53fa9062b4699236$var$resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = $6K3Lx.Scalar.PLAIN;
        value = $53fa9062b4699236$var$plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = $6K3Lx.Scalar.QUOTE_SINGLE;
        value = $53fa9062b4699236$var$singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = $6K3Lx.Scalar.QUOTE_DOUBLE;
        value = $53fa9062b4699236$var$doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [
            offset,
            offset + source.length,
            offset + source.length
          ]
        };
    }
    const valueEnd = offset + source.length;
    const re = $61WSR.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [
        offset,
        valueEnd,
        re.offset
      ]
    };
  }
  function $53fa9062b4699236$var$plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "	":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">":
        badChar = `block scalar indicator ${source[0]}`;
        break;
      case "@":
      case "`":
        badChar = `reserved character ${source[0]}`;
        break;
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return $53fa9062b4699236$var$foldLines(source);
  }
  function $53fa9062b4699236$var$singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return $53fa9062b4699236$var$foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function $53fa9062b4699236$var$foldLines(source) {
    let first, line;
    try {
      first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
      line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
    } catch (_) {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === "\n")
          res += sep;
        else
          sep = "\n";
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function $53fa9062b4699236$var$doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1; i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === "\n")
        continue;
      if (ch === "\n") {
        const { fold, offset } = $53fa9062b4699236$var$foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = $53fa9062b4699236$var$escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === "\n") {
          next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === "\n") {
          next = source[++i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = {
            x: 2,
            u: 4,
            U: 8
          }[next];
          res += $53fa9062b4699236$var$parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "	") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
        if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else
        res += ch;
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function $53fa9062b4699236$var$foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== "\n")
        break;
      if (ch === "\n")
        fold += "\n";
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return {
      fold,
      offset
    };
  }
  const $53fa9062b4699236$var$escapeCodes = {
    "0": "\0",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	",
    v: "\v",
    N: "",
    _: " ",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "	": "	"
  };
  function $53fa9062b4699236$var$parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  $53fa9062b4699236$export$2f1c3b16290da8c8 = $53fa9062b4699236$var$resolveFlowScalar;
});
parcelRequire.register("aRsZT", function(module, exports) {
  $parcel$export(module.exports, "emptyScalarPosition", () => $7e8558dfceb11528$export$b4be549696a70562, (v) => $7e8558dfceb11528$export$b4be549696a70562 = v);
  var $7e8558dfceb11528$export$b4be549696a70562;
  function $7e8558dfceb11528$var$emptyScalarPosition(offset, before, pos) {
    if (before) {
      if (pos === null)
        pos = before.length;
      for (let i = pos - 1; i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  $7e8558dfceb11528$export$b4be549696a70562 = $7e8558dfceb11528$var$emptyScalarPosition;
});
parcelRequire.register("9gE5L", function(module, exports) {
  $parcel$export(module.exports, "createScalarToken", () => $6bf4b51d004a2e32$export$bc6e7c97bb928c0c, (v) => $6bf4b51d004a2e32$export$bc6e7c97bb928c0c = v);
  $parcel$export(module.exports, "resolveAsScalar", () => $6bf4b51d004a2e32$export$2606595716b8fd6d, (v) => $6bf4b51d004a2e32$export$2606595716b8fd6d = v);
  $parcel$export(module.exports, "setScalarValue", () => $6bf4b51d004a2e32$export$ca02adc222d12536, (v) => $6bf4b51d004a2e32$export$ca02adc222d12536 = v);
  $parcel$export(module.exports, "stringify", () => $6bf4b51d004a2e32$export$fac44ee5b035f737, (v) => $6bf4b51d004a2e32$export$fac44ee5b035f737 = v);
  $parcel$export(module.exports, "visit", () => $6bf4b51d004a2e32$export$bf638b60ea8b89b7, (v) => $6bf4b51d004a2e32$export$bf638b60ea8b89b7 = v);
  $parcel$export(module.exports, "BOM", () => $6bf4b51d004a2e32$export$159b0f4ed2e9d663, (v) => $6bf4b51d004a2e32$export$159b0f4ed2e9d663 = v);
  $parcel$export(module.exports, "DOCUMENT", () => $6bf4b51d004a2e32$export$ef011b4e114b1fba, (v) => $6bf4b51d004a2e32$export$ef011b4e114b1fba = v);
  $parcel$export(module.exports, "FLOW_END", () => $6bf4b51d004a2e32$export$f3c6ac4b8e8fc405, (v) => $6bf4b51d004a2e32$export$f3c6ac4b8e8fc405 = v);
  $parcel$export(module.exports, "SCALAR", () => $6bf4b51d004a2e32$export$8dde1211cb7c9d16, (v) => $6bf4b51d004a2e32$export$8dde1211cb7c9d16 = v);
  $parcel$export(module.exports, "isCollection", () => $6bf4b51d004a2e32$export$cea7aa84e978eba5, (v) => $6bf4b51d004a2e32$export$cea7aa84e978eba5 = v);
  $parcel$export(module.exports, "isScalar", () => $6bf4b51d004a2e32$export$8f3495e22775e76c, (v) => $6bf4b51d004a2e32$export$8f3495e22775e76c = v);
  $parcel$export(module.exports, "prettyToken", () => $6bf4b51d004a2e32$export$a7c32ec3dbc53b0d, (v) => $6bf4b51d004a2e32$export$a7c32ec3dbc53b0d = v);
  $parcel$export(module.exports, "tokenType", () => $6bf4b51d004a2e32$export$290cf9fbadf470bd, (v) => $6bf4b51d004a2e32$export$290cf9fbadf470bd = v);
  var $6bf4b51d004a2e32$export$bc6e7c97bb928c0c;
  var $6bf4b51d004a2e32$export$2606595716b8fd6d;
  var $6bf4b51d004a2e32$export$ca02adc222d12536;
  var $6bf4b51d004a2e32$export$fac44ee5b035f737;
  var $6bf4b51d004a2e32$export$bf638b60ea8b89b7;
  var $6bf4b51d004a2e32$export$159b0f4ed2e9d663;
  var $6bf4b51d004a2e32$export$ef011b4e114b1fba;
  var $6bf4b51d004a2e32$export$f3c6ac4b8e8fc405;
  var $6bf4b51d004a2e32$export$8dde1211cb7c9d16;
  var $6bf4b51d004a2e32$export$cea7aa84e978eba5;
  var $6bf4b51d004a2e32$export$8f3495e22775e76c;
  var $6bf4b51d004a2e32$export$a7c32ec3dbc53b0d;
  var $6bf4b51d004a2e32$export$290cf9fbadf470bd;
  var $2yWS8 = parcelRequire("2yWS8");
  var $gX0uH = parcelRequire("gX0uH");
  var $224a8 = parcelRequire("224a8");
  const $6bf4b51d004a2e32$var$BOM = "\uFEFF";
  const $6bf4b51d004a2e32$var$DOCUMENT = "";
  const $6bf4b51d004a2e32$var$FLOW_END = "";
  const $6bf4b51d004a2e32$var$SCALAR = "";
  const $6bf4b51d004a2e32$var$isCollection = (token) => !!token && "items" in token;
  const $6bf4b51d004a2e32$var$isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function $6bf4b51d004a2e32$var$prettyToken(token) {
    switch (token) {
      case $6bf4b51d004a2e32$var$BOM:
        return "<BOM>";
      case $6bf4b51d004a2e32$var$DOCUMENT:
        return "<DOC>";
      case $6bf4b51d004a2e32$var$FLOW_END:
        return "<FLOW_END>";
      case $6bf4b51d004a2e32$var$SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function $6bf4b51d004a2e32$var$tokenType(source) {
    switch (source) {
      case $6bf4b51d004a2e32$var$BOM:
        return "byte-order-mark";
      case $6bf4b51d004a2e32$var$DOCUMENT:
        return "doc-mode";
      case $6bf4b51d004a2e32$var$FLOW_END:
        return "flow-error-end";
      case $6bf4b51d004a2e32$var$SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case "\n":
      case "\r\n":
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "	":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  $6bf4b51d004a2e32$export$bc6e7c97bb928c0c = $2yWS8.createScalarToken;
  $6bf4b51d004a2e32$export$2606595716b8fd6d = $2yWS8.resolveAsScalar;
  $6bf4b51d004a2e32$export$ca02adc222d12536 = $2yWS8.setScalarValue;
  $6bf4b51d004a2e32$export$fac44ee5b035f737 = $gX0uH.stringify;
  $6bf4b51d004a2e32$export$bf638b60ea8b89b7 = $224a8.visit;
  $6bf4b51d004a2e32$export$159b0f4ed2e9d663 = $6bf4b51d004a2e32$var$BOM;
  $6bf4b51d004a2e32$export$ef011b4e114b1fba = $6bf4b51d004a2e32$var$DOCUMENT;
  $6bf4b51d004a2e32$export$f3c6ac4b8e8fc405 = $6bf4b51d004a2e32$var$FLOW_END;
  $6bf4b51d004a2e32$export$8dde1211cb7c9d16 = $6bf4b51d004a2e32$var$SCALAR;
  $6bf4b51d004a2e32$export$cea7aa84e978eba5 = $6bf4b51d004a2e32$var$isCollection;
  $6bf4b51d004a2e32$export$8f3495e22775e76c = $6bf4b51d004a2e32$var$isScalar;
  $6bf4b51d004a2e32$export$a7c32ec3dbc53b0d = $6bf4b51d004a2e32$var$prettyToken;
  $6bf4b51d004a2e32$export$290cf9fbadf470bd = $6bf4b51d004a2e32$var$tokenType;
});
parcelRequire.register("2yWS8", function(module, exports) {
  $parcel$export(module.exports, "createScalarToken", () => $1ddc6c8d025a95ea$export$bc6e7c97bb928c0c, (v) => $1ddc6c8d025a95ea$export$bc6e7c97bb928c0c = v);
  $parcel$export(module.exports, "resolveAsScalar", () => $1ddc6c8d025a95ea$export$2606595716b8fd6d, (v) => $1ddc6c8d025a95ea$export$2606595716b8fd6d = v);
  $parcel$export(module.exports, "setScalarValue", () => $1ddc6c8d025a95ea$export$ca02adc222d12536, (v) => $1ddc6c8d025a95ea$export$ca02adc222d12536 = v);
  var $1ddc6c8d025a95ea$export$bc6e7c97bb928c0c;
  var $1ddc6c8d025a95ea$export$2606595716b8fd6d;
  var $1ddc6c8d025a95ea$export$ca02adc222d12536;
  var $jXuuI = parcelRequire("jXuuI");
  var $7d13l = parcelRequire("7d13l");
  var $ljAlQ = parcelRequire("ljAlQ");
  var $cz3Ls = parcelRequire("cz3Ls");
  function $1ddc6c8d025a95ea$var$resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new $ljAlQ.YAMLParseError([
            offset,
            offset + 1
          ], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return $7d13l.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return $jXuuI.resolveBlockScalar(token, strict, _onError);
      }
    }
    return null;
  }
  function $1ddc6c8d025a95ea$var$createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = $cz3Ls.stringifyString({
      type,
      value
    }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: {
        blockQuote: true,
        lineWidth: -1
      }
    });
    const end = context.end ?? [
      {
        type: "newline",
        offset: -1,
        indent,
        source: "\n"
      }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf("\n");
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + "\n";
        const props = [
          {
            type: "block-scalar-header",
            offset,
            indent,
            source: head
          }
        ];
        if (!$1ddc6c8d025a95ea$var$addEndtoBlockProps(props, end))
          props.push({
            type: "newline",
            offset: -1,
            indent,
            source: "\n"
          });
        return {
          type: "block-scalar",
          offset,
          indent,
          props,
          source: body
        };
      }
      case '"':
        return {
          type: "double-quoted-scalar",
          offset,
          indent,
          source,
          end
        };
      case "'":
        return {
          type: "single-quoted-scalar",
          offset,
          indent,
          source,
          end
        };
      default:
        return {
          type: "scalar",
          offset,
          indent,
          source,
          end
        };
    }
  }
  function $1ddc6c8d025a95ea$var$setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = $cz3Ls.stringifyString({
      type,
      value
    }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: {
        blockQuote: true,
        lineWidth: -1
      }
    });
    switch (source[0]) {
      case "|":
      case ">":
        $1ddc6c8d025a95ea$var$setBlockScalarValue(token, source);
        break;
      case '"':
        $1ddc6c8d025a95ea$var$setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        $1ddc6c8d025a95ea$var$setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        $1ddc6c8d025a95ea$var$setFlowScalarValue(token, source, "scalar");
    }
  }
  function $1ddc6c8d025a95ea$var$setBlockScalarValue(token, source) {
    const he = source.indexOf("\n");
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + "\n";
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        {
          type: "block-scalar-header",
          offset,
          indent,
          source: head
        }
      ];
      if (!$1ddc6c8d025a95ea$var$addEndtoBlockProps(props, "end" in token ? token.end : void 0))
        props.push({
          type: "newline",
          offset: -1,
          indent,
          source: "\n"
        });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, {
        type: "block-scalar",
        indent,
        props,
        source: body
      });
    }
  }
  function $1ddc6c8d025a95ea$var$addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function $1ddc6c8d025a95ea$var$setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, {
          type,
          source,
          end
        });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = {
          type: "newline",
          offset,
          indent: token.indent,
          source: "\n"
        };
        delete token.items;
        Object.assign(token, {
          type,
          source,
          end: [
            nl
          ]
        });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, {
          type,
          indent,
          source,
          end
        });
      }
    }
  }
  $1ddc6c8d025a95ea$export$bc6e7c97bb928c0c = $1ddc6c8d025a95ea$var$createScalarToken;
  $1ddc6c8d025a95ea$export$2606595716b8fd6d = $1ddc6c8d025a95ea$var$resolveAsScalar;
  $1ddc6c8d025a95ea$export$ca02adc222d12536 = $1ddc6c8d025a95ea$var$setScalarValue;
});
parcelRequire.register("gX0uH", function(module, exports) {
  $parcel$export(module.exports, "stringify", () => $c5728a2c0225b5ad$export$fac44ee5b035f737, (v) => $c5728a2c0225b5ad$export$fac44ee5b035f737 = v);
  var $c5728a2c0225b5ad$export$fac44ee5b035f737;
  const $c5728a2c0225b5ad$var$stringify = (cst) => "type" in cst ? $c5728a2c0225b5ad$var$stringifyToken(cst) : $c5728a2c0225b5ad$var$stringifyItem(cst);
  function $c5728a2c0225b5ad$var$stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += $c5728a2c0225b5ad$var$stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += $c5728a2c0225b5ad$var$stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += $c5728a2c0225b5ad$var$stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = $c5728a2c0225b5ad$var$stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function $c5728a2c0225b5ad$var$stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += $c5728a2c0225b5ad$var$stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += $c5728a2c0225b5ad$var$stringifyToken(value);
    return res;
  }
  $c5728a2c0225b5ad$export$fac44ee5b035f737 = $c5728a2c0225b5ad$var$stringify;
});
parcelRequire.register("224a8", function(module, exports) {
  $parcel$export(module.exports, "visit", () => $17aeff3c2cf95fc0$export$bf638b60ea8b89b7, (v) => $17aeff3c2cf95fc0$export$bf638b60ea8b89b7 = v);
  var $17aeff3c2cf95fc0$export$bf638b60ea8b89b7;
  const $17aeff3c2cf95fc0$var$BREAK = Symbol("break visit");
  const $17aeff3c2cf95fc0$var$SKIP = Symbol("skip children");
  const $17aeff3c2cf95fc0$var$REMOVE = Symbol("remove item");
  function $17aeff3c2cf95fc0$var$visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = {
        start: cst.start,
        value: cst.value
      };
    $17aeff3c2cf95fc0$var$_visit(Object.freeze([]), cst, visitor);
  }
  $17aeff3c2cf95fc0$var$visit.BREAK = $17aeff3c2cf95fc0$var$BREAK;
  $17aeff3c2cf95fc0$var$visit.SKIP = $17aeff3c2cf95fc0$var$SKIP;
  $17aeff3c2cf95fc0$var$visit.REMOVE = $17aeff3c2cf95fc0$var$REMOVE;
  $17aeff3c2cf95fc0$var$visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok)
        item = tok.items[index];
      else
        return void 0;
    }
    return item;
  };
  $17aeff3c2cf95fc0$var$visit.parentCollection = (cst, path) => {
    const parent = $17aeff3c2cf95fc0$var$visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function $17aeff3c2cf95fc0$var$_visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of [
      "key",
      "value"
    ]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0; i < token.items.length; ++i) {
          const ci = $17aeff3c2cf95fc0$var$_visit(Object.freeze(path.concat([
            [
              field,
              i
            ]
          ])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === $17aeff3c2cf95fc0$var$BREAK)
            return $17aeff3c2cf95fc0$var$BREAK;
          else if (ci === $17aeff3c2cf95fc0$var$REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  $17aeff3c2cf95fc0$export$bf638b60ea8b89b7 = $17aeff3c2cf95fc0$var$visit;
});
parcelRequire.register("1NqhN", function(module, exports) {
  $parcel$export(module.exports, "Lexer", () => $14eec1e90cb04ce2$export$6168dc8908a6c652, (v) => $14eec1e90cb04ce2$export$6168dc8908a6c652 = v);
  var $14eec1e90cb04ce2$export$6168dc8908a6c652;
  var $9gE5L = parcelRequire("9gE5L");
  function $14eec1e90cb04ce2$var$isEmpty(ch) {
    switch (ch) {
      case void 0:
      case " ":
      case "\n":
      case "\r":
      case "	":
        return true;
      default:
        return false;
    }
  }
  const $14eec1e90cb04ce2$var$hexDigits = "0123456789ABCDEFabcdef".split("");
  const $14eec1e90cb04ce2$var$tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
  const $14eec1e90cb04ce2$var$invalidFlowScalarChars = ",[]{}".split("");
  const $14eec1e90cb04ce2$var$invalidAnchorChars = " ,[]{}\n\r	".split("");
  const $14eec1e90cb04ce2$var$isNotAnchorChar = (ch) => !ch || $14eec1e90cb04ce2$var$invalidAnchorChars.includes(ch);
  class $14eec1e90cb04ce2$var$Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
      if (source) {
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "	")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === "\n")
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === "\n";
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === "\n" || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && $14eec1e90cb04ce2$var$isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf("\n", this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === $9gE5L.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        const cs = line.indexOf("#");
        if (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "	")
            dirEnd = cs - 1;
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "	")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield $9gE5L.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if (s === "---" && $14eec1e90cb04ce2$var$isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return "doc";
        } else if (s === "..." && $14eec1e90cb04ce2$var$isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          return "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !$14eec1e90cb04ce2$var$isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && $14eec1e90cb04ce2$var$isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case void 0:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil($14eec1e90cb04ce2$var$isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else
          sp = 0;
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && $14eec1e90cb04ce2$var$isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield $9gE5L.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case void 0:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil($14eec1e90cb04ce2$var$isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || $14eec1e90cb04ce2$var$isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'")
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      else
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf("\n", this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf("\n", cs);
        }
        if (nl !== -1)
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => $14eec1e90cb04ce2$var$isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i = this.pos; ch = this.buffer[i]; ++i)
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            default:
              break loop;
          }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else
          this.indentNext += this.blockScalarIndent;
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf("\n", cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      if (!this.blockScalarKeep)
        do {
          let i = nl - 1;
          let ch2 = this.buffer[i];
          if (ch2 === "\r")
            ch2 = this.buffer[--i];
          const lastChar = i;
          while (ch2 === " " || ch2 === "	")
            ch2 = this.buffer[--i];
          if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
            nl = i;
          else
            break;
        } while (true);
      yield $9gE5L.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if ($14eec1e90cb04ce2$var$isEmpty(next) || inFlow && next === ",")
            break;
          end = i;
        } else if ($14eec1e90cb04ce2$var$isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === "\n") {
              i += 1;
              ch = "\n";
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && $14eec1e90cb04ce2$var$invalidFlowScalarChars.includes(next))
            break;
          if (ch === "\n") {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && $14eec1e90cb04ce2$var$invalidFlowScalarChars.includes(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield $9gE5L.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil($14eec1e90cb04ce2$var$isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if ($14eec1e90cb04ce2$var$isEmpty(ch1) || inFlow && $14eec1e90cb04ce2$var$invalidFlowScalarChars.includes(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!$14eec1e90cb04ce2$var$isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if ($14eec1e90cb04ce2$var$tagChars.includes(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && $14eec1e90cb04ce2$var$hexDigits.includes(this.buffer[i + 1]) && $14eec1e90cb04ce2$var$hexDigits.includes(this.buffer[i + 2]))
            ch = this.buffer[i += 3];
          else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === "\n")
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === "\n")
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do
        ch = this.buffer[++i];
      while (ch === " " || allowTabs && ch === "	");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  $14eec1e90cb04ce2$export$6168dc8908a6c652 = $14eec1e90cb04ce2$var$Lexer;
});
parcelRequire.register("phAl4", function(module, exports) {
  $parcel$export(module.exports, "LineCounter", () => $04bff9f3567452e0$export$c8a6f24ae2865e59, (v) => $04bff9f3567452e0$export$c8a6f24ae2865e59 = v);
  var $04bff9f3567452e0$export$c8a6f24ae2865e59;
  class $04bff9f3567452e0$var$LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return {
            line: low + 1,
            col: 1
          };
        if (low === 0)
          return {
            line: 0,
            col: offset
          };
        const start = this.lineStarts[low - 1];
        return {
          line: low,
          col: offset - start + 1
        };
      };
    }
  }
  $04bff9f3567452e0$export$c8a6f24ae2865e59 = $04bff9f3567452e0$var$LineCounter;
});
parcelRequire.register("fnNcU", function(module, exports) {
  $parcel$export(module.exports, "Parser", () => $b32f2c881764e9da$export$7acfa6ed01010e37, (v) => $b32f2c881764e9da$export$7acfa6ed01010e37 = v);
  var $b32f2c881764e9da$export$7acfa6ed01010e37;
  var $9gE5L = parcelRequire("9gE5L");
  var $1NqhN = parcelRequire("1NqhN");
  function $b32f2c881764e9da$var$includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function $b32f2c881764e9da$var$findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i)
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    return -1;
  }
  function $b32f2c881764e9da$var$isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function $b32f2c881764e9da$var$getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function $b32f2c881764e9da$var$getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0)
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
    while (prev[++i]?.type === "space")
      ;
    return prev.splice(i, prev.length);
  }
  function $b32f2c881764e9da$var$fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items)
        if (it.sep && !it.value && !$b32f2c881764e9da$var$includesToken(it.start, "explicit-key-ind") && !$b32f2c881764e9da$var$includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if ($b32f2c881764e9da$var$isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
    }
  }
  class $b32f2c881764e9da$var$Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new $1NqhN.Lexer();
      this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
      this.source = source;
      if (process.env.LOG_TOKENS)
        console.log("|", $9gE5L.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = $9gE5L.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({
          type: "error",
          offset: this.offset,
          message,
          source
        });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield {
          type: "error",
          offset: this.offset,
          source: "",
          message
        };
      } else if (this.stack.length === 0)
        yield token;
      else {
        const top = this.peek(1);
        if (token.type === "block-scalar")
          token.indent = "indent" in top ? top.indent : 0;
        else if (token.type === "flow-collection" && top.type === "document")
          token.indent = 0;
        if (token.type === "flow-collection")
          $b32f2c881764e9da$var$fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({
                start: [],
                key: token,
                sep: []
              });
              this.onKeyLine = true;
              return;
            } else if (it.sep)
              it.value = token;
            else {
              Object.assign(it, {
                key: token,
                sep: []
              });
              this.onKeyLine = !$b32f2c881764e9da$var$includesToken(it.start, "explicit-key-ind");
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({
                start: [],
                value: token
              });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({
                start: [],
                key: token,
                sep: []
              });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, {
                key: token,
                sep: []
              });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && $b32f2c881764e9da$var$findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({
                start: last.start
              });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield {
            type: "directive",
            offset: this.offset,
            source: this.source
          };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start":
          if ($b32f2c881764e9da$var$findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = $b32f2c881764e9da$var$getPrevProps(this.peek(2));
        const start = $b32f2c881764e9da$var$getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [
            this.sourceToken
          ];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [
            {
              start,
              key: scalar,
              sep
            }
          ]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf("\n") + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf("\n", nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : void 0;
            const last = Array.isArray(end) ? end[end.length - 1] : void 0;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({
                start: [
                  this.sourceToken
                ]
              });
          } else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            map.items.push({
              start: [
                this.sourceToken
              ]
            });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0; i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({
                start
              });
              this.onKeyLine = true;
            } else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "explicit-key-ind":
            if (!it.sep && !$b32f2c881764e9da$var$includesToken(it.start, "explicit-key-ind"))
              it.start.push(this.sourceToken);
            else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({
                start
              });
            } else
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [
                  {
                    start: [
                      this.sourceToken
                    ]
                  }
                ]
              });
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if ($b32f2c881764e9da$var$includesToken(it.start, "explicit-key-ind")) {
              if (!it.sep) {
                if ($b32f2c881764e9da$var$includesToken(it.start, "newline"))
                  Object.assign(it, {
                    key: null,
                    sep: [
                      this.sourceToken
                    ]
                  });
                else {
                  const start2 = $b32f2c881764e9da$var$getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [
                      {
                        start: start2,
                        key: null,
                        sep: [
                          this.sourceToken
                        ]
                      }
                    ]
                  });
                }
              } else if (it.value)
                map.items.push({
                  start: [],
                  key: null,
                  sep: [
                    this.sourceToken
                  ]
                });
              else if ($b32f2c881764e9da$var$includesToken(it.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start,
                      key: null,
                      sep: [
                        this.sourceToken
                      ]
                    }
                  ]
                });
              else if ($b32f2c881764e9da$var$isFlowToken(it.key) && !$b32f2c881764e9da$var$includesToken(it.sep, "newline")) {
                const start2 = $b32f2c881764e9da$var$getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key, delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start: start2,
                      key,
                      sep
                    }
                  ]
                });
              } else if (start.length > 0)
                it.sep = it.sep.concat(start, this.sourceToken);
              else
                it.sep.push(this.sourceToken);
            } else {
              if (!it.sep)
                Object.assign(it, {
                  key: null,
                  sep: [
                    this.sourceToken
                  ]
                });
              else if (it.value || atNextItem)
                map.items.push({
                  start,
                  key: null,
                  sep: [
                    this.sourceToken
                  ]
                });
              else if ($b32f2c881764e9da$var$includesToken(it.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [
                    {
                      start: [],
                      key: null,
                      sep: [
                        this.sourceToken
                      ]
                    }
                  ]
                });
              else
                it.sep.push(this.sourceToken);
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs2 = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({
                start,
                key: fs2,
                sep: []
              });
              this.onKeyLine = true;
            } else if (it.sep)
              this.stack.push(fs2);
            else {
              Object.assign(it, {
                key: fs2,
                sep: []
              });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (atNextItem && bv.type !== "block-seq" && $b32f2c881764e9da$var$includesToken(it.start, "explicit-key-ind"))
                map.items.push({
                  start
                });
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : void 0;
            const last = Array.isArray(end) ? end[end.length - 1] : void 0;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({
                start: [
                  this.sourceToken
                ]
              });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({
              start: [
                this.sourceToken
              ]
            });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || $b32f2c881764e9da$var$includesToken(it.start, "seq-item-ind"))
            seq.items.push({
              start: [
                this.sourceToken
              ]
            });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({
                start: [
                  this.sourceToken
                ]
              });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({
                start: [],
                key: null,
                sep: [
                  this.sourceToken
                ]
              });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, {
                key: null,
                sep: [
                  this.sourceToken
                ]
              });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({
                start: [
                  this.sourceToken
                ]
              });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs2 = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({
                start: [],
                key: fs2,
                sep: []
              });
            else if (it.sep)
              this.stack.push(fs2);
            else
              Object.assign(it, {
                key: fs2,
                sep: []
              });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = $b32f2c881764e9da$var$getPrevProps(parent);
          const start = $b32f2c881764e9da$var$getFirstKeyStartProps(prev);
          $b32f2c881764e9da$var$fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [
              {
                start,
                key: fc,
                sep
              }
            ]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(fc);
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf("\n") + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf("\n", nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [
              this.sourceToken
            ],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [
              {
                start: [
                  this.sourceToken
                ]
              }
            ]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = $b32f2c881764e9da$var$getPrevProps(parent);
          const start = $b32f2c881764e9da$var$getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [
              {
                start
              }
            ]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = $b32f2c881764e9da$var$getPrevProps(parent);
          const start = $b32f2c881764e9da$var$getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [
              {
                start,
                key: null,
                sep: [
                  this.sourceToken
                ]
              }
            ]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [
            this.sourceToken
          ];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [
              this.sourceToken
            ];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  $b32f2c881764e9da$export$7acfa6ed01010e37 = $b32f2c881764e9da$var$Parser;
});
parcelRequire.register("jHSX9", function(module, exports) {
  $parcel$export(module.exports, "parse", () => $e58ca90602308d42$export$98e6a39c04603d36, (v) => $e58ca90602308d42$export$98e6a39c04603d36 = v);
  $parcel$export(module.exports, "parseAllDocuments", () => $e58ca90602308d42$export$643da2570c3b3d01, (v) => $e58ca90602308d42$export$643da2570c3b3d01 = v);
  $parcel$export(module.exports, "parseDocument", () => $e58ca90602308d42$export$b6a9369736b19f4d, (v) => $e58ca90602308d42$export$b6a9369736b19f4d = v);
  $parcel$export(module.exports, "stringify", () => $e58ca90602308d42$export$fac44ee5b035f737, (v) => $e58ca90602308d42$export$fac44ee5b035f737 = v);
  var $e58ca90602308d42$export$98e6a39c04603d36;
  var $e58ca90602308d42$export$643da2570c3b3d01;
  var $e58ca90602308d42$export$b6a9369736b19f4d;
  var $e58ca90602308d42$export$fac44ee5b035f737;
  var $fzaOJ = parcelRequire("fzaOJ");
  var $6Ua5a = parcelRequire("6Ua5a");
  var $ljAlQ = parcelRequire("ljAlQ");
  var $5pHPF = parcelRequire("5pHPF");
  var $phAl4 = parcelRequire("phAl4");
  var $fnNcU = parcelRequire("fnNcU");
  function $e58ca90602308d42$var$parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new $phAl4.LineCounter() || null;
    return {
      lineCounter: lineCounter$1,
      prettyErrors
    };
  }
  function $e58ca90602308d42$var$parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = $e58ca90602308d42$var$parseOptions(options);
    const parser$1 = new $fnNcU.Parser(lineCounter?.addNewLine);
    const composer$1 = new $fzaOJ.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
      for (const doc of docs) {
        doc.errors.forEach($ljAlQ.prettifyError(source, lineCounter));
        doc.warnings.forEach($ljAlQ.prettifyError(source, lineCounter));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], {
      empty: true
    }, composer$1.streamInfo());
  }
  function $e58ca90602308d42$var$parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = $e58ca90602308d42$var$parseOptions(options);
    const parser$1 = new $fnNcU.Parser(lineCounter?.addNewLine);
    const composer$1 = new $fzaOJ.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new $ljAlQ.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter) {
      doc.errors.forEach($ljAlQ.prettifyError(source, lineCounter));
      doc.warnings.forEach($ljAlQ.prettifyError(source, lineCounter));
    }
    return doc;
  }
  function $e58ca90602308d42$var$parse(src, reviver, options) {
    let _reviver = void 0;
    if (typeof reviver === "function")
      _reviver = reviver;
    else if (options === void 0 && reviver && typeof reviver === "object")
      options = reviver;
    const doc = $e58ca90602308d42$var$parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => $5pHPF.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({
      reviver: _reviver
    }, options));
  }
  function $e58ca90602308d42$var$stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer))
      _replacer = replacer;
    else if (options === void 0 && replacer)
      options = replacer;
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? void 0 : indent > 8 ? {
        indent: 8
      } : {
        indent
      };
    }
    if (value === void 0) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return void 0;
    }
    return new $6Ua5a.Document(value, _replacer, options).toString(options);
  }
  $e58ca90602308d42$export$98e6a39c04603d36 = $e58ca90602308d42$var$parse;
  $e58ca90602308d42$export$643da2570c3b3d01 = $e58ca90602308d42$var$parseAllDocuments;
  $e58ca90602308d42$export$b6a9369736b19f4d = $e58ca90602308d42$var$parseDocument;
  $e58ca90602308d42$export$fac44ee5b035f737 = $e58ca90602308d42$var$stringify;
});
parcelRequire.register("5xH1P", function(module, exports) {
  const $9a1c16c9f228833d$var$frontmatterRegex = /^\s*---((?:.|\s)+?)---/;
  const $9a1c16c9f228833d$var$containsFrontmatter = (toCheck) => $9a1c16c9f228833d$var$frontmatterRegex.exec(toCheck)?.[1] ?? false;
  module.exports = {
    frontmatterRegex: $9a1c16c9f228833d$var$frontmatterRegex,
    containsFrontmatter: $9a1c16c9f228833d$var$containsFrontmatter
  };
});
parcelRequire.register("2WRWK", function(module, exports) {
  const wrapAnsi16 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${code + offset}m`;
  };
  const wrapAnsi256 = (fn, offset) => (...args) => {
    const code = fn(...args);
    return `\x1B[${38 + offset};5;${code}m`;
  };
  const wrapAnsi16m = (fn, offset) => (...args) => {
    const rgb = fn(...args);
    return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
  };
  const ansi2ansi = (n) => n;
  const rgb2rgb = (r, g, b) => [
    r,
    g,
    b
  ];
  const setLazyProperty = (object, property, get) => {
    Object.defineProperty(object, property, {
      get: () => {
        const value = get();
        Object.defineProperty(object, property, {
          value,
          enumerable: true,
          configurable: true
        });
        return value;
      },
      enumerable: true,
      configurable: true
    });
  };
  let colorConvert;
  const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
    if (colorConvert === void 0)
      colorConvert = parcelRequire("4WX4s");
    const offset = isBackground ? 10 : 0;
    const styles = {};
    for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
      const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
      if (sourceSpace === targetSpace)
        styles[name] = wrap(identity, offset);
      else if (typeof suite === "object")
        styles[name] = wrap(suite[targetSpace], offset);
    }
    return styles;
  };
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    const styles = {
      modifier: {
        reset: [
          0,
          0
        ],
        // 21 isn't widely supported and 22 does the same thing
        bold: [
          1,
          22
        ],
        dim: [
          2,
          22
        ],
        italic: [
          3,
          23
        ],
        underline: [
          4,
          24
        ],
        inverse: [
          7,
          27
        ],
        hidden: [
          8,
          28
        ],
        strikethrough: [
          9,
          29
        ]
      },
      color: {
        black: [
          30,
          39
        ],
        red: [
          31,
          39
        ],
        green: [
          32,
          39
        ],
        yellow: [
          33,
          39
        ],
        blue: [
          34,
          39
        ],
        magenta: [
          35,
          39
        ],
        cyan: [
          36,
          39
        ],
        white: [
          37,
          39
        ],
        // Bright color
        blackBright: [
          90,
          39
        ],
        redBright: [
          91,
          39
        ],
        greenBright: [
          92,
          39
        ],
        yellowBright: [
          93,
          39
        ],
        blueBright: [
          94,
          39
        ],
        magentaBright: [
          95,
          39
        ],
        cyanBright: [
          96,
          39
        ],
        whiteBright: [
          97,
          39
        ]
      },
      bgColor: {
        bgBlack: [
          40,
          49
        ],
        bgRed: [
          41,
          49
        ],
        bgGreen: [
          42,
          49
        ],
        bgYellow: [
          43,
          49
        ],
        bgBlue: [
          44,
          49
        ],
        bgMagenta: [
          45,
          49
        ],
        bgCyan: [
          46,
          49
        ],
        bgWhite: [
          47,
          49
        ],
        // Bright color
        bgBlackBright: [
          100,
          49
        ],
        bgRedBright: [
          101,
          49
        ],
        bgGreenBright: [
          102,
          49
        ],
        bgYellowBright: [
          103,
          49
        ],
        bgBlueBright: [
          104,
          49
        ],
        bgMagentaBright: [
          105,
          49
        ],
        bgCyanBright: [
          106,
          49
        ],
        bgWhiteBright: [
          107,
          49
        ]
      }
    };
    styles.color.gray = styles.color.blackBright;
    styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
    styles.color.grey = styles.color.blackBright;
    styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
    setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
    setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
    setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
    return styles;
  }
  Object.defineProperty(module, "exports", {
    enumerable: true,
    get: assembleStyles
  });
});
parcelRequire.register("4WX4s", function(module, exports) {
  var $4QmTn = parcelRequire("4QmTn");
  var $lDe5S = parcelRequire("lDe5S");
  const $39aa6670fa069576$var$convert = {};
  const $39aa6670fa069576$var$models = Object.keys($4QmTn);
  function $39aa6670fa069576$var$wrapRaw(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null)
        return arg0;
      if (arg0.length > 1)
        args = arg0;
      return fn(args);
    };
    if ("conversion" in fn)
      wrappedFn.conversion = fn.conversion;
    return wrappedFn;
  }
  function $39aa6670fa069576$var$wrapRounded(fn) {
    const wrappedFn = function(...args) {
      const arg0 = args[0];
      if (arg0 === void 0 || arg0 === null)
        return arg0;
      if (arg0.length > 1)
        args = arg0;
      const result = fn(args);
      if (typeof result === "object")
        for (let len = result.length, i = 0; i < len; i++)
          result[i] = Math.round(result[i]);
      return result;
    };
    if ("conversion" in fn)
      wrappedFn.conversion = fn.conversion;
    return wrappedFn;
  }
  $39aa6670fa069576$var$models.forEach((fromModel) => {
    $39aa6670fa069576$var$convert[fromModel] = {};
    Object.defineProperty($39aa6670fa069576$var$convert[fromModel], "channels", {
      value: $4QmTn[fromModel].channels
    });
    Object.defineProperty($39aa6670fa069576$var$convert[fromModel], "labels", {
      value: $4QmTn[fromModel].labels
    });
    const routes = $lDe5S(fromModel);
    const routeModels = Object.keys(routes);
    routeModels.forEach((toModel) => {
      const fn = routes[toModel];
      $39aa6670fa069576$var$convert[fromModel][toModel] = $39aa6670fa069576$var$wrapRounded(fn);
      $39aa6670fa069576$var$convert[fromModel][toModel].raw = $39aa6670fa069576$var$wrapRaw(fn);
    });
  });
  module.exports = $39aa6670fa069576$var$convert;
});
parcelRequire.register("4QmTn", function(module, exports) {
  var $bcXwX = parcelRequire("bcXwX");
  const $386dc6a8f80ab96d$var$reverseKeywords = {};
  for (const key of Object.keys($bcXwX))
    $386dc6a8f80ab96d$var$reverseKeywords[$bcXwX[key]] = key;
  const $386dc6a8f80ab96d$var$convert = {
    rgb: {
      channels: 3,
      labels: "rgb"
    },
    hsl: {
      channels: 3,
      labels: "hsl"
    },
    hsv: {
      channels: 3,
      labels: "hsv"
    },
    hwb: {
      channels: 3,
      labels: "hwb"
    },
    cmyk: {
      channels: 4,
      labels: "cmyk"
    },
    xyz: {
      channels: 3,
      labels: "xyz"
    },
    lab: {
      channels: 3,
      labels: "lab"
    },
    lch: {
      channels: 3,
      labels: "lch"
    },
    hex: {
      channels: 1,
      labels: [
        "hex"
      ]
    },
    keyword: {
      channels: 1,
      labels: [
        "keyword"
      ]
    },
    ansi16: {
      channels: 1,
      labels: [
        "ansi16"
      ]
    },
    ansi256: {
      channels: 1,
      labels: [
        "ansi256"
      ]
    },
    hcg: {
      channels: 3,
      labels: [
        "h",
        "c",
        "g"
      ]
    },
    apple: {
      channels: 3,
      labels: [
        "r16",
        "g16",
        "b16"
      ]
    },
    gray: {
      channels: 1,
      labels: [
        "gray"
      ]
    }
  };
  module.exports = $386dc6a8f80ab96d$var$convert;
  for (const model of Object.keys($386dc6a8f80ab96d$var$convert)) {
    if (!("channels" in $386dc6a8f80ab96d$var$convert[model]))
      throw new Error("missing channels property: " + model);
    if (!("labels" in $386dc6a8f80ab96d$var$convert[model]))
      throw new Error("missing channel labels property: " + model);
    if ($386dc6a8f80ab96d$var$convert[model].labels.length !== $386dc6a8f80ab96d$var$convert[model].channels)
      throw new Error("channel and label counts mismatch: " + model);
    const { channels, labels } = $386dc6a8f80ab96d$var$convert[model];
    delete $386dc6a8f80ab96d$var$convert[model].channels;
    delete $386dc6a8f80ab96d$var$convert[model].labels;
    Object.defineProperty($386dc6a8f80ab96d$var$convert[model], "channels", {
      value: channels
    });
    Object.defineProperty($386dc6a8f80ab96d$var$convert[model], "labels", {
      value: labels
    });
  }
  $386dc6a8f80ab96d$var$convert.rgb.hsl = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const min = Math.min(r, g, b);
    const max = Math.max(r, g, b);
    const delta = max - min;
    let h;
    let s;
    if (max === min)
      h = 0;
    else if (r === max)
      h = (g - b) / delta;
    else if (g === max)
      h = 2 + (b - r) / delta;
    else if (b === max)
      h = 4 + (r - g) / delta;
    h = Math.min(h * 60, 360);
    if (h < 0)
      h += 360;
    const l = (min + max) / 2;
    if (max === min)
      s = 0;
    else if (l <= 0.5)
      s = delta / (max + min);
    else
      s = delta / (2 - max - min);
    return [
      h,
      s * 100,
      l * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.hsv = function(rgb) {
    let rdif;
    let gdif;
    let bdif;
    let h;
    let s;
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const v = Math.max(r, g, b);
    const diff = v - Math.min(r, g, b);
    const diffc = function(c) {
      return (v - c) / 6 / diff + 0.5;
    };
    if (diff === 0) {
      h = 0;
      s = 0;
    } else {
      s = diff / v;
      rdif = diffc(r);
      gdif = diffc(g);
      bdif = diffc(b);
      if (r === v)
        h = bdif - gdif;
      else if (g === v)
        h = 1 / 3 + rdif - bdif;
      else if (b === v)
        h = 2 / 3 + gdif - rdif;
      if (h < 0)
        h += 1;
      else if (h > 1)
        h -= 1;
    }
    return [
      h * 360,
      s * 100,
      v * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.hwb = function(rgb) {
    const r = rgb[0];
    const g = rgb[1];
    let b = rgb[2];
    const h = $386dc6a8f80ab96d$var$convert.rgb.hsl(rgb)[0];
    const w = 1 / 255 * Math.min(r, Math.min(g, b));
    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
    return [
      h,
      w * 100,
      b * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.cmyk = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const k = Math.min(1 - r, 1 - g, 1 - b);
    const c = (1 - r - k) / (1 - k) || 0;
    const m = (1 - g - k) / (1 - k) || 0;
    const y = (1 - b - k) / (1 - k) || 0;
    return [
      c * 100,
      m * 100,
      y * 100,
      k * 100
    ];
  };
  function $386dc6a8f80ab96d$var$comparativeDistance(x, y) {
    return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
  }
  $386dc6a8f80ab96d$var$convert.rgb.keyword = function(rgb) {
    const reversed = $386dc6a8f80ab96d$var$reverseKeywords[rgb];
    if (reversed)
      return reversed;
    let currentClosestDistance = Infinity;
    let currentClosestKeyword;
    for (const keyword of Object.keys($bcXwX)) {
      const value = $bcXwX[keyword];
      const distance = $386dc6a8f80ab96d$var$comparativeDistance(rgb, value);
      if (distance < currentClosestDistance) {
        currentClosestDistance = distance;
        currentClosestKeyword = keyword;
      }
    }
    return currentClosestKeyword;
  };
  $386dc6a8f80ab96d$var$convert.keyword.rgb = function(keyword) {
    return $bcXwX[keyword];
  };
  $386dc6a8f80ab96d$var$convert.rgb.xyz = function(rgb) {
    let r = rgb[0] / 255;
    let g = rgb[1] / 255;
    let b = rgb[2] / 255;
    r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
    g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
    b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
    return [
      x * 100,
      y * 100,
      z * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.lab = function(rgb) {
    const xyz = $386dc6a8f80ab96d$var$convert.rgb.xyz(rgb);
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
      l,
      a,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.hsl.rgb = function(hsl) {
    const h = hsl[0] / 360;
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    let t2;
    let t3;
    let val;
    if (s === 0) {
      val = l * 255;
      return [
        val,
        val,
        val
      ];
    }
    if (l < 0.5)
      t2 = l * (1 + s);
    else
      t2 = l + s - l * s;
    const t1 = 2 * l - t2;
    const rgb = [
      0,
      0,
      0
    ];
    for (let i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * -(i - 1);
      if (t3 < 0)
        t3++;
      if (t3 > 1)
        t3--;
      if (6 * t3 < 1)
        val = t1 + (t2 - t1) * 6 * t3;
      else if (2 * t3 < 1)
        val = t2;
      else if (3 * t3 < 2)
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      else
        val = t1;
      rgb[i] = val * 255;
    }
    return rgb;
  };
  $386dc6a8f80ab96d$var$convert.hsl.hsv = function(hsl) {
    const h = hsl[0];
    let s = hsl[1] / 100;
    let l = hsl[2] / 100;
    let smin = s;
    const lmin = Math.max(l, 0.01);
    l *= 2;
    s *= l <= 1 ? l : 2 - l;
    smin *= lmin <= 1 ? lmin : 2 - lmin;
    const v = (l + s) / 2;
    const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
    return [
      h,
      sv * 100,
      v * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hsv.rgb = function(hsv) {
    const h = hsv[0] / 60;
    const s = hsv[1] / 100;
    let v = hsv[2] / 100;
    const hi = Math.floor(h) % 6;
    const f = h - Math.floor(h);
    const p = 255 * v * (1 - s);
    const q = 255 * v * (1 - s * f);
    const t = 255 * v * (1 - s * (1 - f));
    v *= 255;
    switch (hi) {
      case 0:
        return [
          v,
          t,
          p
        ];
      case 1:
        return [
          q,
          v,
          p
        ];
      case 2:
        return [
          p,
          v,
          t
        ];
      case 3:
        return [
          p,
          q,
          v
        ];
      case 4:
        return [
          t,
          p,
          v
        ];
      case 5:
        return [
          v,
          p,
          q
        ];
    }
  };
  $386dc6a8f80ab96d$var$convert.hsv.hsl = function(hsv) {
    const h = hsv[0];
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const vmin = Math.max(v, 0.01);
    let sl;
    let l;
    l = (2 - s) * v;
    const lmin = (2 - s) * vmin;
    sl = s * vmin;
    sl /= lmin <= 1 ? lmin : 2 - lmin;
    sl = sl || 0;
    l /= 2;
    return [
      h,
      sl * 100,
      l * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hwb.rgb = function(hwb) {
    const h = hwb[0] / 360;
    let wh = hwb[1] / 100;
    let bl = hwb[2] / 100;
    const ratio = wh + bl;
    let f;
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }
    const i = Math.floor(6 * h);
    const v = 1 - bl;
    f = 6 * h - i;
    if ((i & 1) !== 0)
      f = 1 - f;
    const n = wh + f * (v - wh);
    let r;
    let g;
    let b;
    switch (i) {
      default:
      case 6:
      case 0:
        r = v;
        g = n;
        b = wh;
        break;
      case 1:
        r = n;
        g = v;
        b = wh;
        break;
      case 2:
        r = wh;
        g = v;
        b = n;
        break;
      case 3:
        r = wh;
        g = n;
        b = v;
        break;
      case 4:
        r = n;
        g = wh;
        b = v;
        break;
      case 5:
        r = v;
        g = wh;
        b = n;
        break;
    }
    return [
      r * 255,
      g * 255,
      b * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.cmyk.rgb = function(cmyk) {
    const c = cmyk[0] / 100;
    const m = cmyk[1] / 100;
    const y = cmyk[2] / 100;
    const k = cmyk[3] / 100;
    const r = 1 - Math.min(1, c * (1 - k) + k);
    const g = 1 - Math.min(1, m * (1 - k) + k);
    const b = 1 - Math.min(1, y * (1 - k) + k);
    return [
      r * 255,
      g * 255,
      b * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.xyz.rgb = function(xyz) {
    const x = xyz[0] / 100;
    const y = xyz[1] / 100;
    const z = xyz[2] / 100;
    let r;
    let g;
    let b;
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);
    return [
      r * 255,
      g * 255,
      b * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.xyz.lab = function(xyz) {
    let x = xyz[0];
    let y = xyz[1];
    let z = xyz[2];
    x /= 95.047;
    y /= 100;
    z /= 108.883;
    x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
    y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
    z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
    const l = 116 * y - 16;
    const a = 500 * (x - y);
    const b = 200 * (y - z);
    return [
      l,
      a,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.lab.xyz = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let x;
    let y;
    let z;
    y = (l + 16) / 116;
    x = a / 500 + y;
    z = y - b / 200;
    const y2 = y ** 3;
    const x2 = x ** 3;
    const z2 = z ** 3;
    y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
    x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
    z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
    x *= 95.047;
    y *= 100;
    z *= 108.883;
    return [
      x,
      y,
      z
    ];
  };
  $386dc6a8f80ab96d$var$convert.lab.lch = function(lab) {
    const l = lab[0];
    const a = lab[1];
    const b = lab[2];
    let h;
    const hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0)
      h += 360;
    const c = Math.sqrt(a * a + b * b);
    return [
      l,
      c,
      h
    ];
  };
  $386dc6a8f80ab96d$var$convert.lch.lab = function(lch) {
    const l = lch[0];
    const c = lch[1];
    const h = lch[2];
    const hr = h / 360 * 2 * Math.PI;
    const a = c * Math.cos(hr);
    const b = c * Math.sin(hr);
    return [
      l,
      a,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.ansi16 = function(args, saturation = null) {
    const [r, g, b] = args;
    let value = saturation === null ? $386dc6a8f80ab96d$var$convert.rgb.hsv(args)[2] : saturation;
    value = Math.round(value / 50);
    if (value === 0)
      return 30;
    let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
    if (value === 2)
      ansi += 60;
    return ansi;
  };
  $386dc6a8f80ab96d$var$convert.hsv.ansi16 = function(args) {
    return $386dc6a8f80ab96d$var$convert.rgb.ansi16($386dc6a8f80ab96d$var$convert.hsv.rgb(args), args[2]);
  };
  $386dc6a8f80ab96d$var$convert.rgb.ansi256 = function(args) {
    const r = args[0];
    const g = args[1];
    const b = args[2];
    if (r === g && g === b) {
      if (r < 8)
        return 16;
      if (r > 248)
        return 231;
      return Math.round((r - 8) / 247 * 24) + 232;
    }
    const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
    return ansi;
  };
  $386dc6a8f80ab96d$var$convert.ansi16.rgb = function(args) {
    let color = args % 10;
    if (color === 0 || color === 7) {
      if (args > 50)
        color += 3.5;
      color = color / 10.5 * 255;
      return [
        color,
        color,
        color
      ];
    }
    const mult = (~~(args > 50) + 1) * 0.5;
    const r = (color & 1) * mult * 255;
    const g = (color >> 1 & 1) * mult * 255;
    const b = (color >> 2 & 1) * mult * 255;
    return [
      r,
      g,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.ansi256.rgb = function(args) {
    if (args >= 232) {
      const c = (args - 232) * 10 + 8;
      return [
        c,
        c,
        c
      ];
    }
    args -= 16;
    let rem;
    const r = Math.floor(args / 36) / 5 * 255;
    const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    const b = rem % 6 / 5 * 255;
    return [
      r,
      g,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.hex = function(args) {
    const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  $386dc6a8f80ab96d$var$convert.hex.rgb = function(args) {
    const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!match)
      return [
        0,
        0,
        0
      ];
    let colorString = match[0];
    if (match[0].length === 3)
      colorString = colorString.split("").map((char) => {
        return char + char;
      }).join("");
    const integer = parseInt(colorString, 16);
    const r = integer >> 16 & 255;
    const g = integer >> 8 & 255;
    const b = integer & 255;
    return [
      r,
      g,
      b
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.hcg = function(rgb) {
    const r = rgb[0] / 255;
    const g = rgb[1] / 255;
    const b = rgb[2] / 255;
    const max = Math.max(Math.max(r, g), b);
    const min = Math.min(Math.min(r, g), b);
    const chroma = max - min;
    let grayscale;
    let hue;
    if (chroma < 1)
      grayscale = min / (1 - chroma);
    else
      grayscale = 0;
    if (chroma <= 0)
      hue = 0;
    else if (max === r)
      hue = (g - b) / chroma % 6;
    else if (max === g)
      hue = 2 + (b - r) / chroma;
    else
      hue = 4 + (r - g) / chroma;
    hue /= 6;
    hue %= 1;
    return [
      hue * 360,
      chroma * 100,
      grayscale * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hsl.hcg = function(hsl) {
    const s = hsl[1] / 100;
    const l = hsl[2] / 100;
    const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
    let f = 0;
    if (c < 1)
      f = (l - 0.5 * c) / (1 - c);
    return [
      hsl[0],
      c * 100,
      f * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hsv.hcg = function(hsv) {
    const s = hsv[1] / 100;
    const v = hsv[2] / 100;
    const c = s * v;
    let f = 0;
    if (c < 1)
      f = (v - c) / (1 - c);
    return [
      hsv[0],
      c * 100,
      f * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hcg.rgb = function(hcg) {
    const h = hcg[0] / 360;
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    if (c === 0)
      return [
        g * 255,
        g * 255,
        g * 255
      ];
    const pure = [
      0,
      0,
      0
    ];
    const hi = h % 1 * 6;
    const v = hi % 1;
    const w = 1 - v;
    let mg = 0;
    switch (Math.floor(hi)) {
      case 0:
        pure[0] = 1;
        pure[1] = v;
        pure[2] = 0;
        break;
      case 1:
        pure[0] = w;
        pure[1] = 1;
        pure[2] = 0;
        break;
      case 2:
        pure[0] = 0;
        pure[1] = 1;
        pure[2] = v;
        break;
      case 3:
        pure[0] = 0;
        pure[1] = w;
        pure[2] = 1;
        break;
      case 4:
        pure[0] = v;
        pure[1] = 0;
        pure[2] = 1;
        break;
      default:
        pure[0] = 1;
        pure[1] = 0;
        pure[2] = w;
    }
    mg = (1 - c) * g;
    return [
      (c * pure[0] + mg) * 255,
      (c * pure[1] + mg) * 255,
      (c * pure[2] + mg) * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.hcg.hsv = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    let f = 0;
    if (v > 0)
      f = c / v;
    return [
      hcg[0],
      f * 100,
      v * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hcg.hsl = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const l = g * (1 - c) + 0.5 * c;
    let s = 0;
    if (l > 0 && l < 0.5)
      s = c / (2 * l);
    else if (l >= 0.5 && l < 1)
      s = c / (2 * (1 - l));
    return [
      hcg[0],
      s * 100,
      l * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hcg.hwb = function(hcg) {
    const c = hcg[1] / 100;
    const g = hcg[2] / 100;
    const v = c + g * (1 - c);
    return [
      hcg[0],
      (v - c) * 100,
      (1 - v) * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.hwb.hcg = function(hwb) {
    const w = hwb[1] / 100;
    const b = hwb[2] / 100;
    const v = 1 - b;
    const c = v - w;
    let g = 0;
    if (c < 1)
      g = (v - c) / (1 - c);
    return [
      hwb[0],
      c * 100,
      g * 100
    ];
  };
  $386dc6a8f80ab96d$var$convert.apple.rgb = function(apple) {
    return [
      apple[0] / 65535 * 255,
      apple[1] / 65535 * 255,
      apple[2] / 65535 * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.rgb.apple = function(rgb) {
    return [
      rgb[0] / 255 * 65535,
      rgb[1] / 255 * 65535,
      rgb[2] / 255 * 65535
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.rgb = function(args) {
    return [
      args[0] / 100 * 255,
      args[0] / 100 * 255,
      args[0] / 100 * 255
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.hsl = function(args) {
    return [
      0,
      0,
      args[0]
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.hsv = $386dc6a8f80ab96d$var$convert.gray.hsl;
  $386dc6a8f80ab96d$var$convert.gray.hwb = function(gray) {
    return [
      0,
      100,
      gray[0]
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.cmyk = function(gray) {
    return [
      0,
      0,
      0,
      gray[0]
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.lab = function(gray) {
    return [
      gray[0],
      0,
      0
    ];
  };
  $386dc6a8f80ab96d$var$convert.gray.hex = function(gray) {
    const val = Math.round(gray[0] / 100 * 255) & 255;
    const integer = (val << 16) + (val << 8) + val;
    const string = integer.toString(16).toUpperCase();
    return "000000".substring(string.length) + string;
  };
  $386dc6a8f80ab96d$var$convert.rgb.gray = function(rgb) {
    const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    return [
      val / 255 * 100
    ];
  };
});
parcelRequire.register("bcXwX", function(module, exports) {
  module.exports = {
    "aliceblue": [
      240,
      248,
      255
    ],
    "antiquewhite": [
      250,
      235,
      215
    ],
    "aqua": [
      0,
      255,
      255
    ],
    "aquamarine": [
      127,
      255,
      212
    ],
    "azure": [
      240,
      255,
      255
    ],
    "beige": [
      245,
      245,
      220
    ],
    "bisque": [
      255,
      228,
      196
    ],
    "black": [
      0,
      0,
      0
    ],
    "blanchedalmond": [
      255,
      235,
      205
    ],
    "blue": [
      0,
      0,
      255
    ],
    "blueviolet": [
      138,
      43,
      226
    ],
    "brown": [
      165,
      42,
      42
    ],
    "burlywood": [
      222,
      184,
      135
    ],
    "cadetblue": [
      95,
      158,
      160
    ],
    "chartreuse": [
      127,
      255,
      0
    ],
    "chocolate": [
      210,
      105,
      30
    ],
    "coral": [
      255,
      127,
      80
    ],
    "cornflowerblue": [
      100,
      149,
      237
    ],
    "cornsilk": [
      255,
      248,
      220
    ],
    "crimson": [
      220,
      20,
      60
    ],
    "cyan": [
      0,
      255,
      255
    ],
    "darkblue": [
      0,
      0,
      139
    ],
    "darkcyan": [
      0,
      139,
      139
    ],
    "darkgoldenrod": [
      184,
      134,
      11
    ],
    "darkgray": [
      169,
      169,
      169
    ],
    "darkgreen": [
      0,
      100,
      0
    ],
    "darkgrey": [
      169,
      169,
      169
    ],
    "darkkhaki": [
      189,
      183,
      107
    ],
    "darkmagenta": [
      139,
      0,
      139
    ],
    "darkolivegreen": [
      85,
      107,
      47
    ],
    "darkorange": [
      255,
      140,
      0
    ],
    "darkorchid": [
      153,
      50,
      204
    ],
    "darkred": [
      139,
      0,
      0
    ],
    "darksalmon": [
      233,
      150,
      122
    ],
    "darkseagreen": [
      143,
      188,
      143
    ],
    "darkslateblue": [
      72,
      61,
      139
    ],
    "darkslategray": [
      47,
      79,
      79
    ],
    "darkslategrey": [
      47,
      79,
      79
    ],
    "darkturquoise": [
      0,
      206,
      209
    ],
    "darkviolet": [
      148,
      0,
      211
    ],
    "deeppink": [
      255,
      20,
      147
    ],
    "deepskyblue": [
      0,
      191,
      255
    ],
    "dimgray": [
      105,
      105,
      105
    ],
    "dimgrey": [
      105,
      105,
      105
    ],
    "dodgerblue": [
      30,
      144,
      255
    ],
    "firebrick": [
      178,
      34,
      34
    ],
    "floralwhite": [
      255,
      250,
      240
    ],
    "forestgreen": [
      34,
      139,
      34
    ],
    "fuchsia": [
      255,
      0,
      255
    ],
    "gainsboro": [
      220,
      220,
      220
    ],
    "ghostwhite": [
      248,
      248,
      255
    ],
    "gold": [
      255,
      215,
      0
    ],
    "goldenrod": [
      218,
      165,
      32
    ],
    "gray": [
      128,
      128,
      128
    ],
    "green": [
      0,
      128,
      0
    ],
    "greenyellow": [
      173,
      255,
      47
    ],
    "grey": [
      128,
      128,
      128
    ],
    "honeydew": [
      240,
      255,
      240
    ],
    "hotpink": [
      255,
      105,
      180
    ],
    "indianred": [
      205,
      92,
      92
    ],
    "indigo": [
      75,
      0,
      130
    ],
    "ivory": [
      255,
      255,
      240
    ],
    "khaki": [
      240,
      230,
      140
    ],
    "lavender": [
      230,
      230,
      250
    ],
    "lavenderblush": [
      255,
      240,
      245
    ],
    "lawngreen": [
      124,
      252,
      0
    ],
    "lemonchiffon": [
      255,
      250,
      205
    ],
    "lightblue": [
      173,
      216,
      230
    ],
    "lightcoral": [
      240,
      128,
      128
    ],
    "lightcyan": [
      224,
      255,
      255
    ],
    "lightgoldenrodyellow": [
      250,
      250,
      210
    ],
    "lightgray": [
      211,
      211,
      211
    ],
    "lightgreen": [
      144,
      238,
      144
    ],
    "lightgrey": [
      211,
      211,
      211
    ],
    "lightpink": [
      255,
      182,
      193
    ],
    "lightsalmon": [
      255,
      160,
      122
    ],
    "lightseagreen": [
      32,
      178,
      170
    ],
    "lightskyblue": [
      135,
      206,
      250
    ],
    "lightslategray": [
      119,
      136,
      153
    ],
    "lightslategrey": [
      119,
      136,
      153
    ],
    "lightsteelblue": [
      176,
      196,
      222
    ],
    "lightyellow": [
      255,
      255,
      224
    ],
    "lime": [
      0,
      255,
      0
    ],
    "limegreen": [
      50,
      205,
      50
    ],
    "linen": [
      250,
      240,
      230
    ],
    "magenta": [
      255,
      0,
      255
    ],
    "maroon": [
      128,
      0,
      0
    ],
    "mediumaquamarine": [
      102,
      205,
      170
    ],
    "mediumblue": [
      0,
      0,
      205
    ],
    "mediumorchid": [
      186,
      85,
      211
    ],
    "mediumpurple": [
      147,
      112,
      219
    ],
    "mediumseagreen": [
      60,
      179,
      113
    ],
    "mediumslateblue": [
      123,
      104,
      238
    ],
    "mediumspringgreen": [
      0,
      250,
      154
    ],
    "mediumturquoise": [
      72,
      209,
      204
    ],
    "mediumvioletred": [
      199,
      21,
      133
    ],
    "midnightblue": [
      25,
      25,
      112
    ],
    "mintcream": [
      245,
      255,
      250
    ],
    "mistyrose": [
      255,
      228,
      225
    ],
    "moccasin": [
      255,
      228,
      181
    ],
    "navajowhite": [
      255,
      222,
      173
    ],
    "navy": [
      0,
      0,
      128
    ],
    "oldlace": [
      253,
      245,
      230
    ],
    "olive": [
      128,
      128,
      0
    ],
    "olivedrab": [
      107,
      142,
      35
    ],
    "orange": [
      255,
      165,
      0
    ],
    "orangered": [
      255,
      69,
      0
    ],
    "orchid": [
      218,
      112,
      214
    ],
    "palegoldenrod": [
      238,
      232,
      170
    ],
    "palegreen": [
      152,
      251,
      152
    ],
    "paleturquoise": [
      175,
      238,
      238
    ],
    "palevioletred": [
      219,
      112,
      147
    ],
    "papayawhip": [
      255,
      239,
      213
    ],
    "peachpuff": [
      255,
      218,
      185
    ],
    "peru": [
      205,
      133,
      63
    ],
    "pink": [
      255,
      192,
      203
    ],
    "plum": [
      221,
      160,
      221
    ],
    "powderblue": [
      176,
      224,
      230
    ],
    "purple": [
      128,
      0,
      128
    ],
    "rebeccapurple": [
      102,
      51,
      153
    ],
    "red": [
      255,
      0,
      0
    ],
    "rosybrown": [
      188,
      143,
      143
    ],
    "royalblue": [
      65,
      105,
      225
    ],
    "saddlebrown": [
      139,
      69,
      19
    ],
    "salmon": [
      250,
      128,
      114
    ],
    "sandybrown": [
      244,
      164,
      96
    ],
    "seagreen": [
      46,
      139,
      87
    ],
    "seashell": [
      255,
      245,
      238
    ],
    "sienna": [
      160,
      82,
      45
    ],
    "silver": [
      192,
      192,
      192
    ],
    "skyblue": [
      135,
      206,
      235
    ],
    "slateblue": [
      106,
      90,
      205
    ],
    "slategray": [
      112,
      128,
      144
    ],
    "slategrey": [
      112,
      128,
      144
    ],
    "snow": [
      255,
      250,
      250
    ],
    "springgreen": [
      0,
      255,
      127
    ],
    "steelblue": [
      70,
      130,
      180
    ],
    "tan": [
      210,
      180,
      140
    ],
    "teal": [
      0,
      128,
      128
    ],
    "thistle": [
      216,
      191,
      216
    ],
    "tomato": [
      255,
      99,
      71
    ],
    "turquoise": [
      64,
      224,
      208
    ],
    "violet": [
      238,
      130,
      238
    ],
    "wheat": [
      245,
      222,
      179
    ],
    "white": [
      255,
      255,
      255
    ],
    "whitesmoke": [
      245,
      245,
      245
    ],
    "yellow": [
      255,
      255,
      0
    ],
    "yellowgreen": [
      154,
      205,
      50
    ]
  };
});
parcelRequire.register("lDe5S", function(module, exports) {
  var $4QmTn = parcelRequire("4QmTn");
  function $fbf82c3f03d780ce$var$buildGraph() {
    const graph = {};
    const models = Object.keys($4QmTn);
    for (let len = models.length, i = 0; i < len; i++)
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return graph;
  }
  function $fbf82c3f03d780ce$var$deriveBFS(fromModel) {
    const graph = $fbf82c3f03d780ce$var$buildGraph();
    const queue = [
      fromModel
    ];
    graph[fromModel].distance = 0;
    while (queue.length) {
      const current = queue.pop();
      const adjacents = Object.keys($4QmTn[current]);
      for (let len = adjacents.length, i = 0; i < len; i++) {
        const adjacent = adjacents[i];
        const node = graph[adjacent];
        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }
    return graph;
  }
  function $fbf82c3f03d780ce$var$link(from, to) {
    return function(args) {
      return to(from(args));
    };
  }
  function $fbf82c3f03d780ce$var$wrapConversion(toModel, graph) {
    const path = [
      graph[toModel].parent,
      toModel
    ];
    let fn = $4QmTn[graph[toModel].parent][toModel];
    let cur = graph[toModel].parent;
    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = $fbf82c3f03d780ce$var$link($4QmTn[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }
    fn.conversion = path;
    return fn;
  }
  module.exports = function(fromModel) {
    const graph = $fbf82c3f03d780ce$var$deriveBFS(fromModel);
    const conversion = {};
    const models = Object.keys(graph);
    for (let len = models.length, i = 0; i < len; i++) {
      const toModel = models[i];
      const node = graph[toModel];
      if (node.parent === null)
        continue;
      conversion[toModel] = $fbf82c3f03d780ce$var$wrapConversion(toModel, graph);
    }
    return conversion;
  };
});
parcelRequire.register("gn0Qn", function(module, exports) {
  const $beaf72e613ab97c3$var$TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  const $beaf72e613ab97c3$var$STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  const $beaf72e613ab97c3$var$STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  const $beaf72e613ab97c3$var$ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
  const $beaf72e613ab97c3$var$ESCAPES = /* @__PURE__ */ new Map([
    [
      "n",
      "\n"
    ],
    [
      "r",
      "\r"
    ],
    [
      "t",
      "	"
    ],
    [
      "b",
      "\b"
    ],
    [
      "f",
      "\f"
    ],
    [
      "v",
      "\v"
    ],
    [
      "0",
      "\0"
    ],
    [
      "\\",
      "\\"
    ],
    [
      "e",
      "\x1B"
    ],
    [
      "a",
      "\x07"
    ]
  ]);
  function $beaf72e613ab97c3$var$unescape(c) {
    const u = c[0] === "u";
    const bracket = c[1] === "{";
    if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3)
      return String.fromCharCode(parseInt(c.slice(1), 16));
    if (u && bracket)
      return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
    return $beaf72e613ab97c3$var$ESCAPES.get(c) || c;
  }
  function $beaf72e613ab97c3$var$parseArguments(name, arguments_) {
    const results = [];
    const chunks = arguments_.trim().split(/\s*,\s*/g);
    let matches;
    for (const chunk of chunks) {
      const number = Number(chunk);
      if (!Number.isNaN(number))
        results.push(number);
      else if (matches = chunk.match($beaf72e613ab97c3$var$STRING_REGEX))
        results.push(matches[2].replace($beaf72e613ab97c3$var$ESCAPE_REGEX, (m, escape, character) => escape ? $beaf72e613ab97c3$var$unescape(escape) : character));
      else
        throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
    }
    return results;
  }
  function $beaf72e613ab97c3$var$parseStyle(style) {
    $beaf72e613ab97c3$var$STYLE_REGEX.lastIndex = 0;
    const results = [];
    let matches;
    while ((matches = $beaf72e613ab97c3$var$STYLE_REGEX.exec(style)) !== null) {
      const name = matches[1];
      if (matches[2]) {
        const args = $beaf72e613ab97c3$var$parseArguments(name, matches[2]);
        results.push([
          name
        ].concat(args));
      } else
        results.push([
          name
        ]);
    }
    return results;
  }
  function $beaf72e613ab97c3$var$buildStyle(chalk, styles) {
    const enabled = {};
    for (const layer of styles)
      for (const style of layer.styles)
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
    let current = chalk;
    for (const [styleName, styles2] of Object.entries(enabled)) {
      if (!Array.isArray(styles2))
        continue;
      if (!(styleName in current))
        throw new Error(`Unknown Chalk style: ${styleName}`);
      current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
    }
    return current;
  }
  module.exports = (chalk, temporary) => {
    const styles = [];
    const chunks = [];
    let chunk = [];
    temporary.replace($beaf72e613ab97c3$var$TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
      if (escapeCharacter)
        chunk.push($beaf72e613ab97c3$var$unescape(escapeCharacter));
      else if (style) {
        const string = chunk.join("");
        chunk = [];
        chunks.push(styles.length === 0 ? string : $beaf72e613ab97c3$var$buildStyle(chalk, styles)(string));
        styles.push({
          inverse,
          styles: $beaf72e613ab97c3$var$parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0)
          throw new Error("Found extraneous } in Chalk template literal");
        chunks.push($beaf72e613ab97c3$var$buildStyle(chalk, styles)(chunk.join("")));
        chunk = [];
        styles.pop();
      } else
        chunk.push(character);
    });
    chunks.push(chunk.join(""));
    if (styles.length > 0) {
      const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
      throw new Error(errMessage);
    }
    return chunks.join("");
  };
});
parcelRequire.register("6PNpJ", function(module, exports) {
  module.exports = `
<!-- 
    MDSvex comes in handy here because it takes frontmatter and shoves it into the metadata object.
    This means that all we need to do is build out the expected page metadata
-->
<!-- Show title as h1 if defined, and not hidden -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title) && metadata.hide_title !== true}
<h1 class="title">{metadata.title ?? metadata.og?.title}</h1>
{/if}
<svelte:head>
<!-- Title has a default case; so we need to handle it in a special way -->
{#if typeof metadata !== "undefined" && (metadata.title || metadata.og?.title)}
<title>{metadata.title ?? metadata.og?.title}</title>
<meta property="og:title" content={metadata.og?.title ?? metadata.title} />
<meta name="twitter:title" content={metadata.og?.title ?? metadata.title} />
{:else}
<!-- EITHER there is no metadata, or there is no specified style -->
<title>Evidence</title>
{/if}

<!-- default twitter cardtags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@evidence_dev" />

{#if typeof metadata === "object"}
{#if metadata.description || metadata.og?.description}
  <meta
    name="description"
    content={metadata.description ?? metadata.og?.description}
  />
  <meta
    property="og:description"
    content={metadata.og?.description ?? metadata.description}
  />
  <meta
    name="twitter:description"
    content={metadata.og?.description ?? metadata.description}
  />
{/if}
{#if metadata.og?.image}
  <meta property="og:image" content={metadata.og?.image} />
  <meta name="twitter:image" content={metadata.og?.image} />
{/if}
{/if}
</svelte:head>
`;
});
var $3fd82c6737eb24ad$exports = {};
var $49260c17099cae5e$exports = {};
(function(global1, factory) {
  factory($49260c17099cae5e$exports);
})($49260c17099cae5e$exports, function(exports1) {
  const now = typeof process !== "undefined" && process.hrtime ? () => {
    const t = process.hrtime();
    return t[0] * 1e3 + t[1] / 1e6;
  } : () => self.performance.now();
  function collapse_timings(timings) {
    const result = {};
    timings.forEach((timing) => {
      result[timing.label] = Object.assign({
        total: timing.end - timing.start
      }, timing.children && collapse_timings(timing.children));
    });
    return result;
  }
  class Stats {
    constructor() {
      this.start_time = now();
      this.stack = [];
      this.current_children = this.timings = [];
    }
    start(label) {
      const timing = {
        label,
        start: now(),
        end: null,
        children: []
      };
      this.current_children.push(timing);
      this.stack.push(timing);
      this.current_timing = timing;
      this.current_children = timing.children;
    }
    stop(label) {
      if (label !== this.current_timing.label)
        throw new Error(`Mismatched timing labels (expected ${this.current_timing.label}, got ${label})`);
      this.current_timing.end = now();
      this.stack.pop();
      this.current_timing = this.stack[this.stack.length - 1];
      this.current_children = this.current_timing ? this.current_timing.children : this.timings;
    }
    render() {
      const timings = Object.assign({
        total: now() - this.start_time
      }, collapse_timings(this.timings));
      return {
        timings
      };
    }
  }
  var astralIdentifierCodes = [
    509,
    0,
    227,
    0,
    150,
    4,
    294,
    9,
    1368,
    2,
    2,
    1,
    6,
    3,
    41,
    2,
    5,
    0,
    166,
    1,
    574,
    3,
    9,
    9,
    370,
    1,
    154,
    10,
    50,
    3,
    123,
    2,
    54,
    14,
    32,
    10,
    3,
    1,
    11,
    3,
    46,
    10,
    8,
    0,
    46,
    9,
    7,
    2,
    37,
    13,
    2,
    9,
    6,
    1,
    45,
    0,
    13,
    2,
    49,
    13,
    9,
    3,
    2,
    11,
    83,
    11,
    7,
    0,
    161,
    11,
    6,
    9,
    7,
    3,
    56,
    1,
    2,
    6,
    3,
    1,
    3,
    2,
    10,
    0,
    11,
    1,
    3,
    6,
    4,
    4,
    193,
    17,
    10,
    9,
    5,
    0,
    82,
    19,
    13,
    9,
    214,
    6,
    3,
    8,
    28,
    1,
    83,
    16,
    16,
    9,
    82,
    12,
    9,
    9,
    84,
    14,
    5,
    9,
    243,
    14,
    166,
    9,
    71,
    5,
    2,
    1,
    3,
    3,
    2,
    0,
    2,
    1,
    13,
    9,
    120,
    6,
    3,
    6,
    4,
    0,
    29,
    9,
    41,
    6,
    2,
    3,
    9,
    0,
    10,
    10,
    47,
    15,
    406,
    7,
    2,
    7,
    17,
    9,
    57,
    21,
    2,
    13,
    123,
    5,
    4,
    0,
    2,
    1,
    2,
    6,
    2,
    0,
    9,
    9,
    49,
    4,
    2,
    1,
    2,
    4,
    9,
    9,
    330,
    3,
    19306,
    9,
    87,
    9,
    39,
    4,
    60,
    6,
    26,
    9,
    1014,
    0,
    2,
    54,
    8,
    3,
    82,
    0,
    12,
    1,
    19628,
    1,
    4706,
    45,
    3,
    22,
    543,
    4,
    4,
    5,
    9,
    7,
    3,
    6,
    31,
    3,
    149,
    2,
    1418,
    49,
    513,
    54,
    5,
    49,
    9,
    0,
    15,
    0,
    23,
    4,
    2,
    14,
    1361,
    6,
    2,
    16,
    3,
    6,
    2,
    1,
    2,
    4,
    262,
    6,
    10,
    9,
    357,
    0,
    62,
    13,
    1495,
    6,
    110,
    6,
    6,
    9,
    4759,
    9,
    787719,
    239
  ];
  var astralIdentifierStartCodes = [
    0,
    11,
    2,
    25,
    2,
    18,
    2,
    1,
    2,
    14,
    3,
    13,
    35,
    122,
    70,
    52,
    268,
    28,
    4,
    48,
    48,
    31,
    14,
    29,
    6,
    37,
    11,
    29,
    3,
    35,
    5,
    7,
    2,
    4,
    43,
    157,
    19,
    35,
    5,
    35,
    5,
    39,
    9,
    51,
    13,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    2,
    10,
    2,
    14,
    2,
    6,
    2,
    1,
    68,
    310,
    10,
    21,
    11,
    7,
    25,
    5,
    2,
    41,
    2,
    8,
    70,
    5,
    3,
    0,
    2,
    43,
    2,
    1,
    4,
    0,
    3,
    22,
    11,
    22,
    10,
    30,
    66,
    18,
    2,
    1,
    11,
    21,
    11,
    25,
    71,
    55,
    7,
    1,
    65,
    0,
    16,
    3,
    2,
    2,
    2,
    28,
    43,
    28,
    4,
    28,
    36,
    7,
    2,
    27,
    28,
    53,
    11,
    21,
    11,
    18,
    14,
    17,
    111,
    72,
    56,
    50,
    14,
    50,
    14,
    35,
    349,
    41,
    7,
    1,
    79,
    28,
    11,
    0,
    9,
    21,
    43,
    17,
    47,
    20,
    28,
    22,
    13,
    52,
    58,
    1,
    3,
    0,
    14,
    44,
    33,
    24,
    27,
    35,
    30,
    0,
    3,
    0,
    9,
    34,
    4,
    0,
    13,
    47,
    15,
    3,
    22,
    0,
    2,
    0,
    36,
    17,
    2,
    24,
    85,
    6,
    2,
    0,
    2,
    3,
    2,
    14,
    2,
    9,
    8,
    46,
    39,
    7,
    3,
    1,
    3,
    21,
    2,
    6,
    2,
    1,
    2,
    4,
    4,
    0,
    19,
    0,
    13,
    4,
    159,
    52,
    19,
    3,
    21,
    2,
    31,
    47,
    21,
    1,
    2,
    0,
    185,
    46,
    42,
    3,
    37,
    47,
    21,
    0,
    60,
    42,
    14,
    0,
    72,
    26,
    38,
    6,
    186,
    43,
    117,
    63,
    32,
    7,
    3,
    0,
    3,
    7,
    2,
    1,
    2,
    23,
    16,
    0,
    2,
    0,
    95,
    7,
    3,
    38,
    17,
    0,
    2,
    0,
    29,
    0,
    11,
    39,
    8,
    0,
    22,
    0,
    12,
    45,
    20,
    0,
    19,
    72,
    264,
    8,
    2,
    36,
    18,
    0,
    50,
    29,
    113,
    6,
    2,
    1,
    2,
    37,
    22,
    0,
    26,
    5,
    2,
    1,
    2,
    31,
    15,
    0,
    328,
    18,
    190,
    0,
    80,
    921,
    103,
    110,
    18,
    195,
    2637,
    96,
    16,
    1070,
    4050,
    582,
    8634,
    568,
    8,
    30,
    18,
    78,
    18,
    29,
    19,
    47,
    17,
    3,
    32,
    20,
    6,
    18,
    689,
    63,
    129,
    74,
    6,
    0,
    67,
    12,
    65,
    1,
    2,
    0,
    29,
    6135,
    9,
    1237,
    43,
    8,
    8936,
    3,
    2,
    6,
    2,
    1,
    2,
    290,
    46,
    2,
    18,
    3,
    9,
    395,
    2309,
    106,
    6,
    12,
    4,
    8,
    8,
    9,
    5991,
    84,
    2,
    70,
    2,
    1,
    3,
    0,
    3,
    1,
    3,
    3,
    2,
    11,
    2,
    0,
    2,
    6,
    2,
    64,
    2,
    3,
    3,
    7,
    2,
    6,
    2,
    27,
    2,
    3,
    2,
    4,
    2,
    0,
    4,
    6,
    2,
    339,
    3,
    24,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    30,
    2,
    24,
    2,
    7,
    1845,
    30,
    482,
    44,
    11,
    6,
    17,
    0,
    322,
    29,
    19,
    43,
    1269,
    6,
    2,
    3,
    2,
    1,
    2,
    14,
    2,
    196,
    60,
    67,
    8,
    0,
    1205,
    3,
    2,
    26,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    9,
    2,
    3,
    2,
    0,
    2,
    0,
    7,
    0,
    5,
    0,
    2,
    0,
    2,
    0,
    2,
    2,
    2,
    1,
    2,
    0,
    3,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    0,
    2,
    1,
    2,
    0,
    3,
    3,
    2,
    6,
    2,
    3,
    2,
    3,
    2,
    0,
    2,
    9,
    2,
    16,
    6,
    2,
    2,
    4,
    2,
    16,
    4421,
    42719,
    33,
    4152,
    8,
    221,
    3,
    5761,
    15,
    7472,
    3104,
    541,
    1507,
    4938
  ];
  var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
  var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
  var reservedWords = {
    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
    5: "class enum extends super const export import",
    6: "enum",
    strict: "implements interface let package private protected public static yield",
    strictBind: "eval arguments"
  };
  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  var keywords$1 = {
    5: ecma5AndLessKeywords,
    "5module": ecma5AndLessKeywords + " export import",
    6: ecma5AndLessKeywords + " const class extends export import super"
  };
  var keywordRelationalOperator = /^in(stanceof)?$/;
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  function isInAstralSet(code, set) {
    var pos = 65536;
    for (var i2 = 0; i2 < set.length; i2 += 2) {
      pos += set[i2];
      if (pos > code)
        return false;
      pos += set[i2 + 1];
      if (pos >= code)
        return true;
    }
  }
  function isIdentifierStart(code, astral) {
    if (code < 65)
      return code === 36;
    if (code < 91)
      return true;
    if (code < 97)
      return code === 95;
    if (code < 123)
      return true;
    if (code <= 65535)
      return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
    if (astral === false)
      return false;
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code, astral) {
    if (code < 48)
      return code === 36;
    if (code < 58)
      return true;
    if (code < 65)
      return false;
    if (code < 91)
      return true;
    if (code < 97)
      return code === 95;
    if (code < 123)
      return true;
    if (code <= 65535)
      return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
    if (astral === false)
      return false;
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  var TokenType = function TokenType2(label, conf) {
    if (conf === void 0)
      conf = {};
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop || null;
    this.updateContext = null;
  };
  function binop(name, prec) {
    return new TokenType(name, {
      beforeExpr: true,
      binop: prec
    });
  }
  var beforeExpr = {
    beforeExpr: true
  }, startsExpr = {
    startsExpr: true
  };
  var keywords = {};
  function kw(name, options) {
    if (options === void 0)
      options = {};
    options.keyword = name;
    return keywords[name] = new TokenType(name, options);
  }
  var types$1 = {
    num: new TokenType("num", startsExpr),
    regexp: new TokenType("regexp", startsExpr),
    string: new TokenType("string", startsExpr),
    name: new TokenType("name", startsExpr),
    privateId: new TokenType("privateId", startsExpr),
    eof: new TokenType("eof"),
    // Punctuation token types.
    bracketL: new TokenType("[", {
      beforeExpr: true,
      startsExpr: true
    }),
    bracketR: new TokenType("]"),
    braceL: new TokenType("{", {
      beforeExpr: true,
      startsExpr: true
    }),
    braceR: new TokenType("}"),
    parenL: new TokenType("(", {
      beforeExpr: true,
      startsExpr: true
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", beforeExpr),
    semi: new TokenType(";", beforeExpr),
    colon: new TokenType(":", beforeExpr),
    dot: new TokenType("."),
    question: new TokenType("?", beforeExpr),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", beforeExpr),
    template: new TokenType("template"),
    invalidTemplate: new TokenType("invalidTemplate"),
    ellipsis: new TokenType("...", beforeExpr),
    backQuote: new TokenType("`", startsExpr),
    dollarBraceL: new TokenType("${", {
      beforeExpr: true,
      startsExpr: true
    }),
    // Operators. These carry several kinds of properties to help the
    // parser use them properly (the presence of these properties is
    // what categorizes them as operators).
    //
    // `binop`, when present, specifies that this operator is a binary
    // operator, and will refer to its precedence.
    //
    // `prefix` and `postfix` mark the operator as a prefix or postfix
    // unary operator.
    //
    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
    // binary operators with a very low precedence, that should result
    // in AssignmentExpression nodes.
    eq: new TokenType("=", {
      beforeExpr: true,
      isAssign: true
    }),
    assign: new TokenType("_=", {
      beforeExpr: true,
      isAssign: true
    }),
    incDec: new TokenType("++/--", {
      prefix: true,
      postfix: true,
      startsExpr: true
    }),
    prefix: new TokenType("!/~", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    logicalOR: binop("||", 1),
    logicalAND: binop("&&", 2),
    bitwiseOR: binop("|", 3),
    bitwiseXOR: binop("^", 4),
    bitwiseAND: binop("&", 5),
    equality: binop("==/!=/===/!==", 6),
    relational: binop("</>/<=/>=", 7),
    bitShift: binop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: true,
      binop: 9,
      prefix: true,
      startsExpr: true
    }),
    modulo: binop("%", 10),
    star: binop("*", 10),
    slash: binop("/", 10),
    starstar: new TokenType("**", {
      beforeExpr: true
    }),
    coalesce: binop("??", 1),
    // Keyword token types.
    _break: kw("break"),
    _case: kw("case", beforeExpr),
    _catch: kw("catch"),
    _continue: kw("continue"),
    _debugger: kw("debugger"),
    _default: kw("default", beforeExpr),
    _do: kw("do", {
      isLoop: true,
      beforeExpr: true
    }),
    _else: kw("else", beforeExpr),
    _finally: kw("finally"),
    _for: kw("for", {
      isLoop: true
    }),
    _function: kw("function", startsExpr),
    _if: kw("if"),
    _return: kw("return", beforeExpr),
    _switch: kw("switch"),
    _throw: kw("throw", beforeExpr),
    _try: kw("try"),
    _var: kw("var"),
    _const: kw("const"),
    _while: kw("while", {
      isLoop: true
    }),
    _with: kw("with"),
    _new: kw("new", {
      beforeExpr: true,
      startsExpr: true
    }),
    _this: kw("this", startsExpr),
    _super: kw("super", startsExpr),
    _class: kw("class", startsExpr),
    _extends: kw("extends", beforeExpr),
    _export: kw("export"),
    _import: kw("import", startsExpr),
    _null: kw("null", startsExpr),
    _true: kw("true", startsExpr),
    _false: kw("false", startsExpr),
    _in: kw("in", {
      beforeExpr: true,
      binop: 7
    }),
    _instanceof: kw("instanceof", {
      beforeExpr: true,
      binop: 7
    }),
    _typeof: kw("typeof", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _void: kw("void", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    }),
    _delete: kw("delete", {
      beforeExpr: true,
      prefix: true,
      startsExpr: true
    })
  };
  var lineBreak = /\r\n?|\n|\u2028|\u2029/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    return code === 10 || code === 13 || code === 8232 || code === 8233;
  }
  function nextLineBreak(code, from, end) {
    if (end === void 0)
      end = code.length;
    for (var i2 = from; i2 < end; i2++) {
      var next = code.charCodeAt(i2);
      if (isNewLine(next))
        return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
    return -1;
  }
  var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  var ref = Object.prototype;
  var hasOwnProperty$1 = ref.hasOwnProperty;
  var toString3 = ref.toString;
  var hasOwn = Object.hasOwn || function(obj, propName) {
    return hasOwnProperty$1.call(obj, propName);
  };
  var isArray3 = Array.isArray || function(obj) {
    return toString3.call(obj) === "[object Array]";
  };
  function wordsRegexp(words) {
    return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
  }
  function codePointToString(code) {
    if (code <= 65535)
      return String.fromCharCode(code);
    code -= 65536;
    return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
  }
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var Position = function Position2(line, col) {
    this.line = line;
    this.column = col;
  };
  Position.prototype.offset = function offset(n2) {
    return new Position(this.line, this.column + n2);
  };
  var SourceLocation = function SourceLocation2(p2, start, end) {
    this.start = start;
    this.end = end;
    if (p2.sourceFile !== null)
      this.source = p2.sourceFile;
  };
  function getLineInfo(input, offset) {
    for (var line = 1, cur = 0; ; ) {
      var nextBreak = nextLineBreak(input, cur, offset);
      if (nextBreak < 0)
        return new Position(line, offset - cur);
      ++line;
      cur = nextBreak;
    }
  }
  var defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must be
    // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
    // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
    // (the latest version the library supports). This influences
    // support for strict mode, the set of reserved words, and support
    // for new syntax features.
    ecmaVersion: null,
    // `sourceType` indicates the mode the code should be parsed in.
    // Can be either `"script"` or `"module"`. This influences global
    // strict mode and parsing of `import` and `export` declarations.
    sourceType: "script",
    // `onInsertedSemicolon` can be a callback that will be called
    // when a semicolon is automatically inserted. It will be passed
    // the position of the comma as an offset, and if `locations` is
    // enabled, it is given the location as a `{line, column}` object
    // as second argument.
    onInsertedSemicolon: null,
    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
    // trailing commas.
    onTrailingComma: null,
    // By default, reserved words are only enforced if ecmaVersion >= 5.
    // Set `allowReserved` to a boolean value to explicitly turn this on
    // an off. When this option has the value "never", reserved words
    // and keywords can also not be used as property names.
    allowReserved: null,
    // When enabled, a return at the top level is not considered an
    // error.
    allowReturnOutsideFunction: false,
    // When enabled, import/export statements are not constrained to
    // appearing at the top of the program, and an import.meta expression
    // in a script isn't considered an error.
    allowImportExportEverywhere: false,
    // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
    // When enabled, await identifiers are allowed to appear at the top-level scope,
    // but they are still not allowed in non-async functions.
    allowAwaitOutsideFunction: null,
    // When enabled, super identifiers are not constrained to
    // appearing in methods and do not raise an error when they appear elsewhere.
    allowSuperOutsideMethod: null,
    // When enabled, hashbang directive in the beginning of file is
    // allowed and treated as a line comment. Enabled by default when
    // `ecmaVersion` >= 2023.
    allowHashBang: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onToken` option, which will
    // cause Acorn to call that function with object in the same
    // format as tokens returned from `tokenizer().getToken()`. Note
    // that you are not allowed to call the parser from the
    // callback—that will corrupt its internal state.
    onToken: null,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments. Note that you are not allowed to call the
    // parser from the callback—that will corrupt its internal state.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `locations` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null,
    // This value, if given, is stored in every node, whether
    // `locations` is on or off.
    directSourceFile: null,
    // When enabled, parenthesized expressions are represented by
    // (non-standard) ParenthesizedExpression nodes
    preserveParens: false
  };
  var warnedAboutEcmaVersion = false;
  function getOptions(opts) {
    var options = {};
    for (var opt in defaultOptions)
      options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
    if (options.ecmaVersion === "latest")
      options.ecmaVersion = 1e8;
    else if (options.ecmaVersion == null) {
      if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
        warnedAboutEcmaVersion = true;
        console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
      }
      options.ecmaVersion = 11;
    } else if (options.ecmaVersion >= 2015)
      options.ecmaVersion -= 2009;
    if (options.allowReserved == null)
      options.allowReserved = options.ecmaVersion < 5;
    if (opts.allowHashBang == null)
      options.allowHashBang = options.ecmaVersion >= 14;
    if (isArray3(options.onToken)) {
      var tokens = options.onToken;
      options.onToken = function(token) {
        return tokens.push(token);
      };
    }
    if (isArray3(options.onComment))
      options.onComment = pushComment(options, options.onComment);
    return options;
  }
  function pushComment(options, array) {
    return function(block, text2, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "Block" : "Line",
        value: text2,
        start,
        end
      };
      if (options.locations)
        comment.loc = new SourceLocation(this, startLoc, endLoc);
      if (options.ranges)
        comment.range = [
          start,
          end
        ];
      array.push(comment);
    };
  }
  var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
  function functionFlags(async, generator) {
    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
  }
  var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
  var Parser = function Parser2(options, input, startPos) {
    this.options = options = getOptions(options);
    this.sourceFile = options.sourceFile;
    this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
    var reserved2 = "";
    if (options.allowReserved !== true) {
      reserved2 = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
      if (options.sourceType === "module")
        reserved2 += " await";
    }
    this.reservedWords = wordsRegexp(reserved2);
    var reservedStrict = (reserved2 ? reserved2 + " " : "") + reservedWords.strict;
    this.reservedWordsStrict = wordsRegexp(reservedStrict);
    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
    this.input = String(input);
    this.containsEsc = false;
    if (startPos) {
      this.pos = startPos;
      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    }
    this.type = types$1.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();
    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;
    this.context = this.initialContext();
    this.exprAllowed = true;
    this.inModule = options.sourceType === "module";
    this.strict = this.inModule || this.strictDirective(this.pos);
    this.potentialArrowAt = -1;
    this.potentialArrowInForAwait = false;
    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
    this.labels = [];
    this.undefinedExports = /* @__PURE__ */ Object.create(null);
    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
      this.skipLineComment(2);
    this.scopeStack = [];
    this.enterScope(SCOPE_TOP);
    this.regexpState = null;
    this.privateNameStack = [];
  };
  var prototypeAccessors = {
    inFunction: {
      configurable: true
    },
    inGenerator: {
      configurable: true
    },
    inAsync: {
      configurable: true
    },
    canAwait: {
      configurable: true
    },
    allowSuper: {
      configurable: true
    },
    allowDirectSuper: {
      configurable: true
    },
    treatFunctionsAsVar: {
      configurable: true
    },
    allowNewDotTarget: {
      configurable: true
    },
    inClassStaticBlock: {
      configurable: true
    }
  };
  Parser.prototype.parse = function parse2() {
    var node2 = this.options.program || this.startNode();
    this.nextToken();
    return this.parseTopLevel(node2);
  };
  prototypeAccessors.inFunction.get = function() {
    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
  };
  prototypeAccessors.inGenerator.get = function() {
    return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
  };
  prototypeAccessors.inAsync.get = function() {
    return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
  };
  prototypeAccessors.canAwait.get = function() {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
      var scope2 = this.scopeStack[i2];
      if (scope2.inClassFieldInit || scope2.flags & SCOPE_CLASS_STATIC_BLOCK)
        return false;
      if (scope2.flags & SCOPE_FUNCTION)
        return (scope2.flags & SCOPE_ASYNC) > 0;
    }
    return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
  };
  prototypeAccessors.allowSuper.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    var inClassFieldInit = ref2.inClassFieldInit;
    return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
  };
  prototypeAccessors.allowDirectSuper.get = function() {
    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
  };
  prototypeAccessors.treatFunctionsAsVar.get = function() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  };
  prototypeAccessors.allowNewDotTarget.get = function() {
    var ref2 = this.currentThisScope();
    var flags = ref2.flags;
    var inClassFieldInit = ref2.inClassFieldInit;
    return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
  };
  prototypeAccessors.inClassStaticBlock.get = function() {
    return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
  };
  Parser.extend = function extend3() {
    var plugins = [], len = arguments.length;
    while (len--)
      plugins[len] = arguments[len];
    var cls = this;
    for (var i2 = 0; i2 < plugins.length; i2++)
      cls = plugins[i2](cls);
    return cls;
  };
  Parser.parse = function parse2(input, options) {
    return new this(options, input).parse();
  };
  Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
    var parser = new this(options, input, pos);
    parser.nextToken();
    return parser.parseExpression();
  };
  Parser.tokenizer = function tokenizer(input, options) {
    return new this(options, input);
  };
  Object.defineProperties(Parser.prototype, prototypeAccessors);
  var pp$9 = Parser.prototype;
  var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
  pp$9.strictDirective = function(start) {
    if (this.options.ecmaVersion < 5)
      return false;
    for (; ; ) {
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      var match = literal.exec(this.input.slice(start));
      if (!match)
        return false;
      if ((match[1] || match[2]) === "use strict") {
        skipWhiteSpace.lastIndex = start + match[0].length;
        var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
        var next = this.input.charAt(end);
        return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
      }
      start += match[0].length;
      skipWhiteSpace.lastIndex = start;
      start += skipWhiteSpace.exec(this.input)[0].length;
      if (this.input[start] === ";")
        start++;
    }
  };
  pp$9.eat = function(type) {
    if (this.type === type) {
      this.next();
      return true;
    } else
      return false;
  };
  pp$9.isContextual = function(name) {
    return this.type === types$1.name && this.value === name && !this.containsEsc;
  };
  pp$9.eatContextual = function(name) {
    if (!this.isContextual(name))
      return false;
    this.next();
    return true;
  };
  pp$9.expectContextual = function(name) {
    if (!this.eatContextual(name))
      this.unexpected();
  };
  pp$9.canInsertSemicolon = function() {
    return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$9.insertSemicolon = function() {
    if (this.canInsertSemicolon()) {
      if (this.options.onInsertedSemicolon)
        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
      return true;
    }
  };
  pp$9.semicolon = function() {
    if (!this.eat(types$1.semi) && !this.insertSemicolon())
      this.unexpected();
  };
  pp$9.afterTrailingComma = function(tokType, notNext) {
    if (this.type === tokType) {
      if (this.options.onTrailingComma)
        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
      if (!notNext)
        this.next();
      return true;
    }
  };
  pp$9.expect = function(type) {
    this.eat(type) || this.unexpected();
  };
  pp$9.unexpected = function(pos) {
    this.raise(pos != null ? pos : this.start, "Unexpected token");
  };
  var DestructuringErrors = function DestructuringErrors2() {
    this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
  };
  pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
    if (!refDestructuringErrors)
      return;
    if (refDestructuringErrors.trailingComma > -1)
      this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
    if (parens > -1)
      this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  };
  pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
    if (!refDestructuringErrors)
      return false;
    var shorthandAssign = refDestructuringErrors.shorthandAssign;
    var doubleProto = refDestructuringErrors.doubleProto;
    if (!andThrow)
      return shorthandAssign >= 0 || doubleProto >= 0;
    if (shorthandAssign >= 0)
      this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
    if (doubleProto >= 0)
      this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  };
  pp$9.checkYieldAwaitInDefaultParams = function() {
    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
      this.raise(this.yieldPos, "Yield expression cannot be a default value");
    if (this.awaitPos)
      this.raise(this.awaitPos, "Await expression cannot be a default value");
  };
  pp$9.isSimpleAssignTarget = function(expr) {
    if (expr.type === "ParenthesizedExpression")
      return this.isSimpleAssignTarget(expr.expression);
    return expr.type === "Identifier" || expr.type === "MemberExpression";
  };
  var pp$8 = Parser.prototype;
  pp$8.parseTopLevel = function(node2) {
    var exports12 = /* @__PURE__ */ Object.create(null);
    if (!node2.body)
      node2.body = [];
    while (this.type !== types$1.eof) {
      var stmt = this.parseStatement(null, true, exports12);
      node2.body.push(stmt);
    }
    if (this.inModule)
      for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
        var name = list2[i2];
        this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
      }
    this.adaptDirectivePrologue(node2.body);
    this.next();
    node2.sourceType = this.options.sourceType;
    return this.finishNode(node2, "Program");
  };
  var loopLabel = {
    kind: "loop"
  }, switchLabel = {
    kind: "switch"
  };
  pp$8.isLet = function(context) {
    if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
      return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
    if (nextCh === 91 || nextCh === 92 || nextCh > 55295 && nextCh < 56320)
      return true;
    if (context)
      return false;
    if (nextCh === 123)
      return true;
    if (isIdentifierStart(nextCh, true)) {
      var pos = next + 1;
      while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true))
        ++pos;
      if (nextCh === 92 || nextCh > 55295 && nextCh < 56320)
        return true;
      var ident = this.input.slice(next, pos);
      if (!keywordRelationalOperator.test(ident))
        return true;
    }
    return false;
  };
  pp$8.isAsyncFunction = function() {
    if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
      return false;
    skipWhiteSpace.lastIndex = this.pos;
    var skip = skipWhiteSpace.exec(this.input);
    var next = this.pos + skip[0].length, after;
    return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
  };
  pp$8.parseStatement = function(context, topLevel, exports12) {
    var starttype = this.type, node2 = this.startNode(), kind;
    if (this.isLet(context)) {
      starttype = types$1._var;
      kind = "let";
    }
    switch (starttype) {
      case types$1._break:
      case types$1._continue:
        return this.parseBreakContinueStatement(node2, starttype.keyword);
      case types$1._debugger:
        return this.parseDebuggerStatement(node2);
      case types$1._do:
        return this.parseDoStatement(node2);
      case types$1._for:
        return this.parseForStatement(node2);
      case types$1._function:
        if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6)
          this.unexpected();
        return this.parseFunctionStatement(node2, false, !context);
      case types$1._class:
        if (context)
          this.unexpected();
        return this.parseClass(node2, true);
      case types$1._if:
        return this.parseIfStatement(node2);
      case types$1._return:
        return this.parseReturnStatement(node2);
      case types$1._switch:
        return this.parseSwitchStatement(node2);
      case types$1._throw:
        return this.parseThrowStatement(node2);
      case types$1._try:
        return this.parseTryStatement(node2);
      case types$1._const:
      case types$1._var:
        kind = kind || this.value;
        if (context && kind !== "var")
          this.unexpected();
        return this.parseVarStatement(node2, kind);
      case types$1._while:
        return this.parseWhileStatement(node2);
      case types$1._with:
        return this.parseWithStatement(node2);
      case types$1.braceL:
        return this.parseBlock(true, node2);
      case types$1.semi:
        return this.parseEmptyStatement(node2);
      case types$1._export:
      case types$1._import:
        if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 40 || nextCh === 46)
            return this.parseExpressionStatement(node2, this.parseExpression());
        }
        if (!this.options.allowImportExportEverywhere) {
          if (!topLevel)
            this.raise(this.start, "'import' and 'export' may only appear at the top level");
          if (!this.inModule)
            this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
        return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports12);
      default:
        if (this.isAsyncFunction()) {
          if (context)
            this.unexpected();
          this.next();
          return this.parseFunctionStatement(node2, true, !context);
        }
        var maybeName = this.value, expr = this.parseExpression();
        if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon))
          return this.parseLabeledStatement(node2, maybeName, expr, context);
        else
          return this.parseExpressionStatement(node2, expr);
    }
  };
  pp$8.parseBreakContinueStatement = function(node2, keyword) {
    var isBreak = keyword === "break";
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon())
      node2.label = null;
    else if (this.type !== types$1.name)
      this.unexpected();
    else {
      node2.label = this.parseIdent();
      this.semicolon();
    }
    var i2 = 0;
    for (; i2 < this.labels.length; ++i2) {
      var lab = this.labels[i2];
      if (node2.label == null || lab.name === node2.label.name) {
        if (lab.kind != null && (isBreak || lab.kind === "loop"))
          break;
        if (node2.label && isBreak)
          break;
      }
    }
    if (i2 === this.labels.length)
      this.raise(node2.start, "Unsyntactic " + keyword);
    return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
  };
  pp$8.parseDebuggerStatement = function(node2) {
    this.next();
    this.semicolon();
    return this.finishNode(node2, "DebuggerStatement");
  };
  pp$8.parseDoStatement = function(node2) {
    this.next();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("do");
    this.labels.pop();
    this.expect(types$1._while);
    node2.test = this.parseParenExpression();
    if (this.options.ecmaVersion >= 6)
      this.eat(types$1.semi);
    else
      this.semicolon();
    return this.finishNode(node2, "DoWhileStatement");
  };
  pp$8.parseForStatement = function(node2) {
    this.next();
    var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
    this.labels.push(loopLabel);
    this.enterScope(0);
    this.expect(types$1.parenL);
    if (this.type === types$1.semi) {
      if (awaitAt > -1)
        this.unexpected(awaitAt);
      return this.parseFor(node2, null);
    }
    var isLet = this.isLet();
    if (this.type === types$1._var || this.type === types$1._const || isLet) {
      var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
      this.next();
      this.parseVar(init$1, true, kind);
      this.finishNode(init$1, "VariableDeclaration");
      if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
        if (this.options.ecmaVersion >= 9) {
          if (this.type === types$1._in) {
            if (awaitAt > -1)
              this.unexpected(awaitAt);
          } else
            node2.await = awaitAt > -1;
        }
        return this.parseForIn(node2, init$1);
      }
      if (awaitAt > -1)
        this.unexpected(awaitAt);
      return this.parseFor(node2, init$1);
    }
    var startsWithLet = this.isContextual("let"), isForOf = false;
    var refDestructuringErrors = new DestructuringErrors();
    var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
    if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1)
            this.unexpected(awaitAt);
        } else
          node2.await = awaitAt > -1;
      }
      if (startsWithLet && isForOf)
        this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
      this.toAssignable(init, false, refDestructuringErrors);
      this.checkLValPattern(init);
      return this.parseForIn(node2, init);
    } else
      this.checkExpressionErrors(refDestructuringErrors, true);
    if (awaitAt > -1)
      this.unexpected(awaitAt);
    return this.parseFor(node2, init);
  };
  pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
    this.next();
    return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
  };
  pp$8.parseIfStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    node2.consequent = this.parseStatement("if");
    node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
    return this.finishNode(node2, "IfStatement");
  };
  pp$8.parseReturnStatement = function(node2) {
    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
      this.raise(this.start, "'return' outside of function");
    this.next();
    if (this.eat(types$1.semi) || this.insertSemicolon())
      node2.argument = null;
    else {
      node2.argument = this.parseExpression();
      this.semicolon();
    }
    return this.finishNode(node2, "ReturnStatement");
  };
  pp$8.parseSwitchStatement = function(node2) {
    this.next();
    node2.discriminant = this.parseParenExpression();
    node2.cases = [];
    this.expect(types$1.braceL);
    this.labels.push(switchLabel);
    this.enterScope(0);
    var cur;
    for (var sawDefault = false; this.type !== types$1.braceR; )
      if (this.type === types$1._case || this.type === types$1._default) {
        var isCase = this.type === types$1._case;
        if (cur)
          this.finishNode(cur, "SwitchCase");
        node2.cases.push(cur = this.startNode());
        cur.consequent = [];
        this.next();
        if (isCase)
          cur.test = this.parseExpression();
        else {
          if (sawDefault)
            this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
          sawDefault = true;
          cur.test = null;
        }
        this.expect(types$1.colon);
      } else {
        if (!cur)
          this.unexpected();
        cur.consequent.push(this.parseStatement(null));
      }
    this.exitScope();
    if (cur)
      this.finishNode(cur, "SwitchCase");
    this.next();
    this.labels.pop();
    return this.finishNode(node2, "SwitchStatement");
  };
  pp$8.parseThrowStatement = function(node2) {
    this.next();
    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
      this.raise(this.lastTokEnd, "Illegal newline after throw");
    node2.argument = this.parseExpression();
    this.semicolon();
    return this.finishNode(node2, "ThrowStatement");
  };
  var empty$1 = [];
  pp$8.parseTryStatement = function(node2) {
    this.next();
    node2.block = this.parseBlock();
    node2.handler = null;
    if (this.type === types$1._catch) {
      var clause = this.startNode();
      this.next();
      if (this.eat(types$1.parenL)) {
        clause.param = this.parseBindingAtom();
        var simple = clause.param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
      } else {
        if (this.options.ecmaVersion < 10)
          this.unexpected();
        clause.param = null;
        this.enterScope(0);
      }
      clause.body = this.parseBlock(false);
      this.exitScope();
      node2.handler = this.finishNode(clause, "CatchClause");
    }
    node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
    if (!node2.handler && !node2.finalizer)
      this.raise(node2.start, "Missing catch or finally clause");
    return this.finishNode(node2, "TryStatement");
  };
  pp$8.parseVarStatement = function(node2, kind) {
    this.next();
    this.parseVar(node2, false, kind);
    this.semicolon();
    return this.finishNode(node2, "VariableDeclaration");
  };
  pp$8.parseWhileStatement = function(node2) {
    this.next();
    node2.test = this.parseParenExpression();
    this.labels.push(loopLabel);
    node2.body = this.parseStatement("while");
    this.labels.pop();
    return this.finishNode(node2, "WhileStatement");
  };
  pp$8.parseWithStatement = function(node2) {
    if (this.strict)
      this.raise(this.start, "'with' in strict mode");
    this.next();
    node2.object = this.parseParenExpression();
    node2.body = this.parseStatement("with");
    return this.finishNode(node2, "WithStatement");
  };
  pp$8.parseEmptyStatement = function(node2) {
    this.next();
    return this.finishNode(node2, "EmptyStatement");
  };
  pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
    for (var i$12 = 0, list2 = this.labels; i$12 < list2.length; i$12 += 1) {
      var label = list2[i$12];
      if (label.name === maybeName)
        this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
    var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
    for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
      var label$1 = this.labels[i2];
      if (label$1.statementStart === node2.start) {
        label$1.statementStart = this.start;
        label$1.kind = kind;
      } else
        break;
    }
    this.labels.push({
      name: maybeName,
      kind,
      statementStart: this.start
    });
    node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
    this.labels.pop();
    node2.label = expr;
    return this.finishNode(node2, "LabeledStatement");
  };
  pp$8.parseExpressionStatement = function(node2, expr) {
    node2.expression = expr;
    this.semicolon();
    return this.finishNode(node2, "ExpressionStatement");
  };
  pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
    if (createNewLexicalScope === void 0)
      createNewLexicalScope = true;
    if (node2 === void 0)
      node2 = this.startNode();
    node2.body = [];
    this.expect(types$1.braceL);
    if (createNewLexicalScope)
      this.enterScope(0);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    if (exitStrict)
      this.strict = false;
    this.next();
    if (createNewLexicalScope)
      this.exitScope();
    return this.finishNode(node2, "BlockStatement");
  };
  pp$8.parseFor = function(node2, init) {
    node2.init = init;
    this.expect(types$1.semi);
    node2.test = this.type === types$1.semi ? null : this.parseExpression();
    this.expect(types$1.semi);
    node2.update = this.type === types$1.parenR ? null : this.parseExpression();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, "ForStatement");
  };
  pp$8.parseForIn = function(node2, init) {
    var isForIn = this.type === types$1._in;
    this.next();
    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier"))
      this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
    node2.left = init;
    node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
    this.expect(types$1.parenR);
    node2.body = this.parseStatement("for");
    this.exitScope();
    this.labels.pop();
    return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
  };
  pp$8.parseVar = function(node2, isFor, kind) {
    node2.declarations = [];
    node2.kind = kind;
    for (; ; ) {
      var decl = this.startNode();
      this.parseVarId(decl, kind);
      if (this.eat(types$1.eq))
        decl.init = this.parseMaybeAssign(isFor);
      else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")))
        this.unexpected();
      else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of"))))
        this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
      else
        decl.init = null;
      node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
      if (!this.eat(types$1.comma))
        break;
    }
    return node2;
  };
  pp$8.parseVarId = function(decl, kind) {
    decl.id = this.parseBindingAtom();
    this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
  };
  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
  pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
      if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT)
        this.unexpected();
      node2.generator = this.eat(types$1.star);
    }
    if (this.options.ecmaVersion >= 8)
      node2.async = !!isAsync;
    if (statement & FUNC_STATEMENT) {
      node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
      if (node2.id && !(statement & FUNC_HANGING_STATEMENT))
        this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(node2.async, node2.generator));
    if (!(statement & FUNC_STATEMENT))
      node2.id = this.type === types$1.name ? this.parseIdent() : null;
    this.parseFunctionParams(node2);
    this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
  };
  pp$8.parseFunctionParams = function(node2) {
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
  };
  pp$8.parseClass = function(node2, isStatement) {
    this.next();
    var oldStrict = this.strict;
    this.strict = true;
    this.parseClassId(node2, isStatement);
    this.parseClassSuper(node2);
    var privateNameMap = this.enterClassBody();
    var classBody = this.startNode();
    var hadConstructor = false;
    classBody.body = [];
    this.expect(types$1.braceL);
    while (this.type !== types$1.braceR) {
      var element = this.parseClassElement(node2.superClass !== null);
      if (element) {
        classBody.body.push(element);
        if (element.type === "MethodDefinition" && element.kind === "constructor") {
          if (hadConstructor)
            this.raise(element.start, "Duplicate constructor in the same class");
          hadConstructor = true;
        } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element))
          this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
    this.strict = oldStrict;
    this.next();
    node2.body = this.finishNode(classBody, "ClassBody");
    this.exitClassBody();
    return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
  };
  pp$8.parseClassElement = function(constructorAllowsSuper) {
    if (this.eat(types$1.semi))
      return null;
    var ecmaVersion2 = this.options.ecmaVersion;
    var node2 = this.startNode();
    var keyName = "";
    var isGenerator = false;
    var isAsync = false;
    var kind = "method";
    var isStatic = false;
    if (this.eatContextual("static")) {
      if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
        this.parseClassStaticBlock(node2);
        return node2;
      }
      if (this.isClassElementNameStart() || this.type === types$1.star)
        isStatic = true;
      else
        keyName = "static";
    }
    node2.static = isStatic;
    if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
      if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon())
        isAsync = true;
      else
        keyName = "async";
    }
    if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star))
      isGenerator = true;
    if (!keyName && !isAsync && !isGenerator) {
      var lastValue = this.value;
      if (this.eatContextual("get") || this.eatContextual("set")) {
        if (this.isClassElementNameStart())
          kind = lastValue;
        else
          keyName = lastValue;
      }
    }
    if (keyName) {
      node2.computed = false;
      node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
      node2.key.name = keyName;
      this.finishNode(node2.key, "Identifier");
    } else
      this.parseClassElementName(node2);
    if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
      var isConstructor = !node2.static && checkKeyName(node2, "constructor");
      var allowsDirectSuper = isConstructor && constructorAllowsSuper;
      if (isConstructor && kind !== "method")
        this.raise(node2.key.start, "Constructor can't have get/set modifier");
      node2.kind = isConstructor ? "constructor" : kind;
      this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
    } else
      this.parseClassField(node2);
    return node2;
  };
  pp$8.isClassElementNameStart = function() {
    return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
  };
  pp$8.parseClassElementName = function(element) {
    if (this.type === types$1.privateId) {
      if (this.value === "constructor")
        this.raise(this.start, "Classes can't have an element named '#constructor'");
      element.computed = false;
      element.key = this.parsePrivateIdent();
    } else
      this.parsePropertyName(element);
  };
  pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
    var key = method.key;
    if (method.kind === "constructor") {
      if (isGenerator)
        this.raise(key.start, "Constructor can't be a generator");
      if (isAsync)
        this.raise(key.start, "Constructor can't be an async method");
    } else if (method.static && checkKeyName(method, "prototype"))
      this.raise(key.start, "Classes may not have a static property named prototype");
    var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
    if (method.kind === "get" && value2.params.length !== 0)
      this.raiseRecoverable(value2.start, "getter should have no params");
    if (method.kind === "set" && value2.params.length !== 1)
      this.raiseRecoverable(value2.start, "setter should have exactly one param");
    if (method.kind === "set" && value2.params[0].type === "RestElement")
      this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
    return this.finishNode(method, "MethodDefinition");
  };
  pp$8.parseClassField = function(field) {
    if (checkKeyName(field, "constructor"))
      this.raise(field.key.start, "Classes can't have a field named 'constructor'");
    else if (field.static && checkKeyName(field, "prototype"))
      this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
    if (this.eat(types$1.eq)) {
      var scope2 = this.currentThisScope();
      var inClassFieldInit = scope2.inClassFieldInit;
      scope2.inClassFieldInit = true;
      field.value = this.parseMaybeAssign();
      scope2.inClassFieldInit = inClassFieldInit;
    } else
      field.value = null;
    this.semicolon();
    return this.finishNode(field, "PropertyDefinition");
  };
  pp$8.parseClassStaticBlock = function(node2) {
    node2.body = [];
    var oldLabels = this.labels;
    this.labels = [];
    this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
    while (this.type !== types$1.braceR) {
      var stmt = this.parseStatement(null);
      node2.body.push(stmt);
    }
    this.next();
    this.exitScope();
    this.labels = oldLabels;
    return this.finishNode(node2, "StaticBlock");
  };
  pp$8.parseClassId = function(node2, isStatement) {
    if (this.type === types$1.name) {
      node2.id = this.parseIdent();
      if (isStatement)
        this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    } else {
      if (isStatement === true)
        this.unexpected();
      node2.id = null;
    }
  };
  pp$8.parseClassSuper = function(node2) {
    node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(false) : null;
  };
  pp$8.enterClassBody = function() {
    var element = {
      declared: /* @__PURE__ */ Object.create(null),
      used: []
    };
    this.privateNameStack.push(element);
    return element.declared;
  };
  pp$8.exitClassBody = function() {
    var ref2 = this.privateNameStack.pop();
    var declared = ref2.declared;
    var used = ref2.used;
    var len = this.privateNameStack.length;
    var parent = len === 0 ? null : this.privateNameStack[len - 1];
    for (var i2 = 0; i2 < used.length; ++i2) {
      var id2 = used[i2];
      if (!hasOwn(declared, id2.name)) {
        if (parent)
          parent.used.push(id2);
        else
          this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  };
  function isPrivateNameConflicted(privateNameMap, element) {
    var name = element.key.name;
    var curr = privateNameMap[name];
    var next = "true";
    if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set"))
      next = (element.static ? "s" : "i") + element.kind;
    if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
      privateNameMap[name] = "true";
      return false;
    } else if (!curr) {
      privateNameMap[name] = next;
      return false;
    } else
      return true;
  }
  function checkKeyName(node2, name) {
    var computed = node2.computed;
    var key = node2.key;
    return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
  }
  pp$8.parseExport = function(node2, exports12) {
    this.next();
    if (this.eat(types$1.star)) {
      if (this.options.ecmaVersion >= 11) {
        if (this.eatContextual("as")) {
          node2.exported = this.parseModuleExportName();
          this.checkExport(exports12, node2.exported, this.lastTokStart);
        } else
          node2.exported = null;
      }
      this.expectContextual("from");
      if (this.type !== types$1.string)
        this.unexpected();
      node2.source = this.parseExprAtom();
      this.semicolon();
      return this.finishNode(node2, "ExportAllDeclaration");
    }
    if (this.eat(types$1._default)) {
      this.checkExport(exports12, "default", this.lastTokStart);
      var isAsync;
      if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
        var fNode = this.startNode();
        this.next();
        if (isAsync)
          this.next();
        node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
      } else if (this.type === types$1._class) {
        var cNode = this.startNode();
        node2.declaration = this.parseClass(cNode, "nullableID");
      } else {
        node2.declaration = this.parseMaybeAssign();
        this.semicolon();
      }
      return this.finishNode(node2, "ExportDefaultDeclaration");
    }
    if (this.shouldParseExportStatement()) {
      node2.declaration = this.parseStatement(null);
      if (node2.declaration.type === "VariableDeclaration")
        this.checkVariableExport(exports12, node2.declaration.declarations);
      else
        this.checkExport(exports12, node2.declaration.id, node2.declaration.id.start);
      node2.specifiers = [];
      node2.source = null;
    } else {
      node2.declaration = null;
      node2.specifiers = this.parseExportSpecifiers(exports12);
      if (this.eatContextual("from")) {
        if (this.type !== types$1.string)
          this.unexpected();
        node2.source = this.parseExprAtom();
      } else {
        for (var i2 = 0, list2 = node2.specifiers; i2 < list2.length; i2 += 1) {
          var spec = list2[i2];
          this.checkUnreserved(spec.local);
          this.checkLocalExport(spec.local);
          if (spec.local.type === "Literal")
            this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
        node2.source = null;
      }
      this.semicolon();
    }
    return this.finishNode(node2, "ExportNamedDeclaration");
  };
  pp$8.checkExport = function(exports12, name, pos) {
    if (!exports12)
      return;
    if (typeof name !== "string")
      name = name.type === "Identifier" ? name.name : name.value;
    if (hasOwn(exports12, name))
      this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
    exports12[name] = true;
  };
  pp$8.checkPatternExport = function(exports12, pat) {
    var type = pat.type;
    if (type === "Identifier")
      this.checkExport(exports12, pat, pat.start);
    else if (type === "ObjectPattern")
      for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
        var prop = list2[i2];
        this.checkPatternExport(exports12, prop);
      }
    else if (type === "ArrayPattern")
      for (var i$12 = 0, list$12 = pat.elements; i$12 < list$12.length; i$12 += 1) {
        var elt = list$12[i$12];
        if (elt)
          this.checkPatternExport(exports12, elt);
      }
    else if (type === "Property")
      this.checkPatternExport(exports12, pat.value);
    else if (type === "AssignmentPattern")
      this.checkPatternExport(exports12, pat.left);
    else if (type === "RestElement")
      this.checkPatternExport(exports12, pat.argument);
    else if (type === "ParenthesizedExpression")
      this.checkPatternExport(exports12, pat.expression);
  };
  pp$8.checkVariableExport = function(exports12, decls) {
    if (!exports12)
      return;
    for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
      var decl = list2[i2];
      this.checkPatternExport(exports12, decl.id);
    }
  };
  pp$8.shouldParseExportStatement = function() {
    return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
  };
  pp$8.parseExportSpecifiers = function(exports12) {
    var nodes = [], first = true;
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR))
          break;
      } else
        first = false;
      var node2 = this.startNode();
      node2.local = this.parseModuleExportName();
      node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
      this.checkExport(exports12, node2.exported, node2.exported.start);
      nodes.push(this.finishNode(node2, "ExportSpecifier"));
    }
    return nodes;
  };
  pp$8.parseImport = function(node2) {
    this.next();
    if (this.type === types$1.string) {
      node2.specifiers = empty$1;
      node2.source = this.parseExprAtom();
    } else {
      node2.specifiers = this.parseImportSpecifiers();
      this.expectContextual("from");
      node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
    }
    this.semicolon();
    return this.finishNode(node2, "ImportDeclaration");
  };
  pp$8.parseImportSpecifiers = function() {
    var nodes = [], first = true;
    if (this.type === types$1.name) {
      var node2 = this.startNode();
      node2.local = this.parseIdent();
      this.checkLValSimple(node2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
      if (!this.eat(types$1.comma))
        return nodes;
    }
    if (this.type === types$1.star) {
      var node$12 = this.startNode();
      this.next();
      this.expectContextual("as");
      node$12.local = this.parseIdent();
      this.checkLValSimple(node$12.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
      return nodes;
    }
    this.expect(types$1.braceL);
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.afterTrailingComma(types$1.braceR))
          break;
      } else
        first = false;
      var node$2 = this.startNode();
      node$2.imported = this.parseModuleExportName();
      if (this.eatContextual("as"))
        node$2.local = this.parseIdent();
      else {
        this.checkUnreserved(node$2.imported);
        node$2.local = node$2.imported;
      }
      this.checkLValSimple(node$2.local, BIND_LEXICAL);
      nodes.push(this.finishNode(node$2, "ImportSpecifier"));
    }
    return nodes;
  };
  pp$8.parseModuleExportName = function() {
    if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
      var stringLiteral = this.parseLiteral(this.value);
      if (loneSurrogate.test(stringLiteral.value))
        this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
      return stringLiteral;
    }
    return this.parseIdent(true);
  };
  pp$8.adaptDirectivePrologue = function(statements) {
    for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2)
      statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  };
  pp$8.isDirectiveCandidate = function(statement) {
    return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
    (this.input[statement.start] === '"' || this.input[statement.start] === "'");
  };
  var pp$7 = Parser.prototype;
  pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 6 && node2)
      switch (node2.type) {
        case "Identifier":
          if (this.inAsync && node2.name === "await")
            this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          node2.type = "ObjectPattern";
          if (refDestructuringErrors)
            this.checkPatternErrors(refDestructuringErrors, true);
          for (var i2 = 0, list2 = node2.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.toAssignable(prop, isBinding);
            if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern"))
              this.raise(prop.argument.start, "Unexpected token");
          }
          break;
        case "Property":
          if (node2.kind !== "init")
            this.raise(node2.key.start, "Object pattern can't contain getter or setter");
          this.toAssignable(node2.value, isBinding);
          break;
        case "ArrayExpression":
          node2.type = "ArrayPattern";
          if (refDestructuringErrors)
            this.checkPatternErrors(refDestructuringErrors, true);
          this.toAssignableList(node2.elements, isBinding);
          break;
        case "SpreadElement":
          node2.type = "RestElement";
          this.toAssignable(node2.argument, isBinding);
          if (node2.argument.type === "AssignmentPattern")
            this.raise(node2.argument.start, "Rest elements cannot have a default value");
          break;
        case "AssignmentExpression":
          if (node2.operator !== "=")
            this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
          node2.type = "AssignmentPattern";
          delete node2.operator;
          this.toAssignable(node2.left, isBinding);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
          break;
        case "ChainExpression":
          this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!isBinding)
            break;
        default:
          this.raise(node2.start, "Assigning to rvalue");
      }
    else if (refDestructuringErrors)
      this.checkPatternErrors(refDestructuringErrors, true);
    return node2;
  };
  pp$7.toAssignableList = function(exprList, isBinding) {
    var end = exprList.length;
    for (var i2 = 0; i2 < end; i2++) {
      var elt = exprList[i2];
      if (elt)
        this.toAssignable(elt, isBinding);
    }
    if (end) {
      var last = exprList[end - 1];
      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
        this.unexpected(last.argument.start);
    }
    return exprList;
  };
  pp$7.parseSpread = function(refDestructuringErrors) {
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    return this.finishNode(node2, "SpreadElement");
  };
  pp$7.parseRestBinding = function() {
    var node2 = this.startNode();
    this.next();
    if (this.options.ecmaVersion === 6 && this.type !== types$1.name)
      this.unexpected();
    node2.argument = this.parseBindingAtom();
    return this.finishNode(node2, "RestElement");
  };
  pp$7.parseBindingAtom = function() {
    if (this.options.ecmaVersion >= 6)
      switch (this.type) {
        case types$1.bracketL:
          var node2 = this.startNode();
          this.next();
          node2.elements = this.parseBindingList(types$1.bracketR, true, true);
          return this.finishNode(node2, "ArrayPattern");
        case types$1.braceL:
          return this.parseObj(true);
      }
    return this.parseIdent();
  };
  pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (first)
        first = false;
      else
        this.expect(types$1.comma);
      if (allowEmpty && this.type === types$1.comma)
        elts.push(null);
      else if (allowTrailingComma && this.afterTrailingComma(close))
        break;
      else if (this.type === types$1.ellipsis) {
        var rest = this.parseRestBinding();
        this.parseBindingListItem(rest);
        elts.push(rest);
        if (this.type === types$1.comma)
          this.raise(this.start, "Comma is not permitted after the rest element");
        this.expect(close);
        break;
      } else {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        elts.push(elem);
      }
    }
    return elts;
  };
  pp$7.parseBindingListItem = function(param) {
    return param;
  };
  pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
    left = left || this.parseBindingAtom();
    if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq))
      return left;
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.right = this.parseMaybeAssign();
    return this.finishNode(node2, "AssignmentPattern");
  };
  pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    var isBind = bindingType !== BIND_NONE;
    switch (expr.type) {
      case "Identifier":
        if (this.strict && this.reservedWordsStrictBind.test(expr.name))
          this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
        if (isBind) {
          if (bindingType === BIND_LEXICAL && expr.name === "let")
            this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
          if (checkClashes) {
            if (hasOwn(checkClashes, expr.name))
              this.raiseRecoverable(expr.start, "Argument name clash");
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_OUTSIDE)
            this.declareName(expr.name, bindingType, expr.start);
        }
        break;
      case "ChainExpression":
        this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (isBind)
          this.raiseRecoverable(expr.start, "Binding member expression");
        break;
      case "ParenthesizedExpression":
        if (isBind)
          this.raiseRecoverable(expr.start, "Binding parenthesized expression");
        return this.checkLValSimple(expr.expression, bindingType, checkClashes);
      default:
        this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
    }
  };
  pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "ObjectPattern":
        for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
          var prop = list2[i2];
          this.checkLValInnerPattern(prop, bindingType, checkClashes);
        }
        break;
      case "ArrayPattern":
        for (var i$12 = 0, list$12 = expr.elements; i$12 < list$12.length; i$12 += 1) {
          var elem = list$12[i$12];
          if (elem)
            this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
        break;
      default:
        this.checkLValSimple(expr, bindingType, checkClashes);
    }
  };
  pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
    if (bindingType === void 0)
      bindingType = BIND_NONE;
    switch (expr.type) {
      case "Property":
        this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
        break;
      case "AssignmentPattern":
        this.checkLValPattern(expr.left, bindingType, checkClashes);
        break;
      case "RestElement":
        this.checkLValPattern(expr.argument, bindingType, checkClashes);
        break;
      default:
        this.checkLValPattern(expr, bindingType, checkClashes);
    }
  };
  var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
    this.token = token;
    this.isExpr = !!isExpr;
    this.preserveSpace = !!preserveSpace;
    this.override = override;
    this.generator = !!generator;
  };
  var types = {
    b_stat: new TokContext("{", false),
    b_expr: new TokContext("{", true),
    b_tmpl: new TokContext("${", false),
    p_stat: new TokContext("(", false),
    p_expr: new TokContext("(", true),
    q_tmpl: new TokContext("`", true, true, function(p2) {
      return p2.tryReadTemplateToken();
    }),
    f_stat: new TokContext("function", false),
    f_expr: new TokContext("function", true),
    f_expr_gen: new TokContext("function", true, false, null, true),
    f_gen: new TokContext("function", false, false, null, true)
  };
  var pp$6 = Parser.prototype;
  pp$6.initialContext = function() {
    return [
      types.b_stat
    ];
  };
  pp$6.curContext = function() {
    return this.context[this.context.length - 1];
  };
  pp$6.braceIsBlock = function(prevType) {
    var parent = this.curContext();
    if (parent === types.f_expr || parent === types.f_stat)
      return true;
    if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr))
      return !parent.isExpr;
    if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed)
      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
    if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow)
      return true;
    if (prevType === types$1.braceL)
      return parent === types.b_stat;
    if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name)
      return false;
    return !this.exprAllowed;
  };
  pp$6.inGeneratorContext = function() {
    for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
      var context = this.context[i2];
      if (context.token === "function")
        return context.generator;
    }
    return false;
  };
  pp$6.updateContext = function(prevType) {
    var update, type = this.type;
    if (type.keyword && prevType === types$1.dot)
      this.exprAllowed = false;
    else if (update = type.updateContext)
      update.call(this, prevType);
    else
      this.exprAllowed = type.beforeExpr;
  };
  pp$6.overrideContext = function(tokenCtx) {
    if (this.curContext() !== tokenCtx)
      this.context[this.context.length - 1] = tokenCtx;
  };
  types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
    if (this.context.length === 1) {
      this.exprAllowed = true;
      return;
    }
    var out = this.context.pop();
    if (out === types.b_stat && this.curContext().token === "function")
      out = this.context.pop();
    this.exprAllowed = !out.isExpr;
  };
  types$1.braceL.updateContext = function(prevType) {
    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
    this.exprAllowed = true;
  };
  types$1.dollarBraceL.updateContext = function() {
    this.context.push(types.b_tmpl);
    this.exprAllowed = true;
  };
  types$1.parenL.updateContext = function(prevType) {
    var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
    this.context.push(statementParens ? types.p_stat : types.p_expr);
    this.exprAllowed = true;
  };
  types$1.incDec.updateContext = function() {
  };
  types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
    if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat))
      this.context.push(types.f_expr);
    else
      this.context.push(types.f_stat);
    this.exprAllowed = false;
  };
  types$1.backQuote.updateContext = function() {
    if (this.curContext() === types.q_tmpl)
      this.context.pop();
    else
      this.context.push(types.q_tmpl);
    this.exprAllowed = false;
  };
  types$1.star.updateContext = function(prevType) {
    if (prevType === types$1._function) {
      var index = this.context.length - 1;
      if (this.context[index] === types.f_expr)
        this.context[index] = types.f_expr_gen;
      else
        this.context[index] = types.f_gen;
    }
    this.exprAllowed = true;
  };
  types$1.name.updateContext = function(prevType) {
    var allowed = false;
    if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
      if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext())
        allowed = true;
    }
    this.exprAllowed = allowed;
  };
  var pp$5 = Parser.prototype;
  pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
    if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
      return;
    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
      return;
    var key = prop.key;
    var name;
    switch (key.type) {
      case "Identifier":
        name = key.name;
        break;
      case "Literal":
        name = String(key.value);
        break;
      default:
        return;
    }
    var kind = prop.kind;
    if (this.options.ecmaVersion >= 6) {
      if (name === "__proto__" && kind === "init") {
        if (propHash.proto) {
          if (refDestructuringErrors) {
            if (refDestructuringErrors.doubleProto < 0)
              refDestructuringErrors.doubleProto = key.start;
          } else
            this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
        propHash.proto = true;
      }
      return;
    }
    name = "$" + name;
    var other = propHash[name];
    if (other) {
      var redefinition;
      if (kind === "init")
        redefinition = this.strict && other.init || other.get || other.set;
      else
        redefinition = other.init || other[kind];
      if (redefinition)
        this.raiseRecoverable(key.start, "Redefinition of property");
    } else
      other = propHash[name] = {
        init: false,
        get: false,
        set: false
      };
    other[kind] = true;
  };
  pp$5.parseExpression = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
    if (this.type === types$1.comma) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.expressions = [
        expr
      ];
      while (this.eat(types$1.comma))
        node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
      return this.finishNode(node2, "SequenceExpression");
    }
    return expr;
  };
  pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
    if (this.isContextual("yield")) {
      if (this.inGenerator)
        return this.parseYield(forInit);
      else
        this.exprAllowed = false;
    }
    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
    if (refDestructuringErrors) {
      oldParenAssign = refDestructuringErrors.parenthesizedAssign;
      oldTrailingComma = refDestructuringErrors.trailingComma;
      oldDoubleProto = refDestructuringErrors.doubleProto;
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
    } else {
      refDestructuringErrors = new DestructuringErrors();
      ownDestructuringErrors = true;
    }
    var startPos = this.start, startLoc = this.startLoc;
    if (this.type === types$1.parenL || this.type === types$1.name) {
      this.potentialArrowAt = this.start;
      this.potentialArrowInForAwait = forInit === "await";
    }
    var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
    if (afterLeftParse)
      left = afterLeftParse.call(this, left, startPos, startLoc);
    if (this.type.isAssign) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.operator = this.value;
      if (this.type === types$1.eq)
        left = this.toAssignable(left, false, refDestructuringErrors);
      if (!ownDestructuringErrors)
        refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
      if (refDestructuringErrors.shorthandAssign >= left.start)
        refDestructuringErrors.shorthandAssign = -1;
      if (this.type === types$1.eq)
        this.checkLValPattern(left);
      else
        this.checkLValSimple(left);
      node2.left = left;
      this.next();
      node2.right = this.parseMaybeAssign(forInit);
      if (oldDoubleProto > -1)
        refDestructuringErrors.doubleProto = oldDoubleProto;
      return this.finishNode(node2, "AssignmentExpression");
    } else if (ownDestructuringErrors)
      this.checkExpressionErrors(refDestructuringErrors, true);
    if (oldParenAssign > -1)
      refDestructuringErrors.parenthesizedAssign = oldParenAssign;
    if (oldTrailingComma > -1)
      refDestructuringErrors.trailingComma = oldTrailingComma;
    return left;
  };
  pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprOps(forInit, refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors))
      return expr;
    if (this.eat(types$1.question)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.test = expr;
      node2.consequent = this.parseMaybeAssign();
      this.expect(types$1.colon);
      node2.alternate = this.parseMaybeAssign(forInit);
      return this.finishNode(node2, "ConditionalExpression");
    }
    return expr;
  };
  pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors))
      return expr;
    return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
  };
  pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
    var prec = this.type.binop;
    if (prec != null && (!forInit || this.type !== types$1._in)) {
      if (prec > minPrec) {
        var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
        var coalesce = this.type === types$1.coalesce;
        if (coalesce)
          prec = types$1.logicalAND.binop;
        var op = this.value;
        this.next();
        var startPos = this.start, startLoc = this.startLoc;
        var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
        var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
        if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND))
          this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
        return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
      }
    }
    return left;
  };
  pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
    if (right.type === "PrivateIdentifier")
      this.raise(right.start, "Private identifier can only be left side of binary expression");
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.left = left;
    node2.operator = op;
    node2.right = right;
    return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
  };
  pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
    var startPos = this.start, startLoc = this.startLoc, expr;
    if (this.isContextual("await") && this.canAwait) {
      expr = this.parseAwait(forInit);
      sawUnary = true;
    } else if (this.type.prefix) {
      var node2 = this.startNode(), update = this.type === types$1.incDec;
      node2.operator = this.value;
      node2.prefix = true;
      this.next();
      node2.argument = this.parseMaybeUnary(null, true, update, forInit);
      this.checkExpressionErrors(refDestructuringErrors, true);
      if (update)
        this.checkLValSimple(node2.argument);
      else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier")
        this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
      else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument))
        this.raiseRecoverable(node2.start, "Private fields can not be deleted");
      else
        sawUnary = true;
      expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
    } else if (!sawUnary && this.type === types$1.privateId) {
      if (forInit || this.privateNameStack.length === 0)
        this.unexpected();
      expr = this.parsePrivateIdent();
      if (this.type !== types$1._in)
        this.unexpected();
    } else {
      expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
      if (this.checkExpressionErrors(refDestructuringErrors))
        return expr;
      while (this.type.postfix && !this.canInsertSemicolon()) {
        var node$12 = this.startNodeAt(startPos, startLoc);
        node$12.operator = this.value;
        node$12.prefix = false;
        node$12.argument = expr;
        this.checkLValSimple(expr);
        this.next();
        expr = this.finishNode(node$12, "UpdateExpression");
      }
    }
    if (!incDec && this.eat(types$1.starstar)) {
      if (sawUnary)
        this.unexpected(this.lastTokStart);
      else
        return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    } else
      return expr;
  };
  function isPrivateFieldAccess(node2) {
    return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
  }
  pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
    var startPos = this.start, startLoc = this.startLoc;
    var expr = this.parseExprAtom(refDestructuringErrors, forInit);
    if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
      return expr;
    var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
    if (refDestructuringErrors && result.type === "MemberExpression") {
      if (refDestructuringErrors.parenthesizedAssign >= result.start)
        refDestructuringErrors.parenthesizedAssign = -1;
      if (refDestructuringErrors.parenthesizedBind >= result.start)
        refDestructuringErrors.parenthesizedBind = -1;
      if (refDestructuringErrors.trailingComma >= result.start)
        refDestructuringErrors.trailingComma = -1;
    }
    return result;
  };
  pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
    var optionalChained = false;
    while (true) {
      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
      if (element.optional)
        optionalChained = true;
      if (element === base || element.type === "ArrowFunctionExpression") {
        if (optionalChained) {
          var chainNode = this.startNodeAt(startPos, startLoc);
          chainNode.expression = element;
          element = this.finishNode(chainNode, "ChainExpression");
        }
        return element;
      }
      base = element;
    }
  };
  pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
    var optionalSupported = this.options.ecmaVersion >= 11;
    var optional = optionalSupported && this.eat(types$1.questionDot);
    if (noCalls && optional)
      this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
    var computed = this.eat(types$1.bracketL);
    if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
      var node2 = this.startNodeAt(startPos, startLoc);
      node2.object = base;
      if (computed) {
        node2.property = this.parseExpression();
        this.expect(types$1.bracketR);
      } else if (this.type === types$1.privateId && base.type !== "Super")
        node2.property = this.parsePrivateIdent();
      else
        node2.property = this.parseIdent(this.options.allowReserved !== "never");
      node2.computed = !!computed;
      if (optionalSupported)
        node2.optional = optional;
      base = this.finishNode(node2, "MemberExpression");
    } else if (!noCalls && this.eat(types$1.parenL)) {
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
      this.yieldPos = 0;
      this.awaitPos = 0;
      this.awaitIdentPos = 0;
      var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        if (this.awaitIdentPos > 0)
          this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      }
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.callee = base;
      node$12.arguments = exprList;
      if (optionalSupported)
        node$12.optional = optional;
      base = this.finishNode(node$12, "CallExpression");
    } else if (this.type === types$1.backQuote) {
      if (optional || optionalChained)
        this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
      var node$2 = this.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this.parseTemplate({
        isTagged: true
      });
      base = this.finishNode(node$2, "TaggedTemplateExpression");
    }
    return base;
  };
  pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
    if (this.type === types$1.slash)
      this.readRegexp();
    var node2, canBeArrow = this.potentialArrowAt === this.start;
    switch (this.type) {
      case types$1._super:
        if (!this.allowSuper)
          this.raise(this.start, "'super' keyword outside a method");
        node2 = this.startNode();
        this.next();
        if (this.type === types$1.parenL && !this.allowDirectSuper)
          this.raise(node2.start, "super() call outside constructor of a subclass");
        if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL)
          this.unexpected();
        return this.finishNode(node2, "Super");
      case types$1._this:
        node2 = this.startNode();
        this.next();
        return this.finishNode(node2, "ThisExpression");
      case types$1.name:
        var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
        var id2 = this.parseIdent(false);
        if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
          this.overrideContext(types.f_expr);
          return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
        }
        if (canBeArrow && !this.canInsertSemicolon()) {
          if (this.eat(types$1.arrow))
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id2
            ], false, forInit);
          if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
            id2 = this.parseIdent(false);
            if (this.canInsertSemicolon() || !this.eat(types$1.arrow))
              this.unexpected();
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [
              id2
            ], true, forInit);
          }
        }
        return id2;
      case types$1.regexp:
        var value2 = this.value;
        node2 = this.parseLiteral(value2.value);
        node2.regex = {
          pattern: value2.pattern,
          flags: value2.flags
        };
        return node2;
      case types$1.num:
      case types$1.string:
        return this.parseLiteral(this.value);
      case types$1._null:
      case types$1._true:
      case types$1._false:
        node2 = this.startNode();
        node2.value = this.type === types$1._null ? null : this.type === types$1._true;
        node2.raw = this.type.keyword;
        this.next();
        return this.finishNode(node2, "Literal");
      case types$1.parenL:
        var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
        if (refDestructuringErrors) {
          if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
            refDestructuringErrors.parenthesizedAssign = start;
          if (refDestructuringErrors.parenthesizedBind < 0)
            refDestructuringErrors.parenthesizedBind = start;
        }
        return expr;
      case types$1.bracketL:
        node2 = this.startNode();
        this.next();
        node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
        return this.finishNode(node2, "ArrayExpression");
      case types$1.braceL:
        this.overrideContext(types.b_expr);
        return this.parseObj(false, refDestructuringErrors);
      case types$1._function:
        node2 = this.startNode();
        this.next();
        return this.parseFunction(node2, 0);
      case types$1._class:
        return this.parseClass(this.startNode(), false);
      case types$1._new:
        return this.parseNew();
      case types$1.backQuote:
        return this.parseTemplate();
      case types$1._import:
        if (this.options.ecmaVersion >= 11)
          return this.parseExprImport();
        else
          return this.unexpected();
      default:
        this.unexpected();
    }
  };
  pp$5.parseExprImport = function() {
    var node2 = this.startNode();
    if (this.containsEsc)
      this.raiseRecoverable(this.start, "Escape sequence in keyword import");
    var meta = this.parseIdent(true);
    switch (this.type) {
      case types$1.parenL:
        return this.parseDynamicImport(node2);
      case types$1.dot:
        node2.meta = meta;
        return this.parseImportMeta(node2);
      default:
        this.unexpected();
    }
  };
  pp$5.parseDynamicImport = function(node2) {
    this.next();
    node2.source = this.parseMaybeAssign();
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR))
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      else
        this.unexpected(errorPos);
    }
    return this.finishNode(node2, "ImportExpression");
  };
  pp$5.parseImportMeta = function(node2) {
    this.next();
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "meta")
      this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
    if (containsEsc)
      this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
    if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere)
      this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
    return this.finishNode(node2, "MetaProperty");
  };
  pp$5.parseLiteral = function(value2) {
    var node2 = this.startNode();
    node2.value = value2;
    node2.raw = this.input.slice(this.start, this.end);
    if (node2.raw.charCodeAt(node2.raw.length - 1) === 110)
      node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
    this.next();
    return this.finishNode(node2, "Literal");
  };
  pp$5.parseParenExpression = function() {
    this.expect(types$1.parenL);
    var val = this.parseExpression();
    this.expect(types$1.parenR);
    return val;
  };
  pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
    if (this.options.ecmaVersion >= 6) {
      this.next();
      var innerStartPos = this.start, innerStartLoc = this.startLoc;
      var exprList = [], first = true, lastIsComma = false;
      var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
      this.yieldPos = 0;
      this.awaitPos = 0;
      while (this.type !== types$1.parenR) {
        first ? first = false : this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
          lastIsComma = true;
          break;
        } else if (this.type === types$1.ellipsis) {
          spreadStart = this.start;
          exprList.push(this.parseParenItem(this.parseRestBinding()));
          if (this.type === types$1.comma)
            this.raise(this.start, "Comma is not permitted after the rest element");
          break;
        } else
          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
      var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
      this.expect(types$1.parenR);
      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
        this.checkPatternErrors(refDestructuringErrors, false);
        this.checkYieldAwaitInDefaultParams();
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
      }
      if (!exprList.length || lastIsComma)
        this.unexpected(this.lastTokStart);
      if (spreadStart)
        this.unexpected(spreadStart);
      this.checkExpressionErrors(refDestructuringErrors, true);
      this.yieldPos = oldYieldPos || this.yieldPos;
      this.awaitPos = oldAwaitPos || this.awaitPos;
      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else
        val = exprList[0];
    } else
      val = this.parseParenExpression();
    if (this.options.preserveParens) {
      var par = this.startNodeAt(startPos, startLoc);
      par.expression = val;
      return this.finishNode(par, "ParenthesizedExpression");
    } else
      return val;
  };
  pp$5.parseParenItem = function(item) {
    return item;
  };
  pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
  };
  var empty = [];
  pp$5.parseNew = function() {
    if (this.containsEsc)
      this.raiseRecoverable(this.start, "Escape sequence in keyword new");
    var node2 = this.startNode();
    var meta = this.parseIdent(true);
    if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
      node2.meta = meta;
      var containsEsc = this.containsEsc;
      node2.property = this.parseIdent(true);
      if (node2.property.name !== "target")
        this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
      if (containsEsc)
        this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
      if (!this.allowNewDotTarget)
        this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
      return this.finishNode(node2, "MetaProperty");
    }
    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
    node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
    if (isImport && node2.callee.type === "ImportExpression")
      this.raise(startPos, "Cannot use new with import()");
    if (this.eat(types$1.parenL))
      node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
    else
      node2.arguments = empty;
    return this.finishNode(node2, "NewExpression");
  };
  pp$5.parseTemplateElement = function(ref2) {
    var isTagged = ref2.isTagged;
    var elem = this.startNode();
    if (this.type === types$1.invalidTemplate) {
      if (!isTagged)
        this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
      elem.value = {
        raw: this.value,
        cooked: null
      };
    } else
      elem.value = {
        raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
        cooked: this.value
      };
    this.next();
    elem.tail = this.type === types$1.backQuote;
    return this.finishNode(elem, "TemplateElement");
  };
  pp$5.parseTemplate = function(ref2) {
    if (ref2 === void 0)
      ref2 = {};
    var isTagged = ref2.isTagged;
    if (isTagged === void 0)
      isTagged = false;
    var node2 = this.startNode();
    this.next();
    node2.expressions = [];
    var curElt = this.parseTemplateElement({
      isTagged
    });
    node2.quasis = [
      curElt
    ];
    while (!curElt.tail) {
      if (this.type === types$1.eof)
        this.raise(this.pos, "Unterminated template literal");
      this.expect(types$1.dollarBraceL);
      node2.expressions.push(this.parseExpression());
      this.expect(types$1.braceR);
      node2.quasis.push(curElt = this.parseTemplateElement({
        isTagged
      }));
    }
    this.next();
    return this.finishNode(node2, "TemplateLiteral");
  };
  pp$5.isAsyncProp = function(prop) {
    return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  };
  pp$5.parseObj = function(isPattern, refDestructuringErrors) {
    var node2 = this.startNode(), first = true, propHash = {};
    node2.properties = [];
    this.next();
    while (!this.eat(types$1.braceR)) {
      if (!first) {
        this.expect(types$1.comma);
        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR))
          break;
      } else
        first = false;
      var prop = this.parseProperty(isPattern, refDestructuringErrors);
      if (!isPattern)
        this.checkPropClash(prop, propHash, refDestructuringErrors);
      node2.properties.push(prop);
    }
    return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
  };
  pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
    if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
      if (isPattern) {
        prop.argument = this.parseIdent(false);
        if (this.type === types$1.comma)
          this.raise(this.start, "Comma is not permitted after the rest element");
        return this.finishNode(prop, "RestElement");
      }
      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
      if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0)
        refDestructuringErrors.trailingComma = this.start;
      return this.finishNode(prop, "SpreadElement");
    }
    if (this.options.ecmaVersion >= 6) {
      prop.method = false;
      prop.shorthand = false;
      if (isPattern || refDestructuringErrors) {
        startPos = this.start;
        startLoc = this.startLoc;
      }
      if (!isPattern)
        isGenerator = this.eat(types$1.star);
    }
    var containsEsc = this.containsEsc;
    this.parsePropertyName(prop);
    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
      isAsync = true;
      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
      this.parsePropertyName(prop, refDestructuringErrors);
    } else
      isAsync = false;
    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
    return this.finishNode(prop, "Property");
  };
  pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
    if ((isGenerator || isAsync) && this.type === types$1.colon)
      this.unexpected();
    if (this.eat(types$1.colon)) {
      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
      prop.kind = "init";
    } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
      if (isPattern)
        this.unexpected();
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq) {
      if (isGenerator || isAsync)
        this.unexpected();
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.value.start;
        if (prop.kind === "get")
          this.raiseRecoverable(start, "getter should have no params");
        else
          this.raiseRecoverable(start, "setter should have exactly one param");
      } else if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
      if (isGenerator || isAsync)
        this.unexpected();
      this.checkUnreserved(prop.key);
      if (prop.key.name === "await" && !this.awaitIdentPos)
        this.awaitIdentPos = startPos;
      prop.kind = "init";
      if (isPattern)
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      else if (this.type === types$1.eq && refDestructuringErrors) {
        if (refDestructuringErrors.shorthandAssign < 0)
          refDestructuringErrors.shorthandAssign = this.start;
        prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
      } else
        prop.value = this.copyNode(prop.key);
      prop.shorthand = true;
    } else
      this.unexpected();
  };
  pp$5.parsePropertyName = function(prop) {
    if (this.options.ecmaVersion >= 6) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssign();
        this.expect(types$1.bracketR);
        return prop.key;
      } else
        prop.computed = false;
    }
    return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  };
  pp$5.initFunction = function(node2) {
    node2.id = null;
    if (this.options.ecmaVersion >= 6)
      node2.generator = node2.expression = false;
    if (this.options.ecmaVersion >= 8)
      node2.async = false;
  };
  pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
    var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 6)
      node2.generator = isGenerator;
    if (this.options.ecmaVersion >= 8)
      node2.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
    this.expect(types$1.parenL);
    node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
    this.checkYieldAwaitInDefaultParams();
    this.parseFunctionBody(node2, false, true, false);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "FunctionExpression");
  };
  pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
    this.initFunction(node2);
    if (this.options.ecmaVersion >= 8)
      node2.async = !!isAsync;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    node2.params = this.toAssignableList(params, true);
    this.parseFunctionBody(node2, true, false, forInit);
    this.yieldPos = oldYieldPos;
    this.awaitPos = oldAwaitPos;
    this.awaitIdentPos = oldAwaitIdentPos;
    return this.finishNode(node2, "ArrowFunctionExpression");
  };
  pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
    var isExpression = isArrowFunction && this.type !== types$1.braceL;
    var oldStrict = this.strict, useStrict = false;
    if (isExpression) {
      node2.body = this.parseMaybeAssign(forInit);
      node2.expression = true;
      this.checkParams(node2, false);
    } else {
      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
      if (!oldStrict || nonSimple) {
        useStrict = this.strictDirective(this.end);
        if (useStrict && nonSimple)
          this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
      var oldLabels = this.labels;
      this.labels = [];
      if (useStrict)
        this.strict = true;
      this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
      if (this.strict && node2.id)
        this.checkLValSimple(node2.id, BIND_OUTSIDE);
      node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
      node2.expression = false;
      this.adaptDirectivePrologue(node2.body.body);
      this.labels = oldLabels;
    }
    this.exitScope();
  };
  pp$5.isSimpleParamList = function(params) {
    for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
      var param = list2[i2];
      if (param.type !== "Identifier")
        return false;
    }
    return true;
  };
  pp$5.checkParams = function(node2, allowDuplicates) {
    var nameHash = /* @__PURE__ */ Object.create(null);
    for (var i2 = 0, list2 = node2.params; i2 < list2.length; i2 += 1) {
      var param = list2[i2];
      this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
    }
  };
  pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
    var elts = [], first = true;
    while (!this.eat(close)) {
      if (!first) {
        this.expect(types$1.comma);
        if (allowTrailingComma && this.afterTrailingComma(close))
          break;
      } else
        first = false;
      var elt = void 0;
      if (allowEmpty && this.type === types$1.comma)
        elt = null;
      else if (this.type === types$1.ellipsis) {
        elt = this.parseSpread(refDestructuringErrors);
        if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0)
          refDestructuringErrors.trailingComma = this.start;
      } else
        elt = this.parseMaybeAssign(false, refDestructuringErrors);
      elts.push(elt);
    }
    return elts;
  };
  pp$5.checkUnreserved = function(ref2) {
    var start = ref2.start;
    var end = ref2.end;
    var name = ref2.name;
    if (this.inGenerator && name === "yield")
      this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
    if (this.inAsync && name === "await")
      this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
    if (this.currentThisScope().inClassFieldInit && name === "arguments")
      this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
    if (this.inClassStaticBlock && (name === "arguments" || name === "await"))
      this.raise(start, "Cannot use " + name + " in class static initialization block");
    if (this.keywords.test(name))
      this.raise(start, "Unexpected keyword '" + name + "'");
    if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1)
      return;
    var re2 = this.strict ? this.reservedWordsStrict : this.reservedWords;
    if (re2.test(name)) {
      if (!this.inAsync && name === "await")
        this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
      this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
    }
  };
  pp$5.parseIdent = function(liberal, isBinding) {
    var node2 = this.startNode();
    if (this.type === types$1.name)
      node2.name = this.value;
    else if (this.type.keyword) {
      node2.name = this.type.keyword;
      if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46))
        this.context.pop();
    } else
      this.unexpected();
    this.next(!!liberal);
    this.finishNode(node2, "Identifier");
    if (!liberal) {
      this.checkUnreserved(node2);
      if (node2.name === "await" && !this.awaitIdentPos)
        this.awaitIdentPos = node2.start;
    }
    return node2;
  };
  pp$5.parsePrivateIdent = function() {
    var node2 = this.startNode();
    if (this.type === types$1.privateId)
      node2.name = this.value;
    else
      this.unexpected();
    this.next();
    this.finishNode(node2, "PrivateIdentifier");
    if (this.privateNameStack.length === 0)
      this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
    else
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
    return node2;
  };
  pp$5.parseYield = function(forInit) {
    if (!this.yieldPos)
      this.yieldPos = this.start;
    var node2 = this.startNode();
    this.next();
    if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
      node2.delegate = false;
      node2.argument = null;
    } else {
      node2.delegate = this.eat(types$1.star);
      node2.argument = this.parseMaybeAssign(forInit);
    }
    return this.finishNode(node2, "YieldExpression");
  };
  pp$5.parseAwait = function(forInit) {
    if (!this.awaitPos)
      this.awaitPos = this.start;
    var node2 = this.startNode();
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, false, forInit);
    return this.finishNode(node2, "AwaitExpression");
  };
  var pp$4 = Parser.prototype;
  pp$4.raise = function(pos, message) {
    var loc = getLineInfo(this.input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos;
    err.loc = loc;
    err.raisedAt = this.pos;
    throw err;
  };
  pp$4.raiseRecoverable = pp$4.raise;
  pp$4.curPosition = function() {
    if (this.options.locations)
      return new Position(this.curLine, this.pos - this.lineStart);
  };
  var pp$3 = Parser.prototype;
  var Scope = function Scope2(flags) {
    this.flags = flags;
    this.var = [];
    this.lexical = [];
    this.functions = [];
    this.inClassFieldInit = false;
  };
  pp$3.enterScope = function(flags) {
    this.scopeStack.push(new Scope(flags));
  };
  pp$3.exitScope = function() {
    this.scopeStack.pop();
  };
  pp$3.treatFunctionsAsVarInScope = function(scope2) {
    return scope2.flags & SCOPE_FUNCTION || !this.inModule && scope2.flags & SCOPE_TOP;
  };
  pp$3.declareName = function(name, bindingType, pos) {
    var redeclared = false;
    if (bindingType === BIND_LEXICAL) {
      var scope2 = this.currentScope();
      redeclared = scope2.lexical.indexOf(name) > -1 || scope2.functions.indexOf(name) > -1 || scope2.var.indexOf(name) > -1;
      scope2.lexical.push(name);
      if (this.inModule && scope2.flags & SCOPE_TOP)
        delete this.undefinedExports[name];
    } else if (bindingType === BIND_SIMPLE_CATCH) {
      var scope$1 = this.currentScope();
      scope$1.lexical.push(name);
    } else if (bindingType === BIND_FUNCTION) {
      var scope$2 = this.currentScope();
      if (this.treatFunctionsAsVar)
        redeclared = scope$2.lexical.indexOf(name) > -1;
      else
        redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
      scope$2.functions.push(name);
    } else
      for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
        var scope$3 = this.scopeStack[i2];
        if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
          redeclared = true;
          break;
        }
        scope$3.var.push(name);
        if (this.inModule && scope$3.flags & SCOPE_TOP)
          delete this.undefinedExports[name];
        if (scope$3.flags & SCOPE_VAR)
          break;
      }
    if (redeclared)
      this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  };
  pp$3.checkLocalExport = function(id2) {
    if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1)
      this.undefinedExports[id2.name] = id2;
  };
  pp$3.currentScope = function() {
    return this.scopeStack[this.scopeStack.length - 1];
  };
  pp$3.currentVarScope = function() {
    for (var i2 = this.scopeStack.length - 1; ; i2--) {
      var scope2 = this.scopeStack[i2];
      if (scope2.flags & SCOPE_VAR)
        return scope2;
    }
  };
  pp$3.currentThisScope = function() {
    for (var i2 = this.scopeStack.length - 1; ; i2--) {
      var scope2 = this.scopeStack[i2];
      if (scope2.flags & SCOPE_VAR && !(scope2.flags & SCOPE_ARROW))
        return scope2;
    }
  };
  var Node = function Node2(parser, pos, loc) {
    this.type = "";
    this.start = pos;
    this.end = 0;
    if (parser.options.locations)
      this.loc = new SourceLocation(parser, loc);
    if (parser.options.directSourceFile)
      this.sourceFile = parser.options.directSourceFile;
    if (parser.options.ranges)
      this.range = [
        pos,
        0
      ];
  };
  var pp$2 = Parser.prototype;
  pp$2.startNode = function() {
    return new Node(this, this.start, this.startLoc);
  };
  pp$2.startNodeAt = function(pos, loc) {
    return new Node(this, pos, loc);
  };
  function finishNodeAt(node2, type, pos, loc) {
    node2.type = type;
    node2.end = pos;
    if (this.options.locations)
      node2.loc.end = loc;
    if (this.options.ranges)
      node2.range[1] = pos;
    return node2;
  }
  pp$2.finishNode = function(node2, type) {
    return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
  };
  pp$2.finishNodeAt = function(node2, type, pos, loc) {
    return finishNodeAt.call(this, node2, type, pos, loc);
  };
  pp$2.copyNode = function(node2) {
    var newNode = new Node(this, node2.start, this.startLoc);
    for (var prop in node2)
      newNode[prop] = node2[prop];
    return newNode;
  };
  var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
  var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
  var ecma11BinaryProperties = ecma10BinaryProperties;
  var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
  var ecma13BinaryProperties = ecma12BinaryProperties;
  var unicodeBinaryProperties = {
    9: ecma9BinaryProperties,
    10: ecma10BinaryProperties,
    11: ecma11BinaryProperties,
    12: ecma12BinaryProperties,
    13: ecma13BinaryProperties
  };
  var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
  var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
  var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
  var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
  var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
  var unicodeScriptValues = {
    9: ecma9ScriptValues,
    10: ecma10ScriptValues,
    11: ecma11ScriptValues,
    12: ecma12ScriptValues,
    13: ecma13ScriptValues
  };
  var data = {};
  function buildUnicodeData(ecmaVersion2) {
    var d = data[ecmaVersion2] = {
      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
      nonBinary: {
        General_Category: wordsRegexp(unicodeGeneralCategoryValues),
        Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
      }
    };
    d.nonBinary.Script_Extensions = d.nonBinary.Script;
    d.nonBinary.gc = d.nonBinary.General_Category;
    d.nonBinary.sc = d.nonBinary.Script;
    d.nonBinary.scx = d.nonBinary.Script_Extensions;
  }
  for (var i = 0, list = [
    9,
    10,
    11,
    12,
    13
  ]; i < list.length; i += 1) {
    var ecmaVersion = list[i];
    buildUnicodeData(ecmaVersion);
  }
  var pp$1 = Parser.prototype;
  var RegExpValidationState = function RegExpValidationState2(parser) {
    this.parser = parser;
    this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
    this.unicodeProperties = data[parser.options.ecmaVersion >= 13 ? 13 : parser.options.ecmaVersion];
    this.source = "";
    this.flags = "";
    this.start = 0;
    this.switchU = false;
    this.switchN = false;
    this.pos = 0;
    this.lastIntValue = 0;
    this.lastStringValue = "";
    this.lastAssertionIsQuantifiable = false;
    this.numCapturingParens = 0;
    this.maxBackReference = 0;
    this.groupNames = [];
    this.backReferenceNames = [];
  };
  RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
    var unicode = flags.indexOf("u") !== -1;
    this.start = start | 0;
    this.source = pattern + "";
    this.flags = flags;
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  };
  RegExpValidationState.prototype.raise = function raise(message) {
    this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
  };
  RegExpValidationState.prototype.at = function at(i2, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s = this.source;
    var l = s.length;
    if (i2 >= l)
      return -1;
    var c2 = s.charCodeAt(i2);
    if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l)
      return c2;
    var next = s.charCodeAt(i2 + 1);
    return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
  };
  RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
    if (forceU === void 0)
      forceU = false;
    var s = this.source;
    var l = s.length;
    if (i2 >= l)
      return l;
    var c2 = s.charCodeAt(i2), next;
    if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343)
      return i2 + 1;
    return i2 + 2;
  };
  RegExpValidationState.prototype.current = function current(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.pos, forceU);
  };
  RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
    if (forceU === void 0)
      forceU = false;
    return this.at(this.nextIndex(this.pos, forceU), forceU);
  };
  RegExpValidationState.prototype.advance = function advance(forceU) {
    if (forceU === void 0)
      forceU = false;
    this.pos = this.nextIndex(this.pos, forceU);
  };
  RegExpValidationState.prototype.eat = function eat(ch, forceU) {
    if (forceU === void 0)
      forceU = false;
    if (this.current(forceU) === ch) {
      this.advance(forceU);
      return true;
    }
    return false;
  };
  pp$1.validateRegExpFlags = function(state) {
    var validFlags = state.validFlags;
    var flags = state.flags;
    for (var i2 = 0; i2 < flags.length; i2++) {
      var flag = flags.charAt(i2);
      if (validFlags.indexOf(flag) === -1)
        this.raise(state.start, "Invalid regular expression flag");
      if (flags.indexOf(flag, i2 + 1) > -1)
        this.raise(state.start, "Duplicate regular expression flag");
    }
  };
  pp$1.validateRegExpPattern = function(state) {
    this.regexp_pattern(state);
    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
      state.switchN = true;
      this.regexp_pattern(state);
    }
  };
  pp$1.regexp_pattern = function(state) {
    state.pos = 0;
    state.lastIntValue = 0;
    state.lastStringValue = "";
    state.lastAssertionIsQuantifiable = false;
    state.numCapturingParens = 0;
    state.maxBackReference = 0;
    state.groupNames.length = 0;
    state.backReferenceNames.length = 0;
    this.regexp_disjunction(state);
    if (state.pos !== state.source.length) {
      if (state.eat(
        41
        /* ) */
      ))
        state.raise("Unmatched ')'");
      if (state.eat(
        93
        /* ] */
      ) || state.eat(
        125
        /* } */
      ))
        state.raise("Lone quantifier brackets");
    }
    if (state.maxBackReference > state.numCapturingParens)
      state.raise("Invalid escape");
    for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
      var name = list2[i2];
      if (state.groupNames.indexOf(name) === -1)
        state.raise("Invalid named capture referenced");
    }
  };
  pp$1.regexp_disjunction = function(state) {
    this.regexp_alternative(state);
    while (state.eat(
      124
      /* | */
    ))
      this.regexp_alternative(state);
    if (this.regexp_eatQuantifier(state, true))
      state.raise("Nothing to repeat");
    if (state.eat(
      123
      /* { */
    ))
      state.raise("Lone quantifier brackets");
  };
  pp$1.regexp_alternative = function(state) {
    while (state.pos < state.source.length && this.regexp_eatTerm(state))
      ;
  };
  pp$1.regexp_eatTerm = function(state) {
    if (this.regexp_eatAssertion(state)) {
      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
        if (state.switchU)
          state.raise("Invalid quantifier");
      }
      return true;
    }
    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
      this.regexp_eatQuantifier(state);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatAssertion = function(state) {
    var start = state.pos;
    state.lastAssertionIsQuantifiable = false;
    if (state.eat(
      94
      /* ^ */
    ) || state.eat(
      36
      /* $ */
    ))
      return true;
    if (state.eat(
      92
      /* \ */
    )) {
      if (state.eat(
        66
        /* B */
      ) || state.eat(
        98
        /* b */
      ))
        return true;
      state.pos = start;
    }
    if (state.eat(
      40
      /* ( */
    ) && state.eat(
      63
      /* ? */
    )) {
      var lookbehind = false;
      if (this.options.ecmaVersion >= 9)
        lookbehind = state.eat(
          60
          /* < */
        );
      if (state.eat(
        61
        /* = */
      ) || state.eat(
        33
        /* ! */
      )) {
        this.regexp_disjunction(state);
        if (!state.eat(
          41
          /* ) */
        ))
          state.raise("Unterminated group");
        state.lastAssertionIsQuantifiable = !lookbehind;
        return true;
      }
    }
    state.pos = start;
    return false;
  };
  pp$1.regexp_eatQuantifier = function(state, noError) {
    if (noError === void 0)
      noError = false;
    if (this.regexp_eatQuantifierPrefix(state, noError)) {
      state.eat(
        63
        /* ? */
      );
      return true;
    }
    return false;
  };
  pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
    return state.eat(
      42
      /* * */
    ) || state.eat(
      43
      /* + */
    ) || state.eat(
      63
      /* ? */
    ) || this.regexp_eatBracedQuantifier(state, noError);
  };
  pp$1.regexp_eatBracedQuantifier = function(state, noError) {
    var start = state.pos;
    if (state.eat(
      123
      /* { */
    )) {
      var min = 0, max = -1;
      if (this.regexp_eatDecimalDigits(state)) {
        min = state.lastIntValue;
        if (state.eat(
          44
          /* , */
        ) && this.regexp_eatDecimalDigits(state))
          max = state.lastIntValue;
        if (state.eat(
          125
          /* } */
        )) {
          if (max !== -1 && max < min && !noError)
            state.raise("numbers out of order in {} quantifier");
          return true;
        }
      }
      if (state.switchU && !noError)
        state.raise("Incomplete quantifier");
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatAtom = function(state) {
    return this.regexp_eatPatternCharacters(state) || state.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
  };
  pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
    var start = state.pos;
    if (state.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatAtomEscape(state))
        return true;
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatUncapturingGroup = function(state) {
    var start = state.pos;
    if (state.eat(
      40
      /* ( */
    )) {
      if (state.eat(
        63
        /* ? */
      ) && state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        ))
          return true;
        state.raise("Unterminated group");
      }
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatCapturingGroup = function(state) {
    if (state.eat(
      40
      /* ( */
    )) {
      if (this.options.ecmaVersion >= 9)
        this.regexp_groupSpecifier(state);
      else if (state.current() === 63)
        state.raise("Invalid group");
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        state.numCapturingParens += 1;
        return true;
      }
      state.raise("Unterminated group");
    }
    return false;
  };
  pp$1.regexp_eatExtendedAtom = function(state) {
    return state.eat(
      46
      /* . */
    ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
  };
  pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
    if (this.regexp_eatBracedQuantifier(state, true))
      state.raise("Nothing to repeat");
    return false;
  };
  pp$1.regexp_eatSyntaxCharacter = function(state) {
    var ch = state.current();
    if (isSyntaxCharacter(ch)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  function isSyntaxCharacter(ch) {
    return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
  }
  pp$1.regexp_eatPatternCharacters = function(state) {
    var start = state.pos;
    var ch = 0;
    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch))
      state.advance();
    return state.pos !== start;
  };
  pp$1.regexp_eatExtendedPatternCharacter = function(state) {
    var ch = state.current();
    if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_groupSpecifier = function(state) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.regexp_eatGroupName(state)) {
        if (state.groupNames.indexOf(state.lastStringValue) !== -1)
          state.raise("Duplicate capture group name");
        state.groupNames.push(state.lastStringValue);
        return;
      }
      state.raise("Invalid group");
    }
  };
  pp$1.regexp_eatGroupName = function(state) {
    state.lastStringValue = "";
    if (state.eat(
      60
      /* < */
    )) {
      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
        62
        /* > */
      ))
        return true;
      state.raise("Invalid capture group name");
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierName = function(state) {
    state.lastStringValue = "";
    if (this.regexp_eatRegExpIdentifierStart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
      while (this.regexp_eatRegExpIdentifierPart(state))
        state.lastStringValue += codePointToString(state.lastIntValue);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatRegExpIdentifierStart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU))
      ch = state.lastIntValue;
    if (isRegExpIdentifierStart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierStart(ch) {
    return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
  }
  pp$1.regexp_eatRegExpIdentifierPart = function(state) {
    var start = state.pos;
    var forceU = this.options.ecmaVersion >= 11;
    var ch = state.current(forceU);
    state.advance(forceU);
    if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU))
      ch = state.lastIntValue;
    if (isRegExpIdentifierPart(ch)) {
      state.lastIntValue = ch;
      return true;
    }
    state.pos = start;
    return false;
  };
  function isRegExpIdentifierPart(ch) {
    return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
  }
  pp$1.regexp_eatAtomEscape = function(state) {
    if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state))
      return true;
    if (state.switchU) {
      if (state.current() === 99)
        state.raise("Invalid unicode escape");
      state.raise("Invalid escape");
    }
    return false;
  };
  pp$1.regexp_eatBackReference = function(state) {
    var start = state.pos;
    if (this.regexp_eatDecimalEscape(state)) {
      var n2 = state.lastIntValue;
      if (state.switchU) {
        if (n2 > state.maxBackReference)
          state.maxBackReference = n2;
        return true;
      }
      if (n2 <= state.numCapturingParens)
        return true;
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatKGroupName = function(state) {
    if (state.eat(
      107
      /* k */
    )) {
      if (this.regexp_eatGroupName(state)) {
        state.backReferenceNames.push(state.lastStringValue);
        return true;
      }
      state.raise("Invalid named reference");
    }
    return false;
  };
  pp$1.regexp_eatCharacterEscape = function(state) {
    return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
  };
  pp$1.regexp_eatCControlLetter = function(state) {
    var start = state.pos;
    if (state.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatControlLetter(state))
        return true;
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatZero = function(state) {
    if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
      state.lastIntValue = 0;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlEscape = function(state) {
    var ch = state.current();
    if (ch === 116) {
      state.lastIntValue = 9;
      state.advance();
      return true;
    }
    if (ch === 110) {
      state.lastIntValue = 10;
      state.advance();
      return true;
    }
    if (ch === 118) {
      state.lastIntValue = 11;
      state.advance();
      return true;
    }
    if (ch === 102) {
      state.lastIntValue = 12;
      state.advance();
      return true;
    }
    if (ch === 114) {
      state.lastIntValue = 13;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatControlLetter = function(state) {
    var ch = state.current();
    if (isControlLetter(ch)) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  function isControlLetter(ch) {
    return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
  }
  pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
    if (forceU === void 0)
      forceU = false;
    var start = state.pos;
    var switchU = forceU || state.switchU;
    if (state.eat(
      117
      /* u */
    )) {
      if (this.regexp_eatFixedHexDigits(state, 4)) {
        var lead = state.lastIntValue;
        if (switchU && lead >= 55296 && lead <= 56319) {
          var leadSurrogateEnd = state.pos;
          if (state.eat(
            92
            /* \ */
          ) && state.eat(
            117
            /* u */
          ) && this.regexp_eatFixedHexDigits(state, 4)) {
            var trail = state.lastIntValue;
            if (trail >= 56320 && trail <= 57343) {
              state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
              return true;
            }
          }
          state.pos = leadSurrogateEnd;
          state.lastIntValue = lead;
        }
        return true;
      }
      if (switchU && state.eat(
        123
        /* { */
      ) && this.regexp_eatHexDigits(state) && state.eat(
        125
        /* } */
      ) && isValidUnicode(state.lastIntValue))
        return true;
      if (switchU)
        state.raise("Invalid unicode escape");
      state.pos = start;
    }
    return false;
  };
  function isValidUnicode(ch) {
    return ch >= 0 && ch <= 1114111;
  }
  pp$1.regexp_eatIdentityEscape = function(state) {
    if (state.switchU) {
      if (this.regexp_eatSyntaxCharacter(state))
        return true;
      if (state.eat(
        47
        /* / */
      )) {
        state.lastIntValue = 47;
        return true;
      }
      return false;
    }
    var ch = state.current();
    if (ch !== 99 && (!state.switchN || ch !== 107)) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatDecimalEscape = function(state) {
    state.lastIntValue = 0;
    var ch = state.current();
    if (ch >= 49 && ch <= 57) {
      do {
        state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
        state.advance();
      } while ((ch = state.current()) >= 48 && ch <= 57);
      return true;
    }
    return false;
  };
  pp$1.regexp_eatCharacterClassEscape = function(state) {
    var ch = state.current();
    if (isCharacterClassEscape(ch)) {
      state.lastIntValue = -1;
      state.advance();
      return true;
    }
    if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
      state.lastIntValue = -1;
      state.advance();
      if (state.eat(
        123
        /* { */
      ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
        125
        /* } */
      ))
        return true;
      state.raise("Invalid property name");
    }
    return false;
  };
  function isCharacterClassEscape(ch) {
    return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
  }
  pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
    var start = state.pos;
    if (this.regexp_eatUnicodePropertyName(state) && state.eat(
      61
      /* = */
    )) {
      var name = state.lastStringValue;
      if (this.regexp_eatUnicodePropertyValue(state)) {
        var value2 = state.lastStringValue;
        this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
        return true;
      }
    }
    state.pos = start;
    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
      var nameOrValue = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
      return true;
    }
    return false;
  };
  pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
    if (!hasOwn(state.unicodeProperties.nonBinary, name))
      state.raise("Invalid property name");
    if (!state.unicodeProperties.nonBinary[name].test(value2))
      state.raise("Invalid property value");
  };
  pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
    if (!state.unicodeProperties.binary.test(nameOrValue))
      state.raise("Invalid property name");
  };
  pp$1.regexp_eatUnicodePropertyName = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyNameCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyNameCharacter(ch) {
    return isControlLetter(ch) || ch === 95;
  }
  pp$1.regexp_eatUnicodePropertyValue = function(state) {
    var ch = 0;
    state.lastStringValue = "";
    while (isUnicodePropertyValueCharacter(ch = state.current())) {
      state.lastStringValue += codePointToString(ch);
      state.advance();
    }
    return state.lastStringValue !== "";
  };
  function isUnicodePropertyValueCharacter(ch) {
    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
  }
  pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
    return this.regexp_eatUnicodePropertyValue(state);
  };
  pp$1.regexp_eatCharacterClass = function(state) {
    if (state.eat(
      91
      /* [ */
    )) {
      state.eat(
        94
        /* ^ */
      );
      this.regexp_classRanges(state);
      if (state.eat(
        93
        /* ] */
      ))
        return true;
      state.raise("Unterminated character class");
    }
    return false;
  };
  pp$1.regexp_classRanges = function(state) {
    while (this.regexp_eatClassAtom(state)) {
      var left = state.lastIntValue;
      if (state.eat(
        45
        /* - */
      ) && this.regexp_eatClassAtom(state)) {
        var right = state.lastIntValue;
        if (state.switchU && (left === -1 || right === -1))
          state.raise("Invalid character class");
        if (left !== -1 && right !== -1 && left > right)
          state.raise("Range out of order in character class");
      }
    }
  };
  pp$1.regexp_eatClassAtom = function(state) {
    var start = state.pos;
    if (state.eat(
      92
      /* \ */
    )) {
      if (this.regexp_eatClassEscape(state))
        return true;
      if (state.switchU) {
        var ch$1 = state.current();
        if (ch$1 === 99 || isOctalDigit(ch$1))
          state.raise("Invalid class escape");
        state.raise("Invalid escape");
      }
      state.pos = start;
    }
    var ch = state.current();
    if (ch !== 93) {
      state.lastIntValue = ch;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatClassEscape = function(state) {
    var start = state.pos;
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    if (state.switchU && state.eat(
      45
      /* - */
    )) {
      state.lastIntValue = 45;
      return true;
    }
    if (!state.switchU && state.eat(
      99
      /* c */
    )) {
      if (this.regexp_eatClassControlLetter(state))
        return true;
      state.pos = start;
    }
    return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
  };
  pp$1.regexp_eatClassControlLetter = function(state) {
    var ch = state.current();
    if (isDecimalDigit(ch) || ch === 95) {
      state.lastIntValue = ch % 32;
      state.advance();
      return true;
    }
    return false;
  };
  pp$1.regexp_eatHexEscapeSequence = function(state) {
    var start = state.pos;
    if (state.eat(
      120
      /* x */
    )) {
      if (this.regexp_eatFixedHexDigits(state, 2))
        return true;
      if (state.switchU)
        state.raise("Invalid escape");
      state.pos = start;
    }
    return false;
  };
  pp$1.regexp_eatDecimalDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isDecimalDigit(ch = state.current())) {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    }
    return state.pos !== start;
  };
  function isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  pp$1.regexp_eatHexDigits = function(state) {
    var start = state.pos;
    var ch = 0;
    state.lastIntValue = 0;
    while (isHexDigit(ch = state.current())) {
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return state.pos !== start;
  };
  function isHexDigit(ch) {
    return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
  }
  function hexToInt(ch) {
    if (ch >= 65 && ch <= 70)
      return 10 + (ch - 65);
    if (ch >= 97 && ch <= 102)
      return 10 + (ch - 97);
    return ch - 48;
  }
  pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
    if (this.regexp_eatOctalDigit(state)) {
      var n1 = state.lastIntValue;
      if (this.regexp_eatOctalDigit(state)) {
        var n2 = state.lastIntValue;
        if (n1 <= 3 && this.regexp_eatOctalDigit(state))
          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
        else
          state.lastIntValue = n1 * 8 + n2;
      } else
        state.lastIntValue = n1;
      return true;
    }
    return false;
  };
  pp$1.regexp_eatOctalDigit = function(state) {
    var ch = state.current();
    if (isOctalDigit(ch)) {
      state.lastIntValue = ch - 48;
      state.advance();
      return true;
    }
    state.lastIntValue = 0;
    return false;
  };
  function isOctalDigit(ch) {
    return ch >= 48 && ch <= 55;
  }
  pp$1.regexp_eatFixedHexDigits = function(state, length) {
    var start = state.pos;
    state.lastIntValue = 0;
    for (var i2 = 0; i2 < length; ++i2) {
      var ch = state.current();
      if (!isHexDigit(ch)) {
        state.pos = start;
        return false;
      }
      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
      state.advance();
    }
    return true;
  };
  var Token = function Token2(p2) {
    this.type = p2.type;
    this.value = p2.value;
    this.start = p2.start;
    this.end = p2.end;
    if (p2.options.locations)
      this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
    if (p2.options.ranges)
      this.range = [
        p2.start,
        p2.end
      ];
  };
  var pp = Parser.prototype;
  pp.next = function(ignoreEscapeSequenceInKeyword) {
    if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
      this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
    if (this.options.onToken)
      this.options.onToken(new Token(this));
    this.lastTokEnd = this.end;
    this.lastTokStart = this.start;
    this.lastTokEndLoc = this.endLoc;
    this.lastTokStartLoc = this.startLoc;
    this.nextToken();
  };
  pp.getToken = function() {
    this.next();
    return new Token(this);
  };
  if (typeof Symbol !== "undefined")
    pp[Symbol.iterator] = function() {
      var this$1$1 = this;
      return {
        next: function() {
          var token = this$1$1.getToken();
          return {
            done: token.type === types$1.eof,
            value: token
          };
        }
      };
    };
  pp.nextToken = function() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace)
      this.skipSpace();
    this.start = this.pos;
    if (this.options.locations)
      this.startLoc = this.curPosition();
    if (this.pos >= this.input.length)
      return this.finishToken(types$1.eof);
    if (curContext.override)
      return curContext.override(this);
    else
      this.readToken(this.fullCharCodeAtPos());
  };
  pp.readToken = function(code) {
    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92)
      return this.readWord();
    return this.getTokenFromCode(code);
  };
  pp.fullCharCodeAtPos = function() {
    var code = this.input.charCodeAt(this.pos);
    if (code <= 55295 || code >= 56320)
      return code;
    var next = this.input.charCodeAt(this.pos + 1);
    return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
  };
  pp.skipBlockComment = function() {
    var startLoc = this.options.onComment && this.curPosition();
    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
    if (end === -1)
      this.raise(this.pos - 2, "Unterminated comment");
    this.pos = end + 2;
    if (this.options.locations)
      for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
        ++this.curLine;
        pos = this.lineStart = nextBreak;
      }
    if (this.options.onComment)
      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  };
  pp.skipLineComment = function(startSkip) {
    var start = this.pos;
    var startLoc = this.options.onComment && this.curPosition();
    var ch = this.input.charCodeAt(this.pos += startSkip);
    while (this.pos < this.input.length && !isNewLine(ch))
      ch = this.input.charCodeAt(++this.pos);
    if (this.options.onComment)
      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  };
  pp.skipSpace = function() {
    loop:
      while (this.pos < this.input.length) {
        var ch = this.input.charCodeAt(this.pos);
        switch (ch) {
          case 32:
          case 160:
            ++this.pos;
            break;
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10)
              ++this.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break;
          case 47:
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break loop;
            }
            break;
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))
              ++this.pos;
            else
              break loop;
        }
      }
  };
  pp.finishToken = function(type, val) {
    this.end = this.pos;
    if (this.options.locations)
      this.endLoc = this.curPosition();
    var prevType = this.type;
    this.type = type;
    this.value = val;
    this.updateContext(prevType);
  };
  pp.readToken_dot = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next >= 48 && next <= 57)
      return this.readNumber(true);
    var next2 = this.input.charCodeAt(this.pos + 2);
    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
      this.pos += 3;
      return this.finishToken(types$1.ellipsis);
    } else {
      ++this.pos;
      return this.finishToken(types$1.dot);
    }
  };
  pp.readToken_slash = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (this.exprAllowed) {
      ++this.pos;
      return this.readRegexp();
    }
    if (next === 61)
      return this.finishOp(types$1.assign, 2);
    return this.finishOp(types$1.slash, 1);
  };
  pp.readToken_mult_modulo_exp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    var tokentype = code === 42 ? types$1.star : types$1.modulo;
    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
      ++size;
      tokentype = types$1.starstar;
      next = this.input.charCodeAt(this.pos + 2);
    }
    if (next === 61)
      return this.finishOp(types$1.assign, size + 1);
    return this.finishOp(tokentype, size);
  };
  pp.readToken_pipe_amp = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (this.options.ecmaVersion >= 12) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 === 61)
          return this.finishOp(types$1.assign, 3);
      }
      return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
    }
    if (next === 61)
      return this.finishOp(types$1.assign, 2);
    return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
  };
  pp.readToken_caret = function() {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61)
      return this.finishOp(types$1.assign, 2);
    return this.finishOp(types$1.bitwiseXOR, 1);
  };
  pp.readToken_plus_min = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === code) {
      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types$1.incDec, 2);
    }
    if (next === 61)
      return this.finishOp(types$1.assign, 2);
    return this.finishOp(types$1.plusMin, 1);
  };
  pp.readToken_lt_gt = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    var size = 1;
    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.pos + size) === 61)
        return this.finishOp(types$1.assign, size + 1);
      return this.finishOp(types$1.bitShift, size);
    }
    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }
    if (next === 61)
      size = 2;
    return this.finishOp(types$1.relational, size);
  };
  pp.readToken_eq_excl = function(code) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 61)
      return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
      this.pos += 2;
      return this.finishToken(types$1.arrow);
    }
    return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
  };
  pp.readToken_question = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    if (ecmaVersion2 >= 11) {
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 46) {
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (next2 < 48 || next2 > 57)
          return this.finishOp(types$1.questionDot, 2);
      }
      if (next === 63) {
        if (ecmaVersion2 >= 12) {
          var next2$1 = this.input.charCodeAt(this.pos + 2);
          if (next2$1 === 61)
            return this.finishOp(types$1.assign, 3);
        }
        return this.finishOp(types$1.coalesce, 2);
      }
    }
    return this.finishOp(types$1.question, 1);
  };
  pp.readToken_numberSign = function() {
    var ecmaVersion2 = this.options.ecmaVersion;
    var code = 35;
    if (ecmaVersion2 >= 13) {
      ++this.pos;
      code = this.fullCharCodeAtPos();
      if (isIdentifierStart(code, true) || code === 92)
        return this.finishToken(types$1.privateId, this.readWord1());
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
  };
  pp.getTokenFromCode = function(code) {
    switch (code) {
      case 46:
        return this.readToken_dot();
      case 40:
        ++this.pos;
        return this.finishToken(types$1.parenL);
      case 41:
        ++this.pos;
        return this.finishToken(types$1.parenR);
      case 59:
        ++this.pos;
        return this.finishToken(types$1.semi);
      case 44:
        ++this.pos;
        return this.finishToken(types$1.comma);
      case 91:
        ++this.pos;
        return this.finishToken(types$1.bracketL);
      case 93:
        ++this.pos;
        return this.finishToken(types$1.bracketR);
      case 123:
        ++this.pos;
        return this.finishToken(types$1.braceL);
      case 125:
        ++this.pos;
        return this.finishToken(types$1.braceR);
      case 58:
        ++this.pos;
        return this.finishToken(types$1.colon);
      case 96:
        if (this.options.ecmaVersion < 6)
          break;
        ++this.pos;
        return this.finishToken(types$1.backQuote);
      case 48:
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 120 || next === 88)
          return this.readRadixNumber(16);
        if (this.options.ecmaVersion >= 6) {
          if (next === 111 || next === 79)
            return this.readRadixNumber(8);
          if (next === 98 || next === 66)
            return this.readRadixNumber(2);
        }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.readNumber(false);
      case 34:
      case 39:
        return this.readString(code);
      case 47:
        return this.readToken_slash();
      case 37:
      case 42:
        return this.readToken_mult_modulo_exp(code);
      case 124:
      case 38:
        return this.readToken_pipe_amp(code);
      case 94:
        return this.readToken_caret();
      case 43:
      case 45:
        return this.readToken_plus_min(code);
      case 60:
      case 62:
        return this.readToken_lt_gt(code);
      case 61:
      case 33:
        return this.readToken_eq_excl(code);
      case 63:
        return this.readToken_question();
      case 126:
        return this.finishOp(types$1.prefix, 1);
      case 35:
        return this.readToken_numberSign();
    }
    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
  };
  pp.finishOp = function(type, size) {
    var str = this.input.slice(this.pos, this.pos + size);
    this.pos += size;
    return this.finishToken(type, str);
  };
  pp.readRegexp = function() {
    var escaped2, inClass, start = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length)
        this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.pos);
      if (lineBreak.test(ch))
        this.raise(start, "Unterminated regular expression");
      if (!escaped2) {
        if (ch === "[")
          inClass = true;
        else if (ch === "]" && inClass)
          inClass = false;
        else if (ch === "/" && !inClass)
          break;
        escaped2 = ch === "\\";
      } else
        escaped2 = false;
      ++this.pos;
    }
    var pattern = this.input.slice(start, this.pos);
    ++this.pos;
    var flagsStart = this.pos;
    var flags = this.readWord1();
    if (this.containsEsc)
      this.unexpected(flagsStart);
    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
    state.reset(start, pattern, flags);
    this.validateRegExpFlags(state);
    this.validateRegExpPattern(state);
    var value2 = null;
    try {
      value2 = new RegExp(pattern, flags);
    } catch (e) {
    }
    return this.finishToken(types$1.regexp, {
      pattern,
      flags,
      value: value2
    });
  };
  pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
    var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
    var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
    var start = this.pos, total = 0, lastCode = 0;
    for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
      var code = this.input.charCodeAt(this.pos), val = void 0;
      if (allowSeparators && code === 95) {
        if (isLegacyOctalNumericLiteral)
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
        if (lastCode === 95)
          this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
        if (i2 === 0)
          this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
        lastCode = code;
        continue;
      }
      if (code >= 97)
        val = code - 97 + 10;
      else if (code >= 65)
        val = code - 65 + 10;
      else if (code >= 48 && code <= 57)
        val = code - 48;
      else
        val = Infinity;
      if (val >= radix)
        break;
      lastCode = code;
      total = total * radix + val;
    }
    if (allowSeparators && lastCode === 95)
      this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
    if (this.pos === start || len != null && this.pos - start !== len)
      return null;
    return total;
  };
  function stringToNumber(str, isLegacyOctalNumericLiteral) {
    if (isLegacyOctalNumericLiteral)
      return parseInt(str, 8);
    return parseFloat(str.replace(/_/g, ""));
  }
  function stringToBigInt(str) {
    if (typeof BigInt !== "function")
      return null;
    return BigInt(str.replace(/_/g, ""));
  }
  pp.readRadixNumber = function(radix) {
    var start = this.pos;
    this.pos += 2;
    var val = this.readInt(radix);
    if (val == null)
      this.raise(this.start + 2, "Expected number in radix " + radix);
    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
      val = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
    } else if (isIdentifierStart(this.fullCharCodeAtPos()))
      this.raise(this.pos, "Identifier directly after number");
    return this.finishToken(types$1.num, val);
  };
  pp.readNumber = function(startsWithDot) {
    var start = this.pos;
    if (!startsWithDot && this.readInt(10, void 0, true) === null)
      this.raise(start, "Invalid number");
    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
    if (octal && this.strict)
      this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.pos);
    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
      var val$1 = stringToBigInt(this.input.slice(start, this.pos));
      ++this.pos;
      if (isIdentifierStart(this.fullCharCodeAtPos()))
        this.raise(this.pos, "Identifier directly after number");
      return this.finishToken(types$1.num, val$1);
    }
    if (octal && /[89]/.test(this.input.slice(start, this.pos)))
      octal = false;
    if (next === 46 && !octal) {
      ++this.pos;
      this.readInt(10);
      next = this.input.charCodeAt(this.pos);
    }
    if ((next === 69 || next === 101) && !octal) {
      next = this.input.charCodeAt(++this.pos);
      if (next === 43 || next === 45)
        ++this.pos;
      if (this.readInt(10) === null)
        this.raise(start, "Invalid number");
    }
    if (isIdentifierStart(this.fullCharCodeAtPos()))
      this.raise(this.pos, "Identifier directly after number");
    var val = stringToNumber(this.input.slice(start, this.pos), octal);
    return this.finishToken(types$1.num, val);
  };
  pp.readCodePoint = function() {
    var ch = this.input.charCodeAt(this.pos), code;
    if (ch === 123) {
      if (this.options.ecmaVersion < 6)
        this.unexpected();
      var codePos = ++this.pos;
      code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
      ++this.pos;
      if (code > 1114111)
        this.invalidStringToken(codePos, "Code point out of bounds");
    } else
      code = this.readHexChar(4);
    return code;
  };
  pp.readString = function(quote2) {
    var out = "", chunkStart = ++this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length)
        this.raise(this.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.pos);
      if (ch === quote2)
        break;
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.pos;
      } else if (ch === 8232 || ch === 8233) {
        if (this.options.ecmaVersion < 10)
          this.raise(this.start, "Unterminated string constant");
        ++this.pos;
        if (this.options.locations) {
          this.curLine++;
          this.lineStart = this.pos;
        }
      } else {
        if (isNewLine(ch))
          this.raise(this.start, "Unterminated string constant");
        ++this.pos;
      }
    }
    out += this.input.slice(chunkStart, this.pos++);
    return this.finishToken(types$1.string, out);
  };
  var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  pp.tryReadTemplateToken = function() {
    this.inTemplateElement = true;
    try {
      this.readTmplToken();
    } catch (err) {
      if (err === INVALID_TEMPLATE_ESCAPE_ERROR)
        this.readInvalidTemplateToken();
      else
        throw err;
    }
    this.inTemplateElement = false;
  };
  pp.invalidStringToken = function(position, message) {
    if (this.inTemplateElement && this.options.ecmaVersion >= 9)
      throw INVALID_TEMPLATE_ESCAPE_ERROR;
    else
      this.raise(position, message);
  };
  pp.readTmplToken = function() {
    var out = "", chunkStart = this.pos;
    for (; ; ) {
      if (this.pos >= this.input.length)
        this.raise(this.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
        if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
          if (ch === 36) {
            this.pos += 2;
            return this.finishToken(types$1.dollarBraceL);
          } else {
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.pos);
        return this.finishToken(types$1.template, out);
      }
      if (ch === 92) {
        out += this.input.slice(chunkStart, this.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.pos);
        ++this.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.pos) === 10)
              ++this.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        chunkStart = this.pos;
      } else
        ++this.pos;
    }
  };
  pp.readInvalidTemplateToken = function() {
    for (; this.pos < this.input.length; this.pos++)
      switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{")
            break;
        case "`":
          return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      }
    this.raise(this.start, "Unterminated template");
  };
  pp.readEscapedChar = function(inTemplate) {
    var ch = this.input.charCodeAt(++this.pos);
    ++this.pos;
    switch (ch) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120:
        return String.fromCharCode(this.readHexChar(2));
      case 117:
        return codePointToString(this.readCodePoint());
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        if (this.input.charCodeAt(this.pos) === 10)
          ++this.pos;
      case 10:
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      case 56:
      case 57:
        if (this.strict)
          this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
        if (inTemplate) {
          var codePos = this.pos - 1;
          this.invalidStringToken(codePos, "Invalid escape sequence in template string");
          return null;
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          this.pos += octalStr.length - 1;
          ch = this.input.charCodeAt(this.pos);
          if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate))
            this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
          return String.fromCharCode(octal);
        }
        if (isNewLine(ch))
          return "";
        return String.fromCharCode(ch);
    }
  };
  pp.readHexChar = function(len) {
    var codePos = this.pos;
    var n2 = this.readInt(16, len);
    if (n2 === null)
      this.invalidStringToken(codePos, "Bad character escape sequence");
    return n2;
  };
  pp.readWord1 = function() {
    this.containsEsc = false;
    var word = "", first = true, chunkStart = this.pos;
    var astral = this.options.ecmaVersion >= 6;
    while (this.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch, astral))
        this.pos += ch <= 65535 ? 1 : 2;
      else if (ch === 92) {
        this.containsEsc = true;
        word += this.input.slice(chunkStart, this.pos);
        var escStart = this.pos;
        if (this.input.charCodeAt(++this.pos) !== 117)
          this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
        ++this.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
          this.invalidStringToken(escStart, "Invalid Unicode escape");
        word += codePointToString(esc);
        chunkStart = this.pos;
      } else
        break;
      first = false;
    }
    return word + this.input.slice(chunkStart, this.pos);
  };
  pp.readWord = function() {
    var word = this.readWord1();
    var type = types$1.name;
    if (this.keywords.test(word))
      type = keywords[word];
    return this.finishToken(type, word);
  };
  var version = "8.8.1";
  Parser.acorn = {
    Parser,
    version,
    defaultOptions,
    Position,
    SourceLocation,
    getLineInfo,
    Node,
    TokenType,
    tokTypes: types$1,
    keywordTypes: keywords,
    TokContext,
    tokContexts: types,
    isIdentifierChar,
    isIdentifierStart,
    Token,
    isNewLine,
    lineBreak,
    lineBreakG,
    nonASCIIwhitespace
  };
  function parse(input, options) {
    return Parser.parse(input, options);
  }
  function parseExpressionAt(input, pos, options) {
    return Parser.parseExpressionAt(input, pos, options);
  }
  function flatten(nodes, target = []) {
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node2 = nodes[i2];
      if (Array.isArray(node2))
        flatten(node2, target);
      else
        target.push(node2);
    }
    return target;
  }
  const regex_whitespace = /\s/;
  const regex_whitespaces = /\s+/;
  const regex_starts_with_whitespace = /^\s/;
  const regex_starts_with_whitespaces = /^[ \t\r\n]*/;
  const regex_ends_with_whitespace = /\s$/;
  const regex_ends_with_whitespaces = /[ \t\r\n]*$/;
  const regex_only_whitespaces = /^\s+$/;
  const regex_whitespace_characters = /\s/g;
  const regex_non_whitespace_character = /\S/;
  const regex_starts_with_newline = /^\r?\n/;
  const regex_not_newline_characters = /[^\n]/g;
  const regex_double_quotes = /"/g;
  const regex_backslashes = /\\/g;
  const regex_starts_with_underscore = /^_/;
  const regex_ends_with_underscore = /_$/;
  const regex_dimensions = /^(?:offset|client)(?:Width|Height)$/;
  const regex_svelte_ignore = /^\s*svelte-ignore\s+([\s\S]+)\s*$/m;
  function extract_svelte_ignore(text2) {
    const match = regex_svelte_ignore.exec(text2);
    return match ? match[1].split(regex_whitespace).map((x2) => x2.trim()).filter(Boolean) : [];
  }
  function extract_svelte_ignore_from_comments(node2) {
    return flatten((node2.leadingComments || []).map((comment) => extract_svelte_ignore(comment.value)));
  }
  function extract_ignores_above_position(position, template_nodes) {
    const previous_node_idx = template_nodes.findIndex((child) => child.end === position);
    if (previous_node_idx === -1)
      return [];
    for (let i2 = previous_node_idx; i2 >= 0; i2--) {
      const node2 = template_nodes[i2];
      if (node2.type !== "Comment" && node2.type !== "Text")
        return [];
      if (node2.type === "Comment") {
        if (node2.ignores.length)
          return node2.ignores;
      }
    }
    return [];
  }
  function fuzzymatch(name, names) {
    const set = new FuzzySet(names);
    const matches = set.get(name);
    return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
  }
  const GRAM_SIZE_LOWER = 2;
  const GRAM_SIZE_UPPER = 3;
  function _distance(str1, str2) {
    if (str1 === null && str2 === null)
      throw "Trying to compare two null values";
    if (str1 === null || str2 === null)
      return 0;
    str1 = String(str1);
    str2 = String(str2);
    const distance = levenshtein(str1, str2);
    if (str1.length > str2.length)
      return 1 - distance / str1.length;
    else
      return 1 - distance / str2.length;
  }
  function levenshtein(str1, str2) {
    const current = [];
    let prev;
    let value2;
    for (let i2 = 0; i2 <= str2.length; i2++)
      for (let j = 0; j <= str1.length; j++) {
        if (i2 && j) {
          if (str1.charAt(j - 1) === str2.charAt(i2 - 1))
            value2 = prev;
          else
            value2 = Math.min(current[j], current[j - 1], prev) + 1;
        } else
          value2 = i2 + j;
        prev = current[j];
        current[j] = value2;
      }
    return current.pop();
  }
  const non_word_regex = /[^\w, ]+/;
  function iterate_grams(value2, gram_size = 2) {
    const simplified = "-" + value2.toLowerCase().replace(non_word_regex, "") + "-";
    const len_diff = gram_size - simplified.length;
    const results = [];
    if (len_diff > 0)
      for (let i2 = 0; i2 < len_diff; ++i2)
        value2 += "-";
    for (let i2 = 0; i2 < simplified.length - gram_size + 1; ++i2)
      results.push(simplified.slice(i2, i2 + gram_size));
    return results;
  }
  function gram_counter(value2, gram_size = 2) {
    const result = {};
    const grams = iterate_grams(value2, gram_size);
    let i2 = 0;
    for (i2; i2 < grams.length; ++i2)
      if (grams[i2] in result)
        result[grams[i2]] += 1;
      else
        result[grams[i2]] = 1;
    return result;
  }
  function sort_descending(a, b2) {
    return b2[0] - a[0];
  }
  class FuzzySet {
    constructor(arr) {
      this.exact_set = {};
      this.match_dict = {};
      this.items = {};
      for (let i2 = GRAM_SIZE_LOWER; i2 < GRAM_SIZE_UPPER + 1; ++i2)
        this.items[i2] = [];
      for (let i2 = 0; i2 < arr.length; ++i2)
        this.add(arr[i2]);
    }
    add(value2) {
      const normalized_value = value2.toLowerCase();
      if (normalized_value in this.exact_set)
        return false;
      let i2 = GRAM_SIZE_LOWER;
      for (i2; i2 < GRAM_SIZE_UPPER + 1; ++i2)
        this._add(value2, i2);
    }
    _add(value2, gram_size) {
      const normalized_value = value2.toLowerCase();
      const items = this.items[gram_size] || [];
      const index = items.length;
      items.push(0);
      const gram_counts = gram_counter(normalized_value, gram_size);
      let sum_of_square_gram_counts = 0;
      let gram;
      let gram_count;
      for (gram in gram_counts) {
        gram_count = gram_counts[gram];
        sum_of_square_gram_counts += Math.pow(gram_count, 2);
        if (gram in this.match_dict)
          this.match_dict[gram].push([
            index,
            gram_count
          ]);
        else
          this.match_dict[gram] = [
            [
              index,
              gram_count
            ]
          ];
      }
      const vector_normal = Math.sqrt(sum_of_square_gram_counts);
      items[index] = [
        vector_normal,
        normalized_value
      ];
      this.items[gram_size] = items;
      this.exact_set[normalized_value] = value2;
    }
    get(value2) {
      const normalized_value = value2.toLowerCase();
      const result = this.exact_set[normalized_value];
      if (result)
        return [
          [
            1,
            result
          ]
        ];
      let results = [];
      for (let gram_size = GRAM_SIZE_UPPER; gram_size >= GRAM_SIZE_LOWER; --gram_size) {
        results = this.__get(value2, gram_size);
        if (results)
          return results;
      }
      return null;
    }
    __get(value2, gram_size) {
      const normalized_value = value2.toLowerCase();
      const matches = {};
      const gram_counts = gram_counter(normalized_value, gram_size);
      const items = this.items[gram_size];
      let sum_of_square_gram_counts = 0;
      let gram;
      let gram_count;
      let i2;
      let index;
      let other_gram_count;
      for (gram in gram_counts) {
        gram_count = gram_counts[gram];
        sum_of_square_gram_counts += Math.pow(gram_count, 2);
        if (gram in this.match_dict)
          for (i2 = 0; i2 < this.match_dict[gram].length; ++i2) {
            index = this.match_dict[gram][i2][0];
            other_gram_count = this.match_dict[gram][i2][1];
            if (index in matches)
              matches[index] += gram_count * other_gram_count;
            else
              matches[index] = gram_count * other_gram_count;
          }
      }
      const vector_normal = Math.sqrt(sum_of_square_gram_counts);
      let results = [];
      let match_score;
      for (const match_index in matches) {
        match_score = matches[match_index];
        results.push([
          match_score / (vector_normal * items[match_index][0]),
          items[match_index][1]
        ]);
      }
      results.sort(sort_descending);
      let new_results = [];
      const end_index = Math.min(50, results.length);
      for (let i3 = 0; i3 < end_index; ++i3)
        new_results.push([
          _distance(results[i3][1], normalized_value),
          results[i3][1]
        ]);
      results = new_results;
      results.sort(sort_descending);
      new_results = [];
      for (let i3 = 0; i3 < results.length; ++i3)
        if (results[i3][0] == results[0][0])
          new_results.push([
            results[i3][0],
            this.exact_set[results[i3][1]]
          ]);
      return new_results;
    }
  }
  const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
  const html_element_names = /^(?:a|abbr|address|area|article|aside|audio|b|base|bdi|bdo|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|data|datalist|dd|del|details|dfn|dialog|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|head|header|hr|html|i|iframe|img|input|ins|kbd|label|legend|li|link|main|map|mark|meta|meter|nav|noscript|object|ol|optgroup|option|output|p|param|picture|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|source|span|strong|style|sub|summary|sup|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|u|ul|var|video|wbr)$/;
  const svg = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|svg|switch|symbol|text|textPath|tref|tspan|unknown|use|view|vkern)$/;
  function is_void(name) {
    return void_element_names.test(name) || name.toLowerCase() === "!doctype";
  }
  function is_html(name) {
    return html_element_names.test(name);
  }
  function is_svg(name) {
    return svg.test(name);
  }
  function list$1(items, conjunction = "or") {
    if (items.length === 1)
      return items[0];
    return `${items.slice(0, -1).join(", ")} ${conjunction} ${items[items.length - 1]}`;
  }
  var parser_errors = {
    css_syntax_error: (message) => ({
      code: "css-syntax-error",
      message
    }),
    duplicate_attribute: {
      code: "duplicate-attribute",
      message: "Attributes need to be unique"
    },
    duplicate_element: (slug, name) => ({
      code: `duplicate-${slug}`,
      message: `A component can only have one <${name}> tag`
    }),
    duplicate_style: {
      code: "duplicate-style",
      message: "You can only have one top-level <style> tag per component"
    },
    empty_attribute_shorthand: {
      code: "empty-attribute-shorthand",
      message: "Attribute shorthand cannot be empty"
    },
    empty_directive_name: (type) => ({
      code: "empty-directive-name",
      message: `${type} name cannot be empty`
    }),
    empty_global_selector: {
      code: "css-syntax-error",
      message: ":global() must contain a selector"
    },
    expected_block_type: {
      code: "expected-block-type",
      message: "Expected if, each or await"
    },
    expected_name: {
      code: "expected-name",
      message: "Expected name"
    },
    invalid_catch_placement_unclosed_block: (block) => ({
      code: "invalid-catch-placement",
      message: `Expected to close ${block} before seeing {:catch} block`
    }),
    invalid_catch_placement_without_await: {
      code: "invalid-catch-placement",
      message: "Cannot have an {:catch} block outside an {#await ...} block"
    },
    invalid_component_definition: {
      code: "invalid-component-definition",
      message: "invalid component definition"
    },
    invalid_closing_tag_unopened: (name) => ({
      code: "invalid-closing-tag",
      message: `</${name}> attempted to close an element that was not open`
    }),
    invalid_closing_tag_autoclosed: (name, reason) => ({
      code: "invalid-closing-tag",
      message: `</${name}> attempted to close <${name}> that was already automatically closed by <${reason}>`
    }),
    invalid_debug_args: {
      code: "invalid-debug-args",
      message: "{@debug ...} arguments must be identifiers, not arbitrary expressions"
    },
    invalid_declaration: {
      code: "invalid-declaration",
      message: "Declaration cannot be empty"
    },
    invalid_directive_value: {
      code: "invalid-directive-value",
      message: "Directive value must be a JavaScript expression enclosed in curly braces"
    },
    invalid_elseif: {
      code: "invalid-elseif",
      message: "'elseif' should be 'else if'"
    },
    invalid_elseif_placement_outside_if: {
      code: "invalid-elseif-placement",
      message: "Cannot have an {:else if ...} block outside an {#if ...} block"
    },
    invalid_elseif_placement_unclosed_block: (block) => ({
      code: "invalid-elseif-placement",
      message: `Expected to close ${block} before seeing {:else if ...} block`
    }),
    invalid_else_placement_outside_if: {
      code: "invalid-else-placement",
      message: "Cannot have an {:else} block outside an {#if ...} or {#each ...} block"
    },
    invalid_else_placement_unclosed_block: (block) => ({
      code: "invalid-else-placement",
      message: `Expected to close ${block} before seeing {:else} block`
    }),
    invalid_element_content: (slug, name) => ({
      code: `invalid-${slug}-content`,
      message: `<${name}> cannot have children`
    }),
    invalid_element_definition: {
      code: "invalid-element-definition",
      message: "Invalid element definition"
    },
    invalid_element_placement: (slug, name) => ({
      code: `invalid-${slug}-placement`,
      message: `<${name}> tags cannot be inside elements or blocks`
    }),
    invalid_logic_block_placement: (location, name) => ({
      code: "invalid-logic-block-placement",
      message: `{#${name}} logic block cannot be ${location}`
    }),
    invalid_tag_placement: (location, name) => ({
      code: "invalid-tag-placement",
      message: `{@${name}} tag cannot be ${location}`
    }),
    invalid_ref_directive: (name) => ({
      code: "invalid-ref-directive",
      message: `The ref directive is no longer supported — use \`bind:this={${name}}\` instead`
    }),
    invalid_ref_selector: {
      code: "invalid-ref-selector",
      message: "ref selectors are no longer supported"
    },
    invalid_self_placement: {
      code: "invalid-self-placement",
      message: "<svelte:self> components can only exist inside {#if} blocks, {#each} blocks, or slots passed to components"
    },
    invalid_script_instance: {
      code: "invalid-script",
      message: "A component can only have one instance-level <script> element"
    },
    invalid_script_module: {
      code: "invalid-script",
      message: 'A component can only have one <script context="module"> element'
    },
    invalid_script_context_attribute: {
      code: "invalid-script",
      message: "context attribute must be static"
    },
    invalid_script_context_value: {
      code: "invalid-script",
      message: 'If the context attribute is supplied, its value must be "module"'
    },
    invalid_tag_name: {
      code: "invalid-tag-name",
      message: "Expected valid tag name"
    },
    invalid_tag_name_svelte_element: (tags, match) => ({
      code: "invalid-tag-name",
      message: `Valid <svelte:...> tag names are ${list$1(tags)}${match ? " (did you mean " + match + "?)" : ""}`
    }),
    invalid_then_placement_unclosed_block: (block) => ({
      code: "invalid-then-placement",
      message: `Expected to close ${block} before seeing {:then} block`
    }),
    invalid_then_placement_without_await: {
      code: "invalid-then-placement",
      message: "Cannot have an {:then} block outside an {#await ...} block"
    },
    invalid_void_content: (name) => ({
      code: "invalid-void-content",
      message: `<${name}> is a void element and cannot have children, or a closing tag`
    }),
    missing_component_definition: {
      code: "missing-component-definition",
      message: "<svelte:component> must have a 'this' attribute"
    },
    missing_attribute_value: {
      code: "missing-attribute-value",
      message: "Expected value for the attribute"
    },
    missing_element_definition: {
      code: "missing-element-definition",
      message: "<svelte:element> must have a 'this' attribute"
    },
    unclosed_script: {
      code: "unclosed-script",
      message: "<script> must have a closing tag"
    },
    unclosed_style: {
      code: "unclosed-style",
      message: "<style> must have a closing tag"
    },
    unclosed_comment: {
      code: "unclosed-comment",
      message: "comment was left open, expected -->"
    },
    unclosed_attribute_value: (token) => ({
      code: "unclosed-attribute-value",
      message: `Expected to close the attribute value with ${token}`
    }),
    unexpected_block_close: {
      code: "unexpected-block-close",
      message: "Unexpected block closing tag"
    },
    unexpected_eof: {
      code: "unexpected-eof",
      message: "Unexpected end of input"
    },
    unexpected_eof_token: (token) => ({
      code: "unexpected-eof",
      message: `Unexpected ${token}`
    }),
    unexpected_token: (token) => ({
      code: "unexpected-token",
      message: `Expected ${token}`
    }),
    unexpected_token_destructure: {
      code: "unexpected-token",
      message: "Expected identifier or destructure pattern"
    }
  };
  class WalkerBase {
    constructor() {
      this.should_skip = false;
      this.should_remove = false;
      this.replacement = null;
      this.context = {
        skip: () => this.should_skip = true,
        remove: () => this.should_remove = true,
        replace: (node2) => this.replacement = node2
      };
    }
    /**
    *
    * @param {any} parent
    * @param {string} prop
    * @param {number} index
    * @param {BaseNode} node
    */
    replace(parent, prop, index, node2) {
      if (parent) {
        if (index !== null)
          parent[prop][index] = node2;
        else
          parent[prop] = node2;
      }
    }
    /**
    *
    * @param {any} parent
    * @param {string} prop
    * @param {number} index
    */
    remove(parent, prop, index) {
      if (parent) {
        if (index !== null)
          parent[prop].splice(index, 1);
        else
          delete parent[prop];
      }
    }
  }
  class SyncWalker extends WalkerBase {
    /**
    *
    * @param {SyncHandler} enter
    * @param {SyncHandler} leave
    */
    constructor(enter, leave) {
      super();
      this.enter = enter;
      this.leave = leave;
    }
    /**
    *
    * @param {BaseNode} node
    * @param {BaseNode} parent
    * @param {string} [prop]
    * @param {number} [index]
    * @returns {BaseNode}
    */
    visit(node2, parent, prop, index) {
      if (node2) {
        if (this.enter) {
          const _should_skip = this.should_skip;
          const _should_remove = this.should_remove;
          const _replacement = this.replacement;
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          this.enter.call(this.context, node2, parent, prop, index);
          if (this.replacement) {
            node2 = this.replacement;
            this.replace(parent, prop, index, node2);
          }
          if (this.should_remove)
            this.remove(parent, prop, index);
          const skipped = this.should_skip;
          const removed = this.should_remove;
          this.should_skip = _should_skip;
          this.should_remove = _should_remove;
          this.replacement = _replacement;
          if (skipped)
            return node2;
          if (removed)
            return null;
        }
        for (const key in node2) {
          const value2 = node2[key];
          if (typeof value2 !== "object")
            continue;
          else if (Array.isArray(value2))
            for (let i2 = 0; i2 < value2.length; i2 += 1) {
              if (value2[i2] !== null && typeof value2[i2].type === "string") {
                if (!this.visit(value2[i2], node2, key, i2))
                  i2--;
              }
            }
          else if (value2 !== null && typeof value2.type === "string")
            this.visit(value2, node2, key, null);
        }
        if (this.leave) {
          const _replacement = this.replacement;
          const _should_remove = this.should_remove;
          this.replacement = null;
          this.should_remove = false;
          this.leave.call(this.context, node2, parent, prop, index);
          if (this.replacement) {
            node2 = this.replacement;
            this.replace(parent, prop, index, node2);
          }
          if (this.should_remove)
            this.remove(parent, prop, index);
          const removed = this.should_remove;
          this.replacement = _replacement;
          this.should_remove = _should_remove;
          if (removed)
            return null;
        }
      }
      return node2;
    }
  }
  function walk(ast, { enter, leave }) {
    const instance = new SyncWalker(enter, leave);
    return instance.visit(ast, null);
  }
  const id = Math.round(Math.random() * 1e20).toString(36);
  const re = new RegExp(`_${id}_(?:(\\d+)|(AT)|(HASH))_(\\w+)?`, "g");
  const get_comment_handlers = (comments, raw) => ({
    // pass to acorn options
    /**
    * @param {boolean} block
    * @param {string} value
    * @param {number} start
    * @param {number} end
    */
    onComment: (block, value2, start, end) => {
      if (block && /\n/.test(value2)) {
        let a = start;
        while (a > 0 && raw[a - 1] !== "\n")
          a -= 1;
        let b2 = a;
        while (/[ \t]/.test(raw[b2]))
          b2 += 1;
        const indentation = raw.slice(a, b2);
        value2 = value2.replace(new RegExp(`^${indentation}`, "gm"), "");
      }
      comments.push({
        type: block ? "Block" : "Line",
        value: value2,
        start,
        end
      });
    },
    // pass to estree-walker options
    /** @param {NodeWithLocation} node */
    enter(node2) {
      let comment;
      while (comments[0] && comments[0].start < node2.start) {
        comment = comments.shift();
        comment.value = comment.value.replace(re, (match, id2, at, hash2, value2) => {
          if (hash2)
            return `#${value2}`;
          if (at)
            return `@${value2}`;
          return match;
        });
        const next = comments[0] || node2;
        comment.has_trailing_newline = comment.type === "Line" || /\n/.test(raw.slice(comment.end, next.start));
        (node2.leadingComments || (node2.leadingComments = [])).push(comment);
      }
    },
    /** @param {NodeWithLocation} node */
    leave(node2) {
      if (comments[0]) {
        const slice2 = raw.slice(node2.end, comments[0].start);
        if (/^[,) \t]*$/.test(slice2))
          node2.trailingComments = [
            comments.shift()
          ];
      }
    }
  });
  function is_reference(node2, parent) {
    if (node2.type === "MemberExpression")
      return !node2.computed && is_reference(node2.object, node2);
    if (node2.type === "Identifier") {
      if (!parent)
        return true;
      switch (parent.type) {
        case "MemberExpression":
          return parent.computed || node2 === parent.object;
        case "MethodDefinition":
          return parent.computed;
        case "PropertyDefinition":
          return parent.computed || node2 === parent.value;
        case "Property":
          return parent.computed || node2 === parent.value;
        case "ExportSpecifier":
        case "ImportSpecifier":
          return node2 === parent.local;
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        default:
          return true;
      }
    }
    return false;
  }
  function analyze(expression) {
    const map = /* @__PURE__ */ new WeakMap();
    const globals2 = /* @__PURE__ */ new Map();
    const scope2 = new Scope$1(null, false);
    const references = [];
    let current_scope = scope2;
    walk(expression, {
      /**
      * @param {Node} node
      * @param {any} parent
      */
      enter(node2, parent) {
        switch (node2.type) {
          case "Identifier":
            if (is_reference(node2, parent))
              references.push([
                current_scope,
                node2
              ]);
            break;
          case "ImportDeclaration":
            node2.specifiers.forEach((specifier) => {
              current_scope.declarations.set(specifier.local.name, specifier);
            });
            break;
          case "FunctionExpression":
          case "FunctionDeclaration":
          case "ArrowFunctionExpression":
            if (node2.type === "FunctionDeclaration") {
              if (node2.id)
                current_scope.declarations.set(node2.id.name, node2);
              map.set(node2, current_scope = new Scope$1(current_scope, false));
            } else {
              map.set(node2, current_scope = new Scope$1(current_scope, false));
              if (node2.type === "FunctionExpression" && node2.id)
                current_scope.declarations.set(node2.id.name, node2);
            }
            node2.params.forEach((param) => {
              extract_names(param).forEach((name) => {
                current_scope.declarations.set(name, node2);
              });
            });
            break;
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
            map.set(node2, current_scope = new Scope$1(current_scope, true));
            break;
          case "BlockStatement":
            map.set(node2, current_scope = new Scope$1(current_scope, true));
            break;
          case "ClassDeclaration":
          case "VariableDeclaration":
            current_scope.add_declaration(node2);
            break;
          case "CatchClause":
            map.set(node2, current_scope = new Scope$1(current_scope, true));
            if (node2.param)
              extract_names(node2.param).forEach((name) => {
                current_scope.declarations.set(name, node2.param);
              });
            break;
        }
      },
      /** @param {Node} node */
      leave(node2) {
        if (map.has(node2))
          current_scope = current_scope.parent;
      }
    });
    for (let i2 = references.length - 1; i2 >= 0; --i2) {
      const [scope3, reference] = references[i2];
      if (!scope3.references.has(reference.name))
        add_reference(scope3, reference.name);
      if (!scope3.find_owner(reference.name))
        globals2.set(reference.name, reference);
    }
    return {
      map,
      scope: scope2,
      globals: globals2
    };
  }
  function add_reference(scope2, name) {
    scope2.references.add(name);
    if (scope2.parent)
      add_reference(scope2.parent, name);
  }
  class Scope$1 {
    constructor(parent, block) {
      this.parent = parent;
      this.block = block;
      this.declarations = /* @__PURE__ */ new Map();
      this.initialised_declarations = /* @__PURE__ */ new Set();
      this.references = /* @__PURE__ */ new Set();
    }
    /** @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node */
    add_declaration(node2) {
      if (node2.type === "VariableDeclaration") {
        if (node2.kind === "var" && this.block && this.parent)
          this.parent.add_declaration(node2);
        else {
          const handle_declarator = (declarator) => {
            extract_names(declarator.id).forEach((name) => {
              this.declarations.set(name, node2);
              if (declarator.init)
                this.initialised_declarations.add(name);
            });
          };
          node2.declarations.forEach(handle_declarator);
        }
      } else if (node2.id)
        this.declarations.set(node2.id.name, node2);
    }
    /**
    * @param {string} name
    * @returns {Scope | null}
    */
    find_owner(name) {
      if (this.declarations.has(name))
        return this;
      return this.parent && this.parent.find_owner(name);
    }
    /**
    * @param {string} name
    * @returns {boolean}
    */
    has(name) {
      return this.declarations.has(name) || !!this.parent && this.parent.has(name);
    }
  }
  function extract_names(param) {
    return extract_identifiers(param).map((node2) => node2.name);
  }
  function extract_identifiers(param, nodes = []) {
    switch (param.type) {
      case "Identifier":
        nodes.push(param);
        break;
      case "MemberExpression":
        let object = param;
        while (object.type === "MemberExpression")
          object = /** @type {any} */
          object.object;
        nodes.push(
          /** @type {any} */
          object
        );
        break;
      case "ObjectPattern":
        const handle_prop = (prop) => {
          if (prop.type === "RestElement")
            extract_identifiers(prop.argument, nodes);
          else
            extract_identifiers(prop.value, nodes);
        };
        param.properties.forEach(handle_prop);
        break;
      case "ArrayPattern":
        const handle_element = (element) => {
          if (element)
            extract_identifiers(element, nodes);
        };
        param.elements.forEach(handle_element);
        break;
      case "RestElement":
        extract_identifiers(param.argument, nodes);
        break;
      case "AssignmentPattern":
        extract_identifiers(param.left, nodes);
        break;
    }
    return nodes;
  }
  function push_array(array, items) {
    for (let i2 = 0; i2 < items.length; i2++)
      array.push(items[i2]);
  }
  function handle(node2, state) {
    const handler = handlers[node2.type];
    if (!handler)
      throw new Error(`Not implemented ${node2.type}`);
    const result = handler(node2, state);
    if (node2.leadingComments)
      result.unshift(c(node2.leadingComments.map((comment) => comment.type === "Block" ? `/*${comment.value}*/${comment.has_trailing_newline ? `
${state.indent}` : ` `}` : `//${comment.value}${comment.has_trailing_newline ? `
${state.indent}` : ` `}`).join(``)));
    if (node2.trailingComments)
      state.comments.push(node2.trailingComments[0]);
    return result;
  }
  function c(content, node2) {
    return {
      content,
      loc: node2 && node2.loc,
      has_newline: /\n/.test(content)
    };
  }
  const OPERATOR_PRECEDENCE = {
    "||": 2,
    "&&": 3,
    "??": 4,
    "|": 5,
    "^": 6,
    "&": 7,
    "==": 8,
    "!=": 8,
    "===": 8,
    "!==": 8,
    "<": 9,
    ">": 9,
    "<=": 9,
    ">=": 9,
    in: 9,
    instanceof: 9,
    "<<": 10,
    ">>": 10,
    ">>>": 10,
    "+": 11,
    "-": 11,
    "*": 12,
    "%": 12,
    "/": 12,
    "**": 13
  };
  const EXPRESSIONS_PRECEDENCE = {
    ArrayExpression: 20,
    TaggedTemplateExpression: 20,
    ThisExpression: 20,
    Identifier: 20,
    Literal: 18,
    TemplateLiteral: 20,
    Super: 20,
    SequenceExpression: 20,
    MemberExpression: 19,
    CallExpression: 19,
    NewExpression: 19,
    AwaitExpression: 17,
    ClassExpression: 17,
    FunctionExpression: 17,
    ObjectExpression: 17,
    UpdateExpression: 16,
    UnaryExpression: 15,
    BinaryExpression: 14,
    LogicalExpression: 13,
    ConditionalExpression: 4,
    ArrowFunctionExpression: 3,
    AssignmentExpression: 3,
    YieldExpression: 2,
    RestElement: 1
  };
  function needs_parens(node2, parent, is_right) {
    if (node2.type === "LogicalExpression" && parent.type === "LogicalExpression" && (parent.operator === "??" && node2.operator !== "??" || parent.operator !== "??" && node2.operator === "??"))
      return true;
    const precedence = EXPRESSIONS_PRECEDENCE[node2.type];
    const parent_precedence = EXPRESSIONS_PRECEDENCE[parent.type];
    if (precedence !== parent_precedence)
      return !is_right && precedence === 15 && parent_precedence === 14 && parent.operator === "**" || precedence < parent_precedence;
    if (precedence !== 13 && precedence !== 14)
      return false;
    if (
      /** @type {BinaryExpression} */
      node2.operator === "**" && parent.operator === "**"
    )
      return !is_right;
    if (is_right)
      return OPERATOR_PRECEDENCE[
        /** @type {BinaryExpression} */
        node2.operator
      ] <= OPERATOR_PRECEDENCE[parent.operator];
    return OPERATOR_PRECEDENCE[
      /** @type {BinaryExpression} */
      node2.operator
    ] < OPERATOR_PRECEDENCE[parent.operator];
  }
  function has_call_expression(node2) {
    while (node2) {
      if (node2.type[0] === "CallExpression")
        return true;
      else if (node2.type === "MemberExpression")
        node2 = node2.object;
      else
        return false;
    }
  }
  const has_newline = (chunks) => {
    for (let i2 = 0; i2 < chunks.length; i2 += 1) {
      if (chunks[i2].has_newline)
        return true;
    }
    return false;
  };
  const get_length = (chunks) => {
    let total = 0;
    for (let i2 = 0; i2 < chunks.length; i2 += 1)
      total += chunks[i2].content.length;
    return total;
  };
  const sum = (a, b2) => a + b2;
  const join = (nodes, separator) => {
    if (nodes.length === 0)
      return [];
    const joined = [
      ...nodes[0]
    ];
    for (let i2 = 1; i2 < nodes.length; i2 += 1) {
      joined.push(separator);
      push_array(joined, nodes[i2]);
    }
    return joined;
  };
  const scoped = (fn) => {
    const scoped_fn = (node2, state) => {
      return fn(node2, {
        ...state,
        scope: state.scope_map.get(node2)
      });
    };
    return scoped_fn;
  };
  const deconflict = (name, names) => {
    const original = name;
    let i2 = 1;
    while (names.has(name))
      name = `${original}$${i2++}`;
    return name;
  };
  const handle_body = (nodes, state) => {
    const chunks = [];
    const body = nodes.map((statement) => {
      const chunks2 = handle(statement, {
        ...state,
        indent: state.indent
      });
      let add_newline = false;
      while (state.comments.length) {
        const comment = state.comments.shift();
        const prefix = add_newline ? `
${state.indent}` : ` `;
        chunks2.push(c(comment.type === "Block" ? `${prefix}/*${comment.value}*/` : `${prefix}//${comment.value}`));
        add_newline = comment.type === "Line";
      }
      return chunks2;
    });
    let needed_padding = false;
    for (let i2 = 0; i2 < body.length; i2 += 1) {
      const needs_padding = has_newline(body[i2]);
      if (i2 > 0)
        chunks.push(c(needs_padding || needed_padding ? `

${state.indent}` : `
${state.indent}`));
      push_array(chunks, body[i2]);
      needed_padding = needs_padding;
    }
    return chunks;
  };
  const handle_var_declaration = (node2, state) => {
    const chunks = [
      c(`${node2.kind} `)
    ];
    const declarators = node2.declarations.map((d) => handle(d, {
      ...state,
      indent: state.indent + (node2.declarations.length === 1 ? "" : "	")
    }));
    const multiple_lines = declarators.some(has_newline) || declarators.map(get_length).reduce(sum, 0) + (state.indent.length + declarators.length - 1) * 2 > 80;
    const separator = c(multiple_lines ? `,
${state.indent}	` : ", ");
    push_array(chunks, join(declarators, separator));
    return chunks;
  };
  const handlers = {
    Program(node2, state) {
      return handle_body(node2.body, state);
    },
    BlockStatement: scoped((node2, state) => {
      return [
        c(`{
${state.indent}	`),
        ...handle_body(node2.body, {
          ...state,
          indent: state.indent + "	"
        }),
        c(`
${state.indent}}`)
      ];
    }),
    EmptyStatement(node2, state) {
      return [
        c(";")
      ];
    },
    ParenthesizedExpression(node2, state) {
      return handle(node2.expression, state);
    },
    ExpressionStatement(node2, state) {
      if (node2.expression.type === "AssignmentExpression" && node2.expression.left.type === "ObjectPattern")
        return [
          c("("),
          ...handle(node2.expression, state),
          c(");")
        ];
      return [
        ...handle(node2.expression, state),
        c(";")
      ];
    },
    IfStatement(node2, state) {
      const chunks = [
        c("if ("),
        ...handle(node2.test, state),
        c(") "),
        ...handle(node2.consequent, state)
      ];
      if (node2.alternate) {
        chunks.push(c(" else "));
        push_array(chunks, handle(node2.alternate, state));
      }
      return chunks;
    },
    LabeledStatement(node2, state) {
      return [
        ...handle(node2.label, state),
        c(": "),
        ...handle(node2.body, state)
      ];
    },
    BreakStatement(node2, state) {
      return node2.label ? [
        c("break "),
        ...handle(node2.label, state),
        c(";")
      ] : [
        c("break;")
      ];
    },
    ContinueStatement(node2, state) {
      return node2.label ? [
        c("continue "),
        ...handle(node2.label, state),
        c(";")
      ] : [
        c("continue;")
      ];
    },
    WithStatement(node2, state) {
      return [
        c("with ("),
        ...handle(node2.object, state),
        c(") "),
        ...handle(node2.body, state)
      ];
    },
    SwitchStatement(node2, state) {
      const chunks = [
        c("switch ("),
        ...handle(node2.discriminant, state),
        c(") {")
      ];
      node2.cases.forEach((block) => {
        if (block.test) {
          chunks.push(c(`
${state.indent}	case `));
          push_array(chunks, handle(block.test, {
            ...state,
            indent: `${state.indent}	`
          }));
          chunks.push(c(":"));
        } else
          chunks.push(c(`
${state.indent}	default:`));
        block.consequent.forEach((statement) => {
          chunks.push(c(`
${state.indent}		`));
          push_array(chunks, handle(statement, {
            ...state,
            indent: `${state.indent}		`
          }));
        });
      });
      chunks.push(c(`
${state.indent}}`));
      return chunks;
    },
    ReturnStatement(node2, state) {
      if (node2.argument) {
        const contains_comment = node2.argument.leadingComments && node2.argument.leadingComments.some((comment) => comment.has_trailing_newline);
        return [
          c(contains_comment ? "return (" : "return "),
          ...handle(node2.argument, state),
          c(contains_comment ? ");" : ";")
        ];
      } else
        return [
          c("return;")
        ];
    },
    ThrowStatement(node2, state) {
      return [
        c("throw "),
        ...handle(node2.argument, state),
        c(";")
      ];
    },
    TryStatement(node2, state) {
      const chunks = [
        c("try "),
        ...handle(node2.block, state)
      ];
      if (node2.handler) {
        if (node2.handler.param) {
          chunks.push(c(" catch("));
          push_array(chunks, handle(node2.handler.param, state));
          chunks.push(c(") "));
        } else
          chunks.push(c(" catch "));
        push_array(chunks, handle(node2.handler.body, state));
      }
      if (node2.finalizer) {
        chunks.push(c(" finally "));
        push_array(chunks, handle(node2.finalizer, state));
      }
      return chunks;
    },
    WhileStatement(node2, state) {
      return [
        c("while ("),
        ...handle(node2.test, state),
        c(") "),
        ...handle(node2.body, state)
      ];
    },
    DoWhileStatement(node2, state) {
      return [
        c("do "),
        ...handle(node2.body, state),
        c(" while ("),
        ...handle(node2.test, state),
        c(");")
      ];
    },
    ForStatement: scoped((node2, state) => {
      const chunks = [
        c("for (")
      ];
      if (node2.init) {
        if (node2.init.type === "VariableDeclaration")
          push_array(chunks, handle_var_declaration(node2.init, state));
        else
          push_array(chunks, handle(node2.init, state));
      }
      chunks.push(c("; "));
      if (node2.test)
        push_array(chunks, handle(node2.test, state));
      chunks.push(c("; "));
      if (node2.update)
        push_array(chunks, handle(node2.update, state));
      chunks.push(c(") "));
      push_array(chunks, handle(node2.body, state));
      return chunks;
    }),
    ForInStatement: scoped((node2, state) => {
      const chunks = [
        c(`for ${node2.await ? "await " : ""}(`)
      ];
      if (node2.left.type === "VariableDeclaration")
        push_array(chunks, handle_var_declaration(node2.left, state));
      else
        push_array(chunks, handle(node2.left, state));
      chunks.push(c(node2.type === "ForInStatement" ? ` in ` : ` of `));
      push_array(chunks, handle(node2.right, state));
      chunks.push(c(") "));
      push_array(chunks, handle(node2.body, state));
      return chunks;
    }),
    DebuggerStatement(node2, state) {
      return [
        c("debugger", node2),
        c(";")
      ];
    },
    FunctionDeclaration: scoped((node2, state) => {
      const chunks = [];
      if (node2.async)
        chunks.push(c("async "));
      chunks.push(c(node2.generator ? "function* " : "function "));
      if (node2.id)
        push_array(chunks, handle(node2.id, state));
      chunks.push(c("("));
      const params = node2.params.map((p2) => handle(p2, {
        ...state,
        indent: state.indent + "	"
      }));
      const multiple_lines = params.some(has_newline) || params.map(get_length).reduce(sum, 0) + (state.indent.length + params.length - 1) * 2 > 80;
      const separator = c(multiple_lines ? `,
${state.indent}` : ", ");
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}	`));
        push_array(chunks, join(params, separator));
        chunks.push(c(`
${state.indent}`));
      } else
        push_array(chunks, join(params, separator));
      chunks.push(c(") "));
      push_array(chunks, handle(node2.body, state));
      return chunks;
    }),
    VariableDeclaration(node2, state) {
      return handle_var_declaration(node2, state).concat(c(";"));
    },
    VariableDeclarator(node2, state) {
      if (node2.init)
        return [
          ...handle(node2.id, state),
          c(" = "),
          ...handle(node2.init, state)
        ];
      else
        return handle(node2.id, state);
    },
    ClassDeclaration(node2, state) {
      const chunks = [
        c("class ")
      ];
      if (node2.id) {
        push_array(chunks, handle(node2.id, state));
        chunks.push(c(" "));
      }
      if (node2.superClass) {
        chunks.push(c("extends "));
        push_array(chunks, handle(node2.superClass, state));
        chunks.push(c(" "));
      }
      push_array(chunks, handle(node2.body, state));
      return chunks;
    },
    ImportDeclaration(node2, state) {
      const chunks = [
        c("import ")
      ];
      const { length } = node2.specifiers;
      const source = handle(node2.source, state);
      if (length > 0) {
        let i2 = 0;
        while (i2 < length) {
          if (i2 > 0)
            chunks.push(c(", "));
          const specifier = node2.specifiers[i2];
          if (specifier.type === "ImportDefaultSpecifier") {
            chunks.push(c(specifier.local.name, specifier));
            i2 += 1;
          } else if (specifier.type === "ImportNamespaceSpecifier") {
            chunks.push(c("* as " + specifier.local.name, specifier));
            i2 += 1;
          } else
            break;
        }
        if (i2 < length) {
          const specifiers = node2.specifiers.slice(i2).map((specifier) => {
            const name = handle(specifier.imported, state)[0];
            const as = handle(specifier.local, state)[0];
            if (name.content === as.content)
              return [
                as
              ];
            return [
              name,
              c(" as "),
              as
            ];
          });
          const width = get_length(chunks) + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length + 6 + get_length(source);
          if (width > 80) {
            chunks.push(c(`{
	`));
            push_array(chunks, join(specifiers, c(",\n	")));
            chunks.push(c("\n}"));
          } else {
            chunks.push(c(`{ `));
            push_array(chunks, join(specifiers, c(", ")));
            chunks.push(c(" }"));
          }
        }
        chunks.push(c(" from "));
      }
      push_array(chunks, source);
      chunks.push(c(";"));
      return chunks;
    },
    ImportExpression(node2, state) {
      return [
        c("import("),
        ...handle(node2.source, state),
        c(")")
      ];
    },
    ExportDefaultDeclaration(node2, state) {
      const chunks = [
        c(`export default `),
        ...handle(node2.declaration, state)
      ];
      if (node2.declaration.type !== "FunctionDeclaration")
        chunks.push(c(";"));
      return chunks;
    },
    ExportNamedDeclaration(node2, state) {
      const chunks = [
        c("export ")
      ];
      if (node2.declaration)
        push_array(chunks, handle(node2.declaration, state));
      else {
        const specifiers = node2.specifiers.map((specifier) => {
          const name = handle(specifier.local, state)[0];
          const as = handle(specifier.exported, state)[0];
          if (name.content === as.content)
            return [
              name
            ];
          return [
            name,
            c(" as "),
            as
          ];
        });
        const width = 7 + specifiers.map(get_length).reduce(sum, 0) + 2 * specifiers.length;
        if (width > 80) {
          chunks.push(c("{\n	"));
          push_array(chunks, join(specifiers, c(",\n	")));
          chunks.push(c("\n}"));
        } else {
          chunks.push(c("{ "));
          push_array(chunks, join(specifiers, c(", ")));
          chunks.push(c(" }"));
        }
        if (node2.source) {
          chunks.push(c(" from "));
          push_array(chunks, handle(node2.source, state));
        }
      }
      chunks.push(c(";"));
      return chunks;
    },
    ExportAllDeclaration(node2, state) {
      return [
        c(`export * from `),
        ...handle(node2.source, state),
        c(`;`)
      ];
    },
    MethodDefinition(node2, state) {
      const chunks = [];
      if (node2.static)
        chunks.push(c("static "));
      if (node2.kind === "get" || node2.kind === "set")
        chunks.push(c(node2.kind + " "));
      if (node2.value.async)
        chunks.push(c("async "));
      if (node2.value.generator)
        chunks.push(c("*"));
      if (node2.computed) {
        chunks.push(c("["));
        push_array(chunks, handle(node2.key, state));
        chunks.push(c("]"));
      } else
        push_array(chunks, handle(node2.key, state));
      chunks.push(c("("));
      const { params } = node2.value;
      for (let i2 = 0; i2 < params.length; i2 += 1) {
        push_array(chunks, handle(params[i2], state));
        if (i2 < params.length - 1)
          chunks.push(c(", "));
      }
      chunks.push(c(") "));
      push_array(chunks, handle(node2.value.body, state));
      return chunks;
    },
    ArrowFunctionExpression: scoped((node2, state) => {
      const chunks = [];
      if (node2.async)
        chunks.push(c("async "));
      if (node2.params.length === 1 && node2.params[0].type === "Identifier")
        push_array(chunks, handle(node2.params[0], state));
      else {
        const params = node2.params.map((param) => handle(param, {
          ...state,
          indent: state.indent + "	"
        }));
        chunks.push(c("("));
        push_array(chunks, join(params, c(", ")));
        chunks.push(c(")"));
      }
      chunks.push(c(" => "));
      if (node2.body.type === "ObjectExpression" || node2.body.type === "AssignmentExpression" && node2.body.left.type === "ObjectPattern") {
        chunks.push(c("("));
        push_array(chunks, handle(node2.body, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.body, state));
      return chunks;
    }),
    ThisExpression(node2, state) {
      return [
        c("this", node2)
      ];
    },
    Super(node2, state) {
      return [
        c("super", node2)
      ];
    },
    RestElement(node2, state) {
      return [
        c("..."),
        ...handle(node2.argument, state)
      ];
    },
    YieldExpression(node2, state) {
      if (node2.argument)
        return [
          c(node2.delegate ? `yield* ` : `yield `),
          ...handle(node2.argument, state)
        ];
      return [
        c(node2.delegate ? `yield*` : `yield`)
      ];
    },
    AwaitExpression(node2, state) {
      if (node2.argument) {
        const precedence = EXPRESSIONS_PRECEDENCE[node2.argument.type];
        if (precedence && precedence < EXPRESSIONS_PRECEDENCE.AwaitExpression)
          return [
            c("await ("),
            ...handle(node2.argument, state),
            c(")")
          ];
        else
          return [
            c("await "),
            ...handle(node2.argument, state)
          ];
      }
      return [
        c("await")
      ];
    },
    TemplateLiteral(node2, state) {
      const chunks = [
        c("`")
      ];
      const { quasis, expressions } = node2;
      for (let i2 = 0; i2 < expressions.length; i2++) {
        chunks.push(c(quasis[i2].value.raw), c("${"));
        push_array(chunks, handle(expressions[i2], state));
        chunks.push(c("}"));
      }
      chunks.push(c(quasis[quasis.length - 1].value.raw), c("`"));
      return chunks;
    },
    TaggedTemplateExpression(node2, state) {
      return handle(node2.tag, state).concat(handle(node2.quasi, state));
    },
    ArrayExpression(node2, state) {
      const chunks = [
        c("[")
      ];
      const elements = [];
      let sparse_commas = [];
      for (let i2 = 0; i2 < node2.elements.length; i2 += 1) {
        const element = node2.elements[i2];
        if (element) {
          elements.push([
            ...sparse_commas,
            ...handle(element, {
              ...state,
              indent: state.indent + "	"
            })
          ]);
          sparse_commas = [];
        } else
          sparse_commas.push(c(","));
      }
      const multiple_lines = elements.some(has_newline) || elements.map(get_length).reduce(sum, 0) + (state.indent.length + elements.length - 1) * 2 > 80;
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}	`));
        push_array(chunks, join(elements, c(`,
${state.indent}	`)));
        chunks.push(c(`
${state.indent}`));
        push_array(chunks, sparse_commas);
      } else {
        push_array(chunks, join(elements, c(", ")));
        push_array(chunks, sparse_commas);
      }
      chunks.push(c("]"));
      return chunks;
    },
    ObjectExpression(node2, state) {
      if (node2.properties.length === 0)
        return [
          c("{}")
        ];
      let has_inline_comment = false;
      const chunks = [];
      const separator = c(", ");
      node2.properties.forEach((p2, i2) => {
        push_array(chunks, handle(p2, {
          ...state,
          indent: state.indent + "	"
        }));
        if (state.comments.length) {
          chunks.push(c(", "));
          while (state.comments.length) {
            const comment = state.comments.shift();
            chunks.push(c(comment.type === "Block" ? `/*${comment.value}*/
${state.indent}	` : `//${comment.value}
${state.indent}	`));
            if (comment.type === "Line")
              has_inline_comment = true;
          }
        } else if (i2 < node2.properties.length - 1)
          chunks.push(separator);
      });
      const multiple_lines = has_inline_comment || has_newline(chunks) || get_length(chunks) > 40;
      if (multiple_lines)
        separator.content = `,
${state.indent}	`;
      return [
        c(multiple_lines ? `{
${state.indent}	` : `{ `),
        ...chunks,
        c(multiple_lines ? `
${state.indent}}` : ` }`)
      ];
    },
    Property(node2, state) {
      const value2 = handle(node2.value, state);
      if (node2.key === node2.value)
        return value2;
      if (!node2.computed && node2.value.type === "AssignmentPattern" && node2.value.left.type === "Identifier" && node2.value.left.name === node2.key.name)
        return value2;
      if (!node2.computed && node2.value.type === "Identifier" && (node2.key.type === "Identifier" && node2.key.name === value2[0].content || node2.key.type === "Literal" && node2.key.value === value2[0].content))
        return value2;
      const key = handle(node2.key, state);
      if (node2.value.type === "FunctionExpression" && !node2.value.id) {
        state = {
          ...state,
          scope: state.scope_map.get(node2.value)
        };
        const chunks = node2.kind !== "init" ? [
          c(`${node2.kind} `)
        ] : [];
        if (node2.value.async)
          chunks.push(c("async "));
        if (node2.value.generator)
          chunks.push(c("*"));
        push_array(chunks, node2.computed ? [
          c("["),
          ...key,
          c("]")
        ] : key);
        chunks.push(c("("));
        push_array(chunks, join(node2.value.params.map((param) => handle(param, state)), c(", ")));
        chunks.push(c(") "));
        push_array(chunks, handle(node2.value.body, state));
        return chunks;
      }
      if (node2.computed)
        return [
          c("["),
          ...key,
          c("]: "),
          ...value2
        ];
      return [
        ...key,
        c(": "),
        ...value2
      ];
    },
    ObjectPattern(node2, state) {
      const chunks = [
        c("{ ")
      ];
      for (let i2 = 0; i2 < node2.properties.length; i2 += 1) {
        push_array(chunks, handle(node2.properties[i2], state));
        if (i2 < node2.properties.length - 1)
          chunks.push(c(", "));
      }
      chunks.push(c(" }"));
      return chunks;
    },
    SequenceExpression(node2, state) {
      const expressions = node2.expressions.map((e) => handle(e, state));
      return [
        c("("),
        ...join(expressions, c(", ")),
        c(")")
      ];
    },
    UnaryExpression(node2, state) {
      const chunks = [
        c(node2.operator)
      ];
      if (node2.operator.length > 1)
        chunks.push(c(" "));
      if (EXPRESSIONS_PRECEDENCE[node2.argument.type] < EXPRESSIONS_PRECEDENCE.UnaryExpression) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.argument, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.argument, state));
      return chunks;
    },
    UpdateExpression(node2, state) {
      return node2.prefix ? [
        c(node2.operator),
        ...handle(node2.argument, state)
      ] : [
        ...handle(node2.argument, state),
        c(node2.operator)
      ];
    },
    AssignmentExpression(node2, state) {
      return [
        ...handle(node2.left, state),
        c(` ${node2.operator || "="} `),
        ...handle(node2.right, state)
      ];
    },
    BinaryExpression(node2, state) {
      const chunks = [];
      if (needs_parens(node2.left, node2, false)) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.left, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.left, state));
      chunks.push(c(` ${node2.operator} `));
      if (needs_parens(node2.right, node2, true)) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.right, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.right, state));
      return chunks;
    },
    ConditionalExpression(node2, state) {
      const chunks = [];
      if (EXPRESSIONS_PRECEDENCE[node2.test.type] > EXPRESSIONS_PRECEDENCE.ConditionalExpression)
        push_array(chunks, handle(node2.test, state));
      else {
        chunks.push(c("("));
        push_array(chunks, handle(node2.test, state));
        chunks.push(c(")"));
      }
      const child_state = {
        ...state,
        indent: state.indent + "	"
      };
      const consequent = handle(node2.consequent, child_state);
      const alternate = handle(node2.alternate, child_state);
      const multiple_lines = has_newline(consequent) || has_newline(alternate) || get_length(chunks) + get_length(consequent) + get_length(alternate) > 50;
      if (multiple_lines) {
        chunks.push(c(`
${state.indent}? `));
        push_array(chunks, consequent);
        chunks.push(c(`
${state.indent}: `));
        push_array(chunks, alternate);
      } else {
        chunks.push(c(` ? `));
        push_array(chunks, consequent);
        chunks.push(c(` : `));
        push_array(chunks, alternate);
      }
      return chunks;
    },
    NewExpression(node2, state) {
      const chunks = [
        c("new ")
      ];
      if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression || has_call_expression(node2.callee)) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.callee, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.callee, state));
      const args = node2.arguments.map((arg) => handle(arg, {
        ...state,
        indent: state.indent + "	"
      }));
      const separator = args.some(has_newline) ? c(",\n" + state.indent) : c(", ");
      chunks.push(c("("));
      push_array(chunks, join(args, separator));
      chunks.push(c(")"));
      return chunks;
    },
    ChainExpression(node2, state) {
      return handle(node2.expression, state);
    },
    CallExpression(node2, state) {
      const chunks = [];
      if (EXPRESSIONS_PRECEDENCE[node2.callee.type] < EXPRESSIONS_PRECEDENCE.CallExpression) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.callee, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.callee, state));
      if (
        /** @type {SimpleCallExpression} */
        node2.optional
      )
        chunks.push(c("?."));
      const args = node2.arguments.map((arg) => handle(arg, state));
      const multiple_lines = args.slice(0, -1).some(has_newline);
      if (multiple_lines) {
        const args2 = node2.arguments.map((arg) => handle(arg, {
          ...state,
          indent: `${state.indent}	`
        }));
        chunks.push(c(`(
${state.indent}	`));
        push_array(chunks, join(args2, c(`,
${state.indent}	`)));
        chunks.push(c(`
${state.indent})`));
      } else {
        chunks.push(c("("));
        push_array(chunks, join(args, c(", ")));
        chunks.push(c(")"));
      }
      return chunks;
    },
    MemberExpression(node2, state) {
      const chunks = [];
      if (EXPRESSIONS_PRECEDENCE[node2.object.type] < EXPRESSIONS_PRECEDENCE.MemberExpression) {
        chunks.push(c("("));
        push_array(chunks, handle(node2.object, state));
        chunks.push(c(")"));
      } else
        push_array(chunks, handle(node2.object, state));
      if (node2.computed) {
        if (node2.optional)
          chunks.push(c("?."));
        chunks.push(c("["));
        push_array(chunks, handle(node2.property, state));
        chunks.push(c("]"));
      } else {
        chunks.push(c(node2.optional ? "?." : "."));
        push_array(chunks, handle(node2.property, state));
      }
      return chunks;
    },
    MetaProperty(node2, state) {
      return [
        ...handle(node2.meta, state),
        c("."),
        ...handle(node2.property, state)
      ];
    },
    Identifier(node2, state) {
      let name = node2.name;
      if (name[0] === "@")
        name = state.getName(name.slice(1));
      else if (node2.name[0] === "#") {
        const owner = state.scope.find_owner(node2.name);
        if (!owner)
          throw new Error(`Could not find owner for node`);
        if (!state.deconflicted.has(owner))
          state.deconflicted.set(owner, /* @__PURE__ */ new Map());
        const deconflict_map = state.deconflicted.get(owner);
        if (!deconflict_map.has(node2.name))
          deconflict_map.set(node2.name, deconflict(node2.name.slice(1), owner.references));
        name = deconflict_map.get(node2.name);
      }
      return [
        c(name, node2)
      ];
    },
    Literal(node2, state) {
      if (typeof node2.value === "string")
        return [
          // TODO do we need to handle weird unicode characters somehow?
          // str.replace(/\\u(\d{4})/g, (m, n) => String.fromCharCode(+n))
          c((node2.raw || JSON.stringify(node2.value)).replace(re, (_m, _i, at, hash2, name) => {
            if (at)
              return "@" + name;
            if (hash2)
              return "#" + name;
            throw new Error(`this shouldn't happen`);
          }), node2)
        ];
      return [
        c(node2.raw || String(node2.value), node2)
      ];
    }
  };
  handlers.ForOfStatement = handlers.ForInStatement;
  handlers.FunctionExpression = handlers.FunctionDeclaration;
  handlers.ClassExpression = handlers.ClassDeclaration;
  handlers.ClassBody = handlers.BlockStatement;
  handlers.SpreadElement = handlers.RestElement;
  handlers.ArrayPattern = handlers.ArrayExpression;
  handlers.LogicalExpression = handlers.BinaryExpression;
  handlers.AssignmentPattern = handlers.AssignmentExpression;
  var charToInteger = {};
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  for (var i$1 = 0; i$1 < chars.length; i$1++)
    charToInteger[chars.charCodeAt(i$1)] = i$1;
  function decode(mappings) {
    var decoded = [];
    var line = [];
    var segment = [
      0,
      0,
      0,
      0,
      0
    ];
    var j = 0;
    for (var i2 = 0, shift = 0, value2 = 0; i2 < mappings.length; i2++) {
      var c2 = mappings.charCodeAt(i2);
      if (c2 === 44) {
        segmentify(line, segment, j);
        j = 0;
      } else if (c2 === 59) {
        segmentify(line, segment, j);
        j = 0;
        decoded.push(line);
        line = [];
        segment[0] = 0;
      } else {
        var integer = charToInteger[c2];
        if (integer === void 0)
          throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
        var hasContinuationBit = integer & 32;
        integer &= 31;
        value2 += integer << shift;
        if (hasContinuationBit)
          shift += 5;
        else {
          var shouldNegate = value2 & 1;
          value2 >>>= 1;
          if (shouldNegate)
            value2 = value2 === 0 ? -2147483648 : -value2;
          segment[j] += value2;
          j++;
          value2 = shift = 0;
        }
      }
    }
    segmentify(line, segment, j);
    decoded.push(line);
    return decoded;
  }
  function segmentify(line, segment, j) {
    if (j === 4)
      line.push([
        segment[0],
        segment[1],
        segment[2],
        segment[3]
      ]);
    else if (j === 5)
      line.push([
        segment[0],
        segment[1],
        segment[2],
        segment[3],
        segment[4]
      ]);
    else if (j === 1)
      line.push([
        segment[0]
      ]);
  }
  function encode(decoded) {
    var sourceFileIndex = 0;
    var sourceCodeLine = 0;
    var sourceCodeColumn = 0;
    var nameIndex = 0;
    var mappings = "";
    for (var i2 = 0; i2 < decoded.length; i2++) {
      var line = decoded[i2];
      if (i2 > 0)
        mappings += ";";
      if (line.length === 0)
        continue;
      var generatedCodeColumn = 0;
      var lineMappings = [];
      for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
        var segment = line_1[_i];
        var segmentMappings = encodeInteger(segment[0] - generatedCodeColumn);
        generatedCodeColumn = segment[0];
        if (segment.length > 1) {
          segmentMappings += encodeInteger(segment[1] - sourceFileIndex) + encodeInteger(segment[2] - sourceCodeLine) + encodeInteger(segment[3] - sourceCodeColumn);
          sourceFileIndex = segment[1];
          sourceCodeLine = segment[2];
          sourceCodeColumn = segment[3];
        }
        if (segment.length === 5) {
          segmentMappings += encodeInteger(segment[4] - nameIndex);
          nameIndex = segment[4];
        }
        lineMappings.push(segmentMappings);
      }
      mappings += lineMappings.join(",");
    }
    return mappings;
  }
  function encodeInteger(num) {
    var result = "";
    num = num < 0 ? -num << 1 | 1 : num << 1;
    do {
      var clamped = num & 31;
      num >>>= 5;
      if (num > 0)
        clamped |= 32;
      result += chars[clamped];
    } while (num > 0);
    return result;
  }
  let btoa$1 = () => {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
  if (typeof window !== "undefined" && typeof window.btoa === "function")
    btoa$1 = (str) => window.btoa(unescape(encodeURIComponent(str)));
  else if (typeof Buffer === "function")
    btoa$1 = (str) => Buffer.from(str, "utf-8").toString("base64");
  function print(node2, opts = {}) {
    if (Array.isArray(node2))
      return print({
        type: "Program",
        body: node2,
        sourceType: "module"
      }, opts);
    const { getName = (
      /** @param {string} x */
      (x2) => {
        throw new Error(`Unhandled sigil @${x2}`);
      }
    ) } = opts;
    let { map: scope_map, scope: scope2 } = analyze(node2);
    const deconflicted = /* @__PURE__ */ new WeakMap();
    const chunks = handle(node2, {
      indent: "",
      getName,
      scope: scope2,
      scope_map,
      deconflicted,
      comments: []
    });
    let code = "";
    let current_column = 0;
    let mappings = [];
    let current_line = [];
    for (let i2 = 0; i2 < chunks.length; i2 += 1) {
      const chunk = chunks[i2];
      code += chunk.content;
      if (chunk.loc)
        current_line.push([
          current_column,
          0,
          chunk.loc.start.line - 1,
          chunk.loc.start.column
        ]);
      for (let i3 = 0; i3 < chunk.content.length; i3 += 1)
        if (chunk.content[i3] === "\n") {
          mappings.push(current_line);
          current_line = [];
          current_column = 0;
        } else
          current_column += 1;
      if (chunk.loc)
        current_line.push([
          current_column,
          0,
          chunk.loc.end.line - 1,
          chunk.loc.end.column
        ]);
    }
    mappings.push(current_line);
    const map = {
      version: 3,
      /** @type {string[]} */
      names: [],
      sources: [
        opts.sourceMapSource || null
      ],
      sourcesContent: [
        opts.sourceMapContent || null
      ],
      mappings: opts.sourceMapEncodeMappings == void 0 || opts.sourceMapEncodeMappings ? encode(mappings) : mappings
    };
    Object.defineProperties(map, {
      toString: {
        enumerable: false,
        value: function toString4() {
          return JSON.stringify(this);
        }
      },
      toUrl: {
        enumerable: false,
        value: function toUrl() {
          return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
        }
      }
    });
    return {
      code,
      map
    };
  }
  const sigils = {
    "@": "AT",
    "#": "HASH"
  };
  const join$1 = (strings) => {
    let str = strings[0];
    for (let i2 = 1; i2 < strings.length; i2 += 1)
      str += `_${id}_${i2 - 1}_${strings[i2]}`;
    return str.replace(/([@#])(\w+)/g, (_m, sigil, name) => `_${id}_${sigils[sigil]}_${name}`);
  };
  const flatten_body = (array, target) => {
    for (let i2 = 0; i2 < array.length; i2 += 1) {
      const statement = array[i2];
      if (Array.isArray(statement)) {
        flatten_body(statement, target);
        continue;
      }
      if (statement.type === "ExpressionStatement") {
        if (statement.expression === EMPTY)
          continue;
        if (Array.isArray(statement.expression)) {
          let node2 = statement.expression[0];
          while (Array.isArray(node2))
            node2 = node2[0];
          if (node2)
            node2.leadingComments = statement.leadingComments;
          flatten_body(statement.expression, target);
          continue;
        }
        if (/(Expression|Literal)$/.test(statement.expression.type)) {
          target.push(statement);
          continue;
        }
        if (statement.leadingComments)
          statement.expression.leadingComments = statement.leadingComments;
        if (statement.trailingComments)
          statement.expression.trailingComments = statement.trailingComments;
        target.push(statement.expression);
        continue;
      }
      target.push(statement);
    }
    return target;
  };
  const flatten_properties = (array, target) => {
    for (let i2 = 0; i2 < array.length; i2 += 1) {
      const property = array[i2];
      if (property.value === EMPTY)
        continue;
      if (property.key === property.value && Array.isArray(property.key)) {
        flatten_properties(property.key, target);
        continue;
      }
      target.push(property);
    }
    return target;
  };
  const flatten$1 = (nodes, target) => {
    for (let i2 = 0; i2 < nodes.length; i2 += 1) {
      const node2 = nodes[i2];
      if (node2 === EMPTY)
        continue;
      if (Array.isArray(node2)) {
        flatten$1(node2, target);
        continue;
      }
      target.push(node2);
    }
    return target;
  };
  const EMPTY = {
    type: "Empty"
  };
  const acorn_opts = (comments, raw) => {
    const { onComment } = get_comment_handlers(comments, raw);
    return {
      ecmaVersion: 2020,
      sourceType: "module",
      allowAwaitOutsideFunction: true,
      allowImportExportEverywhere: true,
      allowReturnOutsideFunction: true,
      onComment
    };
  };
  const inject = (raw, node2, values, comments) => {
    comments.forEach((comment) => {
      comment.value = comment.value.replace(re, (m, i2) => +i2 in values ? values[+i2] : m);
    });
    const { enter, leave } = get_comment_handlers(comments, raw);
    return walk(node2, {
      enter,
      /** @param {any} node */
      leave(node3) {
        if (node3.type === "Identifier") {
          re.lastIndex = 0;
          const match = re.exec(node3.name);
          if (match) {
            if (match[1]) {
              if (+match[1] in values) {
                let value2 = values[+match[1]];
                if (typeof value2 === "string")
                  value2 = {
                    type: "Identifier",
                    name: value2,
                    leadingComments: node3.leadingComments,
                    trailingComments: node3.trailingComments
                  };
                else if (typeof value2 === "number")
                  value2 = {
                    type: "Literal",
                    value: value2,
                    leadingComments: node3.leadingComments,
                    trailingComments: node3.trailingComments
                  };
                this.replace(value2 || EMPTY);
              }
            } else
              node3.name = `${match[2] ? `@` : `#`}${match[4]}`;
          }
        }
        if (node3.type === "Literal") {
          if (typeof node3.value === "string") {
            re.lastIndex = 0;
            const new_value = (
              /** @type {string} */
              node3.value.replace(re, (m, i2) => +i2 in values ? values[+i2] : m)
            );
            const has_changed = new_value !== node3.value;
            node3.value = new_value;
            if (has_changed && node3.raw)
              node3.raw = `${node3.raw[0]}${JSON.stringify(node3.value).slice(1, -1)}${node3.raw[node3.raw.length - 1]}`;
          }
        }
        if (node3.type === "TemplateElement") {
          re.lastIndex = 0;
          node3.value.raw = /** @type {string} */
          node3.value.raw.replace(re, (m, i2) => +i2 in values ? values[+i2] : m);
        }
        if (node3.type === "Program" || node3.type === "BlockStatement")
          node3.body = flatten_body(node3.body, []);
        if (node3.type === "ObjectExpression" || node3.type === "ObjectPattern")
          node3.properties = flatten_properties(node3.properties, []);
        if (node3.type === "ArrayExpression" || node3.type === "ArrayPattern")
          node3.elements = flatten$1(node3.elements, []);
        if (node3.type === "FunctionExpression" || node3.type === "FunctionDeclaration" || node3.type === "ArrowFunctionExpression")
          node3.params = flatten$1(node3.params, []);
        if (node3.type === "CallExpression" || node3.type === "NewExpression")
          node3.arguments = flatten$1(node3.arguments, []);
        if (node3.type === "ImportDeclaration" || node3.type === "ExportNamedDeclaration")
          node3.specifiers = flatten$1(node3.specifiers, []);
        if (node3.type === "ForStatement") {
          node3.init = node3.init === EMPTY ? null : node3.init;
          node3.test = node3.test === EMPTY ? null : node3.test;
          node3.update = node3.update === EMPTY ? null : node3.update;
        }
        leave(node3);
      }
    });
  };
  function b(strings, ...values) {
    const str = join$1(strings);
    const comments = [];
    try {
      let ast = (
        /** @type {any} */
        parse(str, acorn_opts(comments, str))
      );
      ast = inject(str, ast, values, comments);
      return ast.body;
    } catch (err) {
      handle_error(str, err);
    }
  }
  function x(strings, ...values) {
    const str = join$1(strings);
    const comments = [];
    try {
      let expression = (
        /** @type {Expression & { start: Number, end: number }} */
        parseExpressionAt(str, 0, acorn_opts(comments, str))
      );
      const match = /\S+/.exec(str.slice(expression.end));
      if (match)
        throw new Error(`Unexpected token '${match[0]}'`);
      expression = /** @type {Expression & { start: Number, end: number }} */
      inject(str, expression, values, comments);
      return expression;
    } catch (err) {
      handle_error(str, err);
    }
  }
  function p(strings, ...values) {
    const str = `{${join$1(strings)}}`;
    const comments = [];
    try {
      let expression = (
        /** @type {any} */
        parseExpressionAt(str, 0, acorn_opts(comments, str))
      );
      expression = inject(str, expression, values, comments);
      return expression.properties[0];
    } catch (err) {
      handle_error(str, err);
    }
  }
  function handle_error(str, err) {
    re.lastIndex = 0;
    str = str.replace(re, (m, i2, at, hash2, name) => {
      if (at)
        return `@${name}`;
      if (hash2)
        return `#${name}`;
      return "${...}";
    });
    console.log(`failed to parse:
${str}`);
    throw err;
  }
  const parse$1 = (source, opts) => {
    const comments = [];
    const { onComment, enter, leave } = get_comment_handlers(comments, source);
    const ast = (
      /** @type {any} */
      parse(source, {
        onComment,
        ...opts
      })
    );
    walk(ast, {
      enter,
      leave
    });
    return ast;
  };
  const parseExpressionAt$1 = (source, index, opts) => {
    const comments = [];
    const { onComment, enter, leave } = get_comment_handlers(comments, source);
    const ast = (
      /** @type {any} */
      parseExpressionAt(source, index, {
        onComment,
        ...opts
      })
    );
    walk(ast, {
      enter,
      leave
    });
    return ast;
  };
  const parse$2 = (source) => parse$1(source, {
    sourceType: "module",
    ecmaVersion: 12,
    locations: true
  });
  const parse_expression_at = (source, index) => parseExpressionAt$1(source, index, {
    sourceType: "module",
    ecmaVersion: 12,
    locations: true
  });
  function read_expression(parser) {
    try {
      const node2 = parse_expression_at(parser.template, parser.index);
      let num_parens = 0;
      for (let i2 = parser.index; i2 < node2.start; i2 += 1)
        if (parser.template[i2] === "(")
          num_parens += 1;
      let index = node2.end;
      while (num_parens > 0) {
        const char = parser.template[index];
        if (char === ")")
          num_parens -= 1;
        else if (!regex_whitespace.test(char))
          parser.error(parser_errors.unexpected_token(")"), index);
        index += 1;
      }
      parser.index = index;
      return node2;
    } catch (err) {
      parser.acorn_error(err);
    }
  }
  const regex_closing_script_tag = /<\/script\s*>/;
  function get_context(parser, attributes, start) {
    const context = attributes.find((attribute) => attribute.name === "context");
    if (!context)
      return "default";
    if (context.value.length !== 1 || context.value[0].type !== "Text")
      parser.error(parser_errors.invalid_script_context_attribute, start);
    const value2 = context.value[0].data;
    if (value2 !== "module")
      parser.error(parser_errors.invalid_script_context_value, context.start);
    return value2;
  }
  function read_script(parser, start, attributes) {
    const script_start = parser.index;
    const data2 = parser.read_until(regex_closing_script_tag, parser_errors.unclosed_script);
    if (parser.index >= parser.template.length)
      parser.error(parser_errors.unclosed_script);
    const source = parser.template.slice(0, script_start).replace(regex_not_newline_characters, " ") + data2;
    parser.read(regex_closing_script_tag);
    let ast;
    try {
      ast = parse$2(source);
    } catch (err) {
      parser.acorn_error(err);
    }
    ast.start = script_start;
    return {
      type: "Script",
      start,
      end: parser.index,
      context: get_context(parser, attributes, start),
      content: ast
    };
  }
  let releasedCursors = null;
  class List {
    static createItem(data2) {
      return {
        prev: null,
        next: null,
        data: data2
      };
    }
    constructor() {
      this.head = null;
      this.tail = null;
      this.cursor = null;
    }
    createItem(data2) {
      return List.createItem(data2);
    }
    // cursor helpers
    allocateCursor(prev, next) {
      let cursor;
      if (releasedCursors !== null) {
        cursor = releasedCursors;
        releasedCursors = releasedCursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = this.cursor;
      } else
        cursor = {
          prev,
          next,
          cursor: this.cursor
        };
      this.cursor = cursor;
      return cursor;
    }
    releaseCursor() {
      const { cursor } = this;
      this.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = releasedCursors;
      releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
      let { cursor } = this;
      while (cursor !== null) {
        if (cursor.prev === prevOld)
          cursor.prev = prevNew;
        if (cursor.next === nextOld)
          cursor.next = nextNew;
        cursor = cursor.cursor;
      }
    }
    *[Symbol.iterator]() {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next)
        yield cursor.data;
    }
    // getters
    get size() {
      let size = 0;
      for (let cursor = this.head; cursor !== null; cursor = cursor.next)
        size++;
      return size;
    }
    get isEmpty() {
      return this.head === null;
    }
    get first() {
      return this.head && this.head.data;
    }
    get last() {
      return this.tail && this.tail.data;
    }
    // convertors
    fromArray(array) {
      let cursor = null;
      this.head = null;
      for (let data2 of array) {
        const item = List.createItem(data2);
        if (cursor !== null)
          cursor.next = item;
        else
          this.head = item;
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    }
    toArray() {
      return [
        ...this
      ];
    }
    toJSON() {
      return [
        ...this
      ];
    }
    // array-like methods
    forEach(fn, thisArg = this) {
      const cursor = this.allocateCursor(null, this.head);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
      const cursor = this.allocateCursor(this.tail, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(thisArg, item.data, item, this);
      }
      this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(null, this.head);
      let acc = initialValue;
      let item;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
      let cursor = this.allocateCursor(this.tail, null);
      let acc = initialValue;
      let item;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(thisArg, acc, item.data, item, this);
      }
      this.releaseCursor();
      return acc;
    }
    some(fn, thisArg = this) {
      for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
        if (fn.call(thisArg, cursor.data, cursor, this))
          return true;
      }
      return false;
    }
    map(fn, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next)
        result.appendData(fn.call(thisArg, cursor.data, cursor, this));
      return result;
    }
    filter(fn, thisArg = this) {
      const result = new List();
      for (let cursor = this.head; cursor !== null; cursor = cursor.next)
        if (fn.call(thisArg, cursor.data, cursor, this))
          result.appendData(cursor.data);
      return result;
    }
    nextUntil(start, fn, thisArg = this) {
      if (start === null)
        return;
      const cursor = this.allocateCursor(null, start);
      while (cursor.next !== null) {
        const item = cursor.next;
        cursor.next = item.next;
        if (fn.call(thisArg, item.data, item, this))
          break;
      }
      this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
      if (start === null)
        return;
      const cursor = this.allocateCursor(start, null);
      while (cursor.prev !== null) {
        const item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(thisArg, item.data, item, this))
          break;
      }
      this.releaseCursor();
    }
    // mutation
    clear() {
      this.head = null;
      this.tail = null;
    }
    copy() {
      const result = new List();
      for (let data2 of this)
        result.appendData(data2);
      return result;
    }
    prepend(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else
        this.tail = item;
      this.head = item;
      return this;
    }
    prependData(data2) {
      return this.prepend(List.createItem(data2));
    }
    append(item) {
      return this.insert(item);
    }
    appendData(data2) {
      return this.insert(List.createItem(data2));
    }
    insert(item, before = null) {
      if (before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before)
            throw new Error("before doesn't belong to list");
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else
          this.head = item;
        this.tail = item;
      }
      return this;
    }
    insertData(data2, before) {
      return this.insert(List.createItem(data2), before);
    }
    remove(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null)
        item.prev.next = item.next;
      else {
        if (this.head !== item)
          throw new Error("item doesn't belong to list");
        this.head = item.next;
      }
      if (item.next !== null)
        item.next.prev = item.prev;
      else {
        if (this.tail !== item)
          throw new Error("item doesn't belong to list");
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    }
    push(data2) {
      this.insert(List.createItem(data2));
    }
    pop() {
      return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data2) {
      this.prepend(List.createItem(data2));
    }
    shift() {
      return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list2) {
      return this.insertList(list2, this.head);
    }
    appendList(list2) {
      return this.insertList(list2);
    }
    insertList(list2, before) {
      if (list2.head === null)
        return this;
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list2.tail, before, list2.head);
        if (before.prev !== null) {
          before.prev.next = list2.head;
          list2.head.prev = before.prev;
        } else
          this.head = list2.head;
        before.prev = list2.tail;
        list2.tail.next = before;
      } else {
        this.updateCursors(this.tail, list2.tail, null, list2.head);
        if (this.tail !== null) {
          this.tail.next = list2.head;
          list2.head.prev = this.tail;
        } else
          this.head = list2.head;
        this.tail = list2.tail;
      }
      list2.head = null;
      list2.tail = null;
      return this;
    }
    replace(oldItem, newItemOrList) {
      if ("head" in newItemOrList)
        this.insertList(newItemOrList, oldItem);
      else
        this.insert(newItemOrList, oldItem);
      this.remove(oldItem);
    }
  }
  function createCustomError(name, message) {
    const error2 = Object.create(SyntaxError.prototype);
    const errorStack = new Error();
    return Object.assign(error2, {
      name,
      message,
      get stack() {
        return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
      }
    });
  }
  const MAX_LINE_LENGTH = 100;
  const OFFSET_CORRECTION = 60;
  const TAB_REPLACEMENT = "    ";
  function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
      return lines.slice(start, end).map((line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2).join("\n");
    }
    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
    if (column > MAX_LINE_LENGTH) {
      cutLeft = column - OFFSET_CORRECTION + 3;
      column = OFFSET_CORRECTION - 2;
    }
    for (let i2 = startLine; i2 <= endLine; i2++)
      if (i2 >= 0 && i2 < lines.length) {
        lines[i2] = lines[i2].replace(/\t/g, TAB_REPLACEMENT);
        lines[i2] = (cutLeft > 0 && lines[i2].length > cutLeft ? "…" : "") + lines[i2].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i2].length > cutLeft + MAX_LINE_LENGTH - 1 ? "…" : "");
      }
    return [
      processLines(startLine, line),
      new Array(column + maxNumLength + 2).join("-") + "^",
      processLines(line, endLine)
    ].filter(Boolean).join("\n");
  }
  function SyntaxError$1(message, source, offset, line, column) {
    const error2 = Object.assign(createCustomError("SyntaxError", message), {
      source,
      offset,
      line,
      column,
      sourceFragment(extraLines) {
        return sourceFragment({
          source,
          line,
          column
        }, isNaN(extraLines) ? 0 : extraLines);
      },
      get formattedMessage() {
        return `Parse error: ${message}
` + sourceFragment({
          source,
          line,
          column
        }, 2);
      }
    });
    return error2;
  }
  const EOF = 0;
  const Ident = 1;
  const Function$1 = 2;
  const AtKeyword = 3;
  const Hash = 4;
  const String$1 = 5;
  const BadString = 6;
  const Url = 7;
  const BadUrl = 8;
  const Delim = 9;
  const Number$1 = 10;
  const Percentage = 11;
  const Dimension = 12;
  const WhiteSpace = 13;
  const CDO = 14;
  const CDC = 15;
  const Colon = 16;
  const Semicolon = 17;
  const Comma = 18;
  const LeftSquareBracket = 19;
  const RightSquareBracket = 20;
  const LeftParenthesis = 21;
  const RightParenthesis = 22;
  const LeftCurlyBracket = 23;
  const RightCurlyBracket = 24;
  const Comment = 25;
  const EOF$1 = 0;
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isHexDigit$1(code) {
    return isDigit(code) || // 0 .. 9
    code >= 65 && code <= 70 || // A .. F
    code >= 97 && code <= 102;
  }
  function isUppercaseLetter(code) {
    return code >= 65 && code <= 90;
  }
  function isLowercaseLetter(code) {
    return code >= 97 && code <= 122;
  }
  function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
  }
  function isNonAscii(code) {
    return code >= 128;
  }
  function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 95;
  }
  function isName(code) {
    return isNameStart(code) || isDigit(code) || code === 45;
  }
  function isNonPrintable(code) {
    return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
  }
  function isNewline(code) {
    return code === 10 || code === 13 || code === 12;
  }
  function isWhiteSpace(code) {
    return isNewline(code) || code === 32 || code === 9;
  }
  function isValidEscape(first, second) {
    if (first !== 92)
      return false;
    if (isNewline(second) || second === EOF$1)
      return false;
    return true;
  }
  function isIdentifierStart$1(first, second, third) {
    if (first === 45)
      return isNameStart(second) || second === 45 || isValidEscape(second, third);
    if (isNameStart(first))
      return true;
    if (first === 92)
      return isValidEscape(first, second);
    return false;
  }
  function isNumberStart(first, second, third) {
    if (first === 43 || first === 45) {
      if (isDigit(second))
        return 2;
      return second === 46 && isDigit(third) ? 3 : 0;
    }
    if (first === 46)
      return isDigit(second) ? 2 : 0;
    if (isDigit(first))
      return 1;
    return 0;
  }
  function isBOM(code) {
    if (code === 65279)
      return 1;
    if (code === 65534)
      return 1;
    return 0;
  }
  const CATEGORY = new Array(128);
  const EofCategory = 128;
  const WhiteSpaceCategory = 130;
  const DigitCategory = 131;
  const NameStartCategory = 132;
  const NonPrintableCategory = 133;
  for (let i2 = 0; i2 < CATEGORY.length; i2++)
    CATEGORY[i2] = isWhiteSpace(i2) && WhiteSpaceCategory || isDigit(i2) && DigitCategory || isNameStart(i2) && NameStartCategory || isNonPrintable(i2) && NonPrintableCategory || i2 || EofCategory;
  function charCodeCategory(code) {
    return code < 128 ? CATEGORY[code] : NameStartCategory;
  }
  function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
  }
  function getNewlineLength(source, offset, code) {
    if (code === 13 && getCharCode(source, offset + 1) === 10)
      return 2;
    return 1;
  }
  function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);
    if (isUppercaseLetter(code))
      code = code | 32;
    return code === referenceCode;
  }
  function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length)
      return false;
    if (start < 0 || end > testStr.length)
      return false;
    for (let i2 = start; i2 < end; i2++) {
      const referenceCode = referenceStr.charCodeAt(i2 - start);
      let testCode = testStr.charCodeAt(i2);
      if (isUppercaseLetter(testCode))
        testCode = testCode | 32;
      if (testCode !== referenceCode)
        return false;
    }
    return true;
  }
  function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
      if (!isWhiteSpace(source.charCodeAt(offset)))
        break;
    }
    return offset + 1;
  }
  function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isWhiteSpace(source.charCodeAt(offset)))
        break;
    }
    return offset;
  }
  function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
      if (!isDigit(source.charCodeAt(offset)))
        break;
    }
    return offset;
  }
  function consumeEscaped(source, offset) {
    offset += 2;
    if (isHexDigit$1(getCharCode(source, offset - 1))) {
      for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
        if (!isHexDigit$1(getCharCode(source, offset)))
          break;
      }
      const code = getCharCode(source, offset);
      if (isWhiteSpace(code))
        offset += getNewlineLength(source, offset, code);
    }
    return offset;
  }
  function consumeName(source, offset) {
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (isName(code))
        continue;
      if (isValidEscape(code, getCharCode(source, offset + 1))) {
        offset = consumeEscaped(source, offset) - 1;
        continue;
      }
      break;
    }
    return offset;
  }
  function consumeNumber(source, offset) {
    let code = source.charCodeAt(offset);
    if (code === 43 || code === 45)
      code = source.charCodeAt(offset += 1);
    if (isDigit(code)) {
      offset = findDecimalNumberEnd(source, offset + 1);
      code = source.charCodeAt(offset);
    }
    if (code === 46 && isDigit(source.charCodeAt(offset + 1))) {
      offset += 2;
      offset = findDecimalNumberEnd(source, offset);
    }
    if (cmpChar(
      source,
      offset,
      101
      /* e */
    )) {
      let sign = 0;
      code = source.charCodeAt(offset + 1);
      if (code === 45 || code === 43) {
        sign = 1;
        code = source.charCodeAt(offset + 2);
      }
      if (isDigit(code))
        offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
    }
    return offset;
  }
  function consumeBadUrlRemnants(source, offset) {
    for (; offset < source.length; offset++) {
      const code = source.charCodeAt(offset);
      if (code === 41) {
        offset++;
        break;
      }
      if (isValidEscape(code, getCharCode(source, offset + 1)))
        offset = consumeEscaped(source, offset);
    }
    return offset;
  }
  function decodeEscaped(escaped2) {
    if (escaped2.length === 1 && !isHexDigit$1(escaped2.charCodeAt(0)))
      return escaped2[0];
    let code = parseInt(escaped2, 16);
    if (code === 0 || // If this number is zero,
    code >= 55296 && code <= 57343 || // or is for a surrogate,
    code > 1114111)
      code = 65533;
    return String.fromCodePoint(code);
  }
  var tokenNames = [
    "EOF-token",
    "ident-token",
    "function-token",
    "at-keyword-token",
    "hash-token",
    "string-token",
    "bad-string-token",
    "url-token",
    "bad-url-token",
    "delim-token",
    "number-token",
    "percentage-token",
    "dimension-token",
    "whitespace-token",
    "CDO-token",
    "CDC-token",
    "colon-token",
    "semicolon-token",
    "comma-token",
    "[-token",
    "]-token",
    "(-token",
    ")-token",
    "{-token",
    "}-token"
  ];
  const MIN_SIZE = 16384;
  function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size)
      return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    return buffer;
  }
  const N = 10;
  const F = 12;
  const R = 13;
  function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;
    for (let i2 = startOffset; i2 < sourceLength; i2++) {
      const code = source.charCodeAt(i2);
      lines[i2] = line;
      columns[i2] = column++;
      if (code === N || code === R || code === F) {
        if (code === R && i2 + 1 < sourceLength && source.charCodeAt(i2 + 1) === N) {
          i2++;
          lines[i2] = line;
          columns[i2] = column;
        }
        line++;
        column = 1;
      }
    }
    lines[sourceLength] = line;
    columns[sourceLength] = column;
    host.lines = lines;
    host.columns = columns;
    host.computed = true;
  }
  class OffsetToLocation {
    constructor() {
      this.lines = null;
      this.columns = null;
      this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
      this.source = source;
      this.startOffset = startOffset;
      this.startLine = startLine;
      this.startColumn = startColumn;
      this.computed = false;
    }
    getLocation(offset, filename) {
      if (!this.computed)
        computeLinesAndColumns(this);
      return {
        source: filename,
        offset: this.startOffset + offset,
        line: this.lines[offset],
        column: this.columns[offset]
      };
    }
    getLocationRange(start, end, filename) {
      if (!this.computed)
        computeLinesAndColumns(this);
      return {
        source: filename,
        start: {
          offset: this.startOffset + start,
          line: this.lines[start],
          column: this.columns[start]
        },
        end: {
          offset: this.startOffset + end,
          line: this.lines[end],
          column: this.columns[end]
        }
      };
    }
  }
  const OFFSET_MASK = 16777215;
  const TYPE_SHIFT = 24;
  const balancePair = /* @__PURE__ */ new Map([
    [
      Function$1,
      RightParenthesis
    ],
    [
      LeftParenthesis,
      RightParenthesis
    ],
    [
      LeftSquareBracket,
      RightSquareBracket
    ],
    [
      LeftCurlyBracket,
      RightCurlyBracket
    ]
  ]);
  class TokenStream {
    constructor(source, tokenize2) {
      this.setSource(source, tokenize2);
    }
    reset() {
      this.eof = false;
      this.tokenIndex = -1;
      this.tokenType = 0;
      this.tokenStart = this.firstCharOffset;
      this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = "", tokenize2 = () => {
    }) {
      source = String(source || "");
      const sourceLength = source.length;
      const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1);
      const balance = adoptBuffer(this.balance, source.length + 1);
      let tokenCount = 0;
      let balanceCloseType = 0;
      let balanceStart = 0;
      let firstCharOffset = -1;
      this.offsetAndType = null;
      this.balance = null;
      tokenize2(source, (type, start, end) => {
        switch (type) {
          default:
            balance[tokenCount] = sourceLength;
            break;
          case balanceCloseType: {
            let balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (; balancePrev < tokenCount; balancePrev++)
              if (balance[balancePrev] === sourceLength)
                balance[balancePrev] = tokenCount;
            break;
          }
          case LeftParenthesis:
          case Function$1:
          case LeftSquareBracket:
          case LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = balancePair.get(type);
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
        if (firstCharOffset === -1)
          firstCharOffset = start;
      });
      offsetAndType[tokenCount] = EOF << TYPE_SHIFT | sourceLength;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        const balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      this.source = source;
      this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
      this.tokenCount = tokenCount;
      this.offsetAndType = offsetAndType;
      this.balance = balance;
      this.reset();
      this.next();
    }
    lookupType(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount)
        return this.offsetAndType[offset] >> TYPE_SHIFT;
      return EOF;
    }
    lookupOffset(offset) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount)
        return this.offsetAndType[offset - 1] & OFFSET_MASK;
      return this.source.length;
    }
    lookupValue(offset, referenceStr) {
      offset += this.tokenIndex;
      if (offset < this.tokenCount)
        return cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);
      return false;
    }
    getTokenStart(tokenIndex) {
      if (tokenIndex === this.tokenIndex)
        return this.tokenStart;
      if (tokenIndex > 0)
        return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
      return this.firstCharOffset;
    }
    substrToCursor(start) {
      return this.source.substring(start, this.tokenStart);
    }
    isBalanceEdge(pos) {
      return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
      if (offset)
        return this.lookupType(offset) === Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
      return this.tokenType === Delim && this.source.charCodeAt(this.tokenStart) === code;
    }
    skip(tokenCount) {
      let next = this.tokenIndex + tokenCount;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.tokenIndex = this.tokenCount;
        this.next();
      }
    }
    next() {
      let next = this.tokenIndex + 1;
      if (next < this.tokenCount) {
        this.tokenIndex = next;
        this.tokenStart = this.tokenEnd;
        next = this.offsetAndType[next];
        this.tokenType = next >> TYPE_SHIFT;
        this.tokenEnd = next & OFFSET_MASK;
      } else {
        this.eof = true;
        this.tokenIndex = this.tokenCount;
        this.tokenType = EOF;
        this.tokenStart = this.tokenEnd = this.source.length;
      }
    }
    skipSC() {
      while (this.tokenType === WhiteSpace || this.tokenType === Comment)
        this.next();
    }
    skipUntilBalanced(startToken, stopConsume) {
      let cursor = startToken;
      let balanceEnd;
      let offset;
      loop:
        for (; cursor < this.tokenCount; cursor++) {
          balanceEnd = this.balance[cursor];
          if (balanceEnd < startToken)
            break loop;
          offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
          switch (stopConsume(this.source.charCodeAt(offset))) {
            case 1:
              break loop;
            case 2:
              cursor++;
              break loop;
            default:
              if (this.balance[balanceEnd] === cursor)
                cursor = balanceEnd;
          }
        }
      this.skip(cursor - this.tokenIndex);
    }
    forEachToken(fn) {
      for (let i2 = 0, offset = this.firstCharOffset; i2 < this.tokenCount; i2++) {
        const start = offset;
        const item = this.offsetAndType[i2];
        const end = item & OFFSET_MASK;
        const type = item >> TYPE_SHIFT;
        offset = end;
        fn(type, start, end, i2);
      }
    }
    dump() {
      const tokens = new Array(this.tokenCount);
      this.forEachToken((type, start, end, index) => {
        tokens[index] = {
          idx: index,
          type: tokenNames[type],
          chunk: this.source.substring(start, end),
          balance: this.balance[index]
        };
      });
      return tokens;
    }
  }
  function tokenize(source, onToken) {
    function getCharCode2(offset2) {
      return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
    }
    function consumeNumericToken() {
      offset = consumeNumber(source, offset);
      if (isIdentifierStart$1(getCharCode2(offset), getCharCode2(offset + 1), getCharCode2(offset + 2))) {
        type = Dimension;
        offset = consumeName(source, offset);
        return;
      }
      if (getCharCode2(offset) === 37) {
        type = Percentage;
        offset++;
        return;
      }
      type = Number$1;
    }
    function consumeIdentLikeToken() {
      const nameStartOffset = offset;
      offset = consumeName(source, offset);
      if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode2(offset) === 40) {
        offset = findWhiteSpaceEnd(source, offset + 1);
        if (getCharCode2(offset) === 34 || getCharCode2(offset) === 39) {
          type = Function$1;
          offset = nameStartOffset + 4;
          return;
        }
        consumeUrlToken();
        return;
      }
      if (getCharCode2(offset) === 40) {
        type = Function$1;
        offset++;
        return;
      }
      type = Ident;
    }
    function consumeStringToken(endingCodePoint) {
      if (!endingCodePoint)
        endingCodePoint = getCharCode2(offset++);
      type = String$1;
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeCategory(code)) {
          case endingCodePoint:
            offset++;
            return;
          case WhiteSpaceCategory:
            if (isNewline(code)) {
              offset += getNewlineLength(source, offset, code);
              type = BadString;
              return;
            }
            break;
          case 92:
            if (offset === source.length - 1)
              break;
            const nextCode = getCharCode2(offset + 1);
            if (isNewline(nextCode))
              offset += getNewlineLength(source, offset + 1, nextCode);
            else if (isValidEscape(code, nextCode))
              offset = consumeEscaped(source, offset) - 1;
            break;
        }
      }
    }
    function consumeUrlToken() {
      type = Url;
      offset = findWhiteSpaceEnd(source, offset);
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        switch (charCodeCategory(code)) {
          case 41:
            offset++;
            return;
          case WhiteSpaceCategory:
            offset = findWhiteSpaceEnd(source, offset);
            if (getCharCode2(offset) === 41 || offset >= source.length) {
              if (offset < source.length)
                offset++;
              return;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
          case 34:
          case 39:
          case 40:
          case NonPrintableCategory:
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
          case 92:
            if (isValidEscape(code, getCharCode2(offset + 1))) {
              offset = consumeEscaped(source, offset) - 1;
              break;
            }
            offset = consumeBadUrlRemnants(source, offset);
            type = BadUrl;
            return;
        }
      }
    }
    source = String(source || "");
    const sourceLength = source.length;
    let start = isBOM(getCharCode2(0));
    let offset = start;
    let type;
    while (offset < sourceLength) {
      const code = source.charCodeAt(offset);
      switch (charCodeCategory(code)) {
        case WhiteSpaceCategory:
          type = WhiteSpace;
          offset = findWhiteSpaceEnd(source, offset + 1);
          break;
        case 34:
          consumeStringToken();
          break;
        case 35:
          if (isName(getCharCode2(offset + 1)) || isValidEscape(getCharCode2(offset + 1), getCharCode2(offset + 2))) {
            type = Hash;
            offset = consumeName(source, offset + 1);
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 39:
          consumeStringToken();
          break;
        case 40:
          type = LeftParenthesis;
          offset++;
          break;
        case 41:
          type = RightParenthesis;
          offset++;
          break;
        case 43:
          if (isNumberStart(code, getCharCode2(offset + 1), getCharCode2(offset + 2)))
            consumeNumericToken();
          else {
            type = Delim;
            offset++;
          }
          break;
        case 44:
          type = Comma;
          offset++;
          break;
        case 45:
          if (isNumberStart(code, getCharCode2(offset + 1), getCharCode2(offset + 2)))
            consumeNumericToken();
          else {
            if (getCharCode2(offset + 1) === 45 && getCharCode2(offset + 2) === 62) {
              type = CDC;
              offset = offset + 3;
            } else if (isIdentifierStart$1(code, getCharCode2(offset + 1), getCharCode2(offset + 2)))
              consumeIdentLikeToken();
            else {
              type = Delim;
              offset++;
            }
          }
          break;
        case 46:
          if (isNumberStart(code, getCharCode2(offset + 1), getCharCode2(offset + 2)))
            consumeNumericToken();
          else {
            type = Delim;
            offset++;
          }
          break;
        case 47:
          if (getCharCode2(offset + 1) === 42) {
            type = Comment;
            offset = source.indexOf("*/", offset + 2);
            offset = offset === -1 ? source.length : offset + 2;
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 58:
          type = Colon;
          offset++;
          break;
        case 59:
          type = Semicolon;
          offset++;
          break;
        case 60:
          if (getCharCode2(offset + 1) === 33 && getCharCode2(offset + 2) === 45 && getCharCode2(offset + 3) === 45) {
            type = CDO;
            offset = offset + 4;
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 64:
          if (isIdentifierStart$1(getCharCode2(offset + 1), getCharCode2(offset + 2), getCharCode2(offset + 3))) {
            type = AtKeyword;
            offset = consumeName(source, offset + 1);
          } else {
            type = Delim;
            offset++;
          }
          break;
        case 91:
          type = LeftSquareBracket;
          offset++;
          break;
        case 92:
          if (isValidEscape(code, getCharCode2(offset + 1)))
            consumeIdentLikeToken();
          else {
            type = Delim;
            offset++;
          }
          break;
        case 93:
          type = RightSquareBracket;
          offset++;
          break;
        case 123:
          type = LeftCurlyBracket;
          offset++;
          break;
        case 125:
          type = RightCurlyBracket;
          offset++;
          break;
        case DigitCategory:
          consumeNumericToken();
          break;
        case NameStartCategory:
          consumeIdentLikeToken();
          break;
        default:
          type = Delim;
          offset++;
      }
      onToken(type, start, start = offset);
    }
  }
  function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
      recognizer
    };
    while (!this.eof) {
      switch (this.tokenType) {
        case Comment:
          this.next();
          continue;
        case WhiteSpace:
          space = true;
          this.next();
          continue;
      }
      let child = recognizer.getNode.call(this, context);
      if (child === void 0)
        break;
      if (space) {
        if (recognizer.onWhiteSpace)
          recognizer.onWhiteSpace.call(this, child, children, context);
        space = false;
      }
      children.push(child);
    }
    if (space && recognizer.onWhiteSpace)
      recognizer.onWhiteSpace.call(this, null, children, context);
    return children;
  }
  const NOOP = () => {
  };
  const EXCLAMATIONMARK = 33;
  const NUMBERSIGN = 35;
  const SEMICOLON = 59;
  const LEFTCURLYBRACKET = 123;
  const NULL = 0;
  function createParseContext(name) {
    return function() {
      return this[name]();
    };
  }
  function fetchParseValues(dict) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const name in dict) {
      const item = dict[name];
      const fn = item.parse || item;
      if (fn)
        result[name] = fn;
    }
    return result;
  }
  function processConfig(config2) {
    const parseConfig = {
      context: /* @__PURE__ */ Object.create(null),
      scope: Object.assign(/* @__PURE__ */ Object.create(null), config2.scope),
      atrule: fetchParseValues(config2.atrule),
      pseudo: fetchParseValues(config2.pseudo),
      node: fetchParseValues(config2.node)
    };
    for (const name in config2.parseContext)
      switch (typeof config2.parseContext[name]) {
        case "function":
          parseConfig.context[name] = config2.parseContext[name];
          break;
        case "string":
          parseConfig.context[name] = createParseContext(config2.parseContext[name]);
          break;
      }
    return {
      config: parseConfig,
      ...parseConfig,
      ...parseConfig.node
    };
  }
  function createParser(config2) {
    let source = "";
    let filename = "<unknown>";
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;
    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config2 || {}), {
      parseAtrulePrelude: true,
      parseRulePrelude: true,
      parseValue: true,
      parseCustomProperty: false,
      readSequence,
      consumeUntilBalanceEnd: () => 0,
      consumeUntilLeftCurlyBracket(code) {
        return code === LEFTCURLYBRACKET ? 1 : 0;
      },
      consumeUntilLeftCurlyBracketOrSemicolon(code) {
        return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilExclamationMarkOrSemicolon(code) {
        return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
      },
      consumeUntilSemicolonIncluded(code) {
        return code === SEMICOLON ? 2 : 0;
      },
      createList() {
        return new List();
      },
      createSingleNodeList(node2) {
        return new List().appendData(node2);
      },
      getFirstListNode(list2) {
        return list2 && list2.first;
      },
      getLastListNode(list2) {
        return list2 && list2.last;
      },
      parseWithFallback(consumer, fallback) {
        const startToken = this.tokenIndex;
        try {
          return consumer.call(this);
        } catch (e) {
          if (onParseErrorThrow)
            throw e;
          const fallbackNode = fallback.call(this, startToken);
          onParseErrorThrow = true;
          onParseError(e, fallbackNode);
          onParseErrorThrow = false;
          return fallbackNode;
        }
      },
      lookupNonWSType(offset) {
        let type;
        do {
          type = this.lookupType(offset++);
          if (type !== WhiteSpace)
            return type;
        } while (type !== NULL);
        return NULL;
      },
      charCodeAt(offset) {
        return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
      },
      substring(offsetStart, offsetEnd) {
        return source.substring(offsetStart, offsetEnd);
      },
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      },
      cmpChar(offset, charCode) {
        return cmpChar(source, offset, charCode);
      },
      cmpStr(offsetStart, offsetEnd, str) {
        return cmpStr(source, offsetStart, offsetEnd, str);
      },
      consume(tokenType) {
        const start = this.tokenStart;
        this.eat(tokenType);
        return this.substrToCursor(start);
      },
      consumeFunctionName() {
        const name = source.substring(this.tokenStart, this.tokenEnd - 1);
        this.eat(Function$1);
        return name;
      },
      consumeNumber(type) {
        const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));
        this.eat(type);
        return number;
      },
      eat(tokenType) {
        if (this.tokenType !== tokenType) {
          const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
          let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
          let offset = this.tokenStart;
          switch (tokenType) {
            case Ident:
              if (this.tokenType === Function$1 || this.tokenType === Url) {
                offset = this.tokenEnd - 1;
                message = "Identifier is expected but function found";
              } else
                message = "Identifier is expected";
              break;
            case Hash:
              if (this.isDelim(NUMBERSIGN)) {
                this.next();
                offset++;
                message = "Name is expected";
              }
              break;
            case Percentage:
              if (this.tokenType === Number$1) {
                offset = this.tokenEnd;
                message = "Percent sign is expected";
              }
              break;
          }
          this.error(message, offset);
        }
        this.next();
      },
      eatIdent(name) {
        if (this.tokenType !== Ident || this.lookupValue(0, name) === false)
          this.error(`Identifier "${name}" is expected`);
        this.next();
      },
      eatDelim(code) {
        if (!this.isDelim(code))
          this.error(`Delim "${String.fromCharCode(code)}" is expected`);
        this.next();
      },
      getLocation(start, end) {
        if (needPositions)
          return locationMap.getLocationRange(start, end, filename);
        return null;
      },
      getLocationFromList(list2) {
        if (needPositions) {
          const head = this.getFirstListNode(list2);
          const tail = this.getLastListNode(list2);
          return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);
        }
        return null;
      },
      error(message, offset) {
        const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
        throw new SyntaxError$1(message || "Unexpected input", source, location.offset, location.line, location.column);
      }
    });
    const parse2 = function(source_, options) {
      source = source_;
      options = options || {};
      parser.setSource(source, tokenize);
      locationMap.setSource(source, options.offset, options.line, options.column);
      filename = options.filename || "<unknown>";
      needPositions = Boolean(options.positions);
      onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
      onParseErrorThrow = false;
      parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
      parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
      parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
      parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
      const { context = "default", onComment } = options;
      if (context in parser.context === false)
        throw new Error("Unknown context `" + context + "`");
      if (typeof onComment === "function")
        parser.forEachToken((type, start, end) => {
          if (type === Comment) {
            const loc = parser.getLocation(start, end);
            const value2 = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
            onComment(value2, loc);
          }
        });
      const ast = parser.context[context].call(parser, options);
      if (!parser.eof)
        parser.error();
      return ast;
    };
    return Object.assign(parse2, {
      SyntaxError: SyntaxError$1,
      config: parser.config
    });
  }
  const NUMBERSIGN$1 = 35;
  const ASTERISK = 42;
  const PLUSSIGN = 43;
  const HYPHENMINUS = 45;
  const SOLIDUS = 47;
  const U = 117;
  function defaultRecognizer(context) {
    switch (this.tokenType) {
      case Hash:
        return this.Hash();
      case Comma:
        return this.Operator();
      case LeftParenthesis:
        return this.Parentheses(this.readSequence, context.recognizer);
      case LeftSquareBracket:
        return this.Brackets(this.readSequence, context.recognizer);
      case String$1:
        return this.String();
      case Dimension:
        return this.Dimension();
      case Percentage:
        return this.Percentage();
      case Number$1:
        return this.Number();
      case Function$1:
        return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
      case Url:
        return this.Url();
      case Ident:
        if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN))
          return this.UnicodeRange();
        else
          return this.Identifier();
      case Delim: {
        const code = this.charCodeAt(this.tokenStart);
        if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS)
          return this.Operator();
        if (code === NUMBERSIGN$1)
          this.error("Hex or identifier is expected", this.tokenStart + 1);
        break;
      }
    }
  }
  var atrulePrelude = {
    getNode: defaultRecognizer
  };
  const NUMBERSIGN$2 = 35;
  const ASTERISK$1 = 42;
  const PLUSSIGN$1 = 43;
  const SOLIDUS$1 = 47;
  const FULLSTOP = 46;
  const GREATERTHANSIGN = 62;
  const VERTICALLINE = 124;
  const TILDE = 126;
  function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator")
      children.push({
        type: "Combinator",
        loc: null,
        name: " "
      });
  }
  function getNode() {
    switch (this.tokenType) {
      case LeftSquareBracket:
        return this.AttributeSelector();
      case Hash:
        return this.IdSelector();
      case Colon:
        if (this.lookupType(1) === Colon)
          return this.PseudoElementSelector();
        else
          return this.PseudoClassSelector();
      case Ident:
        return this.TypeSelector();
      case Number$1:
      case Percentage:
        return this.Percentage();
      case Dimension:
        if (this.charCodeAt(this.tokenStart) === FULLSTOP)
          this.error("Identifier is expected", this.tokenStart + 1);
        break;
      case Delim: {
        const code = this.charCodeAt(this.tokenStart);
        switch (code) {
          case PLUSSIGN$1:
          case GREATERTHANSIGN:
          case TILDE:
          case SOLIDUS$1:
            return this.Combinator();
          case FULLSTOP:
            return this.ClassSelector();
          case ASTERISK$1:
          case VERTICALLINE:
            return this.TypeSelector();
          case NUMBERSIGN$2:
            return this.IdSelector();
        }
        break;
      }
    }
  }
  var selector = {
    onWhiteSpace,
    getNode
  };
  function expressionFn() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  function varFn() {
    const children = this.createList();
    this.skipSC();
    children.push(this.Identifier());
    this.skipSC();
    if (this.tokenType === Comma) {
      children.push(this.Operator());
      const startIndex = this.tokenIndex;
      const value2 = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
      if (value2.type === "Value" && value2.children.isEmpty) {
        for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++)
          if (this.lookupType(offset) === WhiteSpace) {
            value2.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
      }
      children.push(value2);
    }
    return children;
  }
  function isPlusMinusOperator(node2) {
    return node2 !== null && node2.type === "Operator" && (node2.value[node2.value.length - 1] === "-" || node2.value[node2.value.length - 1] === "+");
  }
  var value = {
    getNode: defaultRecognizer,
    onWhiteSpace(next, children) {
      if (isPlusMinusOperator(next))
        next.value = " " + next.value;
      if (isPlusMinusOperator(children.last))
        children.last.value += " ";
    },
    "expression": expressionFn,
    "var": varFn
  };
  var scope = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AtrulePrelude: atrulePrelude,
    Selector: selector,
    Value: value
  });
  var fontFace = {
    parse: {
      prelude: null,
      block() {
        return this.Block(true);
      }
    }
  };
  var importAtrule = {
    parse: {
      prelude() {
        const children = this.createList();
        this.skipSC();
        switch (this.tokenType) {
          case String$1:
            children.push(this.String());
            break;
          case Url:
          case Function$1:
            children.push(this.Url());
            break;
          default:
            this.error("String or url() is expected");
        }
        if (this.lookupNonWSType(0) === Ident || this.lookupNonWSType(0) === LeftParenthesis)
          children.push(this.MediaQueryList());
        return children;
      },
      block: null
    }
  };
  var media = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.MediaQueryList());
      },
      block() {
        return this.Block(false);
      }
    }
  };
  var page = {
    parse: {
      prelude() {
        return this.createSingleNodeList(this.SelectorList());
      },
      block() {
        return this.Block(true);
      }
    }
  };
  function consumeRaw() {
    return this.createSingleNodeList(this.Raw(this.tokenIndex, null, false));
  }
  function parentheses() {
    this.skipSC();
    if (this.tokenType === Ident && this.lookupNonWSType(1) === Colon)
      return this.createSingleNodeList(this.Declaration());
    return readSequence$1.call(this);
  }
  function readSequence$1() {
    const children = this.createList();
    let child;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case Comment:
          case WhiteSpace:
            this.next();
            continue;
          case Function$1:
            child = this.Function(consumeRaw, this.scope.AtrulePrelude);
            break;
          case Ident:
            child = this.Identifier();
            break;
          case LeftParenthesis:
            child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    return children;
  }
  var supports = {
    parse: {
      prelude() {
        const children = readSequence$1.call(this);
        if (this.getFirstListNode(children) === null)
          this.error("Condition is expected");
        return children;
      },
      block() {
        return this.Block(false);
      }
    }
  };
  var atrule = {
    "font-face": fontFace,
    "import": importAtrule,
    media,
    page,
    supports
  };
  const selectorList = {
    parse() {
      return this.createSingleNodeList(this.SelectorList());
    }
  };
  const selector$1 = {
    parse() {
      return this.createSingleNodeList(this.Selector());
    }
  };
  const identList = {
    parse() {
      return this.createSingleNodeList(this.Identifier());
    }
  };
  const nth = {
    parse() {
      return this.createSingleNodeList(this.Nth());
    }
  };
  var pseudo = {
    "dir": identList,
    "has": selectorList,
    "lang": identList,
    "matches": selectorList,
    "is": selectorList,
    "-moz-any": selectorList,
    "-webkit-any": selectorList,
    "where": selectorList,
    "not": selectorList,
    "nth-child": nth,
    "nth-last-child": nth,
    "nth-last-of-type": nth,
    "nth-of-type": nth,
    "slotted": selector$1
  };
  const PLUSSIGN$2 = 43;
  const HYPHENMINUS$1 = 45;
  const N$1 = 110;
  const DISALLOW_SIGN = true;
  const ALLOW_SIGN = false;
  function checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);
    if (code === PLUSSIGN$2 || code === HYPHENMINUS$1) {
      if (disallowSign)
        this.error("Number sign is not allowed");
      pos++;
    }
    for (; pos < this.tokenEnd; pos++)
      if (!isDigit(this.charCodeAt(pos)))
        this.error("Integer is expected", pos);
  }
  function checkTokenIsInteger(disallowSign) {
    return checkInteger.call(this, 0, disallowSign);
  }
  function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
      let msg = "";
      switch (code) {
        case N$1:
          msg = "N is expected";
          break;
        case HYPHENMINUS$1:
          msg = "HyphenMinus is expected";
          break;
      }
      this.error(msg, this.tokenStart + offset);
    }
  }
  function consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;
    while (type === WhiteSpace || type === Comment)
      type = this.lookupType(++offset);
    if (type !== Number$1) {
      if (this.isDelim(PLUSSIGN$2, offset) || this.isDelim(HYPHENMINUS$1, offset)) {
        sign = this.isDelim(PLUSSIGN$2, offset) ? PLUSSIGN$2 : HYPHENMINUS$1;
        do
          type = this.lookupType(++offset);
        while (type === WhiteSpace || type === Comment);
        if (type !== Number$1) {
          this.skip(offset);
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
        }
      } else
        return null;
    }
    if (offset > 0)
      this.skip(offset);
    if (sign === 0) {
      type = this.charCodeAt(this.tokenStart);
      if (type !== PLUSSIGN$2 && type !== HYPHENMINUS$1)
        this.error("Number sign is expected");
    }
    checkTokenIsInteger.call(this, sign !== 0);
    return sign === HYPHENMINUS$1 ? "-" + this.consume(Number$1) : this.consume(Number$1);
  }
  function parse$3() {
    const start = this.tokenStart;
    let a = null;
    let b2 = null;
    if (this.tokenType === Number$1) {
      checkTokenIsInteger.call(this, ALLOW_SIGN);
      b2 = this.consume(Number$1);
    } else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS$1)) {
      a = "-1";
      expectCharCode.call(this, 1, N$1);
      switch (this.tokenEnd - this.tokenStart) {
        case 2:
          this.next();
          b2 = consumeB.call(this);
          break;
        case 3:
          expectCharCode.call(this, 2, HYPHENMINUS$1);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b2 = "-" + this.consume(Number$1);
          break;
        default:
          expectCharCode.call(this, 2, HYPHENMINUS$1);
          checkInteger.call(this, 3, DISALLOW_SIGN);
          this.next();
          b2 = this.substrToCursor(start + 2);
      }
    } else if (this.tokenType === Ident || this.isDelim(PLUSSIGN$2) && this.lookupType(1) === Ident) {
      let sign = 0;
      a = "1";
      if (this.isDelim(PLUSSIGN$2)) {
        sign = 1;
        this.next();
      }
      expectCharCode.call(this, 0, N$1);
      switch (this.tokenEnd - this.tokenStart) {
        case 1:
          this.next();
          b2 = consumeB.call(this);
          break;
        case 2:
          expectCharCode.call(this, 1, HYPHENMINUS$1);
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b2 = "-" + this.consume(Number$1);
          break;
        default:
          expectCharCode.call(this, 1, HYPHENMINUS$1);
          checkInteger.call(this, 2, DISALLOW_SIGN);
          this.next();
          b2 = this.substrToCursor(start + sign + 1);
      }
    } else if (this.tokenType === Dimension) {
      const code = this.charCodeAt(this.tokenStart);
      const sign = code === PLUSSIGN$2 || code === HYPHENMINUS$1;
      let i2 = this.tokenStart + sign;
      for (; i2 < this.tokenEnd; i2++) {
        if (!isDigit(this.charCodeAt(i2)))
          break;
      }
      if (i2 === this.tokenStart + sign)
        this.error("Integer is expected", this.tokenStart + sign);
      expectCharCode.call(this, i2 - this.tokenStart, N$1);
      a = this.substring(start, i2);
      if (i2 + 1 === this.tokenEnd) {
        this.next();
        b2 = consumeB.call(this);
      } else {
        expectCharCode.call(this, i2 - this.tokenStart + 1, HYPHENMINUS$1);
        if (i2 + 2 === this.tokenEnd) {
          this.next();
          this.skipSC();
          checkTokenIsInteger.call(this, DISALLOW_SIGN);
          b2 = "-" + this.consume(Number$1);
        } else {
          checkInteger.call(this, i2 - this.tokenStart + 2, DISALLOW_SIGN);
          this.next();
          b2 = this.substrToCursor(i2 + 1);
        }
      }
    } else
      this.error();
    if (a !== null && a.charCodeAt(0) === PLUSSIGN$2)
      a = a.substr(1);
    if (b2 !== null && b2.charCodeAt(0) === PLUSSIGN$2)
      b2 = b2.substr(1);
    return {
      type: "AnPlusB",
      loc: this.getLocation(start, this.tokenStart),
      a,
      b: b2
    };
  }
  function consumeRaw$1(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
  }
  function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
      if (type === RightCurlyBracket)
        return true;
      if (type === LeftCurlyBracket || type === AtKeyword)
        return false;
    }
    return false;
  }
  function parse$4() {
    const start = this.tokenStart;
    let name;
    let nameLowerCase;
    let prelude = null;
    let block = null;
    this.eat(AtKeyword);
    name = this.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.skipSC();
    if (this.eof === false && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon) {
      if (this.parseAtrulePrelude)
        prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw$1);
      else
        prelude = consumeRaw$1.call(this, this.tokenIndex);
      this.skipSC();
    }
    switch (this.tokenType) {
      case Semicolon:
        this.next();
        break;
      case LeftCurlyBracket:
        if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function")
          block = this.atrule[nameLowerCase].block.call(this);
        else
          block = this.Block(isDeclarationBlockAtrule.call(this));
        break;
    }
    return {
      type: "Atrule",
      loc: this.getLocation(start, this.tokenStart),
      name,
      prelude,
      block
    };
  }
  function parse$5(name) {
    let children = null;
    if (name !== null)
      name = name.toLowerCase();
    this.skipSC();
    if (hasOwnProperty.call(this.atrule, name) && typeof this.atrule[name].prelude === "function")
      children = this.atrule[name].prelude.call(this);
    else
      children = this.readSequence(this.scope.AtrulePrelude);
    this.skipSC();
    if (this.eof !== true && this.tokenType !== LeftCurlyBracket && this.tokenType !== Semicolon)
      this.error("Semicolon or block is expected");
    return {
      type: "AtrulePrelude",
      loc: this.getLocationFromList(children),
      children
    };
  }
  const DOLLARSIGN = 36;
  const ASTERISK$2 = 42;
  const EQUALSSIGN = 61;
  const CIRCUMFLEXACCENT = 94;
  const VERTICALLINE$1 = 124;
  const TILDE$1 = 126;
  function getAttributeName() {
    if (this.eof)
      this.error("Unexpected end of input");
    const start = this.tokenStart;
    let expectIdent = false;
    if (this.isDelim(ASTERISK$2)) {
      expectIdent = true;
      this.next();
    } else if (!this.isDelim(VERTICALLINE$1))
      this.eat(Ident);
    if (this.isDelim(VERTICALLINE$1)) {
      if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
        this.next();
        this.eat(Ident);
      } else if (expectIdent)
        this.error("Identifier is expected", this.tokenEnd);
    } else if (expectIdent)
      this.error("Vertical line is expected");
    return {
      type: "Identifier",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);
    if (code !== EQUALSSIGN && // =
    code !== TILDE$1 && // ~=
    code !== CIRCUMFLEXACCENT && // ^=
    code !== DOLLARSIGN && // $=
    code !== ASTERISK$2 && // *=
    code !== VERTICALLINE$1)
      this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
    this.next();
    if (code !== EQUALSSIGN) {
      if (!this.isDelim(EQUALSSIGN))
        this.error("Equal sign is expected");
      this.next();
    }
    return this.substrToCursor(start);
  }
  function parse$6() {
    const start = this.tokenStart;
    let name;
    let matcher = null;
    let value2 = null;
    let flags = null;
    this.eat(LeftSquareBracket);
    this.skipSC();
    name = getAttributeName.call(this);
    this.skipSC();
    if (this.tokenType !== RightSquareBracket) {
      if (this.tokenType !== Ident) {
        matcher = getOperator.call(this);
        this.skipSC();
        value2 = this.tokenType === String$1 ? this.String() : this.Identifier();
        this.skipSC();
      }
      if (this.tokenType === Ident) {
        flags = this.consume(Ident);
        this.skipSC();
      }
    }
    this.eat(RightSquareBracket);
    return {
      type: "AttributeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name,
      matcher,
      value: value2,
      flags
    };
  }
  function consumeRaw$2(startToken) {
    return this.Raw(startToken, null, true);
  }
  function consumeRule() {
    return this.parseWithFallback(this.Rule, consumeRaw$2);
  }
  function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  function consumeDeclaration() {
    if (this.tokenType === Semicolon)
      return consumeRawDeclaration.call(this, this.tokenIndex);
    const node2 = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
    if (this.tokenType === Semicolon)
      this.next();
    return node2;
  }
  function parse$7(isDeclaration) {
    const consumer = isDeclaration ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();
    this.eat(LeftCurlyBracket);
    scan:
      while (!this.eof)
        switch (this.tokenType) {
          case RightCurlyBracket:
            break scan;
          case WhiteSpace:
          case Comment:
            this.next();
            break;
          case AtKeyword:
            children.push(this.parseWithFallback(this.Atrule, consumeRaw$2));
            break;
          default:
            children.push(consumer.call(this));
        }
    if (!this.eof)
      this.eat(RightCurlyBracket);
    return {
      type: "Block",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function parse$8(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftSquareBracket);
    children = readSequence2.call(this, recognizer);
    if (!this.eof)
      this.eat(RightSquareBracket);
    return {
      type: "Brackets",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function parse$9() {
    const start = this.tokenStart;
    this.eat(CDC);
    return {
      type: "CDC",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  function parse$a() {
    const start = this.tokenStart;
    this.eat(CDO);
    return {
      type: "CDO",
      loc: this.getLocation(start, this.tokenStart)
    };
  }
  const FULLSTOP$1 = 46;
  function parse$b() {
    this.eatDelim(FULLSTOP$1);
    return {
      type: "ClassSelector",
      loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  const PLUSSIGN$3 = 43;
  const SOLIDUS$2 = 47;
  const GREATERTHANSIGN$1 = 62;
  const TILDE$2 = 126;
  function parse$c() {
    const start = this.tokenStart;
    let name;
    switch (this.tokenType) {
      case WhiteSpace:
        name = " ";
        break;
      case Delim:
        switch (this.charCodeAt(this.tokenStart)) {
          case GREATERTHANSIGN$1:
          case PLUSSIGN$3:
          case TILDE$2:
            this.next();
            break;
          case SOLIDUS$2:
            this.next();
            this.eatIdent("deep");
            this.eatDelim(SOLIDUS$2);
            break;
          default:
            this.error("Combinator is expected");
        }
        name = this.substrToCursor(start);
        break;
    }
    return {
      type: "Combinator",
      loc: this.getLocation(start, this.tokenStart),
      name
    };
  }
  const ASTERISK$3 = 42;
  const SOLIDUS$3 = 47;
  function parse$d() {
    const start = this.tokenStart;
    let end = this.tokenEnd;
    this.eat(Comment);
    if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK$3 && this.charCodeAt(end - 1) === SOLIDUS$3)
      end -= 2;
    return {
      type: "Comment",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substring(start + 2, end)
    };
  }
  const HYPHENMINUS$2 = 45;
  function isCustomProperty(str, offset) {
    offset = offset || 0;
    return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS$2 && str.charCodeAt(offset + 1) === HYPHENMINUS$2;
  }
  const EXCLAMATIONMARK$1 = 33;
  const NUMBERSIGN$3 = 35;
  const DOLLARSIGN$1 = 36;
  const AMPERSAND = 38;
  const ASTERISK$4 = 42;
  const PLUSSIGN$4 = 43;
  const SOLIDUS$4 = 47;
  function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
  }
  function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
  }
  function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value2 = this.Value();
    if (value2.type !== "Raw" && this.eof === false && this.tokenType !== Semicolon && this.isDelim(EXCLAMATIONMARK$1) === false && this.isBalanceEdge(startValueToken) === false)
      this.error();
    return value2;
  }
  function parse$e() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = readProperty.call(this);
    const customProperty = isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw2 = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value2;
    this.skipSC();
    this.eat(Colon);
    const valueStart = this.tokenIndex;
    if (!customProperty)
      this.skipSC();
    if (parseValue)
      value2 = this.parseWithFallback(consumeValue, consumeRaw2);
    else
      value2 = consumeRaw2.call(this, this.tokenIndex);
    if (customProperty && value2.type === "Value" && value2.children.isEmpty) {
      for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++)
        if (this.lookupType(offset) === WhiteSpace) {
          value2.children.appendData({
            type: "WhiteSpace",
            loc: null,
            value: " "
          });
          break;
        }
    }
    if (this.isDelim(EXCLAMATIONMARK$1)) {
      important = getImportant.call(this);
      this.skipSC();
    }
    if (this.eof === false && this.tokenType !== Semicolon && this.isBalanceEdge(startToken) === false)
      this.error();
    return {
      type: "Declaration",
      loc: this.getLocation(start, this.tokenStart),
      important,
      property,
      value: value2
    };
  }
  function readProperty() {
    const start = this.tokenStart;
    if (this.tokenType === Delim)
      switch (this.charCodeAt(this.tokenStart)) {
        case ASTERISK$4:
        case DOLLARSIGN$1:
        case PLUSSIGN$4:
        case NUMBERSIGN$3:
        case AMPERSAND:
          this.next();
          break;
        case SOLIDUS$4:
          this.next();
          if (this.isDelim(SOLIDUS$4))
            this.next();
          break;
      }
    if (this.tokenType === Hash)
      this.eat(Hash);
    else
      this.eat(Ident);
    return this.substrToCursor(start);
  }
  function getImportant() {
    this.eat(Delim);
    this.skipSC();
    const important = this.consume(Ident);
    return important === "important" ? true : important;
  }
  function consumeRaw$3(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
  }
  function parse$f() {
    const children = this.createList();
    while (!this.eof)
      switch (this.tokenType) {
        case WhiteSpace:
        case Comment:
        case Semicolon:
          this.next();
          break;
        default:
          children.push(this.parseWithFallback(this.Declaration, consumeRaw$3));
      }
    return {
      type: "DeclarationList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function parse$g() {
    const start = this.tokenStart;
    const value2 = this.consumeNumber(Dimension);
    return {
      type: "Dimension",
      loc: this.getLocation(start, this.tokenStart),
      value: value2,
      unit: this.substring(start + value2.length, this.tokenStart)
    };
  }
  function parse$h(readSequence2, recognizer) {
    const start = this.tokenStart;
    const name = this.consumeFunctionName();
    const nameLowerCase = name.toLowerCase();
    let children;
    children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence2.call(this, recognizer);
    if (!this.eof)
      this.eat(RightParenthesis);
    return {
      type: "Function",
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }
  function parse$i() {
    const start = this.tokenStart;
    this.eat(Hash);
    return {
      type: "Hash",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start + 1)
    };
  }
  function parse$j() {
    return {
      type: "Identifier",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      name: this.consume(Ident)
    };
  }
  function parse$k() {
    const start = this.tokenStart;
    this.eat(Hash);
    return {
      type: "IdSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start + 1)
    };
  }
  function parse$l() {
    const start = this.tokenStart;
    let name;
    let value2 = null;
    this.eat(LeftParenthesis);
    this.skipSC();
    name = this.consume(Ident);
    this.skipSC();
    if (this.tokenType !== RightParenthesis) {
      this.eat(Colon);
      this.skipSC();
      switch (this.tokenType) {
        case Number$1:
          if (this.lookupNonWSType(1) === Delim)
            value2 = this.Ratio();
          else
            value2 = this.Number();
          break;
        case Dimension:
          value2 = this.Dimension();
          break;
        case Ident:
          value2 = this.Identifier();
          break;
        default:
          this.error("Number, dimension, ratio or identifier is expected");
      }
      this.skipSC();
    }
    this.eat(RightParenthesis);
    return {
      type: "MediaFeature",
      loc: this.getLocation(start, this.tokenStart),
      name,
      value: value2
    };
  }
  function parse$m() {
    const children = this.createList();
    let child = null;
    this.skipSC();
    scan:
      while (!this.eof) {
        switch (this.tokenType) {
          case Comment:
          case WhiteSpace:
            this.next();
            continue;
          case Ident:
            child = this.Identifier();
            break;
          case LeftParenthesis:
            child = this.MediaFeature();
            break;
          default:
            break scan;
        }
        children.push(child);
      }
    if (child === null)
      this.error("Identifier or parenthesis is expected");
    return {
      type: "MediaQuery",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function parse$n() {
    const children = this.createList();
    this.skipSC();
    while (!this.eof) {
      children.push(this.MediaQuery());
      if (this.tokenType !== Comma)
        break;
      this.next();
    }
    return {
      type: "MediaQueryList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function parse$o() {
    this.skipSC();
    const start = this.tokenStart;
    let end = start;
    let selector2 = null;
    let nth2;
    if (this.lookupValue(0, "odd") || this.lookupValue(0, "even"))
      nth2 = this.Identifier();
    else
      nth2 = this.AnPlusB();
    end = this.tokenStart;
    this.skipSC();
    if (this.lookupValue(0, "of")) {
      this.next();
      selector2 = this.SelectorList();
      end = this.tokenStart;
    }
    return {
      type: "Nth",
      loc: this.getLocation(start, end),
      nth: nth2,
      selector: selector2
    };
  }
  function parse$p() {
    return {
      type: "Number",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consume(Number$1)
    };
  }
  function parse$q() {
    const start = this.tokenStart;
    this.next();
    return {
      type: "Operator",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  function parse$r(readSequence2, recognizer) {
    const start = this.tokenStart;
    let children = null;
    this.eat(LeftParenthesis);
    children = readSequence2.call(this, recognizer);
    if (!this.eof)
      this.eat(RightParenthesis);
    return {
      type: "Parentheses",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  function parse$s() {
    return {
      type: "Percentage",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: this.consumeNumber(Percentage)
    };
  }
  function parse$t() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;
    this.eat(Colon);
    if (this.tokenType === Function$1) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(RightParenthesis);
    } else
      name = this.consume(Ident);
    return {
      type: "PseudoClassSelector",
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }
  function parse$u() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;
    this.eat(Colon);
    this.eat(Colon);
    if (this.tokenType === Function$1) {
      name = this.consumeFunctionName();
      nameLowerCase = name.toLowerCase();
      if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
        this.skipSC();
        children = this.pseudo[nameLowerCase].call(this);
        this.skipSC();
      } else {
        children = this.createList();
        children.push(this.Raw(this.tokenIndex, null, false));
      }
      this.eat(RightParenthesis);
    } else
      name = this.consume(Ident);
    return {
      type: "PseudoElementSelector",
      loc: this.getLocation(start, this.tokenStart),
      name,
      children
    };
  }
  const SOLIDUS$5 = 47;
  const FULLSTOP$2 = 46;
  function consumeNumber$1() {
    this.skipSC();
    const value2 = this.consume(Number$1);
    for (let i2 = 0; i2 < value2.length; i2++) {
      const code = value2.charCodeAt(i2);
      if (!isDigit(code) && code !== FULLSTOP$2)
        this.error("Unsigned number is expected", this.tokenStart - value2.length + i2);
    }
    if (Number(value2) === 0)
      this.error("Zero number is not allowed", this.tokenStart - value2.length);
    return value2;
  }
  function parse$v() {
    const start = this.tokenStart;
    const left = consumeNumber$1.call(this);
    let right;
    this.skipSC();
    this.eatDelim(SOLIDUS$5);
    right = consumeNumber$1.call(this);
    return {
      type: "Ratio",
      loc: this.getLocation(start, this.tokenStart),
      left,
      right
    };
  }
  function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
      if (this.lookupType(-1) === WhiteSpace)
        return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
    }
    return this.tokenStart;
  }
  function parse$w(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;
    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
    if (excludeWhiteSpace && this.tokenStart > startOffset)
      endOffset = getOffsetExcludeWS.call(this);
    else
      endOffset = this.tokenStart;
    return {
      type: "Raw",
      loc: this.getLocation(startOffset, endOffset),
      value: this.substring(startOffset, endOffset)
    };
  }
  function consumeRaw$4(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
  }
  function consumePrelude() {
    const prelude = this.SelectorList();
    if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== LeftCurlyBracket)
      this.error();
    return prelude;
  }
  function parse$x() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;
    if (this.parseRulePrelude)
      prelude = this.parseWithFallback(consumePrelude, consumeRaw$4);
    else
      prelude = consumeRaw$4.call(this, startToken);
    block = this.Block(true);
    return {
      type: "Rule",
      loc: this.getLocation(startOffset, this.tokenStart),
      prelude,
      block
    };
  }
  function parse$y() {
    const children = this.readSequence(this.scope.Selector);
    if (this.getFirstListNode(children) === null)
      this.error("Selector is expected");
    return {
      type: "Selector",
      loc: this.getLocationFromList(children),
      children
    };
  }
  function parse$z() {
    const children = this.createList();
    while (!this.eof) {
      children.push(this.Selector());
      if (this.tokenType === Comma) {
        this.next();
        continue;
      }
      break;
    }
    return {
      type: "SelectorList",
      loc: this.getLocationFromList(children),
      children
    };
  }
  const REVERSE_SOLIDUS = 92;
  const QUOTATION_MARK = 34;
  const APOSTROPHE = 39;
  function decode$1(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = "";
    for (let i2 = start; i2 <= end; i2++) {
      let code = str.charCodeAt(i2);
      if (code === REVERSE_SOLIDUS) {
        if (i2 === end) {
          if (i2 !== len - 1)
            decoded = str.substr(i2 + 1);
          break;
        }
        code = str.charCodeAt(++i2);
        if (isValidEscape(REVERSE_SOLIDUS, code)) {
          const escapeStart = i2 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i2 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else if (code === 13 && str.charCodeAt(i2 + 1) === 10)
          i2++;
      } else
        decoded += str[i2];
    }
    return decoded;
  }
  function parse$A() {
    return {
      type: "String",
      loc: this.getLocation(this.tokenStart, this.tokenEnd),
      value: decode$1(this.consume(String$1))
    };
  }
  const EXCLAMATIONMARK$2 = 33;
  function consumeRaw$5(startToken) {
    return this.Raw(startToken, null, false);
  }
  function parse$B() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;
    while (!this.eof) {
      switch (this.tokenType) {
        case WhiteSpace:
          this.next();
          continue;
        case Comment:
          if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK$2) {
            this.next();
            continue;
          }
          child = this.Comment();
          break;
        case CDO:
          child = this.CDO();
          break;
        case CDC:
          child = this.CDC();
          break;
        case AtKeyword:
          child = this.parseWithFallback(this.Atrule, consumeRaw$5);
          break;
        default:
          child = this.parseWithFallback(this.Rule, consumeRaw$5);
      }
      children.push(child);
    }
    return {
      type: "StyleSheet",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  const ASTERISK$5 = 42;
  const VERTICALLINE$2 = 124;
  function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident && this.isDelim(ASTERISK$5) === false)
      this.error("Identifier or asterisk is expected");
    this.next();
  }
  function parse$C() {
    const start = this.tokenStart;
    if (this.isDelim(VERTICALLINE$2)) {
      this.next();
      eatIdentifierOrAsterisk.call(this);
    } else {
      eatIdentifierOrAsterisk.call(this);
      if (this.isDelim(VERTICALLINE$2)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      }
    }
    return {
      type: "TypeSelector",
      loc: this.getLocation(start, this.tokenStart),
      name: this.substrToCursor(start)
    };
  }
  const PLUSSIGN$5 = 43;
  const HYPHENMINUS$3 = 45;
  const QUESTIONMARK = 63;
  function eatHexSequence(offset, allowDash) {
    let len = 0;
    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
      const code = this.charCodeAt(pos);
      if (code === HYPHENMINUS$3 && allowDash && len !== 0) {
        eatHexSequence.call(this, offset + len + 1, false);
        return -1;
      }
      if (!isHexDigit$1(code))
        this.error(allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input", pos);
      if (++len > 6)
        this.error("Too many hex digits", pos);
    }
    this.next();
    return len;
  }
  function eatQuestionMarkSequence(max) {
    let count = 0;
    while (this.isDelim(QUESTIONMARK)) {
      if (++count > max)
        this.error("Too many question marks");
      this.next();
    }
  }
  function startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code)
      this.error((code === PLUSSIGN$5 ? "Plus sign" : "Hyphen minus") + " is expected");
  }
  function scanUnicodeRange() {
    let hexLength = 0;
    switch (this.tokenType) {
      case Number$1:
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.tokenType === Dimension || this.tokenType === Number$1) {
          startsWith.call(this, HYPHENMINUS$3);
          eatHexSequence.call(this, 1, false);
          break;
        }
        break;
      case Dimension:
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0)
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        break;
      default:
        this.eatDelim(PLUSSIGN$5);
        if (this.tokenType === Ident) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0)
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          break;
        }
        if (this.isDelim(QUESTIONMARK)) {
          this.next();
          eatQuestionMarkSequence.call(this, 5);
          break;
        }
        this.error("Hex digit or question mark is expected");
    }
  }
  function parse$D() {
    const start = this.tokenStart;
    this.eatIdent("u");
    scanUnicodeRange.call(this);
    return {
      type: "UnicodeRange",
      loc: this.getLocation(start, this.tokenStart),
      value: this.substrToCursor(start)
    };
  }
  const REVERSE_SOLIDUS$1 = 92;
  const RIGHTPARENTHESIS = 41;
  function decode$2(str) {
    const len = str.length;
    let start = 4;
    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = "";
    while (start < end && isWhiteSpace(str.charCodeAt(start)))
      start++;
    while (start < end && isWhiteSpace(str.charCodeAt(end)))
      end--;
    for (let i2 = start; i2 <= end; i2++) {
      let code = str.charCodeAt(i2);
      if (code === REVERSE_SOLIDUS$1) {
        if (i2 === end) {
          if (i2 !== len - 1)
            decoded = str.substr(i2 + 1);
          break;
        }
        code = str.charCodeAt(++i2);
        if (isValidEscape(REVERSE_SOLIDUS$1, code)) {
          const escapeStart = i2 - 1;
          const escapeEnd = consumeEscaped(str, escapeStart);
          i2 = escapeEnd - 1;
          decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
        } else if (code === 13 && str.charCodeAt(i2 + 1) === 10)
          i2++;
      } else
        decoded += str[i2];
    }
    return decoded;
  }
  function parse$E() {
    const start = this.tokenStart;
    let value2;
    switch (this.tokenType) {
      case Url:
        value2 = decode$2(this.consume(Url));
        break;
      case Function$1:
        if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url("))
          this.error("Function name must be `url`");
        this.eat(Function$1);
        this.skipSC();
        value2 = decode$1(this.consume(String$1));
        this.skipSC();
        if (!this.eof)
          this.eat(RightParenthesis);
        break;
      default:
        this.error("Url or Function is expected");
    }
    return {
      type: "Url",
      loc: this.getLocation(start, this.tokenStart),
      value: value2
    };
  }
  function parse$F() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);
    return {
      type: "Value",
      loc: this.getLocation(start, this.tokenStart),
      children
    };
  }
  const SPACE = Object.freeze({
    type: "WhiteSpace",
    loc: null,
    value: " "
  });
  function parse$G() {
    this.eat(WhiteSpace);
    return SPACE;
  }
  var node = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AnPlusB: parse$3,
    Atrule: parse$4,
    AtrulePrelude: parse$5,
    AttributeSelector: parse$6,
    Block: parse$7,
    Brackets: parse$8,
    CDC: parse$9,
    CDO: parse$a,
    ClassSelector: parse$b,
    Combinator: parse$c,
    Comment: parse$d,
    Declaration: parse$e,
    DeclarationList: parse$f,
    Dimension: parse$g,
    Function: parse$h,
    Hash: parse$i,
    Identifier: parse$j,
    IdSelector: parse$k,
    MediaFeature: parse$l,
    MediaQuery: parse$m,
    MediaQueryList: parse$n,
    Nth: parse$o,
    Number: parse$p,
    Operator: parse$q,
    Parentheses: parse$r,
    Percentage: parse$s,
    PseudoClassSelector: parse$t,
    PseudoElementSelector: parse$u,
    Ratio: parse$v,
    Raw: parse$w,
    Rule: parse$x,
    Selector: parse$y,
    SelectorList: parse$z,
    String: parse$A,
    StyleSheet: parse$B,
    TypeSelector: parse$C,
    UnicodeRange: parse$D,
    Url: parse$E,
    Value: parse$F,
    WhiteSpace: parse$G
  });
  var config = {
    parseContext: {
      default: "StyleSheet",
      stylesheet: "StyleSheet",
      atrule: "Atrule",
      atrulePrelude(options) {
        return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
      },
      mediaQueryList: "MediaQueryList",
      mediaQuery: "MediaQuery",
      rule: "Rule",
      selectorList: "SelectorList",
      selector: "Selector",
      block() {
        return this.Block(true);
      },
      declarationList: "DeclarationList",
      declaration: "Declaration",
      value: "Value"
    },
    scope,
    atrule,
    pseudo,
    node
  };
  var parse$H = createParser(config);
  const regex_closing_style_tag = /<\/style\s*>/;
  function read_style(parser, start, attributes) {
    const content_start = parser.index;
    const styles = parser.read_until(regex_closing_style_tag, parser_errors.unclosed_style);
    if (parser.index >= parser.template.length)
      parser.error(parser_errors.unclosed_style);
    const content_end = parser.index;
    if (parser.css_mode === "none") {
      parser.read(regex_closing_style_tag);
      return null;
    }
    let ast;
    try {
      ast = parse$H(styles, {
        positions: true,
        offset: content_start,
        onParseError(error2) {
          throw error2;
        }
      });
    } catch (err) {
      if (err.name === "SyntaxError")
        parser.error(parser_errors.css_syntax_error(err.message), err.offset);
      else
        throw err;
    }
    ast = JSON.parse(JSON.stringify(ast));
    walk(ast, {
      enter: (node2) => {
        if (node2.type === "Selector")
          for (let i2 = 0; i2 < node2.children.length; i2 += 1) {
            const a = node2.children[i2];
            const b2 = node2.children[i2 + 1];
            if (is_ref_selector(a, b2))
              parser.error(parser_errors.invalid_ref_selector, a.loc.start.offset);
          }
        if (node2.type === "Declaration" && node2.value.type === "Value" && node2.value.children.length === 0)
          parser.error(parser_errors.invalid_declaration, node2.start);
        if (node2.type === "PseudoClassSelector" && node2.name === "global" && node2.children === null)
          parser.error(parser_errors.empty_global_selector, node2.loc.start.offset);
        if (node2.loc) {
          node2.start = node2.loc.start.offset;
          node2.end = node2.loc.end.offset;
          delete node2.loc;
        }
      }
    });
    parser.read(regex_closing_style_tag);
    const end = parser.index;
    return {
      type: "Style",
      start,
      end,
      attributes,
      children: ast.children,
      content: {
        start: content_start,
        end: content_end,
        styles
      }
    };
  }
  function is_ref_selector(a, b2) {
    if (!b2)
      return false;
    return a.type === "TypeSelector" && a.name === "ref" && b2.type === "PseudoClassSelector";
  }
  var entities = {
    CounterClockwiseContourIntegral: 8755,
    ClockwiseContourIntegral: 8754,
    DoubleLongLeftRightArrow: 10234,
    DiacriticalDoubleAcute: 733,
    NotSquareSupersetEqual: 8931,
    CloseCurlyDoubleQuote: 8221,
    DoubleContourIntegral: 8751,
    FilledVerySmallSquare: 9642,
    NegativeVeryThinSpace: 8203,
    NotPrecedesSlantEqual: 8928,
    NotRightTriangleEqual: 8941,
    NotSucceedsSlantEqual: 8929,
    CapitalDifferentialD: 8517,
    DoubleLeftRightArrow: 8660,
    DoubleLongRightArrow: 10233,
    EmptyVerySmallSquare: 9643,
    NestedGreaterGreater: 8811,
    NotDoubleVerticalBar: 8742,
    NotLeftTriangleEqual: 8940,
    NotSquareSubsetEqual: 8930,
    OpenCurlyDoubleQuote: 8220,
    ReverseUpEquilibrium: 10607,
    DoubleLongLeftArrow: 10232,
    DownLeftRightVector: 10576,
    LeftArrowRightArrow: 8646,
    NegativeMediumSpace: 8203,
    RightArrowLeftArrow: 8644,
    SquareSupersetEqual: 8850,
    leftrightsquigarrow: 8621,
    DownRightTeeVector: 10591,
    DownRightVectorBar: 10583,
    LongLeftRightArrow: 10231,
    Longleftrightarrow: 10234,
    NegativeThickSpace: 8203,
    PrecedesSlantEqual: 8828,
    ReverseEquilibrium: 8651,
    RightDoubleBracket: 10215,
    RightDownTeeVector: 10589,
    RightDownVectorBar: 10581,
    RightTriangleEqual: 8885,
    SquareIntersection: 8851,
    SucceedsSlantEqual: 8829,
    blacktriangleright: 9656,
    longleftrightarrow: 10231,
    DoubleUpDownArrow: 8661,
    DoubleVerticalBar: 8741,
    DownLeftTeeVector: 10590,
    DownLeftVectorBar: 10582,
    FilledSmallSquare: 9724,
    GreaterSlantEqual: 10878,
    LeftDoubleBracket: 10214,
    LeftDownTeeVector: 10593,
    LeftDownVectorBar: 10585,
    LeftTriangleEqual: 8884,
    NegativeThinSpace: 8203,
    NotReverseElement: 8716,
    NotTildeFullEqual: 8775,
    RightAngleBracket: 10217,
    RightUpDownVector: 10575,
    SquareSubsetEqual: 8849,
    VerticalSeparator: 10072,
    blacktriangledown: 9662,
    blacktriangleleft: 9666,
    leftrightharpoons: 8651,
    rightleftharpoons: 8652,
    twoheadrightarrow: 8608,
    DiacriticalAcute: 180,
    DiacriticalGrave: 96,
    DiacriticalTilde: 732,
    DoubleRightArrow: 8658,
    DownArrowUpArrow: 8693,
    EmptySmallSquare: 9723,
    GreaterEqualLess: 8923,
    GreaterFullEqual: 8807,
    LeftAngleBracket: 10216,
    LeftUpDownVector: 10577,
    LessEqualGreater: 8922,
    NonBreakingSpace: 160,
    NotRightTriangle: 8939,
    NotSupersetEqual: 8841,
    RightTriangleBar: 10704,
    RightUpTeeVector: 10588,
    RightUpVectorBar: 10580,
    UnderParenthesis: 9181,
    UpArrowDownArrow: 8645,
    circlearrowright: 8635,
    downharpoonright: 8642,
    ntrianglerighteq: 8941,
    rightharpoondown: 8641,
    rightrightarrows: 8649,
    twoheadleftarrow: 8606,
    vartriangleright: 8883,
    CloseCurlyQuote: 8217,
    ContourIntegral: 8750,
    DoubleDownArrow: 8659,
    DoubleLeftArrow: 8656,
    DownRightVector: 8641,
    LeftRightVector: 10574,
    LeftTriangleBar: 10703,
    LeftUpTeeVector: 10592,
    LeftUpVectorBar: 10584,
    LowerRightArrow: 8600,
    NotGreaterEqual: 8817,
    NotGreaterTilde: 8821,
    NotLeftTriangle: 8938,
    OverParenthesis: 9180,
    RightDownVector: 8642,
    ShortRightArrow: 8594,
    UpperRightArrow: 8599,
    bigtriangledown: 9661,
    circlearrowleft: 8634,
    curvearrowright: 8631,
    downharpoonleft: 8643,
    leftharpoondown: 8637,
    leftrightarrows: 8646,
    nLeftrightarrow: 8654,
    nleftrightarrow: 8622,
    ntrianglelefteq: 8940,
    rightleftarrows: 8644,
    rightsquigarrow: 8605,
    rightthreetimes: 8908,
    straightepsilon: 1013,
    trianglerighteq: 8885,
    vartriangleleft: 8882,
    DiacriticalDot: 729,
    DoubleRightTee: 8872,
    DownLeftVector: 8637,
    GreaterGreater: 10914,
    HorizontalLine: 9472,
    InvisibleComma: 8291,
    InvisibleTimes: 8290,
    LeftDownVector: 8643,
    LeftRightArrow: 8596,
    Leftrightarrow: 8660,
    LessSlantEqual: 10877,
    LongRightArrow: 10230,
    Longrightarrow: 10233,
    LowerLeftArrow: 8601,
    NestedLessLess: 8810,
    NotGreaterLess: 8825,
    NotLessGreater: 8824,
    NotSubsetEqual: 8840,
    NotVerticalBar: 8740,
    OpenCurlyQuote: 8216,
    ReverseElement: 8715,
    RightTeeVector: 10587,
    RightVectorBar: 10579,
    ShortDownArrow: 8595,
    ShortLeftArrow: 8592,
    SquareSuperset: 8848,
    TildeFullEqual: 8773,
    UpperLeftArrow: 8598,
    ZeroWidthSpace: 8203,
    curvearrowleft: 8630,
    doublebarwedge: 8966,
    downdownarrows: 8650,
    hookrightarrow: 8618,
    leftleftarrows: 8647,
    leftrightarrow: 8596,
    leftthreetimes: 8907,
    longrightarrow: 10230,
    looparrowright: 8620,
    nshortparallel: 8742,
    ntriangleright: 8939,
    rightarrowtail: 8611,
    rightharpoonup: 8640,
    trianglelefteq: 8884,
    upharpoonright: 8638,
    ApplyFunction: 8289,
    DifferentialD: 8518,
    DoubleLeftTee: 10980,
    DoubleUpArrow: 8657,
    LeftTeeVector: 10586,
    LeftVectorBar: 10578,
    LessFullEqual: 8806,
    LongLeftArrow: 10229,
    Longleftarrow: 10232,
    NotTildeEqual: 8772,
    NotTildeTilde: 8777,
    Poincareplane: 8460,
    PrecedesEqual: 10927,
    PrecedesTilde: 8830,
    RightArrowBar: 8677,
    RightTeeArrow: 8614,
    RightTriangle: 8883,
    RightUpVector: 8638,
    SucceedsEqual: 10928,
    SucceedsTilde: 8831,
    SupersetEqual: 8839,
    UpEquilibrium: 10606,
    VerticalTilde: 8768,
    VeryThinSpace: 8202,
    bigtriangleup: 9651,
    blacktriangle: 9652,
    divideontimes: 8903,
    fallingdotseq: 8786,
    hookleftarrow: 8617,
    leftarrowtail: 8610,
    leftharpoonup: 8636,
    longleftarrow: 10229,
    looparrowleft: 8619,
    measuredangle: 8737,
    ntriangleleft: 8938,
    shortparallel: 8741,
    smallsetminus: 8726,
    triangleright: 9657,
    upharpoonleft: 8639,
    DownArrowBar: 10515,
    DownTeeArrow: 8615,
    ExponentialE: 8519,
    GreaterEqual: 8805,
    GreaterTilde: 8819,
    HilbertSpace: 8459,
    HumpDownHump: 8782,
    Intersection: 8898,
    LeftArrowBar: 8676,
    LeftTeeArrow: 8612,
    LeftTriangle: 8882,
    LeftUpVector: 8639,
    NotCongruent: 8802,
    NotLessEqual: 8816,
    NotLessTilde: 8820,
    Proportional: 8733,
    RightCeiling: 8969,
    RoundImplies: 10608,
    ShortUpArrow: 8593,
    SquareSubset: 8847,
    UnderBracket: 9141,
    VerticalLine: 124,
    blacklozenge: 10731,
    exponentiale: 8519,
    risingdotseq: 8787,
    triangledown: 9663,
    triangleleft: 9667,
    CircleMinus: 8854,
    CircleTimes: 8855,
    Equilibrium: 8652,
    GreaterLess: 8823,
    LeftCeiling: 8968,
    LessGreater: 8822,
    MediumSpace: 8287,
    NotPrecedes: 8832,
    NotSucceeds: 8833,
    OverBracket: 9140,
    RightVector: 8640,
    Rrightarrow: 8667,
    RuleDelayed: 10740,
    SmallCircle: 8728,
    SquareUnion: 8852,
    SubsetEqual: 8838,
    UpDownArrow: 8597,
    Updownarrow: 8661,
    VerticalBar: 8739,
    backepsilon: 1014,
    blacksquare: 9642,
    circledcirc: 8858,
    circleddash: 8861,
    curlyeqprec: 8926,
    curlyeqsucc: 8927,
    diamondsuit: 9830,
    eqslantless: 10901,
    expectation: 8496,
    nRightarrow: 8655,
    nrightarrow: 8603,
    preccurlyeq: 8828,
    precnapprox: 10937,
    quaternions: 8461,
    straightphi: 981,
    succcurlyeq: 8829,
    succnapprox: 10938,
    thickapprox: 8776,
    updownarrow: 8597,
    Bernoullis: 8492,
    CirclePlus: 8853,
    EqualTilde: 8770,
    Fouriertrf: 8497,
    ImaginaryI: 8520,
    Laplacetrf: 8466,
    LeftVector: 8636,
    Lleftarrow: 8666,
    NotElement: 8713,
    NotGreater: 8815,
    Proportion: 8759,
    RightArrow: 8594,
    RightFloor: 8971,
    Rightarrow: 8658,
    TildeEqual: 8771,
    TildeTilde: 8776,
    UnderBrace: 9183,
    UpArrowBar: 10514,
    UpTeeArrow: 8613,
    circledast: 8859,
    complement: 8705,
    curlywedge: 8911,
    eqslantgtr: 10902,
    gtreqqless: 10892,
    lessapprox: 10885,
    lesseqqgtr: 10891,
    lmoustache: 9136,
    longmapsto: 10236,
    mapstodown: 8615,
    mapstoleft: 8612,
    nLeftarrow: 8653,
    nleftarrow: 8602,
    precapprox: 10935,
    rightarrow: 8594,
    rmoustache: 9137,
    sqsubseteq: 8849,
    sqsupseteq: 8850,
    subsetneqq: 10955,
    succapprox: 10936,
    supsetneqq: 10956,
    upuparrows: 8648,
    varepsilon: 949,
    varnothing: 8709,
    Backslash: 8726,
    CenterDot: 183,
    CircleDot: 8857,
    Congruent: 8801,
    Coproduct: 8720,
    DoubleDot: 168,
    DownArrow: 8595,
    DownBreve: 785,
    Downarrow: 8659,
    HumpEqual: 8783,
    LeftArrow: 8592,
    LeftFloor: 8970,
    Leftarrow: 8656,
    LessTilde: 8818,
    Mellintrf: 8499,
    MinusPlus: 8723,
    NotCupCap: 8813,
    NotExists: 8708,
    OverBrace: 9182,
    PlusMinus: 177,
    Therefore: 8756,
    ThinSpace: 8201,
    TripleDot: 8411,
    UnionPlus: 8846,
    backprime: 8245,
    backsimeq: 8909,
    bigotimes: 10754,
    centerdot: 183,
    checkmark: 10003,
    complexes: 8450,
    dotsquare: 8865,
    downarrow: 8595,
    gtrapprox: 10886,
    gtreqless: 8923,
    heartsuit: 9829,
    leftarrow: 8592,
    lesseqgtr: 8922,
    nparallel: 8742,
    nshortmid: 8740,
    nsubseteq: 8840,
    nsupseteq: 8841,
    pitchfork: 8916,
    rationals: 8474,
    spadesuit: 9824,
    subseteqq: 10949,
    subsetneq: 8842,
    supseteqq: 10950,
    supsetneq: 8843,
    therefore: 8756,
    triangleq: 8796,
    varpropto: 8733,
    DDotrahd: 10513,
    DotEqual: 8784,
    Integral: 8747,
    LessLess: 10913,
    NotEqual: 8800,
    NotTilde: 8769,
    PartialD: 8706,
    Precedes: 8826,
    RightTee: 8866,
    Succeeds: 8827,
    SuchThat: 8715,
    Superset: 8835,
    Uarrocir: 10569,
    UnderBar: 818,
    andslope: 10840,
    angmsdaa: 10664,
    angmsdab: 10665,
    angmsdac: 10666,
    angmsdad: 10667,
    angmsdae: 10668,
    angmsdaf: 10669,
    angmsdag: 10670,
    angmsdah: 10671,
    angrtvbd: 10653,
    approxeq: 8778,
    awconint: 8755,
    backcong: 8780,
    barwedge: 8965,
    bbrktbrk: 9142,
    bigoplus: 10753,
    bigsqcup: 10758,
    biguplus: 10756,
    bigwedge: 8896,
    boxminus: 8863,
    boxtimes: 8864,
    capbrcup: 10825,
    circledR: 174,
    circledS: 9416,
    cirfnint: 10768,
    clubsuit: 9827,
    cupbrcap: 10824,
    curlyvee: 8910,
    cwconint: 8754,
    doteqdot: 8785,
    dotminus: 8760,
    drbkarow: 10512,
    dzigrarr: 10239,
    elinters: 9191,
    emptyset: 8709,
    eqvparsl: 10725,
    fpartint: 10765,
    geqslant: 10878,
    gesdotol: 10884,
    gnapprox: 10890,
    hksearow: 10533,
    hkswarow: 10534,
    imagline: 8464,
    imagpart: 8465,
    infintie: 10717,
    integers: 8484,
    intercal: 8890,
    intlarhk: 10775,
    laemptyv: 10676,
    ldrushar: 10571,
    leqslant: 10877,
    lesdotor: 10883,
    llcorner: 8990,
    lnapprox: 10889,
    lrcorner: 8991,
    lurdshar: 10570,
    mapstoup: 8613,
    multimap: 8888,
    naturals: 8469,
    otimesas: 10806,
    parallel: 8741,
    plusacir: 10787,
    pointint: 10773,
    precneqq: 10933,
    precnsim: 8936,
    profalar: 9006,
    profline: 8978,
    profsurf: 8979,
    raemptyv: 10675,
    realpart: 8476,
    rppolint: 10770,
    rtriltri: 10702,
    scpolint: 10771,
    setminus: 8726,
    shortmid: 8739,
    smeparsl: 10724,
    sqsubset: 8847,
    sqsupset: 8848,
    subseteq: 8838,
    succneqq: 10934,
    succnsim: 8937,
    supseteq: 8839,
    thetasym: 977,
    thicksim: 8764,
    timesbar: 10801,
    triangle: 9653,
    triminus: 10810,
    trpezium: 9186,
    ulcorner: 8988,
    urcorner: 8989,
    varkappa: 1008,
    varsigma: 962,
    vartheta: 977,
    Because: 8757,
    Cayleys: 8493,
    Cconint: 8752,
    Cedilla: 184,
    Diamond: 8900,
    DownTee: 8868,
    Element: 8712,
    Epsilon: 917,
    Implies: 8658,
    LeftTee: 8867,
    NewLine: 10,
    NoBreak: 8288,
    NotLess: 8814,
    Omicron: 927,
    OverBar: 175,
    Product: 8719,
    UpArrow: 8593,
    Uparrow: 8657,
    Upsilon: 933,
    alefsym: 8501,
    angrtvb: 8894,
    angzarr: 9084,
    asympeq: 8781,
    backsim: 8765,
    because: 8757,
    bemptyv: 10672,
    between: 8812,
    bigcirc: 9711,
    bigodot: 10752,
    bigstar: 9733,
    boxplus: 8862,
    ccupssm: 10832,
    cemptyv: 10674,
    cirscir: 10690,
    coloneq: 8788,
    congdot: 10861,
    cudarrl: 10552,
    cudarrr: 10549,
    cularrp: 10557,
    curarrm: 10556,
    dbkarow: 10511,
    ddagger: 8225,
    ddotseq: 10871,
    demptyv: 10673,
    diamond: 8900,
    digamma: 989,
    dotplus: 8724,
    dwangle: 10662,
    epsilon: 949,
    eqcolon: 8789,
    equivDD: 10872,
    gesdoto: 10882,
    gtquest: 10876,
    gtrless: 8823,
    harrcir: 10568,
    intprod: 10812,
    isindot: 8949,
    larrbfs: 10527,
    larrsim: 10611,
    lbrksld: 10639,
    lbrkslu: 10637,
    ldrdhar: 10599,
    lesdoto: 10881,
    lessdot: 8918,
    lessgtr: 8822,
    lesssim: 8818,
    lotimes: 10804,
    lozenge: 9674,
    ltquest: 10875,
    luruhar: 10598,
    maltese: 10016,
    minusdu: 10794,
    napprox: 8777,
    natural: 9838,
    nearrow: 8599,
    nexists: 8708,
    notinva: 8713,
    notinvb: 8951,
    notinvc: 8950,
    notniva: 8716,
    notnivb: 8958,
    notnivc: 8957,
    npolint: 10772,
    nsqsube: 8930,
    nsqsupe: 8931,
    nvinfin: 10718,
    nwarrow: 8598,
    olcross: 10683,
    omicron: 959,
    orderof: 8500,
    orslope: 10839,
    pertenk: 8241,
    planckh: 8462,
    pluscir: 10786,
    plussim: 10790,
    plustwo: 10791,
    precsim: 8830,
    quatint: 10774,
    questeq: 8799,
    rarrbfs: 10528,
    rarrsim: 10612,
    rbrksld: 10638,
    rbrkslu: 10640,
    rdldhar: 10601,
    realine: 8475,
    rotimes: 10805,
    ruluhar: 10600,
    searrow: 8600,
    simplus: 10788,
    simrarr: 10610,
    subedot: 10947,
    submult: 10945,
    subplus: 10943,
    subrarr: 10617,
    succsim: 8831,
    supdsub: 10968,
    supedot: 10948,
    suphsub: 10967,
    suplarr: 10619,
    supmult: 10946,
    supplus: 10944,
    swarrow: 8601,
    topfork: 10970,
    triplus: 10809,
    tritime: 10811,
    uparrow: 8593,
    upsilon: 965,
    uwangle: 10663,
    vzigzag: 10650,
    zigrarr: 8669,
    Aacute: 193,
    Abreve: 258,
    Agrave: 192,
    Assign: 8788,
    Atilde: 195,
    Barwed: 8966,
    Bumpeq: 8782,
    Cacute: 262,
    Ccaron: 268,
    Ccedil: 199,
    Colone: 10868,
    Conint: 8751,
    CupCap: 8781,
    Dagger: 8225,
    Dcaron: 270,
    DotDot: 8412,
    Dstrok: 272,
    Eacute: 201,
    Ecaron: 282,
    Egrave: 200,
    Exists: 8707,
    ForAll: 8704,
    Gammad: 988,
    Gbreve: 286,
    Gcedil: 290,
    HARDcy: 1066,
    Hstrok: 294,
    Iacute: 205,
    Igrave: 204,
    Itilde: 296,
    Jsercy: 1032,
    Kcedil: 310,
    Lacute: 313,
    Lambda: 923,
    Lcaron: 317,
    Lcedil: 315,
    Lmidot: 319,
    Lstrok: 321,
    Nacute: 323,
    Ncaron: 327,
    Ncedil: 325,
    Ntilde: 209,
    Oacute: 211,
    Odblac: 336,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Otimes: 10807,
    Racute: 340,
    Rarrtl: 10518,
    Rcaron: 344,
    Rcedil: 342,
    SHCHcy: 1065,
    SOFTcy: 1068,
    Sacute: 346,
    Scaron: 352,
    Scedil: 350,
    Square: 9633,
    Subset: 8912,
    Supset: 8913,
    Tcaron: 356,
    Tcedil: 354,
    Tstrok: 358,
    Uacute: 218,
    Ubreve: 364,
    Udblac: 368,
    Ugrave: 217,
    Utilde: 360,
    Vdashl: 10982,
    Verbar: 8214,
    Vvdash: 8874,
    Yacute: 221,
    Zacute: 377,
    Zcaron: 381,
    aacute: 225,
    abreve: 259,
    agrave: 224,
    andand: 10837,
    angmsd: 8737,
    angsph: 8738,
    apacir: 10863,
    approx: 8776,
    atilde: 227,
    barvee: 8893,
    barwed: 8965,
    becaus: 8757,
    bernou: 8492,
    bigcap: 8898,
    bigcup: 8899,
    bigvee: 8897,
    bkarow: 10509,
    bottom: 8869,
    bowtie: 8904,
    boxbox: 10697,
    bprime: 8245,
    brvbar: 166,
    bullet: 8226,
    bumpeq: 8783,
    cacute: 263,
    capand: 10820,
    capcap: 10827,
    capcup: 10823,
    capdot: 10816,
    ccaron: 269,
    ccedil: 231,
    circeq: 8791,
    cirmid: 10991,
    colone: 8788,
    commat: 64,
    compfn: 8728,
    conint: 8750,
    coprod: 8720,
    copysr: 8471,
    cularr: 8630,
    cupcap: 10822,
    cupcup: 10826,
    cupdot: 8845,
    curarr: 8631,
    curren: 164,
    cylcty: 9005,
    dagger: 8224,
    daleth: 8504,
    dcaron: 271,
    dfisht: 10623,
    divide: 247,
    divonx: 8903,
    dlcorn: 8990,
    dlcrop: 8973,
    dollar: 36,
    drcorn: 8991,
    drcrop: 8972,
    dstrok: 273,
    eacute: 233,
    easter: 10862,
    ecaron: 283,
    ecolon: 8789,
    egrave: 232,
    egsdot: 10904,
    elsdot: 10903,
    emptyv: 8709,
    emsp13: 8196,
    emsp14: 8197,
    eparsl: 10723,
    eqcirc: 8790,
    equals: 61,
    equest: 8799,
    female: 9792,
    ffilig: 64259,
    ffllig: 64260,
    forall: 8704,
    frac12: 189,
    frac13: 8531,
    frac14: 188,
    frac15: 8533,
    frac16: 8537,
    frac18: 8539,
    frac23: 8532,
    frac25: 8534,
    frac34: 190,
    frac35: 8535,
    frac38: 8540,
    frac45: 8536,
    frac56: 8538,
    frac58: 8541,
    frac78: 8542,
    gacute: 501,
    gammad: 989,
    gbreve: 287,
    gesdot: 10880,
    gesles: 10900,
    gtlPar: 10645,
    gtrarr: 10616,
    gtrdot: 8919,
    gtrsim: 8819,
    hairsp: 8202,
    hamilt: 8459,
    hardcy: 1098,
    hearts: 9829,
    hellip: 8230,
    hercon: 8889,
    homtht: 8763,
    horbar: 8213,
    hslash: 8463,
    hstrok: 295,
    hybull: 8259,
    hyphen: 8208,
    iacute: 237,
    igrave: 236,
    iiiint: 10764,
    iinfin: 10716,
    incare: 8453,
    inodot: 305,
    intcal: 8890,
    iquest: 191,
    isinsv: 8947,
    itilde: 297,
    jsercy: 1112,
    kappav: 1008,
    kcedil: 311,
    kgreen: 312,
    lAtail: 10523,
    lacute: 314,
    lagran: 8466,
    lambda: 955,
    langle: 10216,
    larrfs: 10525,
    larrhk: 8617,
    larrlp: 8619,
    larrpl: 10553,
    larrtl: 8610,
    latail: 10521,
    lbrace: 123,
    lbrack: 91,
    lcaron: 318,
    lcedil: 316,
    ldquor: 8222,
    lesdot: 10879,
    lesges: 10899,
    lfisht: 10620,
    lfloor: 8970,
    lharul: 10602,
    llhard: 10603,
    lmidot: 320,
    lmoust: 9136,
    loplus: 10797,
    lowast: 8727,
    lowbar: 95,
    lparlt: 10643,
    lrhard: 10605,
    lsaquo: 8249,
    lsquor: 8218,
    lstrok: 322,
    lthree: 8907,
    ltimes: 8905,
    ltlarr: 10614,
    ltrPar: 10646,
    mapsto: 8614,
    marker: 9646,
    mcomma: 10793,
    midast: 42,
    midcir: 10992,
    middot: 183,
    minusb: 8863,
    minusd: 8760,
    mnplus: 8723,
    models: 8871,
    mstpos: 8766,
    nVDash: 8879,
    nVdash: 8878,
    nacute: 324,
    ncaron: 328,
    ncedil: 326,
    nearhk: 10532,
    nequiv: 8802,
    nesear: 10536,
    nexist: 8708,
    nltrie: 8940,
    nprcue: 8928,
    nrtrie: 8941,
    nsccue: 8929,
    nsimeq: 8772,
    ntilde: 241,
    numero: 8470,
    nvDash: 8877,
    nvHarr: 10500,
    nvdash: 8876,
    nvlArr: 10498,
    nvrArr: 10499,
    nwarhk: 10531,
    nwnear: 10535,
    oacute: 243,
    odblac: 337,
    odsold: 10684,
    ograve: 242,
    ominus: 8854,
    origof: 8886,
    oslash: 248,
    otilde: 245,
    otimes: 8855,
    parsim: 10995,
    percnt: 37,
    period: 46,
    permil: 8240,
    phmmat: 8499,
    planck: 8463,
    plankv: 8463,
    plusdo: 8724,
    plusdu: 10789,
    plusmn: 177,
    preceq: 10927,
    primes: 8473,
    prnsim: 8936,
    propto: 8733,
    prurel: 8880,
    puncsp: 8200,
    qprime: 8279,
    rAtail: 10524,
    racute: 341,
    rangle: 10217,
    rarrap: 10613,
    rarrfs: 10526,
    rarrhk: 8618,
    rarrlp: 8620,
    rarrpl: 10565,
    rarrtl: 8611,
    ratail: 10522,
    rbrace: 125,
    rbrack: 93,
    rcaron: 345,
    rcedil: 343,
    rdquor: 8221,
    rfisht: 10621,
    rfloor: 8971,
    rharul: 10604,
    rmoust: 9137,
    roplus: 10798,
    rpargt: 10644,
    rsaquo: 8250,
    rsquor: 8217,
    rthree: 8908,
    rtimes: 8906,
    sacute: 347,
    scaron: 353,
    scedil: 351,
    scnsim: 8937,
    searhk: 10533,
    seswar: 10537,
    sfrown: 8994,
    shchcy: 1097,
    sigmaf: 962,
    sigmav: 962,
    simdot: 10858,
    smashp: 10803,
    softcy: 1100,
    solbar: 9023,
    spades: 9824,
    sqsube: 8849,
    sqsupe: 8850,
    square: 9633,
    squarf: 9642,
    ssetmn: 8726,
    ssmile: 8995,
    sstarf: 8902,
    subdot: 10941,
    subset: 8834,
    subsim: 10951,
    subsub: 10965,
    subsup: 10963,
    succeq: 10928,
    supdot: 10942,
    supset: 8835,
    supsim: 10952,
    supsub: 10964,
    supsup: 10966,
    swarhk: 10534,
    swnwar: 10538,
    target: 8982,
    tcaron: 357,
    tcedil: 355,
    telrec: 8981,
    there4: 8756,
    thetav: 977,
    thinsp: 8201,
    thksim: 8764,
    timesb: 8864,
    timesd: 10800,
    topbot: 9014,
    topcir: 10993,
    tprime: 8244,
    tridot: 9708,
    tstrok: 359,
    uacute: 250,
    ubreve: 365,
    udblac: 369,
    ufisht: 10622,
    ugrave: 249,
    ulcorn: 8988,
    ulcrop: 8975,
    urcorn: 8989,
    urcrop: 8974,
    utilde: 361,
    vangrt: 10652,
    varphi: 966,
    varrho: 1009,
    veebar: 8891,
    vellip: 8942,
    verbar: 124,
    wedbar: 10847,
    wedgeq: 8793,
    weierp: 8472,
    wreath: 8768,
    xoplus: 10753,
    xotime: 10754,
    xsqcup: 10758,
    xuplus: 10756,
    xwedge: 8896,
    yacute: 253,
    zacute: 378,
    zcaron: 382,
    zeetrf: 8488,
    AElig: 198,
    Acirc: 194,
    Alpha: 913,
    Amacr: 256,
    Aogon: 260,
    Aring: 197,
    Breve: 728,
    Ccirc: 264,
    Colon: 8759,
    Cross: 10799,
    Dashv: 10980,
    Delta: 916,
    Ecirc: 202,
    Emacr: 274,
    Eogon: 280,
    Equal: 10869,
    Gamma: 915,
    Gcirc: 284,
    Hacek: 711,
    Hcirc: 292,
    IJlig: 306,
    Icirc: 206,
    Imacr: 298,
    Iogon: 302,
    Iukcy: 1030,
    Jcirc: 308,
    Jukcy: 1028,
    Kappa: 922,
    OElig: 338,
    Ocirc: 212,
    Omacr: 332,
    Omega: 937,
    Prime: 8243,
    RBarr: 10512,
    Scirc: 348,
    Sigma: 931,
    THORN: 222,
    TRADE: 8482,
    TSHcy: 1035,
    Theta: 920,
    Tilde: 8764,
    Ubrcy: 1038,
    Ucirc: 219,
    Umacr: 362,
    Union: 8899,
    Uogon: 370,
    UpTee: 8869,
    Uring: 366,
    VDash: 8875,
    Vdash: 8873,
    Wcirc: 372,
    Wedge: 8896,
    Ycirc: 374,
    acirc: 226,
    acute: 180,
    aelig: 230,
    aleph: 8501,
    alpha: 945,
    amacr: 257,
    amalg: 10815,
    angle: 8736,
    angrt: 8735,
    angst: 8491,
    aogon: 261,
    aring: 229,
    asymp: 8776,
    awint: 10769,
    bcong: 8780,
    bdquo: 8222,
    bepsi: 1014,
    blank: 9251,
    blk12: 9618,
    blk14: 9617,
    blk34: 9619,
    block: 9608,
    boxDL: 9559,
    boxDR: 9556,
    boxDl: 9558,
    boxDr: 9555,
    boxHD: 9574,
    boxHU: 9577,
    boxHd: 9572,
    boxHu: 9575,
    boxUL: 9565,
    boxUR: 9562,
    boxUl: 9564,
    boxUr: 9561,
    boxVH: 9580,
    boxVL: 9571,
    boxVR: 9568,
    boxVh: 9579,
    boxVl: 9570,
    boxVr: 9567,
    boxdL: 9557,
    boxdR: 9554,
    boxdl: 9488,
    boxdr: 9484,
    boxhD: 9573,
    boxhU: 9576,
    boxhd: 9516,
    boxhu: 9524,
    boxuL: 9563,
    boxuR: 9560,
    boxul: 9496,
    boxur: 9492,
    boxvH: 9578,
    boxvL: 9569,
    boxvR: 9566,
    boxvh: 9532,
    boxvl: 9508,
    boxvr: 9500,
    breve: 728,
    bsemi: 8271,
    bsime: 8909,
    bsolb: 10693,
    bumpE: 10926,
    bumpe: 8783,
    caret: 8257,
    caron: 711,
    ccaps: 10829,
    ccirc: 265,
    ccups: 10828,
    cedil: 184,
    check: 10003,
    clubs: 9827,
    colon: 58,
    comma: 44,
    crarr: 8629,
    cross: 10007,
    csube: 10961,
    csupe: 10962,
    ctdot: 8943,
    cuepr: 8926,
    cuesc: 8927,
    cupor: 10821,
    cuvee: 8910,
    cuwed: 8911,
    cwint: 8753,
    dashv: 8867,
    dblac: 733,
    ddarr: 8650,
    delta: 948,
    dharl: 8643,
    dharr: 8642,
    diams: 9830,
    disin: 8946,
    doteq: 8784,
    dtdot: 8945,
    dtrif: 9662,
    duarr: 8693,
    duhar: 10607,
    eDDot: 10871,
    ecirc: 234,
    efDot: 8786,
    emacr: 275,
    empty: 8709,
    eogon: 281,
    eplus: 10865,
    epsiv: 949,
    eqsim: 8770,
    equiv: 8801,
    erDot: 8787,
    erarr: 10609,
    esdot: 8784,
    exist: 8707,
    fflig: 64256,
    filig: 64257,
    fllig: 64258,
    fltns: 9649,
    forkv: 10969,
    frasl: 8260,
    frown: 8994,
    gamma: 947,
    gcirc: 285,
    gescc: 10921,
    gimel: 8503,
    gneqq: 8809,
    gnsim: 8935,
    grave: 96,
    gsime: 10894,
    gsiml: 10896,
    gtcir: 10874,
    gtdot: 8919,
    harrw: 8621,
    hcirc: 293,
    hoarr: 8703,
    icirc: 238,
    iexcl: 161,
    iiint: 8749,
    iiota: 8489,
    ijlig: 307,
    imacr: 299,
    image: 8465,
    imath: 305,
    imped: 437,
    infin: 8734,
    iogon: 303,
    iprod: 10812,
    isinE: 8953,
    isins: 8948,
    isinv: 8712,
    iukcy: 1110,
    jcirc: 309,
    jmath: 567,
    jukcy: 1108,
    kappa: 954,
    lAarr: 8666,
    lBarr: 10510,
    langd: 10641,
    laquo: 171,
    larrb: 8676,
    lbarr: 10508,
    lbbrk: 10098,
    lbrke: 10635,
    lceil: 8968,
    ldquo: 8220,
    lescc: 10920,
    lhard: 8637,
    lharu: 8636,
    lhblk: 9604,
    llarr: 8647,
    lltri: 9722,
    lneqq: 8808,
    lnsim: 8934,
    loang: 10220,
    loarr: 8701,
    lobrk: 10214,
    lopar: 10629,
    lrarr: 8646,
    lrhar: 8651,
    lrtri: 8895,
    lsime: 10893,
    lsimg: 10895,
    lsquo: 8216,
    ltcir: 10873,
    ltdot: 8918,
    ltrie: 8884,
    ltrif: 9666,
    mDDot: 8762,
    mdash: 8212,
    micro: 181,
    minus: 8722,
    mumap: 8888,
    nabla: 8711,
    napos: 329,
    natur: 9838,
    ncong: 8775,
    ndash: 8211,
    neArr: 8663,
    nearr: 8599,
    ngsim: 8821,
    nhArr: 8654,
    nharr: 8622,
    nhpar: 10994,
    nlArr: 8653,
    nlarr: 8602,
    nless: 8814,
    nlsim: 8820,
    nltri: 8938,
    notin: 8713,
    notni: 8716,
    nprec: 8832,
    nrArr: 8655,
    nrarr: 8603,
    nrtri: 8939,
    nsime: 8772,
    nsmid: 8740,
    nspar: 8742,
    nsube: 8840,
    nsucc: 8833,
    nsupe: 8841,
    numsp: 8199,
    nwArr: 8662,
    nwarr: 8598,
    ocirc: 244,
    odash: 8861,
    oelig: 339,
    ofcir: 10687,
    ohbar: 10677,
    olarr: 8634,
    olcir: 10686,
    oline: 8254,
    omacr: 333,
    omega: 969,
    operp: 10681,
    oplus: 8853,
    orarr: 8635,
    order: 8500,
    ovbar: 9021,
    parsl: 11005,
    phone: 9742,
    plusb: 8862,
    pluse: 10866,
    pound: 163,
    prcue: 8828,
    prime: 8242,
    prnap: 10937,
    prsim: 8830,
    quest: 63,
    rAarr: 8667,
    rBarr: 10511,
    radic: 8730,
    rangd: 10642,
    range: 10661,
    raquo: 187,
    rarrb: 8677,
    rarrc: 10547,
    rarrw: 8605,
    ratio: 8758,
    rbarr: 10509,
    rbbrk: 10099,
    rbrke: 10636,
    rceil: 8969,
    rdquo: 8221,
    reals: 8477,
    rhard: 8641,
    rharu: 8640,
    rlarr: 8644,
    rlhar: 8652,
    rnmid: 10990,
    roang: 10221,
    roarr: 8702,
    robrk: 10215,
    ropar: 10630,
    rrarr: 8649,
    rsquo: 8217,
    rtrie: 8885,
    rtrif: 9656,
    sbquo: 8218,
    sccue: 8829,
    scirc: 349,
    scnap: 10938,
    scsim: 8831,
    sdotb: 8865,
    sdote: 10854,
    seArr: 8664,
    searr: 8600,
    setmn: 8726,
    sharp: 9839,
    sigma: 963,
    simeq: 8771,
    simgE: 10912,
    simlE: 10911,
    simne: 8774,
    slarr: 8592,
    smile: 8995,
    sqcap: 8851,
    sqcup: 8852,
    sqsub: 8847,
    sqsup: 8848,
    srarr: 8594,
    starf: 9733,
    strns: 175,
    subnE: 10955,
    subne: 8842,
    supnE: 10956,
    supne: 8843,
    swArr: 8665,
    swarr: 8601,
    szlig: 223,
    theta: 952,
    thkap: 8776,
    thorn: 254,
    tilde: 732,
    times: 215,
    trade: 8482,
    trisb: 10701,
    tshcy: 1115,
    twixt: 8812,
    ubrcy: 1118,
    ucirc: 251,
    udarr: 8645,
    udhar: 10606,
    uharl: 8639,
    uharr: 8638,
    uhblk: 9600,
    ultri: 9720,
    umacr: 363,
    uogon: 371,
    uplus: 8846,
    upsih: 978,
    uring: 367,
    urtri: 9721,
    utdot: 8944,
    utrif: 9652,
    uuarr: 8648,
    vBarv: 10985,
    vDash: 8872,
    varpi: 982,
    vdash: 8866,
    veeeq: 8794,
    vltri: 8882,
    vprop: 8733,
    vrtri: 8883,
    wcirc: 373,
    wedge: 8743,
    xcirc: 9711,
    xdtri: 9661,
    xhArr: 10234,
    xharr: 10231,
    xlArr: 10232,
    xlarr: 10229,
    xodot: 10752,
    xrArr: 10233,
    xrarr: 10230,
    xutri: 9651,
    ycirc: 375,
    Aopf: 120120,
    Ascr: 119964,
    Auml: 196,
    Barv: 10983,
    Beta: 914,
    Bopf: 120121,
    Bscr: 8492,
    CHcy: 1063,
    COPY: 169,
    Cdot: 266,
    Copf: 8450,
    Cscr: 119966,
    DJcy: 1026,
    DScy: 1029,
    DZcy: 1039,
    Darr: 8609,
    Dopf: 120123,
    Dscr: 119967,
    Edot: 278,
    Eopf: 120124,
    Escr: 8496,
    Esim: 10867,
    Euml: 203,
    Fopf: 120125,
    Fscr: 8497,
    GJcy: 1027,
    Gdot: 288,
    Gopf: 120126,
    Gscr: 119970,
    Hopf: 8461,
    Hscr: 8459,
    IEcy: 1045,
    IOcy: 1025,
    Idot: 304,
    Iopf: 120128,
    Iota: 921,
    Iscr: 8464,
    Iuml: 207,
    Jopf: 120129,
    Jscr: 119973,
    KHcy: 1061,
    KJcy: 1036,
    Kopf: 120130,
    Kscr: 119974,
    LJcy: 1033,
    Lang: 10218,
    Larr: 8606,
    Lopf: 120131,
    Lscr: 8466,
    Mopf: 120132,
    Mscr: 8499,
    NJcy: 1034,
    Nopf: 8469,
    Nscr: 119977,
    Oopf: 120134,
    Oscr: 119978,
    Ouml: 214,
    Popf: 8473,
    Pscr: 119979,
    QUOT: 34,
    Qopf: 8474,
    Qscr: 119980,
    Rang: 10219,
    Rarr: 8608,
    Ropf: 8477,
    Rscr: 8475,
    SHcy: 1064,
    Sopf: 120138,
    Sqrt: 8730,
    Sscr: 119982,
    Star: 8902,
    TScy: 1062,
    Topf: 120139,
    Tscr: 119983,
    Uarr: 8607,
    Uopf: 120140,
    Upsi: 978,
    Uscr: 119984,
    Uuml: 220,
    Vbar: 10987,
    Vert: 8214,
    Vopf: 120141,
    Vscr: 119985,
    Wopf: 120142,
    Wscr: 119986,
    Xopf: 120143,
    Xscr: 119987,
    YAcy: 1071,
    YIcy: 1031,
    YUcy: 1070,
    Yopf: 120144,
    Yscr: 119988,
    Yuml: 376,
    ZHcy: 1046,
    Zdot: 379,
    Zeta: 918,
    Zopf: 8484,
    Zscr: 119989,
    andd: 10844,
    andv: 10842,
    ange: 10660,
    aopf: 120146,
    apid: 8779,
    apos: 39,
    ascr: 119990,
    auml: 228,
    bNot: 10989,
    bbrk: 9141,
    beta: 946,
    beth: 8502,
    bnot: 8976,
    bopf: 120147,
    boxH: 9552,
    boxV: 9553,
    boxh: 9472,
    boxv: 9474,
    bscr: 119991,
    bsim: 8765,
    bsol: 92,
    bull: 8226,
    bump: 8782,
    cdot: 267,
    cent: 162,
    chcy: 1095,
    cirE: 10691,
    circ: 710,
    cire: 8791,
    comp: 8705,
    cong: 8773,
    copf: 120148,
    copy: 169,
    cscr: 119992,
    csub: 10959,
    csup: 10960,
    dArr: 8659,
    dHar: 10597,
    darr: 8595,
    dash: 8208,
    diam: 8900,
    djcy: 1106,
    dopf: 120149,
    dscr: 119993,
    dscy: 1109,
    dsol: 10742,
    dtri: 9663,
    dzcy: 1119,
    eDot: 8785,
    ecir: 8790,
    edot: 279,
    emsp: 8195,
    ensp: 8194,
    eopf: 120150,
    epar: 8917,
    epsi: 1013,
    escr: 8495,
    esim: 8770,
    euml: 235,
    euro: 8364,
    excl: 33,
    flat: 9837,
    fnof: 402,
    fopf: 120151,
    fork: 8916,
    fscr: 119995,
    gdot: 289,
    geqq: 8807,
    gjcy: 1107,
    gnap: 10890,
    gneq: 10888,
    gopf: 120152,
    gscr: 8458,
    gsim: 8819,
    gtcc: 10919,
    hArr: 8660,
    half: 189,
    harr: 8596,
    hbar: 8463,
    hopf: 120153,
    hscr: 119997,
    iecy: 1077,
    imof: 8887,
    iocy: 1105,
    iopf: 120154,
    iota: 953,
    iscr: 119998,
    isin: 8712,
    iuml: 239,
    jopf: 120155,
    jscr: 119999,
    khcy: 1093,
    kjcy: 1116,
    kopf: 120156,
    kscr: 12e4,
    lArr: 8656,
    lHar: 10594,
    lang: 10216,
    larr: 8592,
    late: 10925,
    lcub: 123,
    ldca: 10550,
    ldsh: 8626,
    leqq: 8806,
    ljcy: 1113,
    lnap: 10889,
    lneq: 10887,
    lopf: 120157,
    lozf: 10731,
    lpar: 40,
    lscr: 120001,
    lsim: 8818,
    lsqb: 91,
    ltcc: 10918,
    ltri: 9667,
    macr: 175,
    male: 9794,
    malt: 10016,
    mlcp: 10971,
    mldr: 8230,
    mopf: 120158,
    mscr: 120002,
    nbsp: 160,
    ncap: 10819,
    ncup: 10818,
    ngeq: 8817,
    ngtr: 8815,
    nisd: 8954,
    njcy: 1114,
    nldr: 8229,
    nleq: 8816,
    nmid: 8740,
    nopf: 120159,
    npar: 8742,
    nscr: 120003,
    nsim: 8769,
    nsub: 8836,
    nsup: 8837,
    ntgl: 8825,
    ntlg: 8824,
    oast: 8859,
    ocir: 8858,
    odiv: 10808,
    odot: 8857,
    ogon: 731,
    oint: 8750,
    omid: 10678,
    oopf: 120160,
    opar: 10679,
    ordf: 170,
    ordm: 186,
    oror: 10838,
    oscr: 8500,
    osol: 8856,
    ouml: 246,
    para: 182,
    part: 8706,
    perp: 8869,
    phiv: 966,
    plus: 43,
    popf: 120161,
    prap: 10935,
    prec: 8826,
    prnE: 10933,
    prod: 8719,
    prop: 8733,
    pscr: 120005,
    qint: 10764,
    qopf: 120162,
    qscr: 120006,
    quot: 34,
    rArr: 8658,
    rHar: 10596,
    race: 10714,
    rang: 10217,
    rarr: 8594,
    rcub: 125,
    rdca: 10551,
    rdsh: 8627,
    real: 8476,
    rect: 9645,
    rhov: 1009,
    ring: 730,
    ropf: 120163,
    rpar: 41,
    rscr: 120007,
    rsqb: 93,
    rtri: 9657,
    scap: 10936,
    scnE: 10934,
    sdot: 8901,
    sect: 167,
    semi: 59,
    sext: 10038,
    shcy: 1096,
    sime: 8771,
    simg: 10910,
    siml: 10909,
    smid: 8739,
    smte: 10924,
    solb: 10692,
    sopf: 120164,
    spar: 8741,
    squf: 9642,
    sscr: 120008,
    star: 9734,
    subE: 10949,
    sube: 8838,
    succ: 8827,
    sung: 9834,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    supE: 10950,
    supe: 8839,
    tbrk: 9140,
    tdot: 8411,
    tint: 8749,
    toea: 10536,
    topf: 120165,
    tosa: 10537,
    trie: 8796,
    tscr: 120009,
    tscy: 1094,
    uArr: 8657,
    uHar: 10595,
    uarr: 8593,
    uopf: 120166,
    upsi: 965,
    uscr: 120010,
    utri: 9653,
    uuml: 252,
    vArr: 8661,
    vBar: 10984,
    varr: 8597,
    vert: 124,
    vopf: 120167,
    vscr: 120011,
    wopf: 120168,
    wscr: 120012,
    xcap: 8898,
    xcup: 8899,
    xmap: 10236,
    xnis: 8955,
    xopf: 120169,
    xscr: 120013,
    xvee: 8897,
    yacy: 1103,
    yicy: 1111,
    yopf: 120170,
    yscr: 120014,
    yucy: 1102,
    yuml: 255,
    zdot: 380,
    zeta: 950,
    zhcy: 1078,
    zopf: 120171,
    zscr: 120015,
    zwnj: 8204,
    AMP: 38,
    Acy: 1040,
    Afr: 120068,
    And: 10835,
    Bcy: 1041,
    Bfr: 120069,
    Cap: 8914,
    Cfr: 8493,
    Chi: 935,
    Cup: 8915,
    Dcy: 1044,
    Del: 8711,
    Dfr: 120071,
    Dot: 168,
    ENG: 330,
    ETH: 208,
    Ecy: 1069,
    Efr: 120072,
    Eta: 919,
    Fcy: 1060,
    Ffr: 120073,
    Gcy: 1043,
    Gfr: 120074,
    Hat: 94,
    Hfr: 8460,
    Icy: 1048,
    Ifr: 8465,
    Int: 8748,
    Jcy: 1049,
    Jfr: 120077,
    Kcy: 1050,
    Kfr: 120078,
    Lcy: 1051,
    Lfr: 120079,
    Lsh: 8624,
    Map: 10501,
    Mcy: 1052,
    Mfr: 120080,
    Ncy: 1053,
    Nfr: 120081,
    Not: 10988,
    Ocy: 1054,
    Ofr: 120082,
    Pcy: 1055,
    Pfr: 120083,
    Phi: 934,
    Psi: 936,
    Qfr: 120084,
    REG: 174,
    Rcy: 1056,
    Rfr: 8476,
    Rho: 929,
    Rsh: 8625,
    Scy: 1057,
    Sfr: 120086,
    Sub: 8912,
    Sum: 8721,
    Sup: 8913,
    Tab: 9,
    Tau: 932,
    Tcy: 1058,
    Tfr: 120087,
    Ucy: 1059,
    Ufr: 120088,
    Vcy: 1042,
    Vee: 8897,
    Vfr: 120089,
    Wfr: 120090,
    Xfr: 120091,
    Ycy: 1067,
    Yfr: 120092,
    Zcy: 1047,
    Zfr: 8488,
    acd: 8767,
    acy: 1072,
    afr: 120094,
    amp: 38,
    and: 8743,
    ang: 8736,
    apE: 10864,
    ape: 8778,
    ast: 42,
    bcy: 1073,
    bfr: 120095,
    bot: 8869,
    cap: 8745,
    cfr: 120096,
    chi: 967,
    cir: 9675,
    cup: 8746,
    dcy: 1076,
    deg: 176,
    dfr: 120097,
    die: 168,
    div: 247,
    dot: 729,
    ecy: 1101,
    efr: 120098,
    egs: 10902,
    ell: 8467,
    els: 10901,
    eng: 331,
    eta: 951,
    eth: 240,
    fcy: 1092,
    ffr: 120099,
    gEl: 10892,
    gap: 10886,
    gcy: 1075,
    gel: 8923,
    geq: 8805,
    ges: 10878,
    gfr: 120100,
    ggg: 8921,
    glE: 10898,
    gla: 10917,
    glj: 10916,
    gnE: 8809,
    gne: 10888,
    hfr: 120101,
    icy: 1080,
    iff: 8660,
    ifr: 120102,
    int: 8747,
    jcy: 1081,
    jfr: 120103,
    kcy: 1082,
    kfr: 120104,
    lEg: 10891,
    lap: 10885,
    lat: 10923,
    lcy: 1083,
    leg: 8922,
    leq: 8804,
    les: 10877,
    lfr: 120105,
    lgE: 10897,
    lnE: 8808,
    lne: 10887,
    loz: 9674,
    lrm: 8206,
    lsh: 8624,
    map: 8614,
    mcy: 1084,
    mfr: 120106,
    mho: 8487,
    mid: 8739,
    nap: 8777,
    ncy: 1085,
    nfr: 120107,
    nge: 8817,
    ngt: 8815,
    nis: 8956,
    niv: 8715,
    nle: 8816,
    nlt: 8814,
    not: 172,
    npr: 8832,
    nsc: 8833,
    num: 35,
    ocy: 1086,
    ofr: 120108,
    ogt: 10689,
    ohm: 8486,
    olt: 10688,
    ord: 10845,
    orv: 10843,
    par: 8741,
    pcy: 1087,
    pfr: 120109,
    phi: 966,
    piv: 982,
    prE: 10931,
    pre: 10927,
    psi: 968,
    qfr: 120110,
    rcy: 1088,
    reg: 174,
    rfr: 120111,
    rho: 961,
    rlm: 8207,
    rsh: 8625,
    scE: 10932,
    sce: 10928,
    scy: 1089,
    sfr: 120112,
    shy: 173,
    sim: 8764,
    smt: 10922,
    sol: 47,
    squ: 9633,
    sub: 8834,
    sum: 8721,
    sup: 8835,
    tau: 964,
    tcy: 1090,
    tfr: 120113,
    top: 8868,
    ucy: 1091,
    ufr: 120114,
    uml: 168,
    vcy: 1074,
    vee: 8744,
    vfr: 120115,
    wfr: 120116,
    xfr: 120117,
    ycy: 1099,
    yen: 165,
    yfr: 120118,
    zcy: 1079,
    zfr: 120119,
    zwj: 8205,
    DD: 8517,
    GT: 62,
    Gg: 8921,
    Gt: 8811,
    Im: 8465,
    LT: 60,
    Ll: 8920,
    Lt: 8810,
    Mu: 924,
    Nu: 925,
    Or: 10836,
    Pi: 928,
    Pr: 10939,
    Re: 8476,
    Sc: 10940,
    Xi: 926,
    ac: 8766,
    af: 8289,
    ap: 8776,
    dd: 8518,
    ee: 8519,
    eg: 10906,
    el: 10905,
    gE: 8807,
    ge: 8805,
    gg: 8811,
    gl: 8823,
    gt: 62,
    ic: 8291,
    ii: 8520,
    in: 8712,
    it: 8290,
    lE: 8806,
    le: 8804,
    lg: 8822,
    ll: 8810,
    lt: 60,
    mp: 8723,
    mu: 956,
    ne: 8800,
    ni: 8715,
    nu: 957,
    oS: 9416,
    or: 8744,
    pi: 960,
    pm: 177,
    pr: 8826,
    rx: 8478,
    sc: 8827,
    wp: 8472,
    wr: 8768,
    xi: 958
  };
  const windows_1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376
  ];
  const entity_pattern = new RegExp(`&(#?(?:x[\\w\\d]+|\\d+|${Object.keys(entities).join("|")}))(?:;|\\b)`, "g");
  function decode_character_references(html2) {
    return html2.replace(entity_pattern, (match, entity) => {
      let code;
      if (entity[0] !== "#")
        code = entities[entity];
      else if (entity[1] === "x")
        code = parseInt(entity.substring(2), 16);
      else
        code = parseInt(entity.substring(1), 10);
      if (!code)
        return match;
      return String.fromCodePoint(validate_code(code));
    });
  }
  const NUL = 0;
  function validate_code(code) {
    if (code === 10)
      return 32;
    if (code < 128)
      return code;
    if (code <= 159)
      return windows_1252[code - 128];
    if (code < 55296)
      return code;
    if (code <= 57343)
      return NUL;
    if (code <= 65535)
      return code;
    if (code >= 65536 && code <= 131071)
      return code;
    if (code >= 131072 && code <= 196607)
      return code;
    return NUL;
  }
  const disallowed_contents = /* @__PURE__ */ new Map([
    [
      "li",
      /* @__PURE__ */ new Set([
        "li"
      ])
    ],
    [
      "dt",
      /* @__PURE__ */ new Set([
        "dt",
        "dd"
      ])
    ],
    [
      "dd",
      /* @__PURE__ */ new Set([
        "dt",
        "dd"
      ])
    ],
    [
      "p",
      new Set("address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul".split(" "))
    ],
    [
      "rt",
      /* @__PURE__ */ new Set([
        "rt",
        "rp"
      ])
    ],
    [
      "rp",
      /* @__PURE__ */ new Set([
        "rt",
        "rp"
      ])
    ],
    [
      "optgroup",
      /* @__PURE__ */ new Set([
        "optgroup"
      ])
    ],
    [
      "option",
      /* @__PURE__ */ new Set([
        "option",
        "optgroup"
      ])
    ],
    [
      "thead",
      /* @__PURE__ */ new Set([
        "tbody",
        "tfoot"
      ])
    ],
    [
      "tbody",
      /* @__PURE__ */ new Set([
        "tbody",
        "tfoot"
      ])
    ],
    [
      "tfoot",
      /* @__PURE__ */ new Set([
        "tbody"
      ])
    ],
    [
      "tr",
      /* @__PURE__ */ new Set([
        "tr",
        "tbody"
      ])
    ],
    [
      "td",
      /* @__PURE__ */ new Set([
        "td",
        "th",
        "tr"
      ])
    ],
    [
      "th",
      /* @__PURE__ */ new Set([
        "td",
        "th",
        "tr"
      ])
    ]
  ]);
  function closing_tag_omitted(current, next) {
    if (disallowed_contents.has(current)) {
      if (!next || disallowed_contents.get(current).has(next))
        return true;
    }
    return false;
  }
  const valid_tag_name = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
  const meta_tags = /* @__PURE__ */ new Map([
    [
      "svelte:head",
      "Head"
    ],
    [
      "svelte:options",
      "Options"
    ],
    [
      "svelte:window",
      "Window"
    ],
    [
      "svelte:body",
      "Body"
    ]
  ]);
  const valid_meta_tags = Array.from(meta_tags.keys()).concat("svelte:self", "svelte:component", "svelte:fragment", "svelte:element");
  const specials = /* @__PURE__ */ new Map([
    [
      "script",
      {
        read: read_script,
        property: "js"
      }
    ],
    [
      "style",
      {
        read: read_style,
        property: "css"
      }
    ]
  ]);
  const SELF = /^svelte:self(?=[\s/>])/;
  const COMPONENT = /^svelte:component(?=[\s/>])/;
  const SLOT = /^svelte:fragment(?=[\s/>])/;
  const ELEMENT = /^svelte:element(?=[\s/>])/;
  function parent_is_head(stack) {
    let i2 = stack.length;
    while (i2--) {
      const { type } = stack[i2];
      if (type === "Head")
        return true;
      if (type === "Element" || type === "InlineComponent")
        return false;
    }
    return false;
  }
  const regex_closing_textarea_tag = /^<\/textarea(\s[^>]*)?>/i;
  const regex_closing_comment = /-->/;
  const regex_capital_letter = /[A-Z]/;
  function tag(parser) {
    const start = parser.index++;
    let parent = parser.current();
    if (parser.eat("!--")) {
      const data2 = parser.read_until(regex_closing_comment);
      parser.eat("-->", true, parser_errors.unclosed_comment);
      parser.current().children.push({
        start,
        end: parser.index,
        type: "Comment",
        data: data2,
        ignores: extract_svelte_ignore(data2)
      });
      return;
    }
    const is_closing_tag = parser.eat("/");
    const name = read_tag_name(parser);
    if (meta_tags.has(name)) {
      const slug = meta_tags.get(name).toLowerCase();
      if (is_closing_tag) {
        if ((name === "svelte:window" || name === "svelte:body") && parser.current().children.length)
          parser.error(parser_errors.invalid_element_content(slug, name), parser.current().children[0].start);
      } else {
        if (name in parser.meta_tags)
          parser.error(parser_errors.duplicate_element(slug, name), start);
        if (parser.stack.length > 1)
          parser.error(parser_errors.invalid_element_placement(slug, name), start);
        parser.meta_tags[name] = true;
      }
    }
    const type = meta_tags.has(name) ? meta_tags.get(name) : regex_capital_letter.test(name[0]) || name === "svelte:self" || name === "svelte:component" ? "InlineComponent" : name === "svelte:fragment" ? "SlotTemplate" : name === "title" && parent_is_head(parser.stack) ? "Title" : name === "slot" && !parser.customElement ? "Slot" : "Element";
    const element = {
      start,
      end: null,
      type,
      name,
      attributes: [],
      children: []
    };
    parser.allow_whitespace();
    if (is_closing_tag) {
      if (is_void(name))
        parser.error(parser_errors.invalid_void_content(name), start);
      parser.eat(">", true);
      while (parent.name !== name) {
        if (parent.type !== "Element") {
          const error2 = parser.last_auto_closed_tag && parser.last_auto_closed_tag.tag === name ? parser_errors.invalid_closing_tag_autoclosed(name, parser.last_auto_closed_tag.reason) : parser_errors.invalid_closing_tag_unopened(name);
          parser.error(error2, start);
        }
        parent.end = start;
        parser.stack.pop();
        parent = parser.current();
      }
      parent.end = parser.index;
      parser.stack.pop();
      if (parser.last_auto_closed_tag && parser.stack.length < parser.last_auto_closed_tag.depth)
        parser.last_auto_closed_tag = null;
      return;
    } else if (closing_tag_omitted(parent.name, name)) {
      parent.end = start;
      parser.stack.pop();
      parser.last_auto_closed_tag = {
        tag: parent.name,
        reason: name,
        depth: parser.stack.length
      };
    }
    const unique_names = /* @__PURE__ */ new Set();
    let attribute;
    while (attribute = read_attribute(parser, unique_names)) {
      element.attributes.push(attribute);
      parser.allow_whitespace();
    }
    if (name === "svelte:component") {
      const index = element.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
      if (index === -1)
        parser.error(parser_errors.missing_component_definition, start);
      const definition = element.attributes.splice(index, 1)[0];
      if (definition.value === true || definition.value.length !== 1 || definition.value[0].type === "Text")
        parser.error(parser_errors.invalid_component_definition, definition.start);
      element.expression = definition.value[0].expression;
    }
    if (name === "svelte:element") {
      const index = element.attributes.findIndex((attr) => attr.type === "Attribute" && attr.name === "this");
      if (index === -1)
        parser.error(parser_errors.missing_element_definition, start);
      const definition = element.attributes.splice(index, 1)[0];
      if (definition.value === true)
        parser.error(parser_errors.invalid_element_definition, definition.start);
      element.tag = definition.value[0].data || definition.value[0].expression;
    }
    if (specials.has(name) && parser.stack.length === 1) {
      const special = specials.get(name);
      parser.eat(">", true);
      const content = special.read(parser, start, element.attributes);
      if (content)
        parser[special.property].push(content);
      return;
    }
    parser.current().children.push(element);
    const self_closing = parser.eat("/") || is_void(name);
    parser.eat(">", true);
    if (self_closing)
      element.end = parser.index;
    else if (name === "textarea") {
      element.children = read_sequence(parser, () => regex_closing_textarea_tag.test(parser.template.slice(parser.index)), "inside <textarea>");
      parser.read(regex_closing_textarea_tag);
      element.end = parser.index;
    } else if (name === "script" || name === "style") {
      const start2 = parser.index;
      const data2 = parser.read_until(new RegExp(`</${name}>`));
      const end = parser.index;
      element.children.push({
        start: start2,
        end,
        type: "Text",
        data: data2
      });
      parser.eat(`</${name}>`, true);
      element.end = parser.index;
    } else
      parser.stack.push(element);
  }
  const regex_whitespace_or_slash_or_closing_tag = /(\s|\/|>)/;
  function read_tag_name(parser) {
    const start = parser.index;
    if (parser.read(SELF)) {
      let i2 = parser.stack.length;
      let legal = false;
      while (i2--) {
        const fragment2 = parser.stack[i2];
        if (fragment2.type === "IfBlock" || fragment2.type === "EachBlock" || fragment2.type === "InlineComponent") {
          legal = true;
          break;
        }
      }
      if (!legal)
        parser.error(parser_errors.invalid_self_placement, start);
      return "svelte:self";
    }
    if (parser.read(COMPONENT))
      return "svelte:component";
    if (parser.read(ELEMENT))
      return "svelte:element";
    if (parser.read(SLOT))
      return "svelte:fragment";
    const name = parser.read_until(regex_whitespace_or_slash_or_closing_tag);
    if (meta_tags.has(name))
      return name;
    if (name.startsWith("svelte:")) {
      const match = fuzzymatch(name.slice(7), valid_meta_tags);
      parser.error(parser_errors.invalid_tag_name_svelte_element(valid_meta_tags, match), start);
    }
    if (!valid_tag_name.test(name))
      parser.error(parser_errors.invalid_tag_name, start);
    return name;
  }
  const regex_token_ending_character = /[\s=\/>"']/;
  const regex_quote_characters = /["']/;
  function read_attribute(parser, unique_names) {
    const start = parser.index;
    function check_unique(name2) {
      if (unique_names.has(name2))
        parser.error(parser_errors.duplicate_attribute, start);
      unique_names.add(name2);
    }
    if (parser.eat("{")) {
      parser.allow_whitespace();
      if (parser.eat("...")) {
        const expression = read_expression(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
        return {
          start,
          end: parser.index,
          type: "Spread",
          expression
        };
      } else {
        const value_start = parser.index;
        const name2 = parser.read_identifier();
        parser.allow_whitespace();
        parser.eat("}", true);
        if (name2 === null)
          parser.error(parser_errors.empty_attribute_shorthand, start);
        check_unique(name2);
        return {
          start,
          end: parser.index,
          type: "Attribute",
          name: name2,
          value: [
            {
              start: value_start,
              end: value_start + name2.length,
              type: "AttributeShorthand",
              expression: {
                start: value_start,
                end: value_start + name2.length,
                type: "Identifier",
                name: name2
              }
            }
          ]
        };
      }
    }
    const name = parser.read_until(regex_token_ending_character);
    if (!name)
      return null;
    let end = parser.index;
    parser.allow_whitespace();
    const colon_index = name.indexOf(":");
    const type = colon_index !== -1 && get_directive_type(name.slice(0, colon_index));
    let value2 = true;
    if (parser.eat("=")) {
      parser.allow_whitespace();
      value2 = read_attribute_value(parser);
      end = parser.index;
    } else if (parser.match_regex(regex_quote_characters))
      parser.error(parser_errors.unexpected_token("="), parser.index);
    if (type) {
      const [directive_name, ...modifiers] = name.slice(colon_index + 1).split("|");
      if (directive_name === "")
        parser.error(parser_errors.empty_directive_name(type), start + colon_index + 1);
      if (type === "Binding" && directive_name !== "this")
        check_unique(directive_name);
      else if (type !== "EventHandler" && type !== "Action")
        check_unique(name);
      if (type === "Ref")
        parser.error(parser_errors.invalid_ref_directive(directive_name), start);
      if (type === "StyleDirective")
        return {
          start,
          end,
          type,
          name: directive_name,
          modifiers,
          value: value2
        };
      const first_value = value2[0];
      let expression = null;
      if (first_value) {
        const attribute_contains_text = value2.length > 1 || first_value.type === "Text";
        if (attribute_contains_text)
          parser.error(parser_errors.invalid_directive_value, first_value.start);
        else
          expression = first_value.expression;
      }
      const directive = {
        start,
        end,
        type,
        name: directive_name,
        modifiers,
        expression
      };
      if (type === "Transition") {
        const direction = name.slice(0, colon_index);
        directive.intro = direction === "in" || direction === "transition";
        directive.outro = direction === "out" || direction === "transition";
      }
      if (!directive.expression && (type === "Binding" || type === "Class"))
        directive.expression = {
          start: directive.start + colon_index + 1,
          end: directive.end,
          type: "Identifier",
          name: directive.name
        };
      return directive;
    }
    check_unique(name);
    return {
      start,
      end,
      type: "Attribute",
      name,
      value: value2
    };
  }
  function get_directive_type(name) {
    if (name === "use")
      return "Action";
    if (name === "animate")
      return "Animation";
    if (name === "bind")
      return "Binding";
    if (name === "class")
      return "Class";
    if (name === "style")
      return "StyleDirective";
    if (name === "on")
      return "EventHandler";
    if (name === "let")
      return "Let";
    if (name === "ref")
      return "Ref";
    if (name === "in" || name === "out" || name === "transition")
      return "Transition";
  }
  function read_attribute_value(parser) {
    const quote_mark = parser.eat("'") ? "'" : parser.eat('"') ? '"' : null;
    if (quote_mark && parser.eat(quote_mark))
      return [
        {
          start: parser.index - 1,
          end: parser.index - 1,
          type: "Text",
          raw: "",
          data: ""
        }
      ];
    const regex2 = quote_mark === "'" ? /'/ : quote_mark === '"' ? /"/ : /(\/>|[\s"'=<>`])/;
    let value2;
    try {
      value2 = read_sequence(parser, () => !!parser.match_regex(regex2), "in attribute value");
    } catch (error2) {
      if (error2.code === "parse-error") {
        if (parser.template.slice(error2.pos - 1, error2.pos + 1) === "/>") {
          parser.index = error2.pos;
          parser.error(parser_errors.unclosed_attribute_value(quote_mark || "}"));
        }
      }
      throw error2;
    }
    if (value2.length === 0 && !quote_mark)
      parser.error(parser_errors.missing_attribute_value);
    if (quote_mark)
      parser.index += 1;
    return value2;
  }
  function read_sequence(parser, done, location) {
    let current_chunk = {
      start: parser.index,
      end: null,
      type: "Text",
      raw: "",
      data: null
    };
    const chunks = [];
    function flush(end) {
      if (current_chunk.raw) {
        current_chunk.data = decode_character_references(current_chunk.raw);
        current_chunk.end = end;
        chunks.push(current_chunk);
      }
    }
    while (parser.index < parser.template.length) {
      const index = parser.index;
      if (done()) {
        flush(parser.index);
        return chunks;
      } else if (parser.eat("{")) {
        if (parser.match("#")) {
          const index2 = parser.index - 1;
          parser.eat("#");
          const name = parser.read_until(/[^a-z]/);
          parser.error(parser_errors.invalid_logic_block_placement(location, name), index2);
        } else if (parser.match("@")) {
          const index2 = parser.index - 1;
          parser.eat("@");
          const name = parser.read_until(/[^a-z]/);
          parser.error(parser_errors.invalid_tag_placement(location, name), index2);
        }
        flush(parser.index - 1);
        parser.allow_whitespace();
        const expression = read_expression(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
        chunks.push({
          start: index,
          end: parser.index,
          type: "MustacheTag",
          expression
        });
        current_chunk = {
          start: parser.index,
          end: null,
          type: "Text",
          raw: "",
          data: null
        };
      } else
        current_chunk.raw += parser.template[parser.index++];
    }
    parser.error(parser_errors.unexpected_eof);
  }
  function full_char_code_at(str, i2) {
    const code = str.charCodeAt(i2);
    if (code <= 55295 || code >= 57344)
      return code;
    const next = str.charCodeAt(i2 + 1);
    return (code << 10) + next - 56613888;
  }
  const SQUARE_BRACKET_OPEN = "[".charCodeAt(0);
  const SQUARE_BRACKET_CLOSE = "]".charCodeAt(0);
  const CURLY_BRACKET_OPEN = "{".charCodeAt(0);
  const CURLY_BRACKET_CLOSE = "}".charCodeAt(0);
  function is_bracket_open(code) {
    return code === SQUARE_BRACKET_OPEN || code === CURLY_BRACKET_OPEN;
  }
  function is_bracket_close(code) {
    return code === SQUARE_BRACKET_CLOSE || code === CURLY_BRACKET_CLOSE;
  }
  function is_bracket_pair(open, close) {
    return open === SQUARE_BRACKET_OPEN && close === SQUARE_BRACKET_CLOSE || open === CURLY_BRACKET_OPEN && close === CURLY_BRACKET_CLOSE;
  }
  function get_bracket_close(open) {
    if (open === SQUARE_BRACKET_OPEN)
      return SQUARE_BRACKET_CLOSE;
    if (open === CURLY_BRACKET_OPEN)
      return CURLY_BRACKET_CLOSE;
  }
  function read_context(parser) {
    const start = parser.index;
    let i2 = parser.index;
    const code = full_char_code_at(parser.template, i2);
    if (isIdentifierStart(code, true))
      return {
        type: "Identifier",
        name: parser.read_identifier(),
        start,
        end: parser.index
      };
    if (!is_bracket_open(code))
      parser.error(parser_errors.unexpected_token_destructure);
    const bracket_stack = [
      code
    ];
    i2 += code <= 65535 ? 1 : 2;
    while (i2 < parser.template.length) {
      const code2 = full_char_code_at(parser.template, i2);
      if (is_bracket_open(code2))
        bracket_stack.push(code2);
      else if (is_bracket_close(code2)) {
        if (!is_bracket_pair(bracket_stack[bracket_stack.length - 1], code2))
          parser.error(parser_errors.unexpected_token(String.fromCharCode(get_bracket_close(bracket_stack[bracket_stack.length - 1]))));
        bracket_stack.pop();
        if (bracket_stack.length === 0) {
          i2 += code2 <= 65535 ? 1 : 2;
          break;
        }
      }
      i2 += code2 <= 65535 ? 1 : 2;
    }
    parser.index = i2;
    const pattern_string = parser.template.slice(start, i2);
    try {
      let space_with_newline = parser.template.slice(0, start).replace(regex_not_newline_characters, " ");
      const first_space = space_with_newline.indexOf(" ");
      space_with_newline = space_with_newline.slice(0, first_space) + space_with_newline.slice(first_space + 1);
      return parse_expression_at(`${space_with_newline}(${pattern_string} = 1)`, start - 1).left;
    } catch (error2) {
      parser.acorn_error(error2);
    }
  }
  function trim_start(str) {
    return str.replace(regex_starts_with_whitespaces, "");
  }
  function trim_end(str) {
    return str.replace(regex_ends_with_whitespaces, "");
  }
  function to_string(node2) {
    switch (node2.type) {
      case "IfBlock":
        return "{#if} block";
      case "ThenBlock":
        return "{:then} block";
      case "ElseBlock":
        return "{:else} block";
      case "PendingBlock":
      case "AwaitBlock":
        return "{#await} block";
      case "CatchBlock":
        return "{:catch} block";
      case "EachBlock":
        return "{#each} block";
      case "RawMustacheTag":
        return "{@html} block";
      case "DebugTag":
        return "{@debug} block";
      case "ConstTag":
        return "{@const} tag";
      case "Element":
      case "InlineComponent":
      case "Slot":
      case "Title":
        return `<${node2.name}> tag`;
      default:
        return node2.type;
    }
  }
  function trim_whitespace(block, trim_before, trim_after) {
    if (!block.children || block.children.length === 0)
      return;
    const first_child = block.children[0];
    const last_child = block.children[block.children.length - 1];
    if (first_child.type === "Text" && trim_before) {
      first_child.data = trim_start(first_child.data);
      if (!first_child.data)
        block.children.shift();
    }
    if (last_child.type === "Text" && trim_after) {
      last_child.data = trim_end(last_child.data);
      if (!last_child.data)
        block.children.pop();
    }
    if (block.else)
      trim_whitespace(block.else, trim_before, trim_after);
    if (first_child.elseif)
      trim_whitespace(first_child, trim_before, trim_after);
  }
  const regex_whitespace_with_closing_curly_brace = /\s*}/;
  function mustache(parser) {
    const start = parser.index;
    parser.index += 1;
    parser.allow_whitespace();
    if (parser.eat("/")) {
      let block = parser.current();
      let expected;
      if (closing_tag_omitted(block.name)) {
        block.end = start;
        parser.stack.pop();
        block = parser.current();
      }
      if (block.type === "ElseBlock" || block.type === "PendingBlock" || block.type === "ThenBlock" || block.type === "CatchBlock") {
        block.end = start;
        parser.stack.pop();
        block = parser.current();
        expected = "await";
      }
      if (block.type === "IfBlock")
        expected = "if";
      else if (block.type === "EachBlock")
        expected = "each";
      else if (block.type === "AwaitBlock")
        expected = "await";
      else if (block.type === "KeyBlock")
        expected = "key";
      else
        parser.error(parser_errors.unexpected_block_close);
      parser.eat(expected, true);
      parser.allow_whitespace();
      parser.eat("}", true);
      while (block.elseif) {
        block.end = parser.index;
        parser.stack.pop();
        block = parser.current();
        if (block.else)
          block.else.end = start;
      }
      const char_before = parser.template[block.start - 1];
      const char_after = parser.template[parser.index];
      const trim_before = !char_before || regex_whitespace.test(char_before);
      const trim_after = !char_after || regex_whitespace.test(char_after);
      trim_whitespace(block, trim_before, trim_after);
      block.end = parser.index;
      parser.stack.pop();
    } else if (parser.eat(":else")) {
      if (parser.eat("if"))
        parser.error(parser_errors.invalid_elseif);
      parser.allow_whitespace();
      if (parser.eat("if")) {
        const block = parser.current();
        if (block.type !== "IfBlock")
          parser.error(parser.stack.some((block2) => block2.type === "IfBlock") ? parser_errors.invalid_elseif_placement_unclosed_block(to_string(block)) : parser_errors.invalid_elseif_placement_outside_if);
        parser.require_whitespace();
        const expression = read_expression(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
        block.else = {
          start: parser.index,
          end: null,
          type: "ElseBlock",
          children: [
            {
              start: parser.index,
              end: null,
              type: "IfBlock",
              elseif: true,
              expression,
              children: []
            }
          ]
        };
        parser.stack.push(block.else.children[0]);
      } else {
        const block = parser.current();
        if (block.type !== "IfBlock" && block.type !== "EachBlock")
          parser.error(parser.stack.some((block2) => block2.type === "IfBlock" || block2.type === "EachBlock") ? parser_errors.invalid_else_placement_unclosed_block(to_string(block)) : parser_errors.invalid_else_placement_outside_if);
        parser.allow_whitespace();
        parser.eat("}", true);
        block.else = {
          start: parser.index,
          end: null,
          type: "ElseBlock",
          children: []
        };
        parser.stack.push(block.else);
      }
    } else if (parser.match(":then") || parser.match(":catch")) {
      const block = parser.current();
      const is_then = parser.eat(":then") || !parser.eat(":catch");
      if (is_then) {
        if (block.type !== "PendingBlock")
          parser.error(parser.stack.some((block2) => block2.type === "PendingBlock") ? parser_errors.invalid_then_placement_unclosed_block(to_string(block)) : parser_errors.invalid_then_placement_without_await);
      } else if (block.type !== "ThenBlock" && block.type !== "PendingBlock")
        parser.error(parser.stack.some((block2) => block2.type === "ThenBlock" || block2.type === "PendingBlock") ? parser_errors.invalid_catch_placement_unclosed_block(to_string(block)) : parser_errors.invalid_catch_placement_without_await);
      block.end = start;
      parser.stack.pop();
      const await_block = parser.current();
      if (!parser.eat("}")) {
        parser.require_whitespace();
        await_block[is_then ? "value" : "error"] = read_context(parser);
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      const new_block = {
        start,
        end: null,
        type: is_then ? "ThenBlock" : "CatchBlock",
        children: [],
        skip: false
      };
      await_block[is_then ? "then" : "catch"] = new_block;
      parser.stack.push(new_block);
    } else if (parser.eat("#")) {
      let type;
      if (parser.eat("if"))
        type = "IfBlock";
      else if (parser.eat("each"))
        type = "EachBlock";
      else if (parser.eat("await"))
        type = "AwaitBlock";
      else if (parser.eat("key"))
        type = "KeyBlock";
      else
        parser.error(parser_errors.expected_block_type);
      parser.require_whitespace();
      const expression = read_expression(parser);
      const block = type === "AwaitBlock" ? {
        start,
        end: null,
        type,
        expression,
        value: null,
        error: null,
        pending: {
          start: null,
          end: null,
          type: "PendingBlock",
          children: [],
          skip: true
        },
        then: {
          start: null,
          end: null,
          type: "ThenBlock",
          children: [],
          skip: true
        },
        catch: {
          start: null,
          end: null,
          type: "CatchBlock",
          children: [],
          skip: true
        }
      } : {
        start,
        end: null,
        type,
        expression,
        children: []
      };
      parser.allow_whitespace();
      if (type === "EachBlock") {
        parser.eat("as", true);
        parser.require_whitespace();
        block.context = read_context(parser);
        parser.allow_whitespace();
        if (parser.eat(",")) {
          parser.allow_whitespace();
          block.index = parser.read_identifier();
          if (!block.index)
            parser.error(parser_errors.expected_name);
          parser.allow_whitespace();
        }
        if (parser.eat("(")) {
          parser.allow_whitespace();
          block.key = read_expression(parser);
          parser.allow_whitespace();
          parser.eat(")", true);
          parser.allow_whitespace();
        }
      }
      const await_block_shorthand = type === "AwaitBlock" && parser.eat("then");
      if (await_block_shorthand) {
        if (parser.match_regex(regex_whitespace_with_closing_curly_brace))
          parser.allow_whitespace();
        else {
          parser.require_whitespace();
          block.value = read_context(parser);
          parser.allow_whitespace();
        }
      }
      const await_block_catch_shorthand = !await_block_shorthand && type === "AwaitBlock" && parser.eat("catch");
      if (await_block_catch_shorthand) {
        if (parser.match_regex(regex_whitespace_with_closing_curly_brace))
          parser.allow_whitespace();
        else {
          parser.require_whitespace();
          block.error = read_context(parser);
          parser.allow_whitespace();
        }
      }
      parser.eat("}", true);
      parser.current().children.push(block);
      parser.stack.push(block);
      if (type === "AwaitBlock") {
        let child_block;
        if (await_block_shorthand) {
          block.then.skip = false;
          child_block = block.then;
        } else if (await_block_catch_shorthand) {
          block.catch.skip = false;
          child_block = block.catch;
        } else {
          block.pending.skip = false;
          child_block = block.pending;
        }
        child_block.start = parser.index;
        parser.stack.push(child_block);
      }
    } else if (parser.eat("@html")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      parser.current().children.push({
        start,
        end: parser.index,
        type: "RawMustacheTag",
        expression
      });
    } else if (parser.eat("@debug")) {
      let identifiers;
      if (parser.read(regex_whitespace_with_closing_curly_brace))
        identifiers = [];
      else {
        const expression = read_expression(parser);
        identifiers = expression.type === "SequenceExpression" ? expression.expressions : [
          expression
        ];
        identifiers.forEach((node2) => {
          if (node2.type !== "Identifier")
            parser.error(parser_errors.invalid_debug_args, node2.start);
        });
        parser.allow_whitespace();
        parser.eat("}", true);
      }
      parser.current().children.push({
        start,
        end: parser.index,
        type: "DebugTag",
        identifiers
      });
    } else if (parser.eat("@const")) {
      parser.require_whitespace();
      const expression = read_expression(parser);
      if (!(expression.type === "AssignmentExpression" && expression.operator === "="))
        parser.error({
          code: "invalid-const-args",
          message: "{@const ...} must be an assignment."
        }, start);
      parser.allow_whitespace();
      parser.eat("}", true);
      parser.current().children.push({
        start,
        end: parser.index,
        type: "ConstTag",
        expression
      });
    } else {
      const expression = read_expression(parser);
      parser.allow_whitespace();
      parser.eat("}", true);
      parser.current().children.push({
        start,
        end: parser.index,
        type: "MustacheTag",
        expression
      });
    }
  }
  function text(parser) {
    const start = parser.index;
    let data2 = "";
    while (parser.index < parser.template.length && !parser.match("<") && !parser.match("{"))
      data2 += parser.template[parser.index++];
    const node2 = {
      start,
      end: parser.index,
      type: "Text",
      raw: data2,
      data: decode_character_references(data2)
    };
    parser.current().children.push(node2);
  }
  function fragment(parser) {
    if (parser.match("<"))
      return tag;
    if (parser.match("{"))
      return mustache;
    return text;
  }
  const reserved = /* @__PURE__ */ new Set([
    "arguments",
    "await",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "enum",
    "eval",
    "export",
    "extends",
    "false",
    "finally",
    "for",
    "function",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "interface",
    "let",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "static",
    "super",
    "switch",
    "this",
    "throw",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with",
    "yield"
  ]);
  function is_valid(str) {
    let i2 = 0;
    while (i2 < str.length) {
      const code = full_char_code_at(str, i2);
      if (!(i2 === 0 ? isIdentifierStart : isIdentifierChar)(code, true))
        return false;
      i2 += code <= 65535 ? 1 : 2;
    }
    return true;
  }
  const regex_non_standard_characters = /[^a-zA-Z0-9_]+/g;
  const regex_starts_with_number = /^[0-9]/;
  function sanitize(name) {
    return name.replace(regex_non_standard_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_number, "_$&");
  }
  function getLocator(source, options) {
    if (options === void 0)
      options = {};
    var offsetLine = options.offsetLine || 0;
    var offsetColumn = options.offsetColumn || 0;
    var originalLines = source.split("\n");
    var start = 0;
    var lineRanges = originalLines.map(function(line, i3) {
      var end = start + line.length + 1;
      var range = {
        start,
        end,
        line: i3
      };
      start = end;
      return range;
    });
    var i2 = 0;
    function rangeContains(range, index) {
      return range.start <= index && index < range.end;
    }
    function getLocation(range, index) {
      return {
        line: offsetLine + range.line,
        column: offsetColumn + index - range.start,
        character: index
      };
    }
    function locate2(search, startIndex) {
      if (typeof search === "string")
        search = source.indexOf(search, startIndex || 0);
      var range = lineRanges[i2];
      var d = search >= range.end ? 1 : -1;
      while (range) {
        if (rangeContains(range, search))
          return getLocation(range, search);
        i2 += d;
        range = lineRanges[i2];
      }
    }
    return locate2;
  }
  function locate(source, search, options) {
    if (typeof options === "number")
      throw new Error("locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument");
    return getLocator(source, options)(search, options && options.startIndex);
  }
  const regex_tabs = /^\t+/;
  function tabs_to_spaces(str) {
    return str.replace(regex_tabs, (match) => match.split("	").join("  "));
  }
  function get_code_frame(source, line, column) {
    const lines = source.split("\n");
    const frame_start = Math.max(0, line - 2);
    const frame_end = Math.min(line + 3, lines.length);
    const digits = String(frame_end + 1).length;
    return lines.slice(frame_start, frame_end).map((str, i2) => {
      const isErrorLine = frame_start + i2 === line;
      const line_num = String(i2 + frame_start + 1).padStart(digits, " ");
      if (isErrorLine) {
        const indicator = " ".repeat(digits + 2 + tabs_to_spaces(str.slice(0, column)).length) + "^";
        return `${line_num}: ${tabs_to_spaces(str)}
${indicator}`;
      }
      return `${line_num}: ${tabs_to_spaces(str)}`;
    }).join("\n");
  }
  class CompileError extends Error {
    toString() {
      return `${this.message} (${this.start.line}:${this.start.column})
${this.frame}`;
    }
  }
  function error(message, props) {
    const error2 = new CompileError(message);
    error2.name = props.name;
    const start = locate(props.source, props.start, {
      offsetLine: 1
    });
    const end = locate(props.source, props.end || props.start, {
      offsetLine: 1
    });
    error2.code = props.code;
    error2.start = start;
    error2.end = end;
    error2.pos = props.start;
    error2.filename = props.filename;
    error2.frame = get_code_frame(props.source, start.line - 1, start.column);
    throw error2;
  }
  const regex_position_indicator = / \(\d+:\d+\)$/;
  class Parser$1 {
    constructor(template, options) {
      this.index = 0;
      this.stack = [];
      this.css = [];
      this.js = [];
      this.meta_tags = {};
      if (typeof template !== "string")
        throw new TypeError("Template must be a string");
      this.template = template.trimRight();
      this.filename = options.filename;
      this.customElement = options.customElement;
      this.css_mode = options.css;
      this.html = {
        start: null,
        end: null,
        type: "Fragment",
        children: []
      };
      this.stack.push(this.html);
      let state = fragment;
      while (this.index < this.template.length)
        state = state(this) || fragment;
      if (this.stack.length > 1) {
        const current = this.current();
        const type = current.type === "Element" ? `<${current.name}>` : "Block";
        const slug = current.type === "Element" ? "element" : "block";
        this.error({
          code: `unclosed-${slug}`,
          message: `${type} was left open`
        }, current.start);
      }
      if (state !== fragment)
        this.error({
          code: "unexpected-eof",
          message: "Unexpected end of input"
        });
      if (this.html.children.length) {
        let start = this.html.children[0].start;
        while (regex_whitespace.test(template[start]))
          start += 1;
        let end = this.html.children[this.html.children.length - 1].end;
        while (regex_whitespace.test(template[end - 1]))
          end -= 1;
        this.html.start = start;
        this.html.end = end;
      } else
        this.html.start = this.html.end = null;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    acorn_error(err) {
      this.error({
        code: "parse-error",
        message: err.message.replace(regex_position_indicator, "")
      }, err.pos);
    }
    error({ code, message }, index = this.index) {
      error(message, {
        name: "ParseError",
        code,
        source: this.template,
        start: index,
        filename: this.filename
      });
    }
    eat(str, required, error2) {
      if (this.match(str)) {
        this.index += str.length;
        return true;
      }
      if (required)
        this.error(error2 || (this.index === this.template.length ? parser_errors.unexpected_eof_token(str) : parser_errors.unexpected_token(str)));
      return false;
    }
    match(str) {
      return this.template.slice(this.index, this.index + str.length) === str;
    }
    match_regex(pattern) {
      const match = pattern.exec(this.template.slice(this.index));
      if (!match || match.index !== 0)
        return null;
      return match[0];
    }
    allow_whitespace() {
      while (this.index < this.template.length && regex_whitespace.test(this.template[this.index]))
        this.index++;
    }
    read(pattern) {
      const result = this.match_regex(pattern);
      if (result)
        this.index += result.length;
      return result;
    }
    read_identifier(allow_reserved = false) {
      const start = this.index;
      let i2 = this.index;
      const code = full_char_code_at(this.template, i2);
      if (!isIdentifierStart(code, true))
        return null;
      i2 += code <= 65535 ? 1 : 2;
      while (i2 < this.template.length) {
        const code2 = full_char_code_at(this.template, i2);
        if (!isIdentifierChar(code2, true))
          break;
        i2 += code2 <= 65535 ? 1 : 2;
      }
      const identifier = this.template.slice(this.index, this.index = i2);
      if (!allow_reserved && reserved.has(identifier))
        this.error({
          code: "unexpected-reserved-word",
          message: `'${identifier}' is a reserved word in JavaScript and cannot be used here`
        }, start);
      return identifier;
    }
    read_until(pattern, error_message) {
      if (this.index >= this.template.length)
        this.error(error_message || {
          code: "unexpected-eof",
          message: "Unexpected end of input"
        });
      const start = this.index;
      const match = pattern.exec(this.template.slice(start));
      if (match) {
        this.index = start + match.index;
        return this.template.slice(start, this.index);
      }
      this.index = this.template.length;
      return this.template.slice(start);
    }
    require_whitespace() {
      if (!regex_whitespace.test(this.template[this.index]))
        this.error({
          code: "missing-whitespace",
          message: "Expected whitespace"
        });
      this.allow_whitespace();
    }
  }
  function parse$I(template, options = {}) {
    const parser = new Parser$1(template, options);
    if (parser.css.length > 1)
      parser.error(parser_errors.duplicate_style, parser.css[1].start);
    const instance_scripts = parser.js.filter((script) => script.context === "default");
    const module_scripts = parser.js.filter((script) => script.context === "module");
    if (instance_scripts.length > 1)
      parser.error(parser_errors.invalid_script_instance, instance_scripts[1].start);
    if (module_scripts.length > 1)
      parser.error(parser_errors.invalid_script_module, module_scripts[1].start);
    return {
      html: parser.html,
      css: parser.css[0],
      instance: instance_scripts[0],
      module: module_scripts[0]
    };
  }
  function is_head(node2) {
    return node2 && node2.type === "MemberExpression" && node2.object["name"] === "@_document" && node2.property["name"] === "head";
  }
  class Block {
    constructor(options) {
      this.dependencies = /* @__PURE__ */ new Set();
      this.binding_group_initialised = /* @__PURE__ */ new Set();
      this.event_listeners = [];
      this.variables = /* @__PURE__ */ new Map();
      this.has_update_method = false;
      this.parent = options.parent;
      this.renderer = options.renderer;
      this.name = options.name;
      this.type = options.type;
      this.comment = options.comment;
      this.wrappers = [];
      this.key = options.key;
      this.first = null;
      this.bindings = options.bindings;
      this.chunks = {
        declarations: [],
        init: [],
        create: [],
        claim: [],
        hydrate: [],
        mount: [],
        measure: [],
        restore_measurements: [],
        fix: [],
        animate: [],
        intro: [],
        update: [],
        outro: [],
        destroy: []
      };
      this.has_animation = false;
      this.has_intro_method = false;
      this.has_outro_method = false;
      this.outros = 0;
      this.get_unique_name = this.renderer.component.get_unique_name_maker();
      this.aliases = /* @__PURE__ */ new Map();
      if (this.key)
        this.aliases.set("key", this.get_unique_name("key"));
    }
    assign_variable_names() {
      const seen = /* @__PURE__ */ new Set();
      const dupes = /* @__PURE__ */ new Set();
      let i2 = this.wrappers.length;
      while (i2--) {
        const wrapper = this.wrappers[i2];
        if (!wrapper.var)
          continue;
        if (seen.has(wrapper.var.name))
          dupes.add(wrapper.var.name);
        seen.add(wrapper.var.name);
      }
      const counts = /* @__PURE__ */ new Map();
      i2 = this.wrappers.length;
      while (i2--) {
        const wrapper = this.wrappers[i2];
        if (!wrapper.var)
          continue;
        let suffix = "";
        if (dupes.has(wrapper.var.name)) {
          const i3 = counts.get(wrapper.var.name) || 0;
          counts.set(wrapper.var.name, i3 + 1);
          suffix = i3;
        }
        wrapper.var.name = this.get_unique_name(wrapper.var.name + suffix).name;
      }
    }
    add_dependencies(dependencies) {
      dependencies.forEach((dependency) => {
        this.dependencies.add(dependency);
      });
      this.has_update_method = true;
      if (this.parent)
        this.parent.add_dependencies(dependencies);
    }
    add_element(id2, render_statement, claim_statement, parent_node, no_detach) {
      this.add_variable(id2);
      this.chunks.create.push(b`${id2} = ${render_statement};`);
      if (this.renderer.options.hydratable)
        this.chunks.claim.push(b`${id2} = ${claim_statement || render_statement};`);
      if (parent_node) {
        this.chunks.mount.push(b`@append(${parent_node}, ${id2});`);
        if (is_head(parent_node) && !no_detach)
          this.chunks.destroy.push(b`@detach(${id2});`);
      } else {
        this.chunks.mount.push(b`@insert(#target, ${id2}, #anchor);`);
        if (!no_detach)
          this.chunks.destroy.push(b`if (detaching) @detach(${id2});`);
      }
    }
    add_intro(local) {
      this.has_intros = this.has_intro_method = true;
      if (!local && this.parent)
        this.parent.add_intro();
    }
    add_outro(local) {
      this.has_outros = this.has_outro_method = true;
      this.outros += 1;
      if (!local && this.parent)
        this.parent.add_outro();
    }
    add_animation() {
      this.has_animation = true;
    }
    add_variable(id2, init) {
      if (this.variables.has(id2.name))
        throw new Error(`Variable '${id2.name}' already initialised with a different value`);
      this.variables.set(id2.name, {
        id: id2,
        init
      });
    }
    alias(name) {
      if (!this.aliases.has(name))
        this.aliases.set(name, this.get_unique_name(name));
      return this.aliases.get(name);
    }
    child(options) {
      return new Block(Object.assign({}, this, {
        key: null
      }, options, {
        parent: this
      }));
    }
    get_contents(key) {
      const { dev } = this.renderer.options;
      if (this.has_outros) {
        this.add_variable({
          type: "Identifier",
          name: "#current"
        });
        if (this.chunks.intro.length > 0) {
          this.chunks.intro.push(b`#current = true;`);
          this.chunks.mount.push(b`#current = true;`);
        }
        if (this.chunks.outro.length > 0)
          this.chunks.outro.push(b`#current = false;`);
      }
      if (this.autofocus) {
        if (this.autofocus.condition_expression)
          this.chunks.mount.push(b`if (${this.autofocus.condition_expression}) ${this.autofocus.element_var}.focus();`);
        else
          this.chunks.mount.push(b`${this.autofocus.element_var}.focus();`);
      }
      this.render_listeners();
      const properties2 = {};
      const noop2 = x`@noop`;
      properties2.key = key;
      if (this.first) {
        properties2.first = x`null`;
        this.chunks.hydrate.push(b`this.first = ${this.first};`);
      }
      if (this.chunks.create.length === 0 && this.chunks.hydrate.length === 0)
        properties2.create = noop2;
      else {
        const hydrate = this.chunks.hydrate.length > 0 && (this.renderer.options.hydratable ? b`this.h();` : this.chunks.hydrate);
        properties2.create = x`function #create() {
				${this.chunks.create}
				${hydrate}
			}`;
      }
      if (this.renderer.options.hydratable || this.chunks.claim.length > 0) {
        if (this.chunks.claim.length === 0 && this.chunks.hydrate.length === 0)
          properties2.claim = noop2;
        else
          properties2.claim = x`function #claim(#nodes) {
					${this.chunks.claim}
					${this.renderer.options.hydratable && this.chunks.hydrate.length > 0 && b`this.h();`}
				}`;
      }
      if (this.renderer.options.hydratable && this.chunks.hydrate.length > 0)
        properties2.hydrate = x`function #hydrate() {
				${this.chunks.hydrate}
			}`;
      if (this.chunks.mount.length === 0)
        properties2.mount = noop2;
      else if (this.event_listeners.length === 0)
        properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
      else
        properties2.mount = x`function #mount(#target, #anchor) {
				${this.chunks.mount}
			}`;
      if (this.has_update_method || this.maintain_context) {
        if (this.chunks.update.length === 0 && !this.maintain_context)
          properties2.update = noop2;
        else {
          const ctx = this.maintain_context ? x`#new_ctx` : x`#ctx`;
          let dirty = {
            type: "Identifier",
            name: "#dirty"
          };
          if (!this.renderer.context_overflow && !this.parent)
            dirty = {
              type: "ArrayPattern",
              elements: [
                dirty
              ]
            };
          properties2.update = x`function #update(${ctx}, ${dirty}) {
					${this.maintain_context && b`#ctx = ${ctx};`}
					${this.chunks.update}
				}`;
        }
      }
      if (this.has_animation) {
        properties2.measure = x`function #measure() {
				${this.chunks.measure}
			}`;
        if (this.chunks.restore_measurements.length)
          properties2.restore_measurements = x`function #restore_measurements(#measurement) {
					${this.chunks.restore_measurements}
				}`;
        properties2.fix = x`function #fix() {
				${this.chunks.fix}
			}`;
        properties2.animate = x`function #animate() {
				${this.chunks.animate}
			}`;
      }
      if (this.has_intro_method || this.has_outro_method) {
        if (this.chunks.intro.length === 0)
          properties2.intro = noop2;
        else
          properties2.intro = x`function #intro(#local) {
					${this.has_outros && b`if (#current) return;`}
					${this.chunks.intro}
				}`;
        if (this.chunks.outro.length === 0)
          properties2.outro = noop2;
        else
          properties2.outro = x`function #outro(#local) {
					${this.chunks.outro}
				}`;
      }
      if (this.chunks.destroy.length === 0)
        properties2.destroy = noop2;
      else
        properties2.destroy = x`function #destroy(detaching) {
				${this.chunks.destroy}
			}`;
      if (!this.renderer.component.compile_options.dev)
        for (const name in properties2) {
          const property = properties2[name];
          if (property)
            property.id = null;
        }
      const return_value = x`{
			key: ${properties2.key},
			first: ${properties2.first},
			c: ${properties2.create},
			l: ${properties2.claim},
			h: ${properties2.hydrate},
			m: ${properties2.mount},
			p: ${properties2.update},
			r: ${properties2.measure},
			s: ${properties2.restore_measurements},
			f: ${properties2.fix},
			a: ${properties2.animate},
			i: ${properties2.intro},
			o: ${properties2.outro},
			d: ${properties2.destroy}
		}`;
      const block = dev && this.get_unique_name("block");
      const body = b`
			${this.chunks.declarations}

			${Array.from(this.variables.values()).map(({ id: id2, init }) => {
        return init ? b`let ${id2} = ${init}` : b`let ${id2}`;
      })}

			${this.chunks.init}

			${dev ? b`
					const ${block} = ${return_value};
					@dispatch_dev("SvelteRegisterBlock", {
						block: ${block},
						id: ${this.name || "create_fragment"}.name,
						type: "${this.type}",
						source: "${this.comment ? this.comment.replace(regex_double_quotes, '\\"') : ""}",
						ctx: #ctx
					});
					return ${block};` : b`
					return ${return_value};`}
		`;
      return body;
    }
    has_content() {
      return !!this.first || this.event_listeners.length > 0 || this.chunks.intro.length > 0 || this.chunks.outro.length > 0 || this.chunks.create.length > 0 || this.chunks.hydrate.length > 0 || this.chunks.claim.length > 0 || this.chunks.mount.length > 0 || this.chunks.update.length > 0 || this.chunks.destroy.length > 0 || this.has_animation;
    }
    render() {
      const key = this.key && this.get_unique_name("key");
      const args = [
        x`#ctx`
      ];
      if (key)
        args.unshift(key);
      const fn = b`function ${this.name}(${args}) {
			${this.get_contents(key)}
		}`;
      return this.comment ? b`
				// ${this.comment}
				${fn}` : fn;
    }
    render_listeners(chunk = "") {
      if (this.event_listeners.length > 0) {
        this.add_variable({
          type: "Identifier",
          name: "#mounted"
        });
        this.chunks.destroy.push(b`#mounted = false`);
        const dispose = {
          type: "Identifier",
          name: `#dispose${chunk}`
        };
        this.add_variable(dispose);
        if (this.event_listeners.length === 1) {
          this.chunks.mount.push(b`
						if (!#mounted) {
							${dispose} = ${this.event_listeners[0]};
							#mounted = true;
						}
					`);
          this.chunks.destroy.push(b`${dispose}();`);
        } else {
          this.chunks.mount.push(b`
					if (!#mounted) {
						${dispose} = [
							${this.event_listeners}
						];
						#mounted = true;
					}
				`);
          this.chunks.destroy.push(b`@run_all(${dispose});`);
        }
      }
    }
  }
  class Wrapper {
    constructor(renderer, block, parent, node2) {
      this.node = node2;
      Object.defineProperties(this, {
        renderer: {
          value: renderer
        },
        parent: {
          value: parent
        }
      });
      this.can_use_innerhtml = !renderer.options.hydratable;
      this.is_static_content = !renderer.options.hydratable;
      block.wrappers.push(this);
    }
    cannot_use_innerhtml() {
      this.can_use_innerhtml = false;
      if (this.parent)
        this.parent.cannot_use_innerhtml();
    }
    not_static_content() {
      this.is_static_content = false;
      if (this.parent)
        this.parent.not_static_content();
    }
    get_or_create_anchor(block, parent_node, parent_nodes) {
      const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
      const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
        type: "Identifier",
        name: "null"
      };
      if (needs_anchor)
        block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
      return anchor;
    }
    get_update_mount_node(anchor) {
      return this.parent && this.parent.is_dom_node() ? this.parent.var : x`${anchor}.parentNode`;
    }
    is_dom_node() {
      return this.node.type === "Element" || this.node.type === "Text" || this.node.type === "MustacheTag";
    }
    render(_block, _parent_node, _parent_nodes) {
      throw Error("Wrapper class is not renderable");
    }
  }
  function create_debugging_comment(node2, component) {
    const { locate: locate2, source } = component;
    let c2 = node2.start;
    if (node2.type === "ElseBlock") {
      while (source[c2 - 1] !== "{")
        c2 -= 1;
      while (source[c2 - 1] === "{")
        c2 -= 1;
    }
    let d;
    if (node2.type === "InlineComponent" || node2.type === "Element" || node2.type === "SlotTemplate") {
      if (node2.children.length) {
        d = node2.children[0].start;
        while (source[d - 1] !== ">")
          d -= 1;
      } else {
        d = node2.start;
        while (source[d] !== ">")
          d += 1;
        d += 1;
      }
    } else if (node2.type === "Text" || node2.type === "Comment")
      d = node2.end;
    else {
      d = node2.expression ? node2.expression.node.end : c2;
      while (source[d] !== "}" && d <= source.length)
        d += 1;
      while (source[d] === "}")
        d += 1;
    }
    const start = locate2(c2);
    const loc = `(${start.line}:${start.column})`;
    return `${loc} ${source.slice(c2, d)}`.replace(regex_whitespace_characters, " ");
  }
  class Node$1 {
    constructor(component, parent, _scope, info) {
      this.start = info.start;
      this.end = info.end;
      this.type = info.type;
      Object.defineProperties(this, {
        component: {
          value: component
        },
        parent: {
          value: parent
        }
      });
    }
    cannot_use_innerhtml() {
      if (this.can_use_innerhtml !== false) {
        this.can_use_innerhtml = false;
        if (this.parent)
          this.parent.cannot_use_innerhtml();
      }
    }
    find_nearest(selector2) {
      if (selector2.test(this.type))
        return this;
      if (this.parent)
        return this.parent.find_nearest(selector2);
    }
    get_static_attribute_value(name) {
      const attribute = this.attributes && this.attributes.find((attr) => attr.type === "Attribute" && attr.name.toLowerCase() === name);
      if (!attribute)
        return null;
      if (attribute.is_true)
        return true;
      if (attribute.chunks.length === 0)
        return "";
      if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Text")
        return attribute.chunks[0].data;
      return null;
    }
    has_ancestor(type) {
      return this.parent ? this.parent.type === type || this.parent.has_ancestor(type) : false;
    }
  }
  var compiler_warnings = {
    custom_element_no_tag: {
      code: "custom-element-no-tag",
      message: `No custom element 'tag' option was specified. To automatically register a custom element, specify a name with a hyphen in it, e.g. <svelte:options tag="my-thing"/>. To hide this warning, use <svelte:options tag={null}/>`
    },
    unused_export_let: (component, property) => ({
      code: "unused-export-let",
      message: `${component} has unused export property '${property}'. If it is for external reference only, please consider using \`export const ${property}\``
    }),
    module_script_reactive_declaration: {
      code: "module-script-reactive-declaration",
      message: "$: has no effect in a module script"
    },
    non_top_level_reactive_declaration: {
      code: "non-top-level-reactive-declaration",
      message: "$: has no effect outside of the top-level"
    },
    module_script_variable_reactive_declaration: (names) => ({
      code: "module-script-reactive-declaration",
      message: `${names.map((name) => `"${name}"`).join(", ")} ${names.length > 1 ? "are" : "is"} declared in a module script and will not be reactive`
    }),
    missing_declaration: (name, has_script) => ({
      code: "missing-declaration",
      message: `'${name}' is not defined` + (has_script ? "" : `. Consider adding a <script> block with 'export let ${name}' to declare a prop`)
    }),
    missing_custom_element_compile_options: {
      code: "missing-custom-element-compile-options",
      message: "The 'tag' option is used when generating a custom element. Did you forget the 'customElement: true' compile option?"
    },
    css_unused_selector: (selector2) => ({
      code: "css-unused-selector",
      message: `Unused CSS selector "${selector2}"`
    }),
    empty_block: {
      code: "empty-block",
      message: "Empty block"
    },
    reactive_component: (name) => ({
      code: "reactive-component",
      message: `<${name}/> will not be reactive if ${name} changes. Use <svelte:component this={${name}}/> if you want this reactivity.`
    }),
    component_name_lowercase: (name) => ({
      code: "component-name-lowercase",
      message: `<${name}> will be treated as an HTML element unless it begins with a capital letter`
    }),
    avoid_is: {
      code: "avoid-is",
      message: "The 'is' attribute is not supported cross-browser and should be avoided"
    },
    invalid_html_attribute: (name, suggestion) => ({
      code: "invalid-html-attribute",
      message: `'${name}' is not a valid HTML attribute. Did you mean '${suggestion}'?`
    }),
    a11y_aria_attributes: (name) => ({
      code: "a11y-aria-attributes",
      message: `A11y: <${name}> should not have aria-* attributes`
    }),
    a11y_incorrect_attribute_type: (schema, attribute) => {
      let message;
      switch (schema.type) {
        case "boolean":
          message = `The value of '${attribute}' must be exactly one of true or false`;
          break;
        case "id":
          message = `The value of '${attribute}' must be a string that represents a DOM element ID`;
          break;
        case "idlist":
          message = `The value of '${attribute}' must be a space-separated list of strings that represent DOM element IDs`;
          break;
        case "tristate":
          message = `The value of '${attribute}' must be exactly one of true, false, or mixed`;
          break;
        case "token":
          message = `The value of '${attribute}' must be exactly one of ${(schema.values || []).join(", ")}`;
          break;
        case "tokenlist":
          message = `The value of '${attribute}' must be a space-separated list of one or more of ${(schema.values || []).join(", ")}`;
          break;
        default:
          message = `The value of '${attribute}' must be of type ${schema.type}`;
      }
      return {
        code: "a11y-incorrect-aria-attribute-type",
        message: `A11y: ${message}`
      };
    },
    a11y_unknown_aria_attribute: (attribute, suggestion) => ({
      code: "a11y-unknown-aria-attribute",
      message: `A11y: Unknown aria attribute 'aria-${attribute}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    }),
    a11y_hidden: (name) => ({
      code: "a11y-hidden",
      message: `A11y: <${name}> element should not be hidden`
    }),
    a11y_misplaced_role: (name) => ({
      code: "a11y-misplaced-role",
      message: `A11y: <${name}> should not have role attribute`
    }),
    a11y_unknown_role: (role, suggestion) => ({
      code: "a11y-unknown-role",
      message: `A11y: Unknown role '${role}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    }),
    a11y_no_abstract_role: (role) => ({
      code: "a11y-no-abstract-role",
      message: `A11y: Abstract role '${role}' is forbidden`
    }),
    a11y_no_redundant_roles: (role) => ({
      code: "a11y-no-redundant-roles",
      message: `A11y: Redundant role '${role}'`
    }),
    a11y_no_interactive_element_to_noninteractive_role: (role, element) => ({
      code: "a11y-no-interactive-element-to-noninteractive-role",
      message: `A11y: <${element}> cannot have role '${role}'`
    }),
    a11y_role_has_required_aria_props: (role, props) => ({
      code: "a11y-role-has-required-aria-props",
      message: `A11y: Elements with the ARIA role "${role}" must have the following attributes defined: ${props.map((name) => `"${name}"`).join(", ")}`
    }),
    a11y_accesskey: {
      code: "a11y-accesskey",
      message: "A11y: Avoid using accesskey"
    },
    a11y_autofocus: {
      code: "a11y-autofocus",
      message: "A11y: Avoid using autofocus"
    },
    a11y_misplaced_scope: {
      code: "a11y-misplaced-scope",
      message: "A11y: The scope attribute should only be used with <th> elements"
    },
    a11y_positive_tabindex: {
      code: "a11y-positive-tabindex",
      message: "A11y: avoid tabindex values above zero"
    },
    a11y_invalid_attribute: (href_attribute, href_value) => ({
      code: "a11y-invalid-attribute",
      message: `A11y: '${href_value}' is not a valid ${href_attribute} attribute`
    }),
    a11y_missing_attribute: (name, article, sequence) => ({
      code: "a11y-missing-attribute",
      message: `A11y: <${name}> element should have ${article} ${sequence} attribute`
    }),
    a11y_img_redundant_alt: {
      code: "a11y-img-redundant-alt",
      message: "A11y: Screenreaders already announce <img> elements as an image."
    },
    a11y_label_has_associated_control: {
      code: "a11y-label-has-associated-control",
      message: "A11y: A form label must be associated with a control."
    },
    a11y_media_has_caption: {
      code: "a11y-media-has-caption",
      message: 'A11y: <video> elements must have a <track kind="captions">'
    },
    a11y_distracting_elements: (name) => ({
      code: "a11y-distracting-elements",
      message: `A11y: Avoid <${name}> elements`
    }),
    a11y_structure_immediate: {
      code: "a11y-structure",
      message: "A11y: <figcaption> must be an immediate child of <figure>"
    },
    a11y_structure_first_or_last: {
      code: "a11y-structure",
      message: "A11y: <figcaption> must be first or last child of <figure>"
    },
    a11y_mouse_events_have_key_events: (event, accompanied_by) => ({
      code: "a11y-mouse-events-have-key-events",
      message: `A11y: on:${event} must be accompanied by on:${accompanied_by}`
    }),
    a11y_click_events_have_key_events: () => ({
      code: "a11y-click-events-have-key-events",
      message: "A11y: visible, non-interactive elements with an on:click event must be accompanied by an on:keydown, on:keyup, or on:keypress event."
    }),
    a11y_missing_content: (name) => ({
      code: "a11y-missing-content",
      message: `A11y: <${name}> element should have child content`
    }),
    a11y_no_noninteractive_tabindex: {
      code: "a11y-no-noninteractive-tabindex",
      message: "A11y: noninteractive element cannot have positive tabIndex value"
    },
    redundant_event_modifier_for_touch: {
      code: "redundant-event-modifier",
      message: "Touch event handlers that don't use the 'event' object are passive by default"
    },
    redundant_event_modifier_passive: {
      code: "redundant-event-modifier",
      message: "The passive modifier only works with wheel and touch events"
    },
    invalid_rest_eachblock_binding: (rest_element_name) => ({
      code: "invalid-rest-eachblock-binding",
      message: `...${rest_element_name} operator will create a new object and binding propagation with original object will not work`
    })
  };
  const regex_non_whitespace_characters = /[^ \r\n\f\v\t]/;
  class AbstractBlock extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
    }
    warn_if_empty_block() {
      if (!this.children || this.children.length > 1)
        return;
      const child = this.children[0];
      if (!child || child.type === "Text" && !regex_non_whitespace_characters.test(child.data))
        this.component.warn(this, compiler_warnings.empty_block);
    }
  }
  function flatten_reference(node2) {
    const nodes = [];
    const parts = [];
    while (node2.type === "MemberExpression") {
      nodes.unshift(node2.property);
      if (!node2.computed)
        parts.unshift(node2.property.name);
      else {
        const computed_property = to_string$1(node2.property);
        if (computed_property)
          parts.unshift(`[${computed_property}]`);
      }
      node2 = node2.object;
    }
    const name = node2.type === "Identifier" ? node2.name : node2.type === "ThisExpression" ? "this" : null;
    nodes.unshift(node2);
    parts.unshift(name);
    return {
      name,
      nodes,
      parts
    };
  }
  function to_string$1(node2) {
    switch (node2.type) {
      case "Literal":
        return String(node2.value);
      case "Identifier":
        return node2.name;
    }
  }
  function create_scopes(expression) {
    return analyze(expression);
  }
  function get_object(node2) {
    while (node2.type === "MemberExpression")
      node2 = node2.object;
    return node2;
  }
  const reserved_keywords = /* @__PURE__ */ new Set([
    "$$props",
    "$$restProps",
    "$$slots"
  ]);
  function is_reserved_keyword(name) {
    return reserved_keywords.has(name);
  }
  function is_dynamic(variable) {
    if (variable) {
      if (variable.mutated || variable.reassigned)
        return true;
      if (!variable.module && variable.writable && variable.export_name)
        return true;
      if (is_reserved_keyword(variable.name))
        return true;
    }
    return false;
  }
  function nodes_match(a, b2) {
    if (!!a !== !!b2)
      return false;
    if (Array.isArray(a) !== Array.isArray(b2))
      return false;
    if (a && typeof a === "object") {
      if (Array.isArray(a)) {
        if (a.length !== b2.length)
          return false;
        return a.every((child, i3) => nodes_match(child, b2[i3]));
      }
      const a_keys = Object.keys(a).sort();
      const b_keys = Object.keys(b2).sort();
      if (a_keys.length !== b_keys.length)
        return false;
      let i2 = a_keys.length;
      while (i2--) {
        const key = a_keys[i2];
        if (b_keys[i2] !== key)
          return false;
        if (key === "start" || key === "end")
          continue;
        if (!nodes_match(a[key], b2[key]))
          return false;
      }
      return true;
    }
    return a === b2;
  }
  function invalidate(renderer, scope2, node2, names, main_execution_context = false) {
    const { component } = renderer;
    const [head, ...tail] = Array.from(names).filter((name) => {
      const owner = scope2.find_owner(name);
      return !owner || owner === component.instance_scope;
    }).map((name) => component.var_lookup.get(name)).filter((variable) => {
      return variable && !variable.hoistable && !variable.global && !variable.module && (variable.referenced || variable.subscribable || variable.is_reactive_dependency || variable.export_name || variable.name[0] === "$");
    });
    function get_invalidated(variable, node3) {
      if (main_execution_context && !variable.subscribable && variable.name[0] !== "$")
        return node3;
      return renderer_invalidate(renderer, variable.name, void 0, main_execution_context);
    }
    if (!head)
      return node2;
    component.has_reactive_assignments = true;
    if (node2.type === "AssignmentExpression" && node2.operator === "=" && nodes_match(node2.left, node2.right) && tail.length === 0)
      return get_invalidated(head, node2);
    const is_store_value = head.name[0] === "$" && head.name[1] !== "$";
    const extra_args = tail.map((variable) => get_invalidated(variable)).filter(Boolean);
    if (is_store_value)
      return x`@set_store_value(${head.name.slice(1)}, ${node2}, ${head.name}, ${extra_args})`;
    let invalidate2;
    if (!main_execution_context) {
      const pass_value = extra_args.length > 0 || node2.type === "AssignmentExpression" && node2.left.type !== "Identifier" || node2.type === "UpdateExpression" && (!node2.prefix || node2.argument.type !== "Identifier");
      if (pass_value)
        extra_args.unshift({
          type: "Identifier",
          name: head.name
        });
      invalidate2 = x`$$invalidate(${renderer.context_lookup.get(head.name).index}, ${node2}, ${extra_args})`;
    } else
      invalidate2 = extra_args.length ? [
        node2,
        ...extra_args
      ] : node2;
    if (head.subscribable && head.reassigned) {
      const subscribe = `$$subscribe_${head.name}`;
      invalidate2 = x`${subscribe}(${invalidate2})`;
    }
    return invalidate2;
  }
  function renderer_invalidate(renderer, name, value2, main_execution_context = false) {
    const variable = renderer.component.var_lookup.get(name);
    if (variable && variable.subscribable && (variable.reassigned || variable.export_name)) {
      if (main_execution_context)
        return x`${`$$subscribe_${name}`}(${value2 || name})`;
      else {
        const member = renderer.context_lookup.get(name);
        return x`${`$$subscribe_${name}`}($$invalidate(${member.index}, ${value2 || name}))`;
      }
    }
    if (name[0] === "$" && name[1] !== "$")
      return x`${name.slice(1)}.set(${value2 || name})`;
    if (variable && (variable.module || !variable.referenced && !variable.is_reactive_dependency && !variable.export_name && !name.startsWith("$$")))
      return value2 || name;
    if (value2) {
      if (main_execution_context)
        return x`${value2}`;
      else {
        const member = renderer.context_lookup.get(name);
        return x`$$invalidate(${member.index}, ${value2})`;
      }
    }
    if (main_execution_context)
      return;
    const deps = /* @__PURE__ */ new Set([
      name
    ]);
    deps.forEach((name2) => {
      const reactive_declarations = renderer.component.reactive_declarations.filter((x2) => x2.assignees.has(name2));
      reactive_declarations.forEach((declaration) => {
        declaration.dependencies.forEach((name3) => {
          deps.add(name3);
        });
      });
    });
    const filtered = Array.from(deps).filter((n2) => renderer.context_lookup.has(n2));
    if (!filtered.length)
      return null;
    return filtered.map((n2) => x`$$invalidate(${renderer.context_lookup.get(n2).index}, ${n2})`).reduce((lhs, rhs) => x`${lhs}, ${rhs}`);
  }
  function replace_object(node2, replacement) {
    if (node2.type === "Identifier")
      return replacement;
    const ancestor = node2;
    let parent;
    while (node2.type === "MemberExpression") {
      parent = node2;
      node2 = node2.object;
    }
    parent.object = replacement;
    return ancestor;
  }
  function is_contextual(component, scope2, name) {
    if (is_reserved_keyword(name))
      return true;
    if (!scope2.is_top_level(name))
      return true;
    const variable = component.var_lookup.get(name);
    if (!variable || variable.hoistable)
      return false;
    return true;
  }
  function clone(val) {
    let k, out, tmp;
    if (Array.isArray(val)) {
      out = Array(k = val.length);
      while (k--)
        out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
      return out;
    }
    if (Object.prototype.toString.call(val) === "[object Object]") {
      out = {};
      for (k in val) {
        if (k === "__proto__")
          Object.defineProperty(out, k, {
            value: clone(val[k]),
            configurable: true,
            enumerable: true,
            writable: true
          });
        else if (typeof val[k] !== "function")
          out[k] = (tmp = val[k]) && typeof tmp === "object" ? clone(tmp) : tmp;
      }
      return out;
    }
    return val;
  }
  var compiler_errors = {
    invalid_binding_elements: (element, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on <${element}> elements`
    }),
    invalid_binding_element_with: (elements, binding) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with ${elements}`
    }),
    invalid_binding_on: (binding, element, post) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding on ${element}` + (post || "")
    }),
    invalid_binding_foreign: (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding. Foreign elements only support bind:this`
    }),
    invalid_binding_no_checkbox: (binding, is_radio) => ({
      code: "invalid-binding",
      message: `'${binding}' binding can only be used with <input type="checkbox">` + (is_radio ? ` — for <input type="radio">, use 'group' binding` : "")
    }),
    invalid_binding: (binding) => ({
      code: "invalid-binding",
      message: `'${binding}' is not a valid binding`
    }),
    invalid_binding_window: (parts) => ({
      code: "invalid-binding",
      message: `Bindings on <svelte:window> must be to top-level properties, e.g. '${parts[parts.length - 1]}' rather than '${parts.join(".")}'`
    }),
    invalid_binding_let: {
      code: "invalid-binding",
      message: "Cannot bind to a variable declared with the let: directive"
    },
    invalid_binding_await: {
      code: "invalid-binding",
      message: "Cannot bind to a variable declared with {#await ... then} or {:catch} blocks"
    },
    invalid_binding_const: {
      code: "invalid-binding",
      message: "Cannot bind to a variable declared with {@const ...}"
    },
    invalid_binding_writibale: {
      code: "invalid-binding",
      message: "Cannot bind to a variable which is not writable"
    },
    binding_undeclared: (name) => ({
      code: "binding-undeclared",
      message: `${name} is not declared`
    }),
    invalid_type: {
      code: "invalid-type",
      message: "'type' attribute cannot be dynamic if input uses two-way binding"
    },
    missing_type: {
      code: "missing-type",
      message: "'type' attribute must be specified"
    },
    dynamic_multiple_attribute: {
      code: "dynamic-multiple-attribute",
      message: "'multiple' attribute cannot be dynamic if select uses two-way binding"
    },
    missing_contenteditable_attribute: {
      code: "missing-contenteditable-attribute",
      message: "'contenteditable' attribute is required for textContent and innerHTML two-way bindings"
    },
    dynamic_contenteditable_attribute: {
      code: "dynamic-contenteditable-attribute",
      message: "'contenteditable' attribute cannot be dynamic if element uses two-way binding"
    },
    invalid_event_modifier_combination: (modifier1, modifier2) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier1}' and '${modifier2}' modifiers cannot be used together`
    }),
    invalid_event_modifier_legacy: (modifier) => ({
      code: "invalid-event-modifier",
      message: `The '${modifier}' modifier cannot be used in legacy mode`
    }),
    invalid_event_modifier: (valid) => ({
      code: "invalid-event-modifier",
      message: `Valid event modifiers are ${valid}`
    }),
    invalid_event_modifier_component: {
      code: "invalid-event-modifier",
      message: "Event modifiers other than 'once' can only be used on DOM elements"
    },
    textarea_duplicate_value: {
      code: "textarea-duplicate-value",
      message: "A <textarea> can have either a value attribute or (equivalently) child content, but not both"
    },
    illegal_attribute: (name) => ({
      code: "illegal-attribute",
      message: `'${name}' is not a valid attribute name`
    }),
    invalid_slot_attribute: {
      code: "invalid-slot-attribute",
      message: "slot attribute cannot have a dynamic value"
    },
    duplicate_slot_attribute: (name) => ({
      code: "duplicate-slot-attribute",
      message: `Duplicate '${name}' slot`
    }),
    invalid_slotted_content: {
      code: "invalid-slotted-content",
      message: "Element with a slot='...' attribute must be a child of a component or a descendant of a custom element"
    },
    invalid_attribute_head: {
      code: "invalid-attribute",
      message: "<svelte:head> should not have any attributes or directives"
    },
    invalid_action: {
      code: "invalid-action",
      message: "Actions can only be applied to DOM elements, not components"
    },
    invalid_class: {
      code: "invalid-class",
      message: "Classes can only be applied to DOM elements, not components"
    },
    invalid_transition: {
      code: "invalid-transition",
      message: "Transitions can only be applied to DOM elements, not components"
    },
    invalid_let: {
      code: "invalid-let",
      message: "let directive value must be an identifier or an object/array pattern"
    },
    invalid_slot_directive: {
      code: "invalid-slot-directive",
      message: "<slot> cannot have directives"
    },
    dynamic_slot_name: {
      code: "dynamic-slot-name",
      message: "<slot> name cannot be dynamic"
    },
    invalid_slot_name: {
      code: "invalid-slot-name",
      message: "default is a reserved word — it cannot be used as a slot name"
    },
    invalid_slot_attribute_value_missing: {
      code: "invalid-slot-attribute",
      message: "slot attribute value is missing"
    },
    invalid_slotted_content_fragment: {
      code: "invalid-slotted-content",
      message: "<svelte:fragment> must be a child of a component"
    },
    illegal_attribute_title: {
      code: "illegal-attribute",
      message: "<title> cannot have attributes"
    },
    illegal_structure_title: {
      code: "illegal-structure",
      message: "<title> can only contain text and {tags}"
    },
    duplicate_transition: (directive, parent_directive) => {
      function describe(_directive) {
        return _directive === "transition" ? "a 'transition'" : `an '${_directive}'`;
      }
      const message = directive === parent_directive ? `An element can only have one '${directive}' directive` : `An element cannot have both ${describe(parent_directive)} directive and ${describe(directive)} directive`;
      return {
        code: "duplicate-transition",
        message
      };
    },
    contextual_store: {
      code: "contextual-store",
      message: "Stores must be declared at the top level of the component (this may change in a future version of Svelte)"
    },
    default_export: {
      code: "default-export",
      message: "A component cannot have a default export"
    },
    illegal_declaration: {
      code: "illegal-declaration",
      message: "The $ prefix is reserved, and cannot be used for variable and import names"
    },
    illegal_subscription: {
      code: "illegal-subscription",
      message: 'Cannot reference store value inside <script context="module">'
    },
    illegal_global: (name) => ({
      code: "illegal-global",
      message: `${name} is an illegal variable name`
    }),
    illegal_variable_declaration: {
      code: "illegal-variable-declaration",
      message: 'Cannot declare same variable name which is imported inside <script context="module">'
    },
    cyclical_reactive_declaration: (cycle) => ({
      code: "cyclical-reactive-declaration",
      message: `Cyclical dependency detected: ${cycle.join(" → ")}`
    }),
    invalid_tag_property: {
      code: "invalid-tag-property",
      message: "tag name must be two or more words joined by the '-' character"
    },
    invalid_tag_attribute: {
      code: "invalid-tag-attribute",
      message: "'tag' must be a string literal"
    },
    invalid_namespace_property: (namespace, suggestion) => ({
      code: "invalid-namespace-property",
      message: `Invalid namespace '${namespace}'` + (suggestion ? ` (did you mean '${suggestion}'?)` : "")
    }),
    invalid_namespace_attribute: {
      code: "invalid-namespace-attribute",
      message: "The 'namespace' attribute must be a string literal representing a valid namespace"
    },
    invalid_attribute_value: (name) => ({
      code: `invalid-${name}-value`,
      message: `${name} attribute must be true or false`
    }),
    invalid_options_attribute_unknown: {
      code: "invalid-options-attribute",
      message: "<svelte:options> unknown attribute"
    },
    invalid_options_attribute: {
      code: "invalid-options-attribute",
      message: "<svelte:options> can only have static 'tag', 'namespace', 'accessors', 'immutable' and 'preserveWhitespace' attributes"
    },
    css_invalid_global: {
      code: "css-invalid-global",
      message: ":global(...) can be at the start or end of a selector sequence, but not in the middle"
    },
    css_invalid_global_selector: {
      code: "css-invalid-global-selector",
      message: ":global(...) must contain a single selector"
    },
    css_invalid_selector: (selector2) => ({
      code: "css-invalid-selector",
      message: `Invalid selector "${selector2}"`
    }),
    duplicate_animation: {
      code: "duplicate-animation",
      message: "An element can only have one 'animate' directive"
    },
    invalid_animation_immediate: {
      code: "invalid-animation",
      message: "An element that uses the animate directive must be the immediate child of a keyed each block"
    },
    invalid_animation_key: {
      code: "invalid-animation",
      message: "An element that uses the animate directive must be used inside a keyed each block. Did you forget to add a key to your each block?"
    },
    invalid_animation_sole: {
      code: "invalid-animation",
      message: "An element that uses the animate directive must be the sole child of a keyed each block"
    },
    invalid_animation_dynamic_element: {
      code: "invalid-animation",
      message: "<svelte:element> cannot have a animate directive"
    },
    invalid_directive_value: {
      code: "invalid-directive-value",
      message: "Can only bind to an identifier (e.g. `foo`) or a member expression (e.g. `foo.bar` or `foo[baz]`)"
    },
    invalid_const_placement: {
      code: "invalid-const-placement",
      message: "{@const} must be the immediate child of {#if}, {:else if}, {:else}, {#each}, {:then}, {:catch}, <svelte:fragment> or <Component>"
    },
    invalid_const_declaration: (name) => ({
      code: "invalid-const-declaration",
      message: `'${name}' has already been declared`
    }),
    invalid_const_update: (name) => ({
      code: "invalid-const-update",
      message: `'${name}' is declared using {@const ...} and is read-only`
    }),
    cyclical_const_tags: (cycle) => ({
      code: "cyclical-const-tags",
      message: `Cyclical dependency detected: ${cycle.join(" → ")}`
    }),
    invalid_component_style_directive: {
      code: "invalid-component-style-directive",
      message: "Style directives cannot be used on components"
    },
    invalid_style_directive_modifier: (valid) => ({
      code: "invalid-style-directive-modifier",
      message: `Valid modifiers for style directives are: ${valid}`
    })
  };
  const regex_contains_term_function_expression = /FunctionExpression/;
  class Expression {
    constructor(component, owner, template_scope, info, lazy) {
      this.type = "Expression";
      this.references = /* @__PURE__ */ new Set();
      this.dependencies = /* @__PURE__ */ new Set();
      this.contextual_dependencies = /* @__PURE__ */ new Set();
      this.declarations = [];
      this.uses_context = false;
      Object.defineProperties(this, {
        component: {
          value: component
        }
      });
      this.node = info;
      this.template_scope = template_scope;
      this.owner = owner;
      const { dependencies, contextual_dependencies, references } = this;
      let { map, scope: scope2 } = create_scopes(info);
      this.scope = scope2;
      this.scope_map = map;
      const expression = this;
      let function_expression;
      walk(info, {
        enter(node2, parent, key) {
          if (key === "key" && parent.shorthand)
            return;
          if (node2.type === "MetaProperty")
            return this.skip();
          if (map.has(node2))
            scope2 = map.get(node2);
          if (!function_expression && regex_contains_term_function_expression.test(node2.type))
            function_expression = node2;
          if (is_reference(node2, parent)) {
            const { name, nodes } = flatten_reference(node2);
            references.add(name);
            if (scope2.has(name))
              return;
            if (name[0] === "$") {
              const store_name = name.slice(1);
              if (template_scope.names.has(store_name) || scope2.has(store_name))
                return component.error(node2, compiler_errors.contextual_store);
            }
            if (template_scope.is_let(name)) {
              if (!lazy) {
                contextual_dependencies.add(name);
                dependencies.add(name);
              }
            } else if (template_scope.names.has(name)) {
              expression.uses_context = true;
              contextual_dependencies.add(name);
              const owner2 = template_scope.get_owner(name);
              const is_index = owner2.type === "EachBlock" && owner2.key && name === owner2.index;
              if (!lazy || is_index)
                template_scope.dependencies_for_name.get(name).forEach((name2) => dependencies.add(name2));
            } else {
              if (!lazy)
                dependencies.add(name);
              component.add_reference(node2, name);
              component.warn_if_undefined(name, nodes[0], template_scope);
            }
            this.skip();
          }
          let names;
          let deep = false;
          if (function_expression) {
            if (node2.type === "AssignmentExpression") {
              deep = node2.left.type === "MemberExpression";
              names = extract_names(deep ? get_object(node2.left) : node2.left);
            } else if (node2.type === "UpdateExpression") {
              deep = node2.argument.type === "MemberExpression";
              names = extract_names(get_object(node2.argument));
            }
          }
          if (names)
            names.forEach((name) => {
              var _a;
              if (template_scope.names.has(name)) {
                if (template_scope.is_const(name))
                  component.error(node2, compiler_errors.invalid_const_update(name));
                template_scope.dependencies_for_name.get(name).forEach((name2) => {
                  const variable = component.var_lookup.get(name2);
                  if (variable)
                    variable[deep ? "mutated" : "reassigned"] = true;
                });
                const each_block = template_scope.get_owner(name);
                each_block.has_binding = true;
              } else {
                component.add_reference(node2, name);
                const variable = component.var_lookup.get(name);
                if (variable)
                  variable[deep ? "mutated" : "reassigned"] = true;
                const declaration = (_a = scope2.find_owner(name)) === null || _a === void 0 ? void 0 : _a.declarations.get(name);
                if (declaration) {
                  if (declaration.kind === "const" && !deep)
                    component.error(node2, {
                      code: "assignment-to-const",
                      message: "You are assigning to a const"
                    });
                } else if (variable && variable.writable === false && !deep)
                  component.error(node2, {
                    code: "assignment-to-const",
                    message: "You are assigning to a const"
                  });
              }
            });
        },
        leave(node2) {
          if (map.has(node2))
            scope2 = scope2.parent;
          if (node2 === function_expression)
            function_expression = null;
        }
      });
    }
    dynamic_dependencies() {
      return Array.from(this.dependencies).filter((name) => {
        if (this.template_scope.is_let(name))
          return true;
        if (is_reserved_keyword(name))
          return true;
        const variable = this.component.var_lookup.get(name);
        return is_dynamic(variable);
      });
    }
    // TODO move this into a render-dom wrapper?
    manipulate(block, ctx) {
      if (this.manipulated)
        return this.manipulated;
      const { component, declarations, scope_map: map, template_scope, owner } = this;
      let scope2 = this.scope;
      let function_expression;
      let dependencies;
      let contextual_dependencies;
      const node2 = walk(this.node, {
        enter(node3, parent) {
          if (node3.type === "Property" && node3.shorthand) {
            node3.value = clone(node3.value);
            node3.shorthand = false;
          }
          if (map.has(node3))
            scope2 = map.get(node3);
          if (node3.type === "Identifier" && is_reference(node3, parent)) {
            const { name } = flatten_reference(node3);
            if (scope2.has(name))
              return;
            if (function_expression) {
              if (template_scope.names.has(name)) {
                contextual_dependencies.add(name);
                template_scope.dependencies_for_name.get(name).forEach((dependency) => {
                  dependencies.add(dependency);
                });
              } else {
                dependencies.add(name);
                component.add_reference(node3, name);
              }
            } else if (is_contextual(component, template_scope, name)) {
              const reference = block.renderer.reference(node3, ctx);
              this.replace(reference);
            }
            this.skip();
          }
          if (!function_expression) {
            node3.type;
            if (node3.type === "FunctionExpression" || node3.type === "ArrowFunctionExpression") {
              function_expression = node3;
              dependencies = /* @__PURE__ */ new Set();
              contextual_dependencies = /* @__PURE__ */ new Set();
            }
          }
        },
        leave(node3, parent) {
          if (map.has(node3))
            scope2 = scope2.parent;
          if (node3 === function_expression) {
            const id2 = component.get_unique_name(sanitize(get_function_name(node3, owner)));
            const declaration = b`const ${id2} = ${node3}`;
            const extract_functions = () => {
              const deps = Array.from(contextual_dependencies);
              const function_expression2 = node3;
              const has_args = function_expression2.params.length > 0;
              function_expression2.params = [
                ...deps.map((name) => ({
                  type: "Identifier",
                  name
                })),
                ...function_expression2.params
              ];
              const context_args = deps.map((name) => block.renderer.reference(name, ctx));
              component.partly_hoisted.push(declaration);
              block.renderer.add_to_context(id2.name);
              const callee = block.renderer.reference(id2);
              this.replace(id2);
              const func_declaration = has_args ? b`function ${id2}(...args) {
								return ${callee}(${context_args}, ...args);
							}` : b`function ${id2}() {
								return ${callee}(${context_args});
							}`;
              return {
                deps,
                func_declaration
              };
            };
            if (owner.type === "ConstTag") {
              if (contextual_dependencies.size === 0) {
                let child_scope = scope2;
                walk(node3, {
                  enter(node4, parent2) {
                    if (map.has(node4))
                      child_scope = map.get(node4);
                    if (node4.type === "Identifier" && is_reference(node4, parent2)) {
                      if (child_scope.has(node4.name))
                        return;
                      this.replace(block.renderer.reference(node4, ctx));
                    }
                  },
                  leave(node4) {
                    if (map.has(node4))
                      child_scope = child_scope.parent;
                  }
                });
              } else {
                const { func_declaration } = extract_functions();
                this.replace(func_declaration[0]);
              }
            } else if (dependencies.size === 0 && contextual_dependencies.size === 0) {
              component.fully_hoisted.push(declaration);
              this.replace(id2);
              component.add_var(node3, {
                name: id2.name,
                internal: true,
                hoistable: true,
                referenced: true
              });
            } else if (contextual_dependencies.size === 0) {
              component.partly_hoisted.push(declaration);
              block.renderer.add_to_context(id2.name);
              this.replace(block.renderer.reference(id2));
            } else {
              const { deps, func_declaration } = extract_functions();
              if (owner.type === "Attribute" && owner.parent.name === "slot") {
                const dep_scopes = new Set(deps.map((name) => template_scope.get_owner(name)));
                let node4 = owner.parent;
                while (node4 && !dep_scopes.has(node4))
                  node4 = node4.parent;
                const func_expression = func_declaration[0];
                if (node4.type === "InlineComponent" || node4.type === "SlotTemplate")
                  this.replace(func_expression);
                else {
                  const func_id = component.get_unique_name(id2.name + "_func");
                  block.renderer.add_to_context(func_id.name, true);
                  walk(func_expression, {
                    enter(node5) {
                      if (node5.type === "Identifier" && node5.name === "#ctx")
                        node5.name = "child_ctx";
                    }
                  });
                  template_scope.get_owner(deps[0]).contexts.push({
                    key: func_id,
                    modifier: () => func_expression,
                    default_modifier: (node5) => node5
                  });
                  this.replace(block.renderer.reference(func_id));
                }
              } else
                declarations.push(func_declaration);
            }
            function_expression = null;
            dependencies = null;
            contextual_dependencies = null;
            if (parent && parent.type === "Property")
              parent.method = false;
          }
          if (node3.type === "AssignmentExpression" || node3.type === "UpdateExpression") {
            const assignee = node3.type === "AssignmentExpression" ? node3.left : node3.argument;
            const object_name = get_object(assignee).name;
            if (scope2.has(object_name))
              return;
            const names = new Set(extract_names(assignee));
            const traced = /* @__PURE__ */ new Set();
            names.forEach((name) => {
              const dependencies2 = template_scope.dependencies_for_name.get(name);
              if (dependencies2)
                dependencies2.forEach((name2) => traced.add(name2));
              else
                traced.add(name);
            });
            const context = block.bindings.get(object_name);
            if (context) {
              const { snippet, object, property } = context;
              const replaced = replace_object(assignee, snippet);
              if (node3.type === "AssignmentExpression")
                node3.left = replaced;
              else
                node3.argument = replaced;
              contextual_dependencies.add(object.name);
              contextual_dependencies.add(property.name);
            }
            this.replace(invalidate(block.renderer, scope2, node3, traced));
          }
        }
      });
      if (declarations.length > 0) {
        block.maintain_context = true;
        declarations.forEach((declaration) => {
          block.chunks.init.push(declaration);
        });
      }
      return this.manipulated = node2;
    }
  }
  function get_function_name(_node, parent) {
    if (parent.type === "EventHandler")
      return `${parent.name}_handler`;
    if (parent.type === "Action")
      return `${parent.name}_function`;
    return "func";
  }
  function unpack_destructuring({ contexts, node: node2, modifier = (node3) => node3, default_modifier = (node3) => node3, scope: scope2, component, context_rest_properties }) {
    if (!node2)
      return;
    if (node2.type === "Identifier")
      contexts.push({
        key: node2,
        modifier,
        default_modifier
      });
    else if (node2.type === "RestElement") {
      contexts.push({
        key: node2.argument,
        modifier,
        default_modifier
      });
      context_rest_properties.set(node2.argument.name, node2);
    } else if (node2.type === "ArrayPattern")
      node2.elements.forEach((element, i2) => {
        if (element && element.type === "RestElement") {
          unpack_destructuring({
            contexts,
            node: element,
            modifier: (node3) => x`${modifier(node3)}.slice(${i2})`,
            default_modifier,
            scope: scope2,
            component,
            context_rest_properties
          });
          context_rest_properties.set(element.argument.name, element);
        } else if (element && element.type === "AssignmentPattern") {
          const n2 = contexts.length;
          mark_referenced(element.right, scope2, component);
          unpack_destructuring({
            contexts,
            node: element.left,
            modifier: (node3) => x`${modifier(node3)}[${i2}]`,
            default_modifier: (node3, to_ctx) => x`${node3} !== undefined ? ${node3} : ${update_reference(contexts, n2, element.right, to_ctx)}`,
            scope: scope2,
            component,
            context_rest_properties
          });
        } else
          unpack_destructuring({
            contexts,
            node: element,
            modifier: (node3) => x`${modifier(node3)}[${i2}]`,
            default_modifier,
            scope: scope2,
            component,
            context_rest_properties
          });
      });
    else if (node2.type === "ObjectPattern") {
      const used_properties = [];
      node2.properties.forEach((property) => {
        if (property.type === "RestElement") {
          unpack_destructuring({
            contexts,
            node: property.argument,
            modifier: (node3) => x`@object_without_properties(${modifier(node3)}, [${used_properties}])`,
            default_modifier,
            scope: scope2,
            component,
            context_rest_properties
          });
          context_rest_properties.set(property.argument.name, property);
        } else {
          const key = property.key;
          const value2 = property.value;
          used_properties.push(x`"${key.name}"`);
          if (value2.type === "AssignmentPattern") {
            const n2 = contexts.length;
            mark_referenced(value2.right, scope2, component);
            unpack_destructuring({
              contexts,
              node: value2.left,
              modifier: (node3) => x`${modifier(node3)}.${key.name}`,
              default_modifier: (node3, to_ctx) => x`${node3} !== undefined ? ${node3} : ${update_reference(contexts, n2, value2.right, to_ctx)}`,
              scope: scope2,
              component,
              context_rest_properties
            });
          } else
            unpack_destructuring({
              contexts,
              node: value2,
              modifier: (node3) => x`${modifier(node3)}.${key.name}`,
              default_modifier,
              scope: scope2,
              component,
              context_rest_properties
            });
        }
      });
    }
  }
  function update_reference(contexts, n2, expression, to_ctx) {
    const find_from_context = (node2) => {
      for (let i2 = n2; i2 < contexts.length; i2++) {
        const { key } = contexts[i2];
        if (node2.name === key.name)
          throw new Error(`Cannot access '${node2.name}' before initialization`);
      }
      return to_ctx(node2.name);
    };
    if (expression.type === "Identifier")
      return find_from_context(expression);
    expression = clone(expression);
    walk(expression, {
      enter(node2, parent) {
        if (is_reference(node2, parent)) {
          this.replace(find_from_context(node2));
          this.skip();
        }
      }
    });
    return expression;
  }
  function mark_referenced(node2, scope2, component) {
    walk(node2, {
      enter(node3, parent) {
        if (is_reference(node3, parent)) {
          const { name } = flatten_reference(node3);
          if (!scope2.is_let(name) && !scope2.names.has(name))
            component.add_reference(node3, name);
        }
      }
    });
  }
  const allowed_parents = /* @__PURE__ */ new Set([
    "EachBlock",
    "CatchBlock",
    "ThenBlock",
    "InlineComponent",
    "SlotTemplate",
    "IfBlock",
    "ElseBlock"
  ]);
  class ConstTag extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.contexts = [];
      this.context_rest_properties = /* @__PURE__ */ new Map();
      this.assignees = /* @__PURE__ */ new Set();
      this.dependencies = /* @__PURE__ */ new Set();
      if (!allowed_parents.has(parent.type))
        component.error(info, compiler_errors.invalid_const_placement);
      this.node = info;
      this.scope = scope2;
      const { assignees, dependencies } = this;
      extract_identifiers(info.expression.left).forEach(({ name }) => {
        assignees.add(name);
        const owner = this.scope.get_owner(name);
        if (owner === parent)
          component.error(info, compiler_errors.invalid_const_declaration(name));
      });
      walk(info.expression.right, {
        enter(node2, parent2) {
          if (is_reference(node2, parent2)) {
            const identifier = get_object(node2);
            const { name } = identifier;
            dependencies.add(name);
          }
        }
      });
    }
    parse_expression() {
      unpack_destructuring({
        contexts: this.contexts,
        node: this.node.expression.left,
        scope: this.scope,
        component: this.component,
        context_rest_properties: this.context_rest_properties
      });
      this.expression = new Expression(this.component, this, this.scope, this.node.expression.right);
      this.contexts.forEach((context) => {
        const owner = this.scope.get_owner(context.key.name);
        if (owner && owner.type === "ConstTag" && owner.parent === this.parent)
          this.component.error(this.node, compiler_errors.invalid_const_declaration(context.key.name));
        this.scope.add(context.key.name, this.expression.dependencies, this);
      });
    }
  }
  class PendingBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.children = map_children(component, parent, scope2, info.children);
      if (!info.skip)
        this.warn_if_empty_block();
    }
  }
  class CatchBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.scope = scope2.child();
      if (parent.catch_node)
        parent.catch_contexts.forEach((context) => {
          this.scope.add(context.key.name, parent.expression.dependencies, this);
        });
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
      if (!info.skip)
        this.warn_if_empty_block();
    }
  }
  class AwaitBlock extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.context_rest_properties = /* @__PURE__ */ new Map();
      this.expression = new Expression(component, this, scope2, info.expression);
      this.then_node = info.value;
      this.catch_node = info.error;
      if (this.then_node) {
        this.then_contexts = [];
        unpack_destructuring({
          contexts: this.then_contexts,
          node: info.value,
          scope: scope2,
          component,
          context_rest_properties: this.context_rest_properties
        });
      }
      if (this.catch_node) {
        this.catch_contexts = [];
        unpack_destructuring({
          contexts: this.catch_contexts,
          node: info.error,
          scope: scope2,
          component,
          context_rest_properties: this.context_rest_properties
        });
      }
      this.pending = new PendingBlock(component, this, scope2, info.pending);
      this.then = new ThenBlock(component, this, scope2, info.then);
      this.catch = new CatchBlock(component, this, scope2, info.catch);
    }
  }
  const regex_contains_term_function_expression$1 = /FunctionExpression/;
  class EventHandler extends Node$1 {
    constructor(component, parent, template_scope, info) {
      super(component, parent, template_scope, info);
      this.uses_context = false;
      this.can_make_passive = false;
      this.name = info.name;
      this.modifiers = new Set(info.modifiers);
      if (info.expression) {
        this.expression = new Expression(component, this, template_scope, info.expression);
        this.uses_context = this.expression.uses_context;
        if (regex_contains_term_function_expression$1.test(info.expression.type) && info.expression.params.length === 0)
          this.can_make_passive = true;
        else if (info.expression.type === "Identifier") {
          let node2 = component.node_for_declaration.get(info.expression.name);
          if (node2) {
            if (node2.type === "VariableDeclaration") {
              const declarator = node2.declarations.find((d) => d.id.name === info.expression.name);
              node2 = declarator && declarator.init;
            }
            if (node2 && (node2.type === "FunctionExpression" || node2.type === "FunctionDeclaration" || node2.type === "ArrowFunctionExpression") && node2.params.length === 0)
              this.can_make_passive = true;
          }
        }
      } else
        this.handler_name = component.get_unique_name(`${sanitize(this.name)}_handler`);
    }
    get reassigned() {
      if (!this.expression)
        return false;
      const node2 = this.expression.node;
      if (regex_contains_term_function_expression$1.test(node2.type))
        return false;
      return this.expression.dynamic_dependencies().length > 0;
    }
  }
  class Action extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      const object = info.name.split(".")[0];
      component.warn_if_undefined(object, info, scope2);
      this.name = info.name;
      component.add_reference(this, object);
      this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
      this.template_scope = scope2;
      this.uses_context = this.expression && this.expression.uses_context;
    }
  }
  class Body extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.handlers = [];
      this.actions = [];
      info.attributes.forEach((node2) => {
        if (node2.type === "EventHandler")
          this.handlers.push(new EventHandler(component, this, scope2, node2));
        else if (node2.type === "Action")
          this.actions.push(new Action(component, this, scope2, node2));
      });
    }
  }
  class Comment$1 extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.data = info.data;
      this.ignores = info.ignores;
    }
  }
  class ElseBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.scope = scope2.child();
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
      this.warn_if_empty_block();
    }
  }
  class EachBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.has_binding = false;
      this.has_index_binding = false;
      this.expression = new Expression(component, this, scope2, info.expression);
      this.context = info.context.name || "each";
      this.context_node = info.context;
      this.index = info.index;
      this.scope = scope2.child();
      this.context_rest_properties = /* @__PURE__ */ new Map();
      this.contexts = [];
      unpack_destructuring({
        contexts: this.contexts,
        node: info.context,
        scope: scope2,
        component,
        context_rest_properties: this.context_rest_properties
      });
      this.contexts.forEach((context) => {
        this.scope.add(context.key.name, this.expression.dependencies, this);
      });
      if (this.index) {
        const dependencies = info.key ? this.expression.dependencies : /* @__PURE__ */ new Set([]);
        this.scope.add(this.index, dependencies, this);
      }
      this.key = info.key ? new Expression(component, this, this.scope, info.key) : null;
      this.has_animation = false;
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
      if (this.has_animation) {
        this.children = this.children.filter((child) => !isEmptyNode(child) && !isCommentNode(child));
        if (this.children.length !== 1) {
          const child = this.children.find((child2) => !!child2.animation);
          component.error(child.animation, compiler_errors.invalid_animation_sole);
          return;
        }
      }
      this.warn_if_empty_block();
      this.else = info.else ? new ElseBlock(component, this, this.scope, info.else) : null;
    }
  }
  function isEmptyNode(node2) {
    return node2.type === "Text" && node2.data.trim() === "";
  }
  function isCommentNode(node2) {
    return node2.type === "Comment";
  }
  function string_literal(data2) {
    return {
      type: "Literal",
      value: data2
    };
  }
  const escaped = {
    '"': "&quot;",
    "'": "&#39;",
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;"
  };
  const regex_html_characters_to_escape = /["'&<>]/g;
  function escape_html(html2) {
    return String(html2).replace(regex_html_characters_to_escape, (match) => escaped[match]);
  }
  const regex_template_characters_to_escape = /(\${|`|\\)/g;
  function escape_template(str) {
    return str.replace(regex_template_characters_to_escape, "\\$1");
  }
  function add_to_set(a, b2) {
    b2.forEach((item) => {
      a.add(item);
    });
  }
  class Attribute extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.scope = scope2;
      if (info.type === "Spread") {
        this.name = null;
        this.is_spread = true;
        this.is_true = false;
        this.expression = new Expression(component, this, scope2, info.expression);
        this.dependencies = this.expression.dependencies;
        this.chunks = null;
        this.is_static = false;
      } else {
        this.name = info.name;
        this.is_true = info.value === true;
        this.is_static = true;
        this.dependencies = /* @__PURE__ */ new Set();
        this.chunks = this.is_true ? [] : info.value.map((node2) => {
          if (node2.type === "Text")
            return node2;
          this.is_static = false;
          const expression = new Expression(component, this, scope2, node2.expression);
          add_to_set(this.dependencies, expression.dependencies);
          return expression;
        });
      }
    }
    get_dependencies() {
      if (this.is_spread)
        return this.expression.dynamic_dependencies();
      const dependencies = /* @__PURE__ */ new Set();
      this.chunks.forEach((chunk) => {
        if (chunk.type === "Expression")
          add_to_set(dependencies, chunk.dynamic_dependencies());
      });
      return Array.from(dependencies);
    }
    get_value(block) {
      if (this.is_true)
        return x`true`;
      if (this.chunks.length === 0)
        return x`""`;
      if (this.chunks.length === 1)
        return this.chunks[0].type === "Text" ? string_literal(this.chunks[0].data) : this.chunks[0].manipulate(block);
      let expression = this.chunks.map((chunk) => chunk.type === "Text" ? string_literal(chunk.data) : chunk.manipulate(block)).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
      if (this.chunks[0].type !== "Text")
        expression = x`"" + ${expression}`;
      return expression;
    }
    get_static_value() {
      if (!this.is_static)
        return null;
      return this.is_true ? true : this.chunks[0] ? this.chunks[0].data : "";
    }
    should_cache() {
      return this.is_static ? false : this.chunks.length === 1 ? this.chunks[0].node.type !== "Identifier" || this.scope.names.has(this.chunks[0].node.name) : true;
    }
  }
  const read_only_media_attributes = /* @__PURE__ */ new Set([
    "duration",
    "buffered",
    "seekable",
    "played",
    "seeking",
    "ended",
    "videoHeight",
    "videoWidth"
  ]);
  class Binding extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      if (info.expression.type !== "Identifier" && info.expression.type !== "MemberExpression") {
        component.error(info, compiler_errors.invalid_directive_value);
        return;
      }
      this.name = info.name;
      this.expression = new Expression(component, this, scope2, info.expression);
      this.raw_expression = clone(info.expression);
      const { name } = get_object(this.expression.node);
      this.is_contextual = Array.from(this.expression.references).some((name2) => scope2.names.has(name2));
      if (this.is_contextual)
        this.validate_binding_rest_properties(scope2);
      if (scope2.is_let(name)) {
        component.error(this, compiler_errors.invalid_binding_let);
        return;
      } else if (scope2.names.has(name)) {
        if (scope2.is_await(name)) {
          component.error(this, compiler_errors.invalid_binding_await);
          return;
        }
        if (scope2.is_const(name))
          component.error(this, compiler_errors.invalid_binding_const);
        scope2.dependencies_for_name.get(name).forEach((name2) => {
          const variable = component.var_lookup.get(name2);
          if (variable)
            variable.mutated = true;
        });
      } else {
        const variable = component.var_lookup.get(name);
        if (!variable || variable.global) {
          component.error(this.expression.node, compiler_errors.binding_undeclared(name));
          return;
        }
        variable[this.expression.node.type === "MemberExpression" ? "mutated" : "reassigned"] = true;
        if (info.expression.type === "Identifier" && !variable.writable) {
          component.error(this.expression.node, compiler_errors.invalid_binding_writibale);
          return;
        }
      }
      const type = parent.get_static_attribute_value("type");
      this.is_readonly = regex_dimensions.test(this.name) || isElement(parent) && (parent.is_media_node() && read_only_media_attributes.has(this.name) || parent.name === "input" && type === "file");
    }
    is_readonly_media_attribute() {
      return read_only_media_attributes.has(this.name);
    }
    validate_binding_rest_properties(scope2) {
      this.expression.references.forEach((name) => {
        const each_block = scope2.get_owner(name);
        if (each_block && each_block.type === "EachBlock") {
          const rest_node = each_block.context_rest_properties.get(name);
          if (rest_node)
            this.component.warn(rest_node, compiler_warnings.invalid_rest_eachblock_binding(name));
        }
      });
    }
  }
  function isElement(node2) {
    return !!node2.is_media_node;
  }
  class Transition extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      component.warn_if_undefined(info.name, info, scope2);
      this.name = info.name;
      component.add_reference(this, info.name.split(".")[0]);
      this.directive = info.intro && info.outro ? "transition" : info.intro ? "in" : "out";
      this.is_local = info.modifiers.includes("local");
      if (info.intro && parent.intro || info.outro && parent.outro) {
        const parent_transition = parent.intro || parent.outro;
        component.error(info, compiler_errors.duplicate_transition(this.directive, parent_transition.directive));
        return;
      }
      this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
    }
  }
  class Animation extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      component.warn_if_undefined(info.name, info, scope2);
      this.name = info.name;
      component.add_reference(this, info.name.split(".")[0]);
      if (parent.animation) {
        component.error(this, compiler_errors.duplicate_animation);
        return;
      }
      const block = parent.parent;
      if (!block || block.type !== "EachBlock") {
        component.error(this, compiler_errors.invalid_animation_immediate);
        return;
      }
      if (!block.key) {
        component.error(this, compiler_errors.invalid_animation_key);
        return;
      }
      block.has_animation = true;
      this.expression = info.expression ? new Expression(component, this, scope2, info.expression, true) : null;
    }
  }
  class Class extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.name = info.name;
      this.expression = info.expression ? new Expression(component, this, scope2, info.expression) : null;
    }
  }
  function nodes_to_template_literal(value2) {
    const literal2 = {
      type: "TemplateLiteral",
      expressions: [],
      quasis: []
    };
    let quasi = {
      type: "TemplateElement",
      value: {
        raw: "",
        cooked: null
      },
      tail: false
    };
    value2.forEach((node2) => {
      if (node2.type === "Text")
        quasi.value.raw += node2.raw;
      else if (node2.type === "MustacheTag") {
        literal2.quasis.push(quasi);
        literal2.expressions.push(node2.expression);
        quasi = {
          type: "TemplateElement",
          value: {
            raw: "",
            cooked: null
          },
          tail: false
        };
      }
    });
    quasi.tail = true;
    literal2.quasis.push(quasi);
    return literal2;
  }
  const valid_modifiers = /* @__PURE__ */ new Set([
    "important"
  ]);
  class StyleDirective extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.name = info.name;
      this.modifiers = new Set(info.modifiers);
      for (const modifier of this.modifiers)
        if (!valid_modifiers.has(modifier))
          component.error(this, compiler_errors.invalid_style_directive_modifier(list$1([
            ...valid_modifiers
          ])));
      if (info.value === true || info.value.length === 1 && info.value[0].type === "MustacheTag") {
        const identifier = info.value === true ? {
          type: "Identifier",
          start: info.end - info.name.length,
          end: info.end,
          name: info.name
        } : info.value[0].expression;
        this.expression = new Expression(component, this, scope2, identifier);
        this.should_cache = false;
      } else {
        const raw_expression = nodes_to_template_literal(info.value);
        this.expression = new Expression(component, this, scope2, raw_expression);
        this.should_cache = raw_expression.expressions.length > 0;
      }
    }
    get important() {
      return this.modifiers.has("important");
    }
  }
  const elements_without_text = /* @__PURE__ */ new Set([
    "audio",
    "datalist",
    "dl",
    "optgroup",
    "select",
    "video"
  ]);
  const regex_ends_with_svg = /svg$/;
  class Text extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.data = info.data;
      this.synthetic = info.synthetic || false;
    }
    should_skip() {
      if (regex_non_whitespace_character.test(this.data))
        return false;
      const parent_element = this.find_nearest(/(?:Element|InlineComponent|SlotTemplate|Head)/);
      if (!parent_element)
        return false;
      if (parent_element.type === "Head")
        return true;
      if (parent_element.type === "InlineComponent")
        return parent_element.children.length === 1 && this === parent_element.children[0];
      if (regex_ends_with_svg.test(parent_element.namespace)) {
        if (this.prev && this.prev.type === "Element" && this.prev.name === "tspan")
          return false;
      }
      return parent_element.namespace || elements_without_text.has(parent_element.name);
    }
    keep_space() {
      if (this.component.component_options.preserveWhitespace)
        return true;
      return this.within_pre();
    }
    within_pre() {
      let node2 = this.parent;
      while (node2) {
        if (node2.type === "Element" && node2.name === "pre")
          return true;
        node2 = node2.parent;
      }
      return false;
    }
  }
  const foreign = "https://svelte.dev/docs#template-syntax-svelte-options";
  const html = "http://www.w3.org/1999/xhtml";
  const mathml = "http://www.w3.org/1998/Math/MathML";
  const svg$1 = "http://www.w3.org/2000/svg";
  const xlink = "http://www.w3.org/1999/xlink";
  const xml = "http://www.w3.org/XML/1998/namespace";
  const xmlns = "http://www.w3.org/2000/xmlns";
  const valid_namespaces = [
    "foreign",
    "html",
    "mathml",
    "svg",
    "xlink",
    "xml",
    "xmlns",
    foreign,
    html,
    mathml,
    svg$1,
    xlink,
    xml,
    xmlns
  ];
  const namespaces = {
    foreign,
    html,
    mathml,
    svg: svg$1,
    xlink,
    xml,
    xmlns
  };
  const applicable = /* @__PURE__ */ new Set([
    "Identifier",
    "ObjectExpression",
    "ArrayExpression",
    "Property"
  ]);
  class Let extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.names = [];
      this.name = {
        type: "Identifier",
        name: info.name
      };
      const { names } = this;
      if (info.expression) {
        this.value = info.expression;
        walk(info.expression, {
          enter(node2) {
            if (!applicable.has(node2.type))
              return component.error(node2, compiler_errors.invalid_let);
            if (node2.type === "Identifier")
              names.push(node2.name);
            if (node2.type === "ArrayExpression")
              node2.type = "ArrayPattern";
            if (node2.type === "ObjectExpression")
              node2.type = "ObjectPattern";
          }
        });
      } else
        names.push(this.name.name);
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof $parcel$global !== "undefined" ? $parcel$global : typeof self !== "undefined" ? self : {};
  function unwrapExports(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  function getCjsExportFromNamespace(n2) {
    return n2 && n2["default"] || n2;
  }
  var iteratorProxy_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next() {
          if (index < values.length) {
            var value2 = values[index];
            index = index + 1;
            return {
              done: false,
              value: value2
            };
          } else
            return {
              done: true
            };
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports12.default = _default;
  });
  unwrapExports(iteratorProxy_1);
  var iterationDecorator_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(iteratorProxy_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol")
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      return collection;
    }
  });
  unwrapExports(iterationDecorator_1);
  var ariaPropsMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var properties2 = [
      [
        "aria-activedescendant",
        {
          "type": "id"
        }
      ],
      [
        "aria-atomic",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-autocomplete",
        {
          "type": "token",
          "values": [
            "inline",
            "list",
            "both",
            "none"
          ]
        }
      ],
      [
        "aria-busy",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-checked",
        {
          "type": "tristate"
        }
      ],
      [
        "aria-colcount",
        {
          type: "integer"
        }
      ],
      [
        "aria-colindex",
        {
          type: "integer"
        }
      ],
      [
        "aria-colspan",
        {
          type: "integer"
        }
      ],
      [
        "aria-controls",
        {
          "type": "idlist"
        }
      ],
      [
        "aria-current",
        {
          type: "token",
          values: [
            "page",
            "step",
            "location",
            "date",
            "time",
            true,
            false
          ]
        }
      ],
      [
        "aria-describedby",
        {
          "type": "idlist"
        }
      ],
      [
        "aria-details",
        {
          "type": "id"
        }
      ],
      [
        "aria-disabled",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-dropeffect",
        {
          "type": "tokenlist",
          "values": [
            "copy",
            "execute",
            "link",
            "move",
            "none",
            "popup"
          ]
        }
      ],
      [
        "aria-errormessage",
        {
          "type": "id"
        }
      ],
      [
        "aria-expanded",
        {
          "type": "boolean",
          "allowundefined": true
        }
      ],
      [
        "aria-flowto",
        {
          "type": "idlist"
        }
      ],
      [
        "aria-grabbed",
        {
          "type": "boolean",
          "allowundefined": true
        }
      ],
      [
        "aria-haspopup",
        {
          "type": "token",
          "values": [
            false,
            true,
            "menu",
            "listbox",
            "tree",
            "grid",
            "dialog"
          ]
        }
      ],
      [
        "aria-hidden",
        {
          "type": "boolean",
          "allowundefined": true
        }
      ],
      [
        "aria-invalid",
        {
          "type": "token",
          "values": [
            "grammar",
            false,
            "spelling",
            true
          ]
        }
      ],
      [
        "aria-keyshortcuts",
        {
          type: "string"
        }
      ],
      [
        "aria-label",
        {
          "type": "string"
        }
      ],
      [
        "aria-labelledby",
        {
          "type": "idlist"
        }
      ],
      [
        "aria-level",
        {
          "type": "integer"
        }
      ],
      [
        "aria-live",
        {
          "type": "token",
          "values": [
            "assertive",
            "off",
            "polite"
          ]
        }
      ],
      [
        "aria-modal",
        {
          type: "boolean"
        }
      ],
      [
        "aria-multiline",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-multiselectable",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-orientation",
        {
          "type": "token",
          "values": [
            "vertical",
            "undefined",
            "horizontal"
          ]
        }
      ],
      [
        "aria-owns",
        {
          "type": "idlist"
        }
      ],
      [
        "aria-placeholder",
        {
          type: "string"
        }
      ],
      [
        "aria-posinset",
        {
          "type": "integer"
        }
      ],
      [
        "aria-pressed",
        {
          "type": "tristate"
        }
      ],
      [
        "aria-readonly",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-relevant",
        {
          "type": "tokenlist",
          "values": [
            "additions",
            "all",
            "removals",
            "text"
          ]
        }
      ],
      [
        "aria-required",
        {
          "type": "boolean"
        }
      ],
      [
        "aria-roledescription",
        {
          type: "string"
        }
      ],
      [
        "aria-rowcount",
        {
          type: "integer"
        }
      ],
      [
        "aria-rowindex",
        {
          type: "integer"
        }
      ],
      [
        "aria-rowspan",
        {
          type: "integer"
        }
      ],
      [
        "aria-selected",
        {
          "type": "boolean",
          "allowundefined": true
        }
      ],
      [
        "aria-setsize",
        {
          "type": "integer"
        }
      ],
      [
        "aria-sort",
        {
          "type": "token",
          "values": [
            "ascending",
            "descending",
            "none",
            "other"
          ]
        }
      ],
      [
        "aria-valuemax",
        {
          "type": "number"
        }
      ],
      [
        "aria-valuemin",
        {
          "type": "number"
        }
      ],
      [
        "aria-valuenow",
        {
          "type": "number"
        }
      ],
      [
        "aria-valuetext",
        {
          "type": "string"
        }
      ]
    ];
    var ariaPropsMap = {
      entries: function entries() {
        return properties2;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(properties2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, properties2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = properties2.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return properties2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return properties2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(ariaPropsMap, ariaPropsMap.entries());
    exports12.default = _default;
  });
  unwrapExports(ariaPropsMap_1);
  var domMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var dom2 = [
      [
        "a",
        {
          reserved: false
        }
      ],
      [
        "abbr",
        {
          reserved: false
        }
      ],
      [
        "acronym",
        {
          reserved: false
        }
      ],
      [
        "address",
        {
          reserved: false
        }
      ],
      [
        "applet",
        {
          reserved: false
        }
      ],
      [
        "area",
        {
          reserved: false
        }
      ],
      [
        "article",
        {
          reserved: false
        }
      ],
      [
        "aside",
        {
          reserved: false
        }
      ],
      [
        "audio",
        {
          reserved: false
        }
      ],
      [
        "b",
        {
          reserved: false
        }
      ],
      [
        "base",
        {
          reserved: true
        }
      ],
      [
        "bdi",
        {
          reserved: false
        }
      ],
      [
        "bdo",
        {
          reserved: false
        }
      ],
      [
        "big",
        {
          reserved: false
        }
      ],
      [
        "blink",
        {
          reserved: false
        }
      ],
      [
        "blockquote",
        {
          reserved: false
        }
      ],
      [
        "body",
        {
          reserved: false
        }
      ],
      [
        "br",
        {
          reserved: false
        }
      ],
      [
        "button",
        {
          reserved: false
        }
      ],
      [
        "canvas",
        {
          reserved: false
        }
      ],
      [
        "caption",
        {
          reserved: false
        }
      ],
      [
        "center",
        {
          reserved: false
        }
      ],
      [
        "cite",
        {
          reserved: false
        }
      ],
      [
        "code",
        {
          reserved: false
        }
      ],
      [
        "col",
        {
          reserved: true
        }
      ],
      [
        "colgroup",
        {
          reserved: true
        }
      ],
      [
        "content",
        {
          reserved: false
        }
      ],
      [
        "data",
        {
          reserved: false
        }
      ],
      [
        "datalist",
        {
          reserved: false
        }
      ],
      [
        "dd",
        {
          reserved: false
        }
      ],
      [
        "del",
        {
          reserved: false
        }
      ],
      [
        "details",
        {
          reserved: false
        }
      ],
      [
        "dfn",
        {
          reserved: false
        }
      ],
      [
        "dialog",
        {
          reserved: false
        }
      ],
      [
        "dir",
        {
          reserved: false
        }
      ],
      [
        "div",
        {
          reserved: false
        }
      ],
      [
        "dl",
        {
          reserved: false
        }
      ],
      [
        "dt",
        {
          reserved: false
        }
      ],
      [
        "em",
        {
          reserved: false
        }
      ],
      [
        "embed",
        {
          reserved: false
        }
      ],
      [
        "fieldset",
        {
          reserved: false
        }
      ],
      [
        "figcaption",
        {
          reserved: false
        }
      ],
      [
        "figure",
        {
          reserved: false
        }
      ],
      [
        "font",
        {
          reserved: false
        }
      ],
      [
        "footer",
        {
          reserved: false
        }
      ],
      [
        "form",
        {
          reserved: false
        }
      ],
      [
        "frame",
        {
          reserved: false
        }
      ],
      [
        "frameset",
        {
          reserved: false
        }
      ],
      [
        "h1",
        {
          reserved: false
        }
      ],
      [
        "h2",
        {
          reserved: false
        }
      ],
      [
        "h3",
        {
          reserved: false
        }
      ],
      [
        "h4",
        {
          reserved: false
        }
      ],
      [
        "h5",
        {
          reserved: false
        }
      ],
      [
        "h6",
        {
          reserved: false
        }
      ],
      [
        "head",
        {
          reserved: true
        }
      ],
      [
        "header",
        {
          reserved: false
        }
      ],
      [
        "hgroup",
        {
          reserved: false
        }
      ],
      [
        "hr",
        {
          reserved: false
        }
      ],
      [
        "html",
        {
          reserved: true
        }
      ],
      [
        "i",
        {
          reserved: false
        }
      ],
      [
        "iframe",
        {
          reserved: false
        }
      ],
      [
        "img",
        {
          reserved: false
        }
      ],
      [
        "input",
        {
          reserved: false
        }
      ],
      [
        "ins",
        {
          reserved: false
        }
      ],
      [
        "kbd",
        {
          reserved: false
        }
      ],
      [
        "keygen",
        {
          reserved: false
        }
      ],
      [
        "label",
        {
          reserved: false
        }
      ],
      [
        "legend",
        {
          reserved: false
        }
      ],
      [
        "li",
        {
          reserved: false
        }
      ],
      [
        "link",
        {
          reserved: true
        }
      ],
      [
        "main",
        {
          reserved: false
        }
      ],
      [
        "map",
        {
          reserved: false
        }
      ],
      [
        "mark",
        {
          reserved: false
        }
      ],
      [
        "marquee",
        {
          reserved: false
        }
      ],
      [
        "menu",
        {
          reserved: false
        }
      ],
      [
        "menuitem",
        {
          reserved: false
        }
      ],
      [
        "meta",
        {
          reserved: true
        }
      ],
      [
        "meter",
        {
          reserved: false
        }
      ],
      [
        "nav",
        {
          reserved: false
        }
      ],
      [
        "noembed",
        {
          reserved: true
        }
      ],
      [
        "noscript",
        {
          reserved: true
        }
      ],
      [
        "object",
        {
          reserved: false
        }
      ],
      [
        "ol",
        {
          reserved: false
        }
      ],
      [
        "optgroup",
        {
          reserved: false
        }
      ],
      [
        "option",
        {
          reserved: false
        }
      ],
      [
        "output",
        {
          reserved: false
        }
      ],
      [
        "p",
        {
          reserved: false
        }
      ],
      [
        "param",
        {
          reserved: true
        }
      ],
      [
        "picture",
        {
          reserved: true
        }
      ],
      [
        "pre",
        {
          reserved: false
        }
      ],
      [
        "progress",
        {
          reserved: false
        }
      ],
      [
        "q",
        {
          reserved: false
        }
      ],
      [
        "rp",
        {
          reserved: false
        }
      ],
      [
        "rt",
        {
          reserved: false
        }
      ],
      [
        "rtc",
        {
          reserved: false
        }
      ],
      [
        "ruby",
        {
          reserved: false
        }
      ],
      [
        "s",
        {
          reserved: false
        }
      ],
      [
        "samp",
        {
          reserved: false
        }
      ],
      [
        "script",
        {
          reserved: true
        }
      ],
      [
        "section",
        {
          reserved: false
        }
      ],
      [
        "select",
        {
          reserved: false
        }
      ],
      [
        "small",
        {
          reserved: false
        }
      ],
      [
        "source",
        {
          reserved: true
        }
      ],
      [
        "spacer",
        {
          reserved: false
        }
      ],
      [
        "span",
        {
          reserved: false
        }
      ],
      [
        "strike",
        {
          reserved: false
        }
      ],
      [
        "strong",
        {
          reserved: false
        }
      ],
      [
        "style",
        {
          reserved: true
        }
      ],
      [
        "sub",
        {
          reserved: false
        }
      ],
      [
        "summary",
        {
          reserved: false
        }
      ],
      [
        "sup",
        {
          reserved: false
        }
      ],
      [
        "table",
        {
          reserved: false
        }
      ],
      [
        "tbody",
        {
          reserved: false
        }
      ],
      [
        "td",
        {
          reserved: false
        }
      ],
      [
        "textarea",
        {
          reserved: false
        }
      ],
      [
        "tfoot",
        {
          reserved: false
        }
      ],
      [
        "th",
        {
          reserved: false
        }
      ],
      [
        "thead",
        {
          reserved: false
        }
      ],
      [
        "time",
        {
          reserved: false
        }
      ],
      [
        "title",
        {
          reserved: true
        }
      ],
      [
        "tr",
        {
          reserved: false
        }
      ],
      [
        "track",
        {
          reserved: true
        }
      ],
      [
        "tt",
        {
          reserved: false
        }
      ],
      [
        "u",
        {
          reserved: false
        }
      ],
      [
        "ul",
        {
          reserved: false
        }
      ],
      [
        "var",
        {
          reserved: false
        }
      ],
      [
        "video",
        {
          reserved: false
        }
      ],
      [
        "wbr",
        {
          reserved: false
        }
      ],
      [
        "xmp",
        {
          reserved: false
        }
      ]
    ];
    var domMap = {
      entries: function entries() {
        return dom2;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(dom2), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, dom2);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = dom2.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return dom2.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return dom2.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(domMap, domMap.entries());
    exports12.default = _default;
  });
  unwrapExports(domMap_1);
  var commandRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var commandRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "menuitem"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = commandRole;
    exports12.default = _default;
  });
  unwrapExports(commandRole_1);
  var compositeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var compositeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = compositeRole;
    exports12.default = _default;
  });
  unwrapExports(compositeRole_1);
  var inputRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var inputRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "input"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = inputRole;
    exports12.default = _default;
  });
  unwrapExports(inputRole_1);
  var landmarkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var landmarkRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = landmarkRole;
    exports12.default = _default;
  });
  unwrapExports(landmarkRole_1);
  var rangeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var rangeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-valuemax": null,
        "aria-valuemin": null,
        "aria-valuenow": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = rangeRole;
    exports12.default = _default;
  });
  unwrapExports(rangeRole_1);
  var roletypeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var roletypeRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {
        "aria-atomic": null,
        "aria-busy": null,
        "aria-controls": null,
        "aria-current": null,
        "aria-describedby": null,
        "aria-details": null,
        "aria-dropeffect": null,
        "aria-flowto": null,
        "aria-grabbed": null,
        "aria-hidden": null,
        "aria-keyshortcuts": null,
        "aria-label": null,
        "aria-labelledby": null,
        "aria-live": null,
        "aria-owns": null,
        "aria-relevant": null,
        "aria-roledescription": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "rel"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "role"
          },
          module: "XHTML"
        },
        {
          concept: {
            name: "type"
          },
          module: "Dublin Core"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = roletypeRole;
    exports12.default = _default;
  });
  unwrapExports(roletypeRole_1);
  var sectionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var sectionRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "frontmatter"
          },
          module: "DTB"
        },
        {
          concept: {
            name: "level"
          },
          module: "DTB"
        },
        {
          concept: {
            name: "level"
          },
          module: "SMIL"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = sectionRole;
    exports12.default = _default;
  });
  unwrapExports(sectionRole_1);
  var sectionheadRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var sectionheadRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = sectionheadRole;
    exports12.default = _default;
  });
  unwrapExports(sectionheadRole_1);
  var selectRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var selectRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-orientation": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group"
        ]
      ]
    };
    var _default = selectRole;
    exports12.default = _default;
  });
  unwrapExports(selectRole_1);
  var structureRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var structureRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype"
        ]
      ]
    };
    var _default = structureRole;
    exports12.default = _default;
  });
  unwrapExports(structureRole_1);
  var widgetRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var widgetRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype"
        ]
      ]
    };
    var _default = widgetRole;
    exports12.default = _default;
  });
  unwrapExports(widgetRole_1);
  var windowRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var windowRole = {
      abstract: true,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-modal": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype"
        ]
      ]
    };
    var _default = windowRole;
    exports12.default = _default;
  });
  unwrapExports(windowRole_1);
  var ariaAbstractRoles_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _commandRole = _interopRequireDefault(commandRole_1);
    var _compositeRole = _interopRequireDefault(compositeRole_1);
    var _inputRole = _interopRequireDefault(inputRole_1);
    var _landmarkRole = _interopRequireDefault(landmarkRole_1);
    var _rangeRole = _interopRequireDefault(rangeRole_1);
    var _roletypeRole = _interopRequireDefault(roletypeRole_1);
    var _sectionRole = _interopRequireDefault(sectionRole_1);
    var _sectionheadRole = _interopRequireDefault(sectionheadRole_1);
    var _selectRole = _interopRequireDefault(selectRole_1);
    var _structureRole = _interopRequireDefault(structureRole_1);
    var _widgetRole = _interopRequireDefault(widgetRole_1);
    var _windowRole = _interopRequireDefault(windowRole_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ariaAbstractRoles = [
      [
        "command",
        _commandRole.default
      ],
      [
        "composite",
        _compositeRole.default
      ],
      [
        "input",
        _inputRole.default
      ],
      [
        "landmark",
        _landmarkRole.default
      ],
      [
        "range",
        _rangeRole.default
      ],
      [
        "roletype",
        _roletypeRole.default
      ],
      [
        "section",
        _sectionRole.default
      ],
      [
        "sectionhead",
        _sectionheadRole.default
      ],
      [
        "select",
        _selectRole.default
      ],
      [
        "structure",
        _structureRole.default
      ],
      [
        "widget",
        _widgetRole.default
      ],
      [
        "window",
        _windowRole.default
      ]
    ];
    var _default = ariaAbstractRoles;
    exports12.default = _default;
  });
  unwrapExports(ariaAbstractRoles_1);
  var alertRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var alertRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "assertive"
      },
      relatedConcepts: [
        {
          concept: {
            name: "alert"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = alertRole;
    exports12.default = _default;
  });
  unwrapExports(alertRole_1);
  var alertdialogRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var alertdialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "alert"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "alert"
        ],
        [
          "roletype",
          "window",
          "dialog"
        ]
      ]
    };
    var _default = alertdialogRole;
    exports12.default = _default;
  });
  unwrapExports(alertdialogRole_1);
  var applicationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var applicationRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "Device Independence Delivery Unit"
          }
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = applicationRole;
    exports12.default = _default;
  });
  unwrapExports(applicationRole_1);
  var articleRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var articleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "article"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "document"
        ]
      ]
    };
    var _default = articleRole;
    exports12.default = _default;
  });
  unwrapExports(articleRole_1);
  var bannerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var bannerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            constraints: [
              "direct descendant of document"
            ],
            name: "header"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = bannerRole;
    exports12.default = _default;
  });
  unwrapExports(bannerRole_1);
  var blockquoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var blockquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = blockquoteRole;
    exports12.default = _default;
  });
  unwrapExports(blockquoteRole_1);
  var buttonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var buttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-pressed": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "aria-pressed"
              },
              {
                name: "type",
                value: "checkbox"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "aria-expanded",
                value: "false"
              }
            ],
            name: "summary"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "aria-expanded",
                value: "true"
              }
            ],
            constraints: [
              "direct descendant of details element with the open attribute defined"
            ],
            name: "summary"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "button"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "image"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "reset"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "submit"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "button"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "trigger"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command"
        ]
      ]
    };
    var _default = buttonRole;
    exports12.default = _default;
  });
  unwrapExports(buttonRole_1);
  var captionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var captionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [
        "figure",
        "grid",
        "table"
      ],
      requiredContextRole: [
        "figure",
        "grid",
        "table"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = captionRole;
    exports12.default = _default;
  });
  unwrapExports(captionRole_1);
  var cellRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var cellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-colspan": null,
        "aria-rowindex": null,
        "aria-rowspan": null
      },
      relatedConcepts: [
        {
          concept: {
            constraints: [
              "descendant of table"
            ],
            name: "td"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "row"
      ],
      requiredContextRole: [
        "row"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = cellRole;
    exports12.default = _default;
  });
  unwrapExports(cellRole_1);
  var checkboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var checkboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "checkbox"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ]
      ]
    };
    var _default = checkboxRole;
    exports12.default = _default;
  });
  unwrapExports(checkboxRole_1);
  var codeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var codeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = codeRole;
    exports12.default = _default;
  });
  unwrapExports(codeRole_1);
  var columnheaderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var columnheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [
        {
          attributes: [
            {
              name: "scope",
              value: "col"
            }
          ],
          concept: {
            name: "th"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "row"
      ],
      requiredContextRole: [
        "row"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "cell"
        ],
        [
          "roletype",
          "structure",
          "section",
          "cell",
          "gridcell"
        ],
        [
          "roletype",
          "widget",
          "gridcell"
        ],
        [
          "roletype",
          "structure",
          "sectionhead"
        ]
      ]
    };
    var _default = columnheaderRole;
    exports12.default = _default;
  });
  unwrapExports(columnheaderRole_1);
  var comboboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var comboboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-expanded": "false",
        "aria-haspopup": "listbox"
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "email"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "search"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "tel"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "text"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "url"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "url"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "multiple"
              },
              {
                constraints: [
                  "undefined"
                ],
                name: "size"
              }
            ],
            name: "select"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "multiple"
              },
              {
                name: "size",
                value: 1
              }
            ],
            name: "select"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "select"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-expanded": "false"
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ]
      ]
    };
    var _default = comboboxRole;
    exports12.default = _default;
  });
  unwrapExports(comboboxRole_1);
  var complementaryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var complementaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "aside"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = complementaryRole;
    exports12.default = _default;
  });
  unwrapExports(complementaryRole_1);
  var contentinfoRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var contentinfoRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            constraints: [
              "direct descendant of document"
            ],
            name: "footer"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = contentinfoRole;
    exports12.default = _default;
  });
  unwrapExports(contentinfoRole_1);
  var definitionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var definitionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "dd"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = definitionRole;
    exports12.default = _default;
  });
  unwrapExports(definitionRole_1);
  var deletionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var deletionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = deletionRole;
    exports12.default = _default;
  });
  unwrapExports(deletionRole_1);
  var dialogRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var dialogRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "dialog"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "window"
        ]
      ]
    };
    var _default = dialogRole;
    exports12.default = _default;
  });
  unwrapExports(dialogRole_1);
  var directoryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var directoryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          module: "DAISY Guide"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "list"
        ]
      ]
    };
    var _default = directoryRole;
    exports12.default = _default;
  });
  unwrapExports(directoryRole_1);
  var documentRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var documentRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "Device Independence Delivery Unit"
          }
        },
        {
          concept: {
            name: "body"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = documentRole;
    exports12.default = _default;
  });
  unwrapExports(documentRole_1);
  var emphasisRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var emphasisRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = emphasisRole;
    exports12.default = _default;
  });
  unwrapExports(emphasisRole_1);
  var feedRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var feedRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "article"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "list"
        ]
      ]
    };
    var _default = feedRole;
    exports12.default = _default;
  });
  unwrapExports(feedRole_1);
  var figureRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var figureRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "figure"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = figureRole;
    exports12.default = _default;
  });
  unwrapExports(figureRole_1);
  var formRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var formRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "aria-label"
              }
            ],
            name: "form"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "aria-labelledby"
              }
            ],
            name: "form"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "name"
              }
            ],
            name: "form"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = formRole;
    exports12.default = _default;
  });
  unwrapExports(formRole_1);
  var genericRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var genericRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "span"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "div"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = genericRole;
    exports12.default = _default;
  });
  unwrapExports(genericRole_1);
  var gridRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var gridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-multiselectable": null,
        "aria-readonly": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "role",
                value: "grid"
              }
            ],
            name: "table"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "row"
        ],
        [
          "row",
          "rowgroup"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite"
        ],
        [
          "roletype",
          "structure",
          "section",
          "table"
        ]
      ]
    };
    var _default = gridRole;
    exports12.default = _default;
  });
  unwrapExports(gridRole_1);
  var gridcellRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var gridcellRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-selected": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "role",
                value: "gridcell"
              }
            ],
            name: "td"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "row"
      ],
      requiredContextRole: [
        "row"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "cell"
        ],
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = gridcellRole;
    exports12.default = _default;
  });
  unwrapExports(gridcellRole_1);
  var groupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var groupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-disabled": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "details"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "fieldset"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "optgroup"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = groupRole;
    exports12.default = _default;
  });
  unwrapExports(groupRole_1);
  var headingRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var headingRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-level": "2"
      },
      relatedConcepts: [
        {
          concept: {
            name: "h1"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "h2"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "h3"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "h4"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "h5"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "h6"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-level": "2"
      },
      superClass: [
        [
          "roletype",
          "structure",
          "sectionhead"
        ]
      ]
    };
    var _default = headingRole;
    exports12.default = _default;
  });
  unwrapExports(headingRole_1);
  var imgRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var imgRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "alt"
              }
            ],
            name: "img"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "alt"
              }
            ],
            name: "img"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "imggroup"
          },
          module: "DTB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = imgRole;
    exports12.default = _default;
  });
  unwrapExports(imgRole_1);
  var insertionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var insertionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = insertionRole;
    exports12.default = _default;
  });
  unwrapExports(insertionRole_1);
  var linkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var linkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "href"
              }
            ],
            name: "a"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "href"
              }
            ],
            name: "area"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "href"
              }
            ],
            name: "link"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command"
        ]
      ]
    };
    var _default = linkRole;
    exports12.default = _default;
  });
  unwrapExports(linkRole_1);
  var listRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var listRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "menu"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "ol"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "ul"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "listitem"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = listRole;
    exports12.default = _default;
  });
  unwrapExports(listRole_1);
  var listboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var listboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  ">1"
                ],
                name: "size"
              },
              {
                name: "multiple"
              }
            ],
            name: "select"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  ">1"
                ],
                name: "size"
              }
            ],
            name: "select"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "multiple"
              }
            ],
            name: "select"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "datalist"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "list"
          },
          module: "ARIA"
        },
        {
          concept: {
            name: "select"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "option",
          "group"
        ],
        [
          "option"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "select"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select"
        ]
      ]
    };
    var _default = listboxRole;
    exports12.default = _default;
  });
  unwrapExports(listboxRole_1);
  var listitemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var listitemRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [
        {
          concept: {
            constraints: [
              "direct descendant of ol, ul or menu"
            ],
            name: "li"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "item"
          },
          module: "XForms"
        }
      ],
      requireContextRole: [
        "directory",
        "list"
      ],
      requiredContextRole: [
        "directory",
        "list"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = listitemRole;
    exports12.default = _default;
  });
  unwrapExports(listitemRole_1);
  var logRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var logRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-live": "polite"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = logRole;
    exports12.default = _default;
  });
  unwrapExports(logRole_1);
  var mainRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var mainRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "main"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = mainRole;
    exports12.default = _default;
  });
  unwrapExports(mainRole_1);
  var marqueeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var marqueeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = marqueeRole;
    exports12.default = _default;
  });
  unwrapExports(marqueeRole_1);
  var mathRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var mathRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "math"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = mathRole;
    exports12.default = _default;
  });
  unwrapExports(mathRole_1);
  var menuRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var menuRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-orientation": "vertical"
      },
      relatedConcepts: [
        {
          concept: {
            name: "MENU"
          },
          module: "JAPI"
        },
        {
          concept: {
            name: "list"
          },
          module: "ARIA"
        },
        {
          concept: {
            name: "select"
          },
          module: "XForms"
        },
        {
          concept: {
            name: "sidebar"
          },
          module: "DTB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "menuitem",
          "group"
        ],
        [
          "menuitemradio",
          "group"
        ],
        [
          "menuitemcheckbox",
          "group"
        ],
        [
          "menuitem"
        ],
        [
          "menuitemcheckbox"
        ],
        [
          "menuitemradio"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "select"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select"
        ]
      ]
    };
    var _default = menuRole;
    exports12.default = _default;
  });
  unwrapExports(menuRole_1);
  var menubarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var menubarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [
        {
          concept: {
            name: "toolbar"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "menuitem",
          "group"
        ],
        [
          "menuitemradio",
          "group"
        ],
        [
          "menuitemcheckbox",
          "group"
        ],
        [
          "menuitem"
        ],
        [
          "menuitemcheckbox"
        ],
        [
          "menuitemradio"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "select",
          "menu"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select",
          "menu"
        ]
      ]
    };
    var _default = menubarRole;
    exports12.default = _default;
  });
  unwrapExports(menubarRole_1);
  var menuitemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var menuitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "MENU_ITEM"
          },
          module: "JAPI"
        },
        {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        },
        {
          concept: {
            name: "menuitem"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "option"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command"
        ]
      ]
    };
    var _default = menuitemRole;
    exports12.default = _default;
  });
  unwrapExports(menuitemRole_1);
  var menuitemcheckboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var menuitemcheckboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input",
          "checkbox"
        ],
        [
          "roletype",
          "widget",
          "command",
          "menuitem"
        ]
      ]
    };
    var _default = menuitemcheckboxRole;
    exports12.default = _default;
  });
  unwrapExports(menuitemcheckboxRole_1);
  var menuitemradioRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var menuitemradioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "menuitem"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredContextRole: [
        "group",
        "menu",
        "menubar"
      ],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input",
          "checkbox",
          "menuitemcheckbox"
        ],
        [
          "roletype",
          "widget",
          "command",
          "menuitem",
          "menuitemcheckbox"
        ],
        [
          "roletype",
          "widget",
          "input",
          "radio"
        ]
      ]
    };
    var _default = menuitemradioRole;
    exports12.default = _default;
  });
  unwrapExports(menuitemradioRole_1);
  var meterRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var meterRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null,
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [
        [
          "roletype",
          "structure",
          "range"
        ]
      ]
    };
    var _default = meterRole;
    exports12.default = _default;
  });
  unwrapExports(meterRole_1);
  var navigationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var navigationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "nav"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = navigationRole;
    exports12.default = _default;
  });
  unwrapExports(navigationRole_1);
  var noneRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var noneRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: []
    };
    var _default = noneRole;
    exports12.default = _default;
  });
  unwrapExports(noneRole_1);
  var noteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var noteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = noteRole;
    exports12.default = _default;
  });
  unwrapExports(noteRole_1);
  var optionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var optionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [
        {
          concept: {
            name: "item"
          },
          module: "XForms"
        },
        {
          concept: {
            name: "listitem"
          },
          module: "ARIA"
        },
        {
          concept: {
            name: "option"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": "false"
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ]
      ]
    };
    var _default = optionRole;
    exports12.default = _default;
  });
  unwrapExports(optionRole_1);
  var paragraphRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var paragraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = paragraphRole;
    exports12.default = _default;
  });
  unwrapExports(paragraphRole_1);
  var presentationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var presentationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = presentationRole;
    exports12.default = _default;
  });
  unwrapExports(presentationRole_1);
  var progressbarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var progressbarRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-valuetext": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "progress"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "status"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "range"
        ],
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = progressbarRole;
    exports12.default = _default;
  });
  unwrapExports(progressbarRole_1);
  var radioRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var radioRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-checked": null,
        "aria-posinset": null,
        "aria-setsize": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "radio"
              }
            ],
            name: "input"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ]
      ]
    };
    var _default = radioRole;
    exports12.default = _default;
  });
  unwrapExports(radioRole_1);
  var radiogroupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var radiogroupRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "list"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "radio"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "select"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select"
        ]
      ]
    };
    var _default = radiogroupRole;
    exports12.default = _default;
  });
  unwrapExports(radiogroupRole_1);
  var regionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var regionRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "aria-label"
              }
            ],
            name: "section"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "set"
                ],
                name: "aria-labelledby"
              }
            ],
            name: "section"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "Device Independence Glossart perceivable unit"
          }
        },
        {
          concept: {
            name: "frame"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = regionRole;
    exports12.default = _default;
  });
  unwrapExports(regionRole_1);
  var rowRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var rowRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-colindex": null,
        "aria-expanded": null,
        "aria-level": null,
        "aria-posinset": null,
        "aria-rowindex": null,
        "aria-selected": null,
        "aria-setsize": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "tr"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "grid",
        "rowgroup",
        "table",
        "treegrid"
      ],
      requiredContextRole: [
        "grid",
        "rowgroup",
        "table",
        "treegrid"
      ],
      requiredOwnedElements: [
        [
          "cell"
        ],
        [
          "columnheader"
        ],
        [
          "gridcell"
        ],
        [
          "rowheader"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "group"
        ],
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = rowRole;
    exports12.default = _default;
  });
  unwrapExports(rowRole_1);
  var rowgroupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var rowgroupRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "tbody"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "tfoot"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "thead"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "grid",
        "table",
        "treegrid"
      ],
      requiredContextRole: [
        "grid",
        "table",
        "treegrid"
      ],
      requiredOwnedElements: [
        [
          "row"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = rowgroupRole;
    exports12.default = _default;
  });
  unwrapExports(rowgroupRole_1);
  var rowheaderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var rowheaderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-sort": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "scope",
                value: "row"
              }
            ],
            name: "th"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                name: "scope",
                value: "rowgroup"
              }
            ],
            name: "th"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [
        "row",
        "rowgroup"
      ],
      requiredContextRole: [
        "row",
        "rowgroup"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "cell"
        ],
        [
          "roletype",
          "structure",
          "section",
          "cell",
          "gridcell"
        ],
        [
          "roletype",
          "widget",
          "gridcell"
        ],
        [
          "roletype",
          "structure",
          "sectionhead"
        ]
      ]
    };
    var _default = rowheaderRole;
    exports12.default = _default;
  });
  unwrapExports(rowheaderRole_1);
  var scrollbarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var scrollbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-valuetext": null,
        "aria-orientation": "vertical",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-controls": null,
        "aria-valuenow": null
      },
      superClass: [
        [
          "roletype",
          "structure",
          "range"
        ],
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = scrollbarRole;
    exports12.default = _default;
  });
  unwrapExports(scrollbarRole_1);
  var searchRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var searchRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = searchRole;
    exports12.default = _default;
  });
  unwrapExports(searchRole_1);
  var searchboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var searchboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "search"
              }
            ],
            name: "input"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "input",
          "textbox"
        ]
      ]
    };
    var _default = searchboxRole;
    exports12.default = _default;
  });
  unwrapExports(searchboxRole_1);
  var separatorRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var separatorRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0",
        "aria-valuenow": null,
        "aria-valuetext": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "hr"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure"
        ]
      ]
    };
    var _default = separatorRole;
    exports12.default = _default;
  });
  unwrapExports(separatorRole_1);
  var sliderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var sliderRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-valuetext": null,
        "aria-orientation": "horizontal",
        "aria-valuemax": "100",
        "aria-valuemin": "0"
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "range"
              }
            ],
            name: "input"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-valuenow": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ],
        [
          "roletype",
          "structure",
          "range"
        ]
      ]
    };
    var _default = sliderRole;
    exports12.default = _default;
  });
  unwrapExports(sliderRole_1);
  var spinbuttonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var spinbuttonRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-readonly": null,
        "aria-required": null,
        "aria-valuetext": null,
        "aria-valuenow": "0"
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                name: "type",
                value: "number"
              }
            ],
            name: "input"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite"
        ],
        [
          "roletype",
          "widget",
          "input"
        ],
        [
          "roletype",
          "structure",
          "range"
        ]
      ]
    };
    var _default = spinbuttonRole;
    exports12.default = _default;
  });
  unwrapExports(spinbuttonRole_1);
  var statusRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var statusRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-atomic": "true",
        "aria-live": "polite"
      },
      relatedConcepts: [
        {
          concept: {
            name: "output"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = statusRole;
    exports12.default = _default;
  });
  unwrapExports(statusRole_1);
  var strongRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var strongRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = strongRole;
    exports12.default = _default;
  });
  unwrapExports(strongRole_1);
  var subscriptRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var subscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = subscriptRole;
    exports12.default = _default;
  });
  unwrapExports(subscriptRole_1);
  var superscriptRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var superscriptRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "prohibited"
      ],
      prohibitedProps: [
        "aria-label",
        "aria-labelledby"
      ],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = superscriptRole;
    exports12.default = _default;
  });
  unwrapExports(superscriptRole_1);
  var switchRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var switchRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "button"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-checked": null
      },
      superClass: [
        [
          "roletype",
          "widget",
          "input",
          "checkbox"
        ]
      ]
    };
    var _default = switchRole;
    exports12.default = _default;
  });
  unwrapExports(switchRole_1);
  var tabRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var tabRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-posinset": null,
        "aria-setsize": null,
        "aria-selected": "false"
      },
      relatedConcepts: [],
      requireContextRole: [
        "tablist"
      ],
      requiredContextRole: [
        "tablist"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "sectionhead"
        ],
        [
          "roletype",
          "widget"
        ]
      ]
    };
    var _default = tabRole;
    exports12.default = _default;
  });
  unwrapExports(tabRole_1);
  var tableRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var tableRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-colcount": null,
        "aria-rowcount": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "table"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "row"
        ],
        [
          "row",
          "rowgroup"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = tableRole;
    exports12.default = _default;
  });
  unwrapExports(tableRole_1);
  var tablistRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var tablistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-level": null,
        "aria-multiselectable": null,
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [
        {
          module: "DAISY",
          concept: {
            name: "guide"
          }
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "tab"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite"
        ]
      ]
    };
    var _default = tablistRole;
    exports12.default = _default;
  });
  unwrapExports(tablistRole_1);
  var tabpanelRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var tabpanelRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = tabpanelRole;
    exports12.default = _default;
  });
  unwrapExports(tabpanelRole_1);
  var termRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var termRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "dfn"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "dt"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = termRole;
    exports12.default = _default;
  });
  unwrapExports(termRole_1);
  var textboxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var textboxRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-activedescendant": null,
        "aria-autocomplete": null,
        "aria-errormessage": null,
        "aria-haspopup": null,
        "aria-invalid": null,
        "aria-multiline": null,
        "aria-placeholder": null,
        "aria-readonly": null,
        "aria-required": null
      },
      relatedConcepts: [
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "type"
              },
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "email"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "tel"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "text"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            attributes: [
              {
                constraints: [
                  "undefined"
                ],
                name: "list"
              },
              {
                name: "type",
                value: "url"
              }
            ],
            name: "input"
          },
          module: "HTML"
        },
        {
          concept: {
            name: "input"
          },
          module: "XForms"
        },
        {
          concept: {
            name: "textarea"
          },
          module: "HTML"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "input"
        ]
      ]
    };
    var _default = textboxRole;
    exports12.default = _default;
  });
  unwrapExports(textboxRole_1);
  var timeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var timeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = timeRole;
    exports12.default = _default;
  });
  unwrapExports(timeRole_1);
  var timerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var timerRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "status"
        ]
      ]
    };
    var _default = timerRole;
    exports12.default = _default;
  });
  unwrapExports(timerRole_1);
  var toolbarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var toolbarRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-orientation": "horizontal"
      },
      relatedConcepts: [
        {
          concept: {
            name: "menubar"
          },
          module: "ARIA"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "group"
        ]
      ]
    };
    var _default = toolbarRole;
    exports12.default = _default;
  });
  unwrapExports(toolbarRole_1);
  var tooltipRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var tooltipRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = tooltipRole;
    exports12.default = _default;
  });
  unwrapExports(tooltipRole_1);
  var treeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var treeRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null,
        "aria-multiselectable": null,
        "aria-required": null,
        "aria-orientation": "vertical"
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "treeitem",
          "group"
        ],
        [
          "treeitem"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "select"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select"
        ]
      ]
    };
    var _default = treeRole;
    exports12.default = _default;
  });
  unwrapExports(treeRole_1);
  var treegridRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var treegridRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "row"
        ],
        [
          "row",
          "rowgroup"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "composite",
          "grid"
        ],
        [
          "roletype",
          "structure",
          "section",
          "table",
          "grid"
        ],
        [
          "roletype",
          "widget",
          "composite",
          "select",
          "tree"
        ],
        [
          "roletype",
          "structure",
          "section",
          "group",
          "select",
          "tree"
        ]
      ]
    };
    var _default = treegridRole;
    exports12.default = _default;
  });
  unwrapExports(treegridRole_1);
  var treeitemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var treeitemRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-expanded": null,
        "aria-haspopup": null
      },
      relatedConcepts: [],
      requireContextRole: [
        "group",
        "tree"
      ],
      requiredContextRole: [
        "group",
        "tree"
      ],
      requiredOwnedElements: [],
      requiredProps: {
        "aria-selected": null
      },
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "listitem"
        ],
        [
          "roletype",
          "widget",
          "input",
          "option"
        ]
      ]
    };
    var _default = treeitemRole;
    exports12.default = _default;
  });
  unwrapExports(treeitemRole_1);
  var ariaLiteralRoles_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _alertRole = _interopRequireDefault(alertRole_1);
    var _alertdialogRole = _interopRequireDefault(alertdialogRole_1);
    var _applicationRole = _interopRequireDefault(applicationRole_1);
    var _articleRole = _interopRequireDefault(articleRole_1);
    var _bannerRole = _interopRequireDefault(bannerRole_1);
    var _blockquoteRole = _interopRequireDefault(blockquoteRole_1);
    var _buttonRole = _interopRequireDefault(buttonRole_1);
    var _captionRole = _interopRequireDefault(captionRole_1);
    var _cellRole = _interopRequireDefault(cellRole_1);
    var _checkboxRole = _interopRequireDefault(checkboxRole_1);
    var _codeRole = _interopRequireDefault(codeRole_1);
    var _columnheaderRole = _interopRequireDefault(columnheaderRole_1);
    var _comboboxRole = _interopRequireDefault(comboboxRole_1);
    var _complementaryRole = _interopRequireDefault(complementaryRole_1);
    var _contentinfoRole = _interopRequireDefault(contentinfoRole_1);
    var _definitionRole = _interopRequireDefault(definitionRole_1);
    var _deletionRole = _interopRequireDefault(deletionRole_1);
    var _dialogRole = _interopRequireDefault(dialogRole_1);
    var _directoryRole = _interopRequireDefault(directoryRole_1);
    var _documentRole = _interopRequireDefault(documentRole_1);
    var _emphasisRole = _interopRequireDefault(emphasisRole_1);
    var _feedRole = _interopRequireDefault(feedRole_1);
    var _figureRole = _interopRequireDefault(figureRole_1);
    var _formRole = _interopRequireDefault(formRole_1);
    var _genericRole = _interopRequireDefault(genericRole_1);
    var _gridRole = _interopRequireDefault(gridRole_1);
    var _gridcellRole = _interopRequireDefault(gridcellRole_1);
    var _groupRole = _interopRequireDefault(groupRole_1);
    var _headingRole = _interopRequireDefault(headingRole_1);
    var _imgRole = _interopRequireDefault(imgRole_1);
    var _insertionRole = _interopRequireDefault(insertionRole_1);
    var _linkRole = _interopRequireDefault(linkRole_1);
    var _listRole = _interopRequireDefault(listRole_1);
    var _listboxRole = _interopRequireDefault(listboxRole_1);
    var _listitemRole = _interopRequireDefault(listitemRole_1);
    var _logRole = _interopRequireDefault(logRole_1);
    var _mainRole = _interopRequireDefault(mainRole_1);
    var _marqueeRole = _interopRequireDefault(marqueeRole_1);
    var _mathRole = _interopRequireDefault(mathRole_1);
    var _menuRole = _interopRequireDefault(menuRole_1);
    var _menubarRole = _interopRequireDefault(menubarRole_1);
    var _menuitemRole = _interopRequireDefault(menuitemRole_1);
    var _menuitemcheckboxRole = _interopRequireDefault(menuitemcheckboxRole_1);
    var _menuitemradioRole = _interopRequireDefault(menuitemradioRole_1);
    var _meterRole = _interopRequireDefault(meterRole_1);
    var _navigationRole = _interopRequireDefault(navigationRole_1);
    var _noneRole = _interopRequireDefault(noneRole_1);
    var _noteRole = _interopRequireDefault(noteRole_1);
    var _optionRole = _interopRequireDefault(optionRole_1);
    var _paragraphRole = _interopRequireDefault(paragraphRole_1);
    var _presentationRole = _interopRequireDefault(presentationRole_1);
    var _progressbarRole = _interopRequireDefault(progressbarRole_1);
    var _radioRole = _interopRequireDefault(radioRole_1);
    var _radiogroupRole = _interopRequireDefault(radiogroupRole_1);
    var _regionRole = _interopRequireDefault(regionRole_1);
    var _rowRole = _interopRequireDefault(rowRole_1);
    var _rowgroupRole = _interopRequireDefault(rowgroupRole_1);
    var _rowheaderRole = _interopRequireDefault(rowheaderRole_1);
    var _scrollbarRole = _interopRequireDefault(scrollbarRole_1);
    var _searchRole = _interopRequireDefault(searchRole_1);
    var _searchboxRole = _interopRequireDefault(searchboxRole_1);
    var _separatorRole = _interopRequireDefault(separatorRole_1);
    var _sliderRole = _interopRequireDefault(sliderRole_1);
    var _spinbuttonRole = _interopRequireDefault(spinbuttonRole_1);
    var _statusRole = _interopRequireDefault(statusRole_1);
    var _strongRole = _interopRequireDefault(strongRole_1);
    var _subscriptRole = _interopRequireDefault(subscriptRole_1);
    var _superscriptRole = _interopRequireDefault(superscriptRole_1);
    var _switchRole = _interopRequireDefault(switchRole_1);
    var _tabRole = _interopRequireDefault(tabRole_1);
    var _tableRole = _interopRequireDefault(tableRole_1);
    var _tablistRole = _interopRequireDefault(tablistRole_1);
    var _tabpanelRole = _interopRequireDefault(tabpanelRole_1);
    var _termRole = _interopRequireDefault(termRole_1);
    var _textboxRole = _interopRequireDefault(textboxRole_1);
    var _timeRole = _interopRequireDefault(timeRole_1);
    var _timerRole = _interopRequireDefault(timerRole_1);
    var _toolbarRole = _interopRequireDefault(toolbarRole_1);
    var _tooltipRole = _interopRequireDefault(tooltipRole_1);
    var _treeRole = _interopRequireDefault(treeRole_1);
    var _treegridRole = _interopRequireDefault(treegridRole_1);
    var _treeitemRole = _interopRequireDefault(treeitemRole_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ariaLiteralRoles = [
      [
        "alert",
        _alertRole.default
      ],
      [
        "alertdialog",
        _alertdialogRole.default
      ],
      [
        "application",
        _applicationRole.default
      ],
      [
        "article",
        _articleRole.default
      ],
      [
        "banner",
        _bannerRole.default
      ],
      [
        "blockquote",
        _blockquoteRole.default
      ],
      [
        "button",
        _buttonRole.default
      ],
      [
        "caption",
        _captionRole.default
      ],
      [
        "cell",
        _cellRole.default
      ],
      [
        "checkbox",
        _checkboxRole.default
      ],
      [
        "code",
        _codeRole.default
      ],
      [
        "columnheader",
        _columnheaderRole.default
      ],
      [
        "combobox",
        _comboboxRole.default
      ],
      [
        "complementary",
        _complementaryRole.default
      ],
      [
        "contentinfo",
        _contentinfoRole.default
      ],
      [
        "definition",
        _definitionRole.default
      ],
      [
        "deletion",
        _deletionRole.default
      ],
      [
        "dialog",
        _dialogRole.default
      ],
      [
        "directory",
        _directoryRole.default
      ],
      [
        "document",
        _documentRole.default
      ],
      [
        "emphasis",
        _emphasisRole.default
      ],
      [
        "feed",
        _feedRole.default
      ],
      [
        "figure",
        _figureRole.default
      ],
      [
        "form",
        _formRole.default
      ],
      [
        "generic",
        _genericRole.default
      ],
      [
        "grid",
        _gridRole.default
      ],
      [
        "gridcell",
        _gridcellRole.default
      ],
      [
        "group",
        _groupRole.default
      ],
      [
        "heading",
        _headingRole.default
      ],
      [
        "img",
        _imgRole.default
      ],
      [
        "insertion",
        _insertionRole.default
      ],
      [
        "link",
        _linkRole.default
      ],
      [
        "list",
        _listRole.default
      ],
      [
        "listbox",
        _listboxRole.default
      ],
      [
        "listitem",
        _listitemRole.default
      ],
      [
        "log",
        _logRole.default
      ],
      [
        "main",
        _mainRole.default
      ],
      [
        "marquee",
        _marqueeRole.default
      ],
      [
        "math",
        _mathRole.default
      ],
      [
        "menu",
        _menuRole.default
      ],
      [
        "menubar",
        _menubarRole.default
      ],
      [
        "menuitem",
        _menuitemRole.default
      ],
      [
        "menuitemcheckbox",
        _menuitemcheckboxRole.default
      ],
      [
        "menuitemradio",
        _menuitemradioRole.default
      ],
      [
        "meter",
        _meterRole.default
      ],
      [
        "navigation",
        _navigationRole.default
      ],
      [
        "none",
        _noneRole.default
      ],
      [
        "note",
        _noteRole.default
      ],
      [
        "option",
        _optionRole.default
      ],
      [
        "paragraph",
        _paragraphRole.default
      ],
      [
        "presentation",
        _presentationRole.default
      ],
      [
        "progressbar",
        _progressbarRole.default
      ],
      [
        "radio",
        _radioRole.default
      ],
      [
        "radiogroup",
        _radiogroupRole.default
      ],
      [
        "region",
        _regionRole.default
      ],
      [
        "row",
        _rowRole.default
      ],
      [
        "rowgroup",
        _rowgroupRole.default
      ],
      [
        "rowheader",
        _rowheaderRole.default
      ],
      [
        "scrollbar",
        _scrollbarRole.default
      ],
      [
        "search",
        _searchRole.default
      ],
      [
        "searchbox",
        _searchboxRole.default
      ],
      [
        "separator",
        _separatorRole.default
      ],
      [
        "slider",
        _sliderRole.default
      ],
      [
        "spinbutton",
        _spinbuttonRole.default
      ],
      [
        "status",
        _statusRole.default
      ],
      [
        "strong",
        _strongRole.default
      ],
      [
        "subscript",
        _subscriptRole.default
      ],
      [
        "superscript",
        _superscriptRole.default
      ],
      [
        "switch",
        _switchRole.default
      ],
      [
        "tab",
        _tabRole.default
      ],
      [
        "table",
        _tableRole.default
      ],
      [
        "tablist",
        _tablistRole.default
      ],
      [
        "tabpanel",
        _tabpanelRole.default
      ],
      [
        "term",
        _termRole.default
      ],
      [
        "textbox",
        _textboxRole.default
      ],
      [
        "time",
        _timeRole.default
      ],
      [
        "timer",
        _timerRole.default
      ],
      [
        "toolbar",
        _toolbarRole.default
      ],
      [
        "tooltip",
        _tooltipRole.default
      ],
      [
        "tree",
        _treeRole.default
      ],
      [
        "treegrid",
        _treegridRole.default
      ],
      [
        "treeitem",
        _treeitemRole.default
      ]
    ];
    var _default = ariaLiteralRoles;
    exports12.default = _default;
  });
  unwrapExports(ariaLiteralRoles_1);
  var docAbstractRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docAbstractRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "abstract [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docAbstractRole;
    exports12.default = _default;
  });
  unwrapExports(docAbstractRole_1);
  var docAcknowledgmentsRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docAcknowledgmentsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "acknowledgments [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docAcknowledgmentsRole;
    exports12.default = _default;
  });
  unwrapExports(docAcknowledgmentsRole_1);
  var docAfterwordRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docAfterwordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "afterword [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docAfterwordRole;
    exports12.default = _default;
  });
  unwrapExports(docAfterwordRole_1);
  var docAppendixRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docAppendixRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "appendix [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docAppendixRole;
    exports12.default = _default;
  });
  unwrapExports(docAppendixRole_1);
  var docBacklinkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docBacklinkRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "content"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "referrer [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command",
          "link"
        ]
      ]
    };
    var _default = docBacklinkRole;
    exports12.default = _default;
  });
  unwrapExports(docBacklinkRole_1);
  var docBiblioentryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docBiblioentryRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "EPUB biblioentry [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [
        "doc-bibliography"
      ],
      requiredContextRole: [
        "doc-bibliography"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "listitem"
        ]
      ]
    };
    var _default = docBiblioentryRole;
    exports12.default = _default;
  });
  unwrapExports(docBiblioentryRole_1);
  var docBibliographyRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docBibliographyRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "bibliography [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "doc-biblioentry"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docBibliographyRole;
    exports12.default = _default;
  });
  unwrapExports(docBibliographyRole_1);
  var docBibliorefRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docBibliorefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "biblioref [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command",
          "link"
        ]
      ]
    };
    var _default = docBibliorefRole;
    exports12.default = _default;
  });
  unwrapExports(docBibliorefRole_1);
  var docChapterRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docChapterRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "chapter [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docChapterRole;
    exports12.default = _default;
  });
  unwrapExports(docChapterRole_1);
  var docColophonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docColophonRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "colophon [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docColophonRole;
    exports12.default = _default;
  });
  unwrapExports(docColophonRole_1);
  var docConclusionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docConclusionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "conclusion [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docConclusionRole;
    exports12.default = _default;
  });
  unwrapExports(docConclusionRole_1);
  var docCoverRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docCoverRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "cover [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "img"
        ]
      ]
    };
    var _default = docCoverRole;
    exports12.default = _default;
  });
  unwrapExports(docCoverRole_1);
  var docCreditRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docCreditRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "credit [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docCreditRole;
    exports12.default = _default;
  });
  unwrapExports(docCreditRole_1);
  var docCreditsRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docCreditsRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "credits [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docCreditsRole;
    exports12.default = _default;
  });
  unwrapExports(docCreditsRole_1);
  var docDedicationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docDedicationRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "dedication [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docDedicationRole;
    exports12.default = _default;
  });
  unwrapExports(docDedicationRole_1);
  var docEndnoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docEndnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "rearnote [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [
        "doc-endnotes"
      ],
      requiredContextRole: [
        "doc-endnotes"
      ],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "listitem"
        ]
      ]
    };
    var _default = docEndnoteRole;
    exports12.default = _default;
  });
  unwrapExports(docEndnoteRole_1);
  var docEndnotesRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docEndnotesRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "rearnotes [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "doc-endnote"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docEndnotesRole;
    exports12.default = _default;
  });
  unwrapExports(docEndnotesRole_1);
  var docEpigraphRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docEpigraphRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "epigraph [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docEpigraphRole;
    exports12.default = _default;
  });
  unwrapExports(docEpigraphRole_1);
  var docEpilogueRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docEpilogueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "epilogue [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docEpilogueRole;
    exports12.default = _default;
  });
  unwrapExports(docEpilogueRole_1);
  var docErrataRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docErrataRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "errata [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docErrataRole;
    exports12.default = _default;
  });
  unwrapExports(docErrataRole_1);
  var docExampleRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docExampleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docExampleRole;
    exports12.default = _default;
  });
  unwrapExports(docExampleRole_1);
  var docFootnoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docFootnoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "footnote [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docFootnoteRole;
    exports12.default = _default;
  });
  unwrapExports(docFootnoteRole_1);
  var docForewordRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docForewordRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "foreword [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docForewordRole;
    exports12.default = _default;
  });
  unwrapExports(docForewordRole_1);
  var docGlossaryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docGlossaryRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "glossary [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [
        [
          "definition"
        ],
        [
          "term"
        ]
      ],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docGlossaryRole;
    exports12.default = _default;
  });
  unwrapExports(docGlossaryRole_1);
  var docGlossrefRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docGlossrefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "glossref [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command",
          "link"
        ]
      ]
    };
    var _default = docGlossrefRole;
    exports12.default = _default;
  });
  unwrapExports(docGlossrefRole_1);
  var docIndexRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docIndexRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "index [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark",
          "navigation"
        ]
      ]
    };
    var _default = docIndexRole;
    exports12.default = _default;
  });
  unwrapExports(docIndexRole_1);
  var docIntroductionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docIntroductionRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "introduction [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docIntroductionRole;
    exports12.default = _default;
  });
  unwrapExports(docIntroductionRole_1);
  var docNoterefRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docNoterefRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author",
        "contents"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "noteref [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "widget",
          "command",
          "link"
        ]
      ]
    };
    var _default = docNoterefRole;
    exports12.default = _default;
  });
  unwrapExports(docNoterefRole_1);
  var docNoticeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docNoticeRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "notice [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "note"
        ]
      ]
    };
    var _default = docNoticeRole;
    exports12.default = _default;
  });
  unwrapExports(docNoticeRole_1);
  var docPagebreakRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPagebreakRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: true,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "pagebreak [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "separator"
        ]
      ]
    };
    var _default = docPagebreakRole;
    exports12.default = _default;
  });
  unwrapExports(docPagebreakRole_1);
  var docPagelistRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPagelistRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "page-list [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark",
          "navigation"
        ]
      ]
    };
    var _default = docPagelistRole;
    exports12.default = _default;
  });
  unwrapExports(docPagelistRole_1);
  var docPartRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPartRole = {
      abstract: false,
      accessibleNameRequired: true,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "part [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docPartRole;
    exports12.default = _default;
  });
  unwrapExports(docPartRole_1);
  var docPrefaceRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPrefaceRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "preface [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docPrefaceRole;
    exports12.default = _default;
  });
  unwrapExports(docPrefaceRole_1);
  var docPrologueRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPrologueRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "prologue [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark"
        ]
      ]
    };
    var _default = docPrologueRole;
    exports12.default = _default;
  });
  unwrapExports(docPrologueRole_1);
  var docPullquoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docPullquoteRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {},
      relatedConcepts: [
        {
          concept: {
            name: "pullquote [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "none"
        ]
      ]
    };
    var _default = docPullquoteRole;
    exports12.default = _default;
  });
  unwrapExports(docPullquoteRole_1);
  var docQnaRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docQnaRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "qna [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section"
        ]
      ]
    };
    var _default = docQnaRole;
    exports12.default = _default;
  });
  unwrapExports(docQnaRole_1);
  var docSubtitleRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docSubtitleRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "subtitle [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "sectionhead"
        ]
      ]
    };
    var _default = docSubtitleRole;
    exports12.default = _default;
  });
  unwrapExports(docSubtitleRole_1);
  var docTipRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docTipRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "help [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "note"
        ]
      ]
    };
    var _default = docTipRole;
    exports12.default = _default;
  });
  unwrapExports(docTipRole_1);
  var docTocRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var docTocRole = {
      abstract: false,
      accessibleNameRequired: false,
      baseConcepts: [],
      childrenPresentational: false,
      nameFrom: [
        "author"
      ],
      prohibitedProps: [],
      props: {
        "aria-disabled": null,
        "aria-errormessage": null,
        "aria-expanded": null,
        "aria-haspopup": null,
        "aria-invalid": null
      },
      relatedConcepts: [
        {
          concept: {
            name: "toc [EPUB-SSV]"
          },
          module: "EPUB"
        }
      ],
      requireContextRole: [],
      requiredContextRole: [],
      requiredOwnedElements: [],
      requiredProps: {},
      superClass: [
        [
          "roletype",
          "structure",
          "section",
          "landmark",
          "navigation"
        ]
      ]
    };
    var _default = docTocRole;
    exports12.default = _default;
  });
  unwrapExports(docTocRole_1);
  var ariaDpubRoles_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _docAbstractRole = _interopRequireDefault(docAbstractRole_1);
    var _docAcknowledgmentsRole = _interopRequireDefault(docAcknowledgmentsRole_1);
    var _docAfterwordRole = _interopRequireDefault(docAfterwordRole_1);
    var _docAppendixRole = _interopRequireDefault(docAppendixRole_1);
    var _docBacklinkRole = _interopRequireDefault(docBacklinkRole_1);
    var _docBiblioentryRole = _interopRequireDefault(docBiblioentryRole_1);
    var _docBibliographyRole = _interopRequireDefault(docBibliographyRole_1);
    var _docBibliorefRole = _interopRequireDefault(docBibliorefRole_1);
    var _docChapterRole = _interopRequireDefault(docChapterRole_1);
    var _docColophonRole = _interopRequireDefault(docColophonRole_1);
    var _docConclusionRole = _interopRequireDefault(docConclusionRole_1);
    var _docCoverRole = _interopRequireDefault(docCoverRole_1);
    var _docCreditRole = _interopRequireDefault(docCreditRole_1);
    var _docCreditsRole = _interopRequireDefault(docCreditsRole_1);
    var _docDedicationRole = _interopRequireDefault(docDedicationRole_1);
    var _docEndnoteRole = _interopRequireDefault(docEndnoteRole_1);
    var _docEndnotesRole = _interopRequireDefault(docEndnotesRole_1);
    var _docEpigraphRole = _interopRequireDefault(docEpigraphRole_1);
    var _docEpilogueRole = _interopRequireDefault(docEpilogueRole_1);
    var _docErrataRole = _interopRequireDefault(docErrataRole_1);
    var _docExampleRole = _interopRequireDefault(docExampleRole_1);
    var _docFootnoteRole = _interopRequireDefault(docFootnoteRole_1);
    var _docForewordRole = _interopRequireDefault(docForewordRole_1);
    var _docGlossaryRole = _interopRequireDefault(docGlossaryRole_1);
    var _docGlossrefRole = _interopRequireDefault(docGlossrefRole_1);
    var _docIndexRole = _interopRequireDefault(docIndexRole_1);
    var _docIntroductionRole = _interopRequireDefault(docIntroductionRole_1);
    var _docNoterefRole = _interopRequireDefault(docNoterefRole_1);
    var _docNoticeRole = _interopRequireDefault(docNoticeRole_1);
    var _docPagebreakRole = _interopRequireDefault(docPagebreakRole_1);
    var _docPagelistRole = _interopRequireDefault(docPagelistRole_1);
    var _docPartRole = _interopRequireDefault(docPartRole_1);
    var _docPrefaceRole = _interopRequireDefault(docPrefaceRole_1);
    var _docPrologueRole = _interopRequireDefault(docPrologueRole_1);
    var _docPullquoteRole = _interopRequireDefault(docPullquoteRole_1);
    var _docQnaRole = _interopRequireDefault(docQnaRole_1);
    var _docSubtitleRole = _interopRequireDefault(docSubtitleRole_1);
    var _docTipRole = _interopRequireDefault(docTipRole_1);
    var _docTocRole = _interopRequireDefault(docTocRole_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ariaDpubRoles = [
      [
        "doc-abstract",
        _docAbstractRole.default
      ],
      [
        "doc-acknowledgments",
        _docAcknowledgmentsRole.default
      ],
      [
        "doc-afterword",
        _docAfterwordRole.default
      ],
      [
        "doc-appendix",
        _docAppendixRole.default
      ],
      [
        "doc-backlink",
        _docBacklinkRole.default
      ],
      [
        "doc-biblioentry",
        _docBiblioentryRole.default
      ],
      [
        "doc-bibliography",
        _docBibliographyRole.default
      ],
      [
        "doc-biblioref",
        _docBibliorefRole.default
      ],
      [
        "doc-chapter",
        _docChapterRole.default
      ],
      [
        "doc-colophon",
        _docColophonRole.default
      ],
      [
        "doc-conclusion",
        _docConclusionRole.default
      ],
      [
        "doc-cover",
        _docCoverRole.default
      ],
      [
        "doc-credit",
        _docCreditRole.default
      ],
      [
        "doc-credits",
        _docCreditsRole.default
      ],
      [
        "doc-dedication",
        _docDedicationRole.default
      ],
      [
        "doc-endnote",
        _docEndnoteRole.default
      ],
      [
        "doc-endnotes",
        _docEndnotesRole.default
      ],
      [
        "doc-epigraph",
        _docEpigraphRole.default
      ],
      [
        "doc-epilogue",
        _docEpilogueRole.default
      ],
      [
        "doc-errata",
        _docErrataRole.default
      ],
      [
        "doc-example",
        _docExampleRole.default
      ],
      [
        "doc-footnote",
        _docFootnoteRole.default
      ],
      [
        "doc-foreword",
        _docForewordRole.default
      ],
      [
        "doc-glossary",
        _docGlossaryRole.default
      ],
      [
        "doc-glossref",
        _docGlossrefRole.default
      ],
      [
        "doc-index",
        _docIndexRole.default
      ],
      [
        "doc-introduction",
        _docIntroductionRole.default
      ],
      [
        "doc-noteref",
        _docNoterefRole.default
      ],
      [
        "doc-notice",
        _docNoticeRole.default
      ],
      [
        "doc-pagebreak",
        _docPagebreakRole.default
      ],
      [
        "doc-pagelist",
        _docPagelistRole.default
      ],
      [
        "doc-part",
        _docPartRole.default
      ],
      [
        "doc-preface",
        _docPrefaceRole.default
      ],
      [
        "doc-prologue",
        _docPrologueRole.default
      ],
      [
        "doc-pullquote",
        _docPullquoteRole.default
      ],
      [
        "doc-qna",
        _docQnaRole.default
      ],
      [
        "doc-subtitle",
        _docSubtitleRole.default
      ],
      [
        "doc-tip",
        _docTipRole.default
      ],
      [
        "doc-toc",
        _docTocRole.default
      ]
    ];
    var _default = ariaDpubRoles;
    exports12.default = _default;
  });
  unwrapExports(ariaDpubRoles_1);
  var rolesMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _ariaAbstractRoles = _interopRequireDefault(ariaAbstractRoles_1);
    var _ariaLiteralRoles = _interopRequireDefault(ariaLiteralRoles_1);
    var _ariaDpubRoles = _interopRequireDefault(ariaDpubRoles_1);
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperty(obj, key, value2) {
      if (key in obj)
        Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      else
        obj[key] = value2;
      return obj;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var roles = [].concat(_ariaAbstractRoles.default, _ariaLiteralRoles.default, _ariaDpubRoles.default);
    roles.forEach(function(_ref) {
      var _ref2 = _slicedToArray(_ref, 2), roleDefinition = _ref2[1];
      var _iterator = _createForOfIteratorHelper(roleDefinition.superClass), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var superClassIter = _step.value;
          var _iterator2 = _createForOfIteratorHelper(superClassIter), _step2;
          try {
            var _loop = function _loop2() {
              var superClassName = _step2.value;
              var superClassRoleTuple = roles.find(function(_ref3) {
                var _ref4 = _slicedToArray(_ref3, 1), name = _ref4[0];
                return name === superClassName;
              });
              if (superClassRoleTuple) {
                var superClassDefinition = superClassRoleTuple[1];
                for (var _i2 = 0, _Object$keys = Object.keys(superClassDefinition.props); _i2 < _Object$keys.length; _i2++) {
                  var prop = _Object$keys[_i2];
                  if (!Object.prototype.hasOwnProperty.call(roleDefinition.props, prop))
                    Object.assign(roleDefinition.props, _defineProperty({}, prop, superClassDefinition.props[prop]));
                }
              }
            };
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; )
              _loop();
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
    var rolesMap = {
      entries: function entries() {
        return roles;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator3 = _createForOfIteratorHelper(roles), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _step3$value = _slicedToArray(_step3.value, 2), key = _step3$value[0], values = _step3$value[1];
            fn.call(thisArg, values, key, roles);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      },
      get: function get(key) {
        var item = roles.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return roles.map(function(_ref5) {
          var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
          return key;
        });
      },
      values: function values() {
        return roles.map(function(_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2), values2 = _ref8[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(rolesMap, rolesMap.entries());
    exports12.default = _default;
  });
  unwrapExports(rolesMap_1);
  var toStr = Object.prototype.toString;
  var isArguments = function isArguments2(value2) {
    var str = toStr.call(value2);
    var isArgs2 = str === "[object Arguments]";
    if (!isArgs2)
      isArgs2 = str !== "[object Array]" && value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && toStr.call(value2.callee) === "[object Function]";
    return isArgs2;
  };
  var keysShim;
  if (!Object.keys) {
    var has = Object.prototype.hasOwnProperty;
    var toStr$1 = Object.prototype.toString;
    var isArgs = isArguments;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var hasDontEnumBug = !isEnumerable.call({
      toString: null
    }, "toString");
    var hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    var dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    var equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    var excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    var hasAutomationEqualityBug = function() {
      if (typeof window === "undefined")
        return false;
      for (var k in window)
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object")
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
        } catch (e) {
          return true;
        }
      return false;
    }();
    var equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug)
        return equalsConstructorPrototype(o);
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object) {
      var isObject2 = object !== null && typeof object === "object";
      var isFunction2 = toStr$1.call(object) === "[object Function]";
      var isArguments2 = isArgs(object);
      var isString2 = isObject2 && toStr$1.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject2 && !isFunction2 && !isArguments2)
        throw new TypeError("Object.keys called on a non-object");
      var skipProto = hasProtoEnumBug && isFunction2;
      if (isString2 && object.length > 0 && !has.call(object, 0))
        for (var i2 = 0; i2 < object.length; ++i2)
          theKeys.push(String(i2));
      if (isArguments2 && object.length > 0)
        for (var j = 0; j < object.length; ++j)
          theKeys.push(String(j));
      else {
        for (var name in object)
          if (!(skipProto && name === "prototype") && has.call(object, name))
            theKeys.push(String(name));
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k)
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k]))
            theKeys.push(dontEnums[k]);
      }
      return theKeys;
    };
  }
  var implementation = keysShim;
  var slice = Array.prototype.slice;
  var origKeys = Object.keys;
  var keysShim$1 = origKeys ? function keys(o) {
    return origKeys(o);
  } : implementation;
  var originalKeys = Object.keys;
  keysShim$1.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments)
        Object.keys = function keys(object) {
          if (isArguments(object))
            return originalKeys(slice.call(object));
          return originalKeys(object);
        };
    } else
      Object.keys = keysShim$1;
    return Object.keys || keysShim$1;
  };
  var objectKeys = keysShim$1;
  var shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function")
      return false;
    if (typeof Symbol.iterator === "symbol")
      return true;
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string")
      return false;
    if (Object.prototype.toString.call(sym) !== "[object Symbol]")
      return false;
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]")
      return false;
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj)
      return false;
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0)
      return false;
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0)
      return false;
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym)
      return false;
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym))
      return false;
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true)
        return false;
    }
    return true;
  };
  var shams$1 = function hasToStringTagShams() {
    return shams() && !!Symbol.toStringTag;
  };
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function")
      return false;
    if (typeof Symbol !== "function")
      return false;
    if (typeof origSymbol("foo") !== "symbol")
      return false;
    if (typeof Symbol("bar") !== "symbol")
      return false;
    return shams();
  };
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice$1 = Array.prototype.slice;
  var toStr$2 = Object.prototype.toString;
  var funcType = "[object Function]";
  var implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr$2.call(target) !== funcType)
      throw new TypeError(ERROR_MESSAGE + target);
    var args = slice$1.call(arguments, 1);
    var bound2;
    var binder = function() {
      if (this instanceof bound2) {
        var result = target.apply(this, args.concat(slice$1.call(arguments)));
        if (Object(result) === result)
          return result;
        return this;
      } else
        return target.apply(that, args.concat(slice$1.call(arguments)));
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++)
      boundArgs.push("$" + i2);
    bound2 = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound2.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound2;
  };
  var functionBind = Function.prototype.bind || implementation$1;
  var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);
  var undefined$1;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD)
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols$1 = hasSymbols();
  var getProto = Object.getPrototypeOf || function(x2) {
    return x2.__proto__;
  };
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols$1 ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols$1 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$1 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols$1 ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  var doEval = function doEval2(name) {
    var value2;
    if (name === "%AsyncFunction%")
      value2 = getEvalledConstructor("async function () {}");
    else if (name === "%GeneratorFunction%")
      value2 = getEvalledConstructor("function* () {}");
    else if (name === "%AsyncGeneratorFunction%")
      value2 = getEvalledConstructor("async function* () {}");
    else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn)
        value2 = fn.prototype;
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen)
        value2 = getProto(gen.prototype);
    }
    INTRINSICS[name] = value2;
    return value2;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": [
      "ArrayBuffer",
      "prototype"
    ],
    "%ArrayPrototype%": [
      "Array",
      "prototype"
    ],
    "%ArrayProto_entries%": [
      "Array",
      "prototype",
      "entries"
    ],
    "%ArrayProto_forEach%": [
      "Array",
      "prototype",
      "forEach"
    ],
    "%ArrayProto_keys%": [
      "Array",
      "prototype",
      "keys"
    ],
    "%ArrayProto_values%": [
      "Array",
      "prototype",
      "values"
    ],
    "%AsyncFunctionPrototype%": [
      "AsyncFunction",
      "prototype"
    ],
    "%AsyncGenerator%": [
      "AsyncGeneratorFunction",
      "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
      "AsyncGeneratorFunction",
      "prototype",
      "prototype"
    ],
    "%BooleanPrototype%": [
      "Boolean",
      "prototype"
    ],
    "%DataViewPrototype%": [
      "DataView",
      "prototype"
    ],
    "%DatePrototype%": [
      "Date",
      "prototype"
    ],
    "%ErrorPrototype%": [
      "Error",
      "prototype"
    ],
    "%EvalErrorPrototype%": [
      "EvalError",
      "prototype"
    ],
    "%Float32ArrayPrototype%": [
      "Float32Array",
      "prototype"
    ],
    "%Float64ArrayPrototype%": [
      "Float64Array",
      "prototype"
    ],
    "%FunctionPrototype%": [
      "Function",
      "prototype"
    ],
    "%Generator%": [
      "GeneratorFunction",
      "prototype"
    ],
    "%GeneratorPrototype%": [
      "GeneratorFunction",
      "prototype",
      "prototype"
    ],
    "%Int8ArrayPrototype%": [
      "Int8Array",
      "prototype"
    ],
    "%Int16ArrayPrototype%": [
      "Int16Array",
      "prototype"
    ],
    "%Int32ArrayPrototype%": [
      "Int32Array",
      "prototype"
    ],
    "%JSONParse%": [
      "JSON",
      "parse"
    ],
    "%JSONStringify%": [
      "JSON",
      "stringify"
    ],
    "%MapPrototype%": [
      "Map",
      "prototype"
    ],
    "%NumberPrototype%": [
      "Number",
      "prototype"
    ],
    "%ObjectPrototype%": [
      "Object",
      "prototype"
    ],
    "%ObjProto_toString%": [
      "Object",
      "prototype",
      "toString"
    ],
    "%ObjProto_valueOf%": [
      "Object",
      "prototype",
      "valueOf"
    ],
    "%PromisePrototype%": [
      "Promise",
      "prototype"
    ],
    "%PromiseProto_then%": [
      "Promise",
      "prototype",
      "then"
    ],
    "%Promise_all%": [
      "Promise",
      "all"
    ],
    "%Promise_reject%": [
      "Promise",
      "reject"
    ],
    "%Promise_resolve%": [
      "Promise",
      "resolve"
    ],
    "%RangeErrorPrototype%": [
      "RangeError",
      "prototype"
    ],
    "%ReferenceErrorPrototype%": [
      "ReferenceError",
      "prototype"
    ],
    "%RegExpPrototype%": [
      "RegExp",
      "prototype"
    ],
    "%SetPrototype%": [
      "Set",
      "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
      "SharedArrayBuffer",
      "prototype"
    ],
    "%StringPrototype%": [
      "String",
      "prototype"
    ],
    "%SymbolPrototype%": [
      "Symbol",
      "prototype"
    ],
    "%SyntaxErrorPrototype%": [
      "SyntaxError",
      "prototype"
    ],
    "%TypedArrayPrototype%": [
      "TypedArray",
      "prototype"
    ],
    "%TypeErrorPrototype%": [
      "TypeError",
      "prototype"
    ],
    "%Uint8ArrayPrototype%": [
      "Uint8Array",
      "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
      "Uint8ClampedArray",
      "prototype"
    ],
    "%Uint16ArrayPrototype%": [
      "Uint16Array",
      "prototype"
    ],
    "%Uint32ArrayPrototype%": [
      "Uint32Array",
      "prototype"
    ],
    "%URIErrorPrototype%": [
      "URIError",
      "prototype"
    ],
    "%WeakMapPrototype%": [
      "WeakMap",
      "prototype"
    ],
    "%WeakSetPrototype%": [
      "WeakSet",
      "prototype"
    ]
  };
  var $concat = functionBind.call(Function.call, Array.prototype.concat);
  var $spliceApply = functionBind.call(Function.apply, Array.prototype.splice);
  var $replace = functionBind.call(Function.call, String.prototype.replace);
  var $strSlice = functionBind.call(Function.call, String.prototype.slice);
  var $exec = functionBind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%")
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    else if (last === "%" && first !== "%")
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    var result = [];
    $replace(string, rePropName, function(match, number, quote2, subString) {
      result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (src(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (src(INTRINSICS, intrinsicName)) {
      var value2 = INTRINSICS[intrinsicName];
      if (value2 === needsEval)
        value2 = doEval(intrinsicName);
      if (typeof value2 === "undefined" && !allowMissing)
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      return {
        alias,
        name: intrinsicName,
        value: value2
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  var getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0)
      throw new $TypeError("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof allowMissing !== "boolean")
      throw new $TypeError('"allowMissing" argument must be a boolean');
    if ($exec(/^%?[^%]*%?$/, name) === null)
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value2 = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([
        0,
        1
      ], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last)
        throw new $SyntaxError("property names with quotes must have matching quotes");
      if (part === "constructor" || !isOwn)
        skipFurtherCaching = true;
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (src(INTRINSICS, intrinsicRealName))
        value2 = INTRINSICS[intrinsicRealName];
      else if (value2 != null) {
        if (!(part in value2)) {
          if (!allowMissing)
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          return void 0;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value2, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get))
            value2 = desc.get;
          else
            value2 = value2[part];
        } else {
          isOwn = src(value2, part);
          value2 = value2[part];
        }
        if (isOwn && !skipFurtherCaching)
          INTRINSICS[intrinsicRealName] = value2;
      }
    }
    return value2;
  };
  var callBind = createCommonjsModule(function(module) {
    var $apply = getIntrinsic("%Function.prototype.apply%");
    var $call = getIntrinsic("%Function.prototype.call%");
    var $reflectApply = getIntrinsic("%Reflect.apply%", true) || functionBind.call($call, $apply);
    var $gOPD2 = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty2 = getIntrinsic("%Object.defineProperty%", true);
    var $max = getIntrinsic("%Math.max%");
    if ($defineProperty2)
      try {
        $defineProperty2({}, "a", {
          value: 1
        });
      } catch (e) {
        $defineProperty2 = null;
      }
    module.exports = function callBind2(originalFunction) {
      var func = $reflectApply(functionBind, $call, arguments);
      if ($gOPD2 && $defineProperty2) {
        var desc = $gOPD2(func, "length");
        if (desc.configurable)
          $defineProperty2(func, "length", {
            value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
          });
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(functionBind, $apply, arguments);
    };
    if ($defineProperty2)
      $defineProperty2(module.exports, "apply", {
        value: applyBind
      });
    else
      module.exports.apply = applyBind;
  });
  callBind.apply;
  var $indexOf = callBind(getIntrinsic("String.prototype.indexOf"));
  var callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = getIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1)
      return callBind(intrinsic);
    return intrinsic;
  };
  var hasToStringTag = shams$1();
  var $toString = callBound("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value2) {
    if (hasToStringTag && value2 && typeof value2 === "object" && Symbol.toStringTag in value2)
      return false;
    return $toString(value2) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value2) {
    if (isStandardArguments(value2))
      return true;
    return value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && $toString(value2) !== "[object Array]" && $toString(value2.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  var $defineProperty = getIntrinsic("%Object.defineProperty%", true);
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    if ($defineProperty)
      try {
        $defineProperty({}, "a", {
          value: 1
        });
        return true;
      } catch (e) {
        return false;
      }
    return false;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!hasPropertyDescriptors())
      return null;
    try {
      return $defineProperty([], "length", {
        value: 1
      }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  var hasPropertyDescriptors_1 = hasPropertyDescriptors;
  var hasSymbols$2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr$3 = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr$3.call(fn) === "[object Function]";
  };
  var hasPropertyDescriptors$1 = hasPropertyDescriptors_1();
  var supportsDescriptors = origDefineProperty && hasPropertyDescriptors$1;
  var defineProperty = function(object, name, value2, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate()))
      return;
    if (supportsDescriptors)
      origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value: value2,
        writable: true
      });
    else
      object[name] = value2;
  };
  var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = objectKeys(map);
    if (hasSymbols$2)
      props = concat.call(props, Object.getOwnPropertySymbols(map));
    for (var i2 = 0; i2 < props.length; i2 += 1)
      defineProperty(object, props[i2], map[props[i2]], predicates[props[i2]]);
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  var defineProperties_1 = defineProperties;
  var numberIsNaN = function(value2) {
    return value2 !== value2;
  };
  var implementation$2 = function is(a, b2) {
    if (a === 0 && b2 === 0)
      return 1 / a === 1 / b2;
    if (a === b2)
      return true;
    if (numberIsNaN(a) && numberIsNaN(b2))
      return true;
    return false;
  };
  var polyfill = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation$2;
  };
  var shim = function shimObjectIs() {
    var polyfill$12 = polyfill();
    defineProperties_1(Object, {
      is: polyfill$12
    }, {
      is: function testObjectIs() {
        return Object.is !== polyfill$12;
      }
    });
    return polyfill$12;
  };
  var polyfill$1 = callBind(polyfill(), Object);
  defineProperties_1(polyfill$1, {
    getPolyfill: polyfill,
    implementation: implementation$2,
    shim
  });
  var objectIs = polyfill$1;
  var hasToStringTag$1 = shams$1();
  var has$1;
  var $exec$1;
  var isRegexMarker;
  var badStringifier;
  if (hasToStringTag$1) {
    has$1 = callBound("Object.prototype.hasOwnProperty");
    $exec$1 = callBound("RegExp.prototype.exec");
    isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol")
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
  var $toString$1 = callBound("Object.prototype.toString");
  var gOPD = Object.getOwnPropertyDescriptor;
  var regexClass = "[object RegExp]";
  var isRegex = hasToStringTag$1 ? function isRegex2(value2) {
    if (!value2 || typeof value2 !== "object")
      return false;
    var descriptor = gOPD(value2, "lastIndex");
    var hasLastIndexDataProperty = descriptor && has$1(descriptor, "value");
    if (!hasLastIndexDataProperty)
      return false;
    try {
      $exec$1(value2, badStringifier);
    } catch (e) {
      return e === isRegexMarker;
    }
  } : function isRegex2(value2) {
    if (!value2 || typeof value2 !== "object" && typeof value2 !== "function")
      return false;
    return $toString$1(value2) === regexClass;
  };
  var functionsHaveNames = function functionsHaveNames2() {
    return typeof function f() {
    }.name === "string";
  };
  var gOPD$1 = Object.getOwnPropertyDescriptor;
  if (gOPD$1)
    try {
      gOPD$1([], "length");
    } catch (e) {
      gOPD$1 = null;
    }
  functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
    if (!functionsHaveNames() || !gOPD$1)
      return false;
    var desc = gOPD$1(function() {
    }, "name");
    return !!desc && !!desc.configurable;
  };
  var $bind = Function.prototype.bind;
  functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
    return functionsHaveNames() && typeof $bind === "function" && function f() {
    }.bind().name !== "";
  };
  var functionsHaveNames_1 = functionsHaveNames;
  var implementation$3 = createCommonjsModule(function(module) {
    var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();
    var $Object = Object;
    var $TypeError2 = TypeError;
    module.exports = function flags() {
      if (this != null && this !== $Object(this))
        throw new $TypeError2("RegExp.prototype.flags getter called on non-object");
      var result = "";
      if (this.hasIndices)
        result += "d";
      if (this.global)
        result += "g";
      if (this.ignoreCase)
        result += "i";
      if (this.multiline)
        result += "m";
      if (this.dotAll)
        result += "s";
      if (this.unicode)
        result += "u";
      if (this.sticky)
        result += "y";
      return result;
    };
    if (functionsHaveConfigurableNames && Object.defineProperty)
      Object.defineProperty(module.exports, "name", {
        value: "get flags"
      });
  });
  var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  var polyfill$2 = function getPolyfill() {
    if (supportsDescriptors$1 && /a/mig.flags === "gim") {
      var descriptor = $gOPD$1(RegExp.prototype, "flags");
      if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
        var calls = "";
        var o = {};
        Object.defineProperty(o, "hasIndices", {
          get: function() {
            calls += "d";
          }
        });
        Object.defineProperty(o, "sticky", {
          get: function() {
            calls += "y";
          }
        });
        if (calls === "dy")
          return descriptor.get;
      }
    }
    return implementation$3;
  };
  var supportsDescriptors$2 = defineProperties_1.supportsDescriptors;
  var gOPD$2 = Object.getOwnPropertyDescriptor;
  var defineProperty$1 = Object.defineProperty;
  var TypeErr = TypeError;
  var getProto$1 = Object.getPrototypeOf;
  var regex = /a/;
  var shim$1 = function shimFlags() {
    if (!supportsDescriptors$2 || !getProto$1)
      throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
    var polyfill2 = polyfill$2();
    var proto = getProto$1(regex);
    var descriptor = gOPD$2(proto, "flags");
    if (!descriptor || descriptor.get !== polyfill2)
      defineProperty$1(proto, "flags", {
        configurable: true,
        enumerable: false,
        get: polyfill2
      });
    return polyfill2;
  };
  var flagsBound = callBind(polyfill$2());
  defineProperties_1(flagsBound, {
    getPolyfill: polyfill$2,
    implementation: implementation$3,
    shim: shim$1
  });
  var regexp_prototype_flags = flagsBound;
  var toString$1 = {}.toString;
  var isarray = Array.isArray || function(arr) {
    return toString$1.call(arr) == "[object Array]";
  };
  var getDay = Date.prototype.getDay;
  var tryDateObject = function tryDateGetDayCall(value2) {
    try {
      getDay.call(value2);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$4 = Object.prototype.toString;
  var dateClass = "[object Date]";
  var hasToStringTag$2 = shams$1();
  var isDateObject = function isDateObject2(value2) {
    if (typeof value2 !== "object" || value2 === null)
      return false;
    return hasToStringTag$2 ? tryDateObject(value2) : toStr$4.call(value2) === dateClass;
  };
  var strValue = String.prototype.valueOf;
  var tryStringObject = function tryStringObject2(value2) {
    try {
      strValue.call(value2);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$5 = Object.prototype.toString;
  var strClass = "[object String]";
  var hasToStringTag$3 = shams$1();
  var isString = function isString2(value2) {
    if (typeof value2 === "string")
      return true;
    if (typeof value2 !== "object")
      return false;
    return hasToStringTag$3 ? tryStringObject(value2) : toStr$5.call(value2) === strClass;
  };
  var numToStr = Number.prototype.toString;
  var tryNumberObject = function tryNumberObject2(value2) {
    try {
      numToStr.call(value2);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$6 = Object.prototype.toString;
  var numClass = "[object Number]";
  var hasToStringTag$4 = shams$1();
  var isNumberObject = function isNumberObject2(value2) {
    if (typeof value2 === "number")
      return true;
    if (typeof value2 !== "object")
      return false;
    return hasToStringTag$4 ? tryNumberObject(value2) : toStr$6.call(value2) === numClass;
  };
  var $boolToStr = callBound("Boolean.prototype.toString");
  var $toString$2 = callBound("Object.prototype.toString");
  var tryBooleanObject = function booleanBrandCheck(value2) {
    try {
      $boolToStr(value2);
      return true;
    } catch (e) {
      return false;
    }
  };
  var boolClass = "[object Boolean]";
  var hasToStringTag$5 = shams$1();
  var isBooleanObject = function isBoolean2(value2) {
    if (typeof value2 === "boolean")
      return true;
    if (value2 === null || typeof value2 !== "object")
      return false;
    return hasToStringTag$5 && Symbol.toStringTag in value2 ? tryBooleanObject(value2) : $toString$2(value2) === boolClass;
  };
  var isSymbol = createCommonjsModule(function(module) {
    var toStr2 = Object.prototype.toString;
    var hasSymbols$12 = hasSymbols();
    if (hasSymbols$12) {
      var symToStr = Symbol.prototype.toString;
      var symStringRegex = /^Symbol\(.*\)$/;
      var isSymbolObject = function isRealSymbolObject(value2) {
        if (typeof value2.valueOf() !== "symbol")
          return false;
        return symStringRegex.test(symToStr.call(value2));
      };
      module.exports = function isSymbol2(value2) {
        if (typeof value2 === "symbol")
          return true;
        if (toStr2.call(value2) !== "[object Symbol]")
          return false;
        try {
          return isSymbolObject(value2);
        } catch (e) {
          return false;
        }
      };
    } else
      module.exports = function isSymbol2(value2) {
        return false;
      };
  });
  var $BigInt = typeof BigInt !== "undefined" && BigInt;
  var hasBigints = function hasNativeBigInts() {
    return typeof $BigInt === "function" && typeof BigInt === "function" && typeof $BigInt(42) === "bigint" && typeof BigInt(42) === "bigint";
  };
  var isBigint = createCommonjsModule(function(module) {
    var hasBigInts = hasBigints();
    if (hasBigInts) {
      var bigIntValueOf2 = BigInt.prototype.valueOf;
      var tryBigInt = function tryBigIntObject(value2) {
        try {
          bigIntValueOf2.call(value2);
          return true;
        } catch (e) {
        }
        return false;
      };
      module.exports = function isBigInt2(value2) {
        if (value2 === null || typeof value2 === "undefined" || typeof value2 === "boolean" || typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "symbol" || typeof value2 === "function")
          return false;
        if (typeof value2 === "bigint")
          return true;
        return tryBigInt(value2);
      };
    } else
      module.exports = function isBigInt2(value2) {
        return false;
      };
  });
  var whichBoxedPrimitive = function whichBoxedPrimitive2(value2) {
    if (value2 == null || typeof value2 !== "object" && typeof value2 !== "function")
      return null;
    if (isString(value2))
      return "String";
    if (isNumberObject(value2))
      return "Number";
    if (isBooleanObject(value2))
      return "Boolean";
    if (isSymbol(value2))
      return "Symbol";
    if (isBigint(value2))
      return "BigInt";
  };
  var $Map = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set = typeof Set === "function" && Set.prototype ? Set : null;
  var exported;
  if (!$Map)
    exported = function isMap2(x2) {
      return false;
    };
  var $mapHas = $Map ? Map.prototype.has : null;
  var $setHas = $Set ? Set.prototype.has : null;
  if (!exported && !$mapHas)
    exported = function isMap2(x2) {
      return false;
    };
  var isMap = exported || function isMap2(x2) {
    if (!x2 || typeof x2 !== "object")
      return false;
    try {
      $mapHas.call(x2);
      if ($setHas)
        try {
          $setHas.call(x2);
        } catch (e) {
          return true;
        }
      return x2 instanceof $Map;
    } catch (e) {
    }
    return false;
  };
  var $Map$1 = typeof Map === "function" && Map.prototype ? Map : null;
  var $Set$1 = typeof Set === "function" && Set.prototype ? Set : null;
  var exported$1;
  if (!$Set$1)
    exported$1 = function isSet2(x2) {
      return false;
    };
  var $mapHas$1 = $Map$1 ? Map.prototype.has : null;
  var $setHas$1 = $Set$1 ? Set.prototype.has : null;
  if (!exported$1 && !$setHas$1)
    exported$1 = function isSet2(x2) {
      return false;
    };
  var isSet = exported$1 || function isSet2(x2) {
    if (!x2 || typeof x2 !== "object")
      return false;
    try {
      $setHas$1.call(x2);
      if ($mapHas$1)
        try {
          $mapHas$1.call(x2);
        } catch (e) {
          return true;
        }
      return x2 instanceof $Set$1;
    } catch (e) {
    }
    return false;
  };
  var $WeakMap = typeof WeakMap === "function" && WeakMap.prototype ? WeakMap : null;
  var $WeakSet = typeof WeakSet === "function" && WeakSet.prototype ? WeakSet : null;
  var exported$2;
  if (!$WeakMap)
    exported$2 = function isWeakMap2(x2) {
      return false;
    };
  var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
  var $setHas$2 = $WeakSet ? $WeakSet.prototype.has : null;
  if (!exported$2 && !$mapHas$2)
    exported$2 = function isWeakMap2(x2) {
      return false;
    };
  var isWeakmap = exported$2 || function isWeakMap2(x2) {
    if (!x2 || typeof x2 !== "object")
      return false;
    try {
      $mapHas$2.call(x2, $mapHas$2);
      if ($setHas$2)
        try {
          $setHas$2.call(x2, $setHas$2);
        } catch (e) {
          return true;
        }
      return x2 instanceof $WeakMap;
    } catch (e) {
    }
    return false;
  };
  var isWeakset = createCommonjsModule(function(module) {
    var $WeakSet2 = getIntrinsic("%WeakSet%", true);
    var $setHas2 = callBound("WeakSet.prototype.has", true);
    if ($setHas2) {
      var $mapHas2 = callBound("WeakMap.prototype.has", true);
      module.exports = function isWeakSet2(x2) {
        if (!x2 || typeof x2 !== "object")
          return false;
        try {
          $setHas2(x2, $setHas2);
          if ($mapHas2)
            try {
              $mapHas2(x2, $mapHas2);
            } catch (e) {
              return true;
            }
          return x2 instanceof $WeakSet2;
        } catch (e) {
        }
        return false;
      };
    } else
      module.exports = function isWeakSet2(x2) {
        return false;
      };
  });
  var whichCollection = function whichCollection2(value2) {
    if (value2 && typeof value2 === "object") {
      if (isMap(value2))
        return "Map";
      if (isSet(value2))
        return "Set";
      if (isWeakmap(value2))
        return "WeakMap";
      if (isWeakset(value2))
        return "WeakSet";
    }
    return false;
  };
  var $iterator = Symbol.iterator;
  function getIterator(iterable) {
    if (iterable != null && iterable[$iterator] !== void 0)
      return iterable[$iterator]();
  }
  var node$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    "default": getIterator
  });
  var toStr$7 = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag$6 = shams$1();
  var getProto$2 = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag$6)
      return false;
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  var isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function")
      return false;
    if (isFnRegex.test(fnToStr.call(fn)))
      return true;
    if (!hasToStringTag$6) {
      var str = toStr$7.call(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto$2)
      return false;
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? getProto$2(generatorFunc) : false;
    }
    return getProto$2(fn) === GeneratorFunction;
  };
  var fnToStr$1 = Function.prototype.toString;
  var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply === "function" && typeof Object.defineProperty === "function")
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_) {
      if (_ !== isCallableMarker)
        reflectApply = null;
    }
  else
    reflectApply = null;
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value2) {
    try {
      var fnStr = fnToStr$1.call(value2);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value2) {
    try {
      if (isES6ClassFn(value2))
        return false;
      fnToStr$1.call(value2);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr$8 = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag$7 = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [
    ,
  ]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr$8.call(all) === toStr$8.call(document.all))
      isDDA = function isDocumentDotAll(value2) {
        if ((isIE68 || !value2) && (typeof value2 === "undefined" || typeof value2 === "object"))
          try {
            var str = toStr$8.call(value2);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value2("") == null;
          } catch (e) {
          }
        return false;
      };
  }
  var isCallable = reflectApply ? function isCallable2(value2) {
    if (isDDA(value2))
      return true;
    if (!value2)
      return false;
    if (typeof value2 !== "function" && typeof value2 !== "object")
      return false;
    try {
      reflectApply(value2, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker)
        return false;
    }
    return !isES6ClassFn(value2) && tryFunctionObject(value2);
  } : function isCallable2(value2) {
    if (isDDA(value2))
      return true;
    if (!value2)
      return false;
    if (typeof value2 !== "function" && typeof value2 !== "object")
      return false;
    if (hasToStringTag$7)
      return tryFunctionObject(value2);
    if (isES6ClassFn(value2))
      return false;
    var strClass2 = toStr$8.call(value2);
    if (strClass2 !== fnClass && strClass2 !== genClass && !/^\[object HTML/.test(strClass2))
      return false;
    return tryFunctionObject(value2);
  };
  var toStr$9 = Object.prototype.toString;
  var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i2 = 0, len = array.length; i2 < len; i2++)
      if (hasOwnProperty$2.call(array, i2)) {
        if (receiver == null)
          iterator(array[i2], i2, array);
        else
          iterator.call(receiver, array[i2], i2, array);
      }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i2 = 0, len = string.length; i2 < len; i2++)
      if (receiver == null)
        iterator(string.charAt(i2), i2, string);
      else
        iterator.call(receiver, string.charAt(i2), i2, string);
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object)
      if (hasOwnProperty$2.call(object, k)) {
        if (receiver == null)
          iterator(object[k], k, object);
        else
          iterator.call(receiver, object[k], k, object);
      }
  };
  var forEach = function forEach2(list2, iterator, thisArg) {
    if (!isCallable(iterator))
      throw new TypeError("iterator must be a function");
    var receiver;
    if (arguments.length >= 3)
      receiver = thisArg;
    if (toStr$9.call(list2) === "[object Array]")
      forEachArray(list2, iterator, receiver);
    else if (typeof list2 === "string")
      forEachString(list2, iterator, receiver);
    else
      forEachObject(list2, iterator, receiver);
  };
  var forEach_1 = forEach;
  var possibleNames = [
    "BigInt64Array",
    "BigUint64Array",
    "Float32Array",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray"
  ];
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i2 = 0; i2 < possibleNames.length; i2++)
      if (typeof g[possibleNames[i2]] === "function")
        out[out.length] = possibleNames[i2];
    return out;
  };
  var $gOPD$2 = getIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD$2)
    try {
      $gOPD$2([], "length");
    } catch (e) {
      $gOPD$2 = null;
    }
  var getOwnPropertyDescriptor = $gOPD$2;
  var $toString$3 = callBound("Object.prototype.toString");
  var hasToStringTag$8 = shams$1();
  var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays();
  var $indexOf$1 = callBound("Array.prototype.indexOf", true) || function indexOf2(array, value2) {
    for (var i2 = 0; i2 < array.length; i2 += 1) {
      if (array[i2] === value2)
        return i2;
    }
    return -1;
  };
  var $slice = callBound("String.prototype.slice");
  var toStrTags = {};
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag$8 && getOwnPropertyDescriptor && getPrototypeOf)
    forEach_1(typedArrays, function(typedArray) {
      var arr = new g$1[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    });
  var tryTypedArrays = function tryAllTypedArrays(value2) {
    var anyTrue = false;
    forEach_1(toStrTags, function(getter, typedArray) {
      if (!anyTrue)
        try {
          anyTrue = getter.call(value2) === typedArray;
        } catch (e) {
        }
    });
    return anyTrue;
  };
  var isTypedArray = function isTypedArray2(value2) {
    if (!value2 || typeof value2 !== "object")
      return false;
    if (!hasToStringTag$8 || !(Symbol.toStringTag in value2)) {
      var tag2 = $slice($toString$3(value2), 8, -1);
      return $indexOf$1(typedArrays, tag2) > -1;
    }
    if (!getOwnPropertyDescriptor)
      return false;
    return tryTypedArrays(value2);
  };
  var $toString$4 = callBound("Object.prototype.toString");
  var hasToStringTag$9 = shams$1();
  var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays$1 = availableTypedArrays();
  var $slice$1 = callBound("String.prototype.slice");
  var toStrTags$1 = {};
  var getPrototypeOf$1 = Object.getPrototypeOf;
  if (hasToStringTag$9 && getOwnPropertyDescriptor && getPrototypeOf$1)
    forEach_1(typedArrays$1, function(typedArray) {
      if (typeof g$2[typedArray] === "function") {
        var arr = new g$2[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf$1(arr);
          var descriptor = getOwnPropertyDescriptor(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf$1(proto);
            descriptor = getOwnPropertyDescriptor(superProto, Symbol.toStringTag);
          }
          toStrTags$1[typedArray] = descriptor.get;
        }
      }
    });
  var tryTypedArrays$1 = function tryAllTypedArrays(value2) {
    var foundName = false;
    forEach_1(toStrTags$1, function(getter, typedArray) {
      if (!foundName)
        try {
          var name = getter.call(value2);
          if (name === typedArray)
            foundName = name;
        } catch (e) {
        }
    });
    return foundName;
  };
  var whichTypedArray = function whichTypedArray2(value2) {
    if (!isTypedArray(value2))
      return false;
    if (!hasToStringTag$9 || !(Symbol.toStringTag in value2))
      return $slice$1($toString$4(value2), 8, -1);
    return tryTypedArrays$1(value2);
  };
  var types$2 = createCommonjsModule(function(module, exports12) {
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported)
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    if (SymbolSupported)
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    function checkBoxedPrimitive(value2, prototypeValueOf) {
      if (typeof value2 !== "object")
        return false;
      try {
        prototypeValueOf(value2);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports12.isArgumentsObject = isArguments$1;
    exports12.isGeneratorFunction = isGeneratorFunction;
    exports12.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports12.isPromise = isPromise;
    function isArrayBufferView(value2) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView)
        return ArrayBuffer.isView(value2);
      return isTypedArray(value2) || isDataView(value2);
    }
    exports12.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value2) {
      return whichTypedArray(value2) === "Uint8Array";
    }
    exports12.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value2) {
      return whichTypedArray(value2) === "Uint8ClampedArray";
    }
    exports12.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value2) {
      return whichTypedArray(value2) === "Uint16Array";
    }
    exports12.isUint16Array = isUint16Array;
    function isUint32Array(value2) {
      return whichTypedArray(value2) === "Uint32Array";
    }
    exports12.isUint32Array = isUint32Array;
    function isInt8Array(value2) {
      return whichTypedArray(value2) === "Int8Array";
    }
    exports12.isInt8Array = isInt8Array;
    function isInt16Array(value2) {
      return whichTypedArray(value2) === "Int16Array";
    }
    exports12.isInt16Array = isInt16Array;
    function isInt32Array(value2) {
      return whichTypedArray(value2) === "Int32Array";
    }
    exports12.isInt32Array = isInt32Array;
    function isFloat32Array(value2) {
      return whichTypedArray(value2) === "Float32Array";
    }
    exports12.isFloat32Array = isFloat32Array;
    function isFloat64Array(value2) {
      return whichTypedArray(value2) === "Float64Array";
    }
    exports12.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value2) {
      return whichTypedArray(value2) === "BigInt64Array";
    }
    exports12.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value2) {
      return whichTypedArray(value2) === "BigUint64Array";
    }
    exports12.isBigUint64Array = isBigUint64Array;
    function isMapToString(value2) {
      return ObjectToString(value2) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap2(value2) {
      if (typeof Map === "undefined")
        return false;
      return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
    }
    exports12.isMap = isMap2;
    function isSetToString(value2) {
      return ObjectToString(value2) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet2(value2) {
      if (typeof Set === "undefined")
        return false;
      return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
    }
    exports12.isSet = isSet2;
    function isWeakMapToString(value2) {
      return ObjectToString(value2) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap2(value2) {
      if (typeof WeakMap === "undefined")
        return false;
      return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
    }
    exports12.isWeakMap = isWeakMap2;
    function isWeakSetToString(value2) {
      return ObjectToString(value2) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet2(value2) {
      return isWeakSetToString(value2);
    }
    exports12.isWeakSet = isWeakSet2;
    function isArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value2) {
      if (typeof ArrayBuffer === "undefined")
        return false;
      return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
    }
    exports12.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value2) {
      return ObjectToString(value2) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value2) {
      if (typeof DataView === "undefined")
        return false;
      return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
    }
    exports12.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value2) {
      return ObjectToString(value2) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value2) {
      if (typeof SharedArrayBufferCopy === "undefined")
        return false;
      if (typeof isSharedArrayBufferToString.working === "undefined")
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
    }
    exports12.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value2) {
      return ObjectToString(value2) === "[object AsyncFunction]";
    }
    exports12.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value2) {
      return ObjectToString(value2) === "[object Map Iterator]";
    }
    exports12.isMapIterator = isMapIterator;
    function isSetIterator(value2) {
      return ObjectToString(value2) === "[object Set Iterator]";
    }
    exports12.isSetIterator = isSetIterator;
    function isGeneratorObject(value2) {
      return ObjectToString(value2) === "[object Generator]";
    }
    exports12.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value2) {
      return ObjectToString(value2) === "[object WebAssembly.Module]";
    }
    exports12.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject2(value2) {
      return checkBoxedPrimitive(value2, numberValue);
    }
    exports12.isNumberObject = isNumberObject2;
    function isStringObject(value2) {
      return checkBoxedPrimitive(value2, stringValue);
    }
    exports12.isStringObject = isStringObject;
    function isBooleanObject2(value2) {
      return checkBoxedPrimitive(value2, booleanValue);
    }
    exports12.isBooleanObject = isBooleanObject2;
    function isBigIntObject(value2) {
      return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
    }
    exports12.isBigIntObject = isBigIntObject;
    function isSymbolObject(value2) {
      return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
    }
    exports12.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value2) {
      return isNumberObject2(value2) || isStringObject(value2) || isBooleanObject2(value2) || isBigIntObject(value2) || isSymbolObject(value2);
    }
    exports12.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value2) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value2) || isSharedArrayBuffer(value2));
    }
    exports12.isAnyArrayBuffer = isAnyArrayBuffer;
    [
      "isProxy",
      "isExternal",
      "isModuleNamespaceObject"
    ].forEach(function(method) {
      Object.defineProperty(exports12, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  });
  types$2.isArgumentsObject;
  types$2.isGeneratorFunction;
  types$2.isTypedArray;
  types$2.isPromise;
  types$2.isArrayBufferView;
  types$2.isUint8Array;
  types$2.isUint8ClampedArray;
  types$2.isUint16Array;
  types$2.isUint32Array;
  types$2.isInt8Array;
  types$2.isInt16Array;
  types$2.isInt32Array;
  types$2.isFloat32Array;
  types$2.isFloat64Array;
  types$2.isBigInt64Array;
  types$2.isBigUint64Array;
  types$2.isMap;
  types$2.isSet;
  types$2.isWeakMap;
  types$2.isWeakSet;
  types$2.isArrayBuffer;
  types$2.isDataView;
  types$2.isSharedArrayBuffer;
  types$2.isAsyncFunction;
  types$2.isMapIterator;
  types$2.isSetIterator;
  types$2.isGeneratorObject;
  types$2.isWebAssemblyCompiledModule;
  types$2.isNumberObject;
  types$2.isStringObject;
  types$2.isBooleanObject;
  types$2.isBigIntObject;
  types$2.isSymbolObject;
  types$2.isBoxedPrimitive;
  types$2.isAnyArrayBuffer;
  var isBuffer2 = function isBuffer3(arg) {
    return arg instanceof Buffer;
  };
  var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === "function")
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    else
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
  });
  var inherits = createCommonjsModule(function(module) {
    try {
      var util$1 = util;
      if (typeof util$1.inherits !== "function")
        throw "";
      module.exports = util$1.inherits;
    } catch (e) {
      module.exports = inherits_browser;
    }
  });
  var util = createCommonjsModule(function(module, exports12) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i2 = 0; i2 < keys.length; i2++)
        descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports12.format = function(f) {
      if (!isString2(f)) {
        var objects = [];
        for (var i2 = 0; i2 < arguments.length; i2++)
          objects.push(inspect(arguments[i2]));
        return objects.join(" ");
      }
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x3) {
        if (x3 === "%%")
          return "%";
        if (i2 >= len)
          return x3;
        switch (x3) {
          case "%s":
            return String(args[i2++]);
          case "%d":
            return Number(args[i2++]);
          case "%j":
            try {
              return JSON.stringify(args[i2++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x3;
        }
      });
      for (var x2 = args[i2]; i2 < len; x2 = args[++i2])
        if (isNull(x2) || !isObject2(x2))
          str += " " + x2;
        else
          str += " " + inspect(x2);
      return str;
    };
    exports12.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true)
        return fn;
      if (typeof process === "undefined")
        return function() {
          return exports12.deprecate(fn, msg).apply(this, arguments);
        };
      var warned2 = false;
      function deprecated() {
        if (!warned2) {
          if (process.throwDeprecation)
            throw new Error(msg);
          else if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
          warned2 = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    exports12.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports12.format.apply(exports12, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else
          debugs[set] = function() {
          };
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean2(opts))
        ctx.showHidden = opts;
      else if (opts)
        exports12._extend(ctx, opts);
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports12.inspect = inspect;
    inspect.colors = {
      "bold": [
        1,
        22
      ],
      "italic": [
        3,
        23
      ],
      "underline": [
        4,
        24
      ],
      "inverse": [
        7,
        27
      ],
      "white": [
        37,
        39
      ],
      "grey": [
        90,
        39
      ],
      "black": [
        30,
        39
      ],
      "blue": [
        34,
        39
      ],
      "cyan": [
        36,
        39
      ],
      "green": [
        32,
        39
      ],
      "magenta": [
        35,
        39
      ],
      "red": [
        31,
        39
      ],
      "yellow": [
        33,
        39
      ]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style)
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      else
        return str;
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value2, recurseTimes) {
      if (ctx.customInspect && value2 && isFunction2(value2.inspect) && // Filter out the util module, it's inspect function is special
      value2.inspect !== exports12.inspect && // Also filter out any prototype objects using the circular check.
      !(value2.constructor && value2.constructor.prototype === value2)) {
        var ret = value2.inspect(recurseTimes, ctx);
        if (!isString2(ret))
          ret = formatValue(ctx, ret, recurseTimes);
        return ret;
      }
      var primitive = formatPrimitive(ctx, value2);
      if (primitive)
        return primitive;
      var keys = Object.keys(value2);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden)
        keys = Object.getOwnPropertyNames(value2);
      if (isError2(value2) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0))
        return formatError(value2);
      if (keys.length === 0) {
        if (isFunction2(value2)) {
          var name = value2.name ? ": " + value2.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp2(value2))
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        if (isDate2(value2))
          return ctx.stylize(Date.prototype.toString.call(value2), "date");
        if (isError2(value2))
          return formatError(value2);
      }
      var base = "", array = false, braces = [
        "{",
        "}"
      ];
      if (isArray4(value2)) {
        array = true;
        braces = [
          "[",
          "]"
        ];
      }
      if (isFunction2(value2)) {
        var n2 = value2.name ? ": " + value2.name : "";
        base = " [Function" + n2 + "]";
      }
      if (isRegExp2(value2))
        base = " " + RegExp.prototype.toString.call(value2);
      if (isDate2(value2))
        base = " " + Date.prototype.toUTCString.call(value2);
      if (isError2(value2))
        base = " " + formatError(value2);
      if (keys.length === 0 && (!array || value2.length == 0))
        return braces[0] + base + braces[1];
      if (recurseTimes < 0) {
        if (isRegExp2(value2))
          return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
        else
          return ctx.stylize("[Object]", "special");
      }
      ctx.seen.push(value2);
      var output;
      if (array)
        output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys);
      else
        output = keys.map(function(key) {
          return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
        });
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value2) {
      if (isUndefined(value2))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value2)) {
        var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber2(value2))
        return ctx.stylize("" + value2, "number");
      if (isBoolean2(value2))
        return ctx.stylize("" + value2, "boolean");
      if (isNull(value2))
        return ctx.stylize("null", "null");
    }
    function formatError(value2) {
      return "[" + Error.prototype.toString.call(value2) + "]";
    }
    function formatArray(ctx, value2, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i2 = 0, l = value2.length; i2 < l; ++i2)
        if (hasOwnProperty1(value2, String(i2)))
          output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i2), true));
        else
          output.push("");
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/))
          output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key, true));
      });
      return output;
    }
    function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value2, key) || {
        value: value2[key]
      };
      if (desc.get) {
        if (desc.set)
          str = ctx.stylize("[Getter/Setter]", "special");
        else
          str = ctx.stylize("[Getter]", "special");
      } else if (desc.set)
        str = ctx.stylize("[Setter]", "special");
      if (!hasOwnProperty1(visibleKeys, key))
        name = "[" + key + "]";
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes))
            str = formatValue(ctx, desc.value, null);
          else
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          if (str.indexOf("\n") > -1) {
            if (array)
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            else
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
          }
        } else
          str = ctx.stylize("[Circular]", "special");
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/))
          return str;
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        cur.indexOf("\n");
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60)
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports12.types = types$2;
    function isArray4(ar) {
      return Array.isArray(ar);
    }
    exports12.isArray = isArray4;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports12.isBoolean = isBoolean2;
    function isNull(arg) {
      return arg === null;
    }
    exports12.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports12.isNullOrUndefined = isNullOrUndefined;
    function isNumber2(arg) {
      return typeof arg === "number";
    }
    exports12.isNumber = isNumber2;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports12.isString = isString2;
    function isSymbol2(arg) {
      return typeof arg === "symbol";
    }
    exports12.isSymbol = isSymbol2;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports12.isUndefined = isUndefined;
    function isRegExp2(re2) {
      return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
    }
    exports12.isRegExp = isRegExp2;
    exports12.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports12.isObject = isObject2;
    function isDate2(d) {
      return isObject2(d) && objectToString2(d) === "[object Date]";
    }
    exports12.isDate = isDate2;
    exports12.types.isDate = isDate2;
    function isError2(e) {
      return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
    }
    exports12.isError = isError2;
    exports12.types.isNativeError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports12.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports12.isPrimitive = isPrimitive;
    exports12.isBuffer = isBuffer2;
    function objectToString2(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [
        d.getDate(),
        months[d.getMonth()],
        time
      ].join(" ");
    }
    exports12.log = function() {
      console.log("%s - %s", timestamp(), exports12.format.apply(exports12, arguments));
    };
    exports12.inherits = inherits;
    exports12._extend = function(origin, add) {
      if (!add || !isObject2(add))
        return origin;
      var keys = Object.keys(add);
      var i2 = keys.length;
      while (i2--)
        origin[keys[i2]] = add[keys[i2]];
      return origin;
    };
    function hasOwnProperty1(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports12.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++)
          args.push(arguments[i2]);
        args.push(function(err, value2) {
          if (err)
            promiseReject(err);
          else
            promiseResolve(value2);
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports12.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      function callbackified() {
        var args = [];
        for (var i2 = 0; i2 < arguments.length; i2++)
          args.push(arguments[i2]);
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function")
          throw new TypeError("The last argument must be of type Function");
        var self1 = this;
        var cb = function() {
          return maybeCb.apply(self1, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports12.callbackify = callbackify;
  });
  util.format;
  util.deprecate;
  util.debuglog;
  util.inspect;
  util.types;
  util.isArray;
  util.isBoolean;
  util.isNull;
  util.isNullOrUndefined;
  util.isNumber;
  util.isString;
  util.isSymbol;
  util.isUndefined;
  util.isRegExp;
  util.isObject;
  util.isDate;
  util.isError;
  util.isFunction;
  util.isPrimitive;
  util.isBuffer;
  util.log;
  util.inherits;
  util._extend;
  util.promisify;
  util.callbackify;
  var util_inspect = util.inspect;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice$2 = String.prototype.slice;
  var $replace$1 = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat$1 = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable$1 = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str))
      return str;
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice$2.call(str, intStr.length + 1);
        return $replace$1.call(intStr, sepRegex, "$&_") + "." + $replace$1.call($replace$1.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace$1.call(str, sepRegex, "$&_");
  }
  var inspectCustom = util_inspect.custom;
  var inspectSymbol = isSymbol$1(inspectCustom) ? inspectCustom : null;
  var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has$2(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double")
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (has$2(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var customInspect = has$2(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (has$2(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (has$2(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined")
      return "undefined";
    if (obj === null)
      return "null";
    if (typeof obj === "boolean")
      return obj ? "true" : "false";
    if (typeof obj === "string")
      return inspectString(obj, opts);
    if (typeof obj === "number") {
      if (obj === 0)
        return Infinity / obj > 0 ? "0" : "-0";
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined")
      depth = 0;
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object")
      return isArray$1(obj) ? "[Array]" : "[Object]";
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined")
      seen = [];
    else if (indexOf(seen, obj) >= 0)
      return "[Circular]";
    function inspect(value2, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has$2(opts, "quoteStyle"))
          newOpts.quoteStyle = opts.quoteStyle;
        return inspect_(value2, newOpts, depth + 1, seen);
      }
      return inspect_(value2, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol$1(obj)) {
      var symString = hasShammedSymbols ? $replace$1.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement$1(obj)) {
      var s = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++)
        s += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      s += ">";
      if (obj.childNodes && obj.childNodes.length)
        s += "...";
      s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s;
    }
    if (isArray$1(obj)) {
      if (obj.length === 0)
        return "[]";
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs))
        return "[" + indentedJoin(xs, indent) + "]";
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable$1.call(obj, "cause"))
        return "{ [" + String(obj) + "] " + $join.call($concat$1.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      if (parts.length === 0)
        return "[" + String(obj) + "]";
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && util_inspect)
        return util_inspect(obj, {
          depth: maxDepth - depth
        });
      else if (customInspect !== "symbol" && typeof obj.inspect === "function")
        return obj.inspect();
    }
    if (isMap$1(obj)) {
      var mapParts = [];
      mapForEach.call(obj, function(value2, key) {
        mapParts.push(inspect(key, obj, true) + " => " + inspect(value2, obj));
      });
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet$1(obj)) {
      var setParts = [];
      setForEach.call(obj, function(value2) {
        setParts.push(inspect(value2, obj));
      });
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj))
      return weakCollectionOf("WeakMap");
    if (isWeakSet(obj))
      return weakCollectionOf("WeakSet");
    if (isWeakRef(obj))
      return weakCollectionOf("WeakRef");
    if (isNumber(obj))
      return markBoxed(inspect(Number(obj)));
    if (isBigInt(obj))
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    if (isBoolean(obj))
      return markBoxed(booleanValueOf.call(obj));
    if (isString$1(obj))
      return markBoxed(inspect(String(obj)));
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject3 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject3 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice$2.call(toStr$a(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject3 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag2 = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat$1.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0)
        return tag2 + "{}";
      if (indent)
        return tag2 + "{" + indentedJoin(ys, indent) + "}";
      return tag2 + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace$1.call(String(s), /"/g, "&quot;");
  }
  function isArray$1(obj) {
    return toStr$a(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate(obj) {
    return toStr$a(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp(obj) {
    return toStr$a(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError(obj) {
    return toStr$a(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString$1(obj) {
    return toStr$a(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber(obj) {
    return toStr$a(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean(obj) {
    return toStr$a(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol$1(obj) {
    if (hasShammedSymbols)
      return obj && typeof obj === "object" && obj instanceof Symbol;
    if (typeof obj === "symbol")
      return true;
    if (!obj || typeof obj !== "object" || !symToString)
      return false;
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf)
      return false;
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn$1 = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has$2(obj, key) {
    return hasOwn$1.call(obj, key);
  }
  function toStr$a(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f) {
    if (f.name)
      return f.name;
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m)
      return m[1];
    return null;
  }
  function indexOf(xs, x2) {
    if (xs.indexOf)
      return xs.indexOf(x2);
    for (var i2 = 0, l = xs.length; i2 < l; i2++) {
      if (xs[i2] === x2)
        return i2;
    }
    return -1;
  }
  function isMap$1(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object")
      return false;
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object")
      return false;
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x2) {
    if (!weakRefDeref || !x2 || typeof x2 !== "object")
      return false;
    try {
      weakRefDeref.call(x2);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet$1(x2) {
    if (!setSize || !x2 || typeof x2 !== "object")
      return false;
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object")
      return false;
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement$1(x2) {
    if (!x2 || typeof x2 !== "object")
      return false;
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement)
      return true;
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice$2.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var s = $replace$1.call($replace$1.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, "single", opts);
  }
  function lowbyte(c2) {
    var n2 = c2.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x2)
      return "\\" + x2;
    return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i2 = 0; i2 < xs.length; i2++) {
      if (indexOf(xs[i2], "\n") >= 0)
        return false;
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	")
      baseIndent = "	";
    else if (typeof opts.indent === "number" && opts.indent > 0)
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    else
      return null;
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0)
      return "";
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray$1(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++)
        xs[i2] = has$2(obj, i2) ? inspect(obj[i2], obj) : "";
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++)
        symMap["$" + syms[k]] = syms[k];
    }
    for (var key in obj) {
      if (!has$2(obj, key))
        continue;
      if (isArr && String(Number(key)) === key && key < obj.length)
        continue;
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol)
        continue;
      else if ($test.call(/[^\w$]/, key))
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      else
        xs.push(key + ": " + inspect(obj[key], obj));
    }
    if (typeof gOPS === "function") {
      for (var j = 0; j < syms.length; j++)
        if (isEnumerable$1.call(obj, syms[j]))
          xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
    }
    return xs;
  }
  var $TypeError$1 = getIntrinsic("%TypeError%");
  var $WeakMap$1 = getIntrinsic("%WeakMap%", true);
  var $Map$2 = getIntrinsic("%Map%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas$3 = callBound("Map.prototype.has", true);
  var listGetNode = function(list2, key) {
    for (var prev = list2, curr; (curr = prev.next) !== null; prev = curr)
      if (curr.key === key) {
        prev.next = curr.next;
        curr.next = list2.next;
        list2.next = curr;
        return curr;
      }
  };
  var listGet = function(objects, key) {
    var node2 = listGetNode(objects, key);
    return node2 && node2.value;
  };
  var listSet = function(objects, key, value2) {
    var node2 = listGetNode(objects, key);
    if (node2)
      node2.value = value2;
    else
      objects.next = {
        key,
        next: objects.next,
        value: value2
      };
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  var sideChannel = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key))
          throw new $TypeError$1("Side channel does not contain " + objectInspect(key));
      },
      get: function(key) {
        if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm)
            return $weakMapGet($wm, key);
        } else if ($Map$2) {
          if ($m)
            return $mapGet($m, key);
        } else {
          if ($o)
            return listGet($o, key);
        }
      },
      has: function(key) {
        if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm)
            return $weakMapHas($wm, key);
        } else if ($Map$2) {
          if ($m)
            return $mapHas$3($m, key);
        } else {
          if ($o)
            return listHas($o, key);
        }
        return false;
      },
      set: function(key, value2) {
        if ($WeakMap$1 && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm)
            $wm = new $WeakMap$1();
          $weakMapSet($wm, key, value2);
        } else if ($Map$2) {
          if (!$m)
            $m = new $Map$2();
          $mapSet($m, key, value2);
        } else {
          if (!$o)
            $o = {
              key: {},
              next: null
            };
          listSet($o, key, value2);
        }
      }
    };
    return channel;
  };
  var hasSymbols$3 = shams();
  var toObject = Object;
  var $push = callBound("Array.prototype.push");
  var $propIsEnumerable = callBound("Object.prototype.propertyIsEnumerable");
  var originalGetSymbols = hasSymbols$3 ? Object.getOwnPropertySymbols : null;
  var implementation$4 = function assign(target, source1) {
    if (target == null)
      throw new TypeError("target must be an object");
    var to = toObject(target);
    if (arguments.length === 1)
      return to;
    for (var s = 1; s < arguments.length; ++s) {
      var from = toObject(arguments[s]);
      var keys = objectKeys(from);
      var getSymbols = hasSymbols$3 && (Object.getOwnPropertySymbols || originalGetSymbols);
      if (getSymbols) {
        var syms = getSymbols(from);
        for (var j = 0; j < syms.length; ++j) {
          var key = syms[j];
          if ($propIsEnumerable(from, key))
            $push(keys, key);
        }
      }
      for (var i2 = 0; i2 < keys.length; ++i2) {
        var nextKey = keys[i2];
        if ($propIsEnumerable(from, nextKey)) {
          var propValue = from[nextKey];
          to[nextKey] = propValue;
        }
      }
    }
    return to;
  };
  var lacksProperEnumerationOrder = function() {
    if (!Object.assign)
      return false;
    var str = "abcdefghijklmnopqrst";
    var letters = str.split("");
    var map = {};
    for (var i2 = 0; i2 < letters.length; ++i2)
      map[letters[i2]] = letters[i2];
    var obj = Object.assign({}, map);
    var actual = "";
    for (var k in obj)
      actual += k;
    return str !== actual;
  };
  var assignHasPendingExceptions = function() {
    if (!Object.assign || !Object.preventExtensions)
      return false;
    var thrower = Object.preventExtensions({
      1: 2
    });
    try {
      Object.assign(thrower, "xy");
    } catch (e) {
      return thrower[1] === "y";
    }
    return false;
  };
  var polyfill$3 = function getPolyfill() {
    if (!Object.assign)
      return implementation$4;
    if (lacksProperEnumerationOrder())
      return implementation$4;
    if (assignHasPendingExceptions())
      return implementation$4;
    return Object.assign;
  };
  var shim$2 = function shimAssign() {
    var polyfill2 = polyfill$3();
    defineProperties_1(Object, {
      assign: polyfill2
    }, {
      assign: function() {
        return Object.assign !== polyfill2;
      }
    });
    return polyfill2;
  };
  var polyfill$4 = callBind.apply(polyfill$3());
  var bound = function assign(target, source1) {
    return polyfill$4(Object, arguments);
  };
  defineProperties_1(bound, {
    getPolyfill: polyfill$3,
    implementation: implementation$4,
    shim: shim$2
  });
  var object_assign = bound;
  var getIterator$1 = getCjsExportFromNamespace(node$1);
  var $getTime = callBound("Date.prototype.getTime");
  var gPO$1 = Object.getPrototypeOf;
  var $objToString = callBound("Object.prototype.toString");
  var $Set$2 = getIntrinsic("%Set%", true);
  var $mapHas$4 = callBound("Map.prototype.has", true);
  var $mapGet$1 = callBound("Map.prototype.get", true);
  var $mapSize = callBound("Map.prototype.size", true);
  var $setAdd = callBound("Set.prototype.add", true);
  var $setDelete = callBound("Set.prototype.delete", true);
  var $setHas$3 = callBound("Set.prototype.has", true);
  var $setSize = callBound("Set.prototype.size", true);
  function setHasEqualElement(set, val1, opts, channel) {
    var i2 = getIterator$1(set);
    var result;
    while ((result = i2.next()) && !result.done)
      if (internalDeepEqual(val1, result.value, opts, channel)) {
        $setDelete(set, result.value);
        return true;
      }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    if (typeof prim === "undefined")
      return null;
    if (typeof prim === "object")
      return void 0;
    if (typeof prim === "symbol")
      return false;
    if (typeof prim === "string" || typeof prim === "number")
      return +prim === +prim;
    return true;
  }
  function mapMightHaveLoosePrim(a, b2, prim, item, opts, channel) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null)
      return altValue;
    var curB = $mapGet$1(b2, altValue);
    var looseOpts = object_assign({}, opts, {
      strict: false
    });
    if (typeof curB === "undefined" && !$mapHas$4(b2, altValue) || !internalDeepEqual(item, curB, looseOpts, channel))
      return false;
    return !$mapHas$4(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
  }
  function setMightHaveLoosePrim(a, b2, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null)
      return altValue;
    return $setHas$3(b2, altValue) && !$setHas$3(a, altValue);
  }
  function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
    var i2 = getIterator$1(set);
    var result;
    var key2;
    while ((result = i2.next()) && !result.done) {
      key2 = result.value;
      if (
        // eslint-disable-next-line no-use-before-define
        internalDeepEqual(key1, key2, opts, channel) && internalDeepEqual(item1, $mapGet$1(map, key2), opts, channel)
      ) {
        $setDelete(set, key2);
        return true;
      }
    }
    return false;
  }
  function internalDeepEqual(actual, expected, options, channel) {
    var opts = options || {};
    if (opts.strict ? objectIs(actual, expected) : actual === expected)
      return true;
    var actualBoxed = whichBoxedPrimitive(actual);
    var expectedBoxed = whichBoxedPrimitive(expected);
    if (actualBoxed !== expectedBoxed)
      return false;
    if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object")
      return opts.strict ? objectIs(actual, expected) : actual == expected;
    var hasActual = channel.has(actual);
    var hasExpected = channel.has(expected);
    var sentinel;
    if (hasActual && hasExpected) {
      if (channel.get(actual) === channel.get(expected))
        return true;
    } else
      sentinel = {};
    if (!hasActual)
      channel.set(actual, sentinel);
    if (!hasExpected)
      channel.set(expected, sentinel);
    return objEquiv(actual, expected, opts, channel);
  }
  function isBuffer$1(x2) {
    if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number")
      return false;
    if (typeof x2.copy !== "function" || typeof x2.slice !== "function")
      return false;
    if (x2.length > 0 && typeof x2[0] !== "number")
      return false;
    return !!(x2.constructor && x2.constructor.isBuffer && x2.constructor.isBuffer(x2));
  }
  function setEquiv(a, b2, opts, channel) {
    if ($setSize(a) !== $setSize(b2))
      return false;
    var iA = getIterator$1(a);
    var iB = getIterator$1(b2);
    var resultA;
    var resultB;
    var set;
    while ((resultA = iA.next()) && !resultA.done) {
      if (resultA.value && typeof resultA.value === "object") {
        if (!set)
          set = new $Set$2();
        $setAdd(set, resultA.value);
      } else if (!$setHas$3(b2, resultA.value)) {
        if (opts.strict)
          return false;
        if (!setMightHaveLoosePrim(a, b2, resultA.value))
          return false;
        if (!set)
          set = new $Set$2();
        $setAdd(set, resultA.value);
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        if (resultB.value && typeof resultB.value === "object") {
          if (!setHasEqualElement(set, resultB.value, opts.strict, channel))
            return false;
        } else if (!opts.strict && !$setHas$3(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel))
          return false;
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function mapEquiv(a, b2, opts, channel) {
    if ($mapSize(a) !== $mapSize(b2))
      return false;
    var iA = getIterator$1(a);
    var iB = getIterator$1(b2);
    var resultA;
    var resultB;
    var set;
    var key;
    var item1;
    var item2;
    while ((resultA = iA.next()) && !resultA.done) {
      key = resultA.value[0];
      item1 = resultA.value[1];
      if (key && typeof key === "object") {
        if (!set)
          set = new $Set$2();
        $setAdd(set, key);
      } else {
        item2 = $mapGet$1(b2, key);
        if (typeof item2 === "undefined" && !$mapHas$4(b2, key) || !internalDeepEqual(item1, item2, opts, channel)) {
          if (opts.strict)
            return false;
          if (!mapMightHaveLoosePrim(a, b2, key, item1, opts, channel))
            return false;
          if (!set)
            set = new $Set$2();
          $setAdd(set, key);
        }
      }
    }
    if (set) {
      while ((resultB = iB.next()) && !resultB.done) {
        key = resultB.value[0];
        item2 = resultB.value[1];
        if (key && typeof key === "object") {
          if (!mapHasEqualEntry(set, a, key, item2, opts, channel))
            return false;
        } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet$1(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, object_assign({}, opts, {
          strict: false
        }), channel))
          return false;
      }
      return $setSize(set) === 0;
    }
    return true;
  }
  function objEquiv(a, b2, opts, channel) {
    var i2, key;
    if (typeof a !== typeof b2)
      return false;
    if (a == null || b2 == null)
      return false;
    if ($objToString(a) !== $objToString(b2))
      return false;
    if (isArguments$1(a) !== isArguments$1(b2))
      return false;
    var aIsArray = isarray(a);
    var bIsArray = isarray(b2);
    if (aIsArray !== bIsArray)
      return false;
    var aIsError = a instanceof Error;
    var bIsError = b2 instanceof Error;
    if (aIsError !== bIsError)
      return false;
    if (aIsError || bIsError) {
      if (a.name !== b2.name || a.message !== b2.message)
        return false;
    }
    var aIsRegex = isRegex(a);
    var bIsRegex = isRegex(b2);
    if (aIsRegex !== bIsRegex)
      return false;
    if ((aIsRegex || bIsRegex) && (a.source !== b2.source || regexp_prototype_flags(a) !== regexp_prototype_flags(b2)))
      return false;
    var aIsDate = isDateObject(a);
    var bIsDate = isDateObject(b2);
    if (aIsDate !== bIsDate)
      return false;
    if (aIsDate || bIsDate) {
      if ($getTime(a) !== $getTime(b2))
        return false;
    }
    if (opts.strict && gPO$1 && gPO$1(a) !== gPO$1(b2))
      return false;
    if (whichTypedArray(a) !== whichTypedArray(b2))
      return false;
    var aIsBuffer = isBuffer$1(a);
    var bIsBuffer = isBuffer$1(b2);
    if (aIsBuffer !== bIsBuffer)
      return false;
    if (aIsBuffer || bIsBuffer) {
      if (a.length !== b2.length)
        return false;
      for (i2 = 0; i2 < a.length; i2++) {
        if (a[i2] !== b2[i2])
          return false;
      }
      return true;
    }
    if (typeof a !== typeof b2)
      return false;
    var ka = objectKeys(a);
    var kb = objectKeys(b2);
    if (ka.length !== kb.length)
      return false;
    ka.sort();
    kb.sort();
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      if (ka[i2] != kb[i2])
        return false;
    }
    for (i2 = ka.length - 1; i2 >= 0; i2--) {
      key = ka[i2];
      if (!internalDeepEqual(a[key], b2[key], opts, channel))
        return false;
    }
    var aCollection = whichCollection(a);
    var bCollection = whichCollection(b2);
    if (aCollection !== bCollection)
      return false;
    if (aCollection === "Set" || bCollection === "Set")
      return setEquiv(a, b2, opts, channel);
    if (aCollection === "Map")
      return mapEquiv(a, b2, opts, channel);
    return true;
  }
  var deepEqual = function deepEqual2(a, b2, opts) {
    return internalDeepEqual(a, b2, opts, sideChannel());
  };
  var elementRoleMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _deepEqual = _interopRequireDefault(deepEqual);
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
    var _rolesMap = _interopRequireDefault(rolesMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i3) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i3 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i3 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i3++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
        arr2[i3] = arr[i3];
      return arr2;
    }
    var elementRoles = [];
    var keys = _rolesMap.default.keys();
    for (var i2 = 0; i2 < keys.length; i2++) {
      var key = keys[i2];
      var role = _rolesMap.default.get(key);
      if (role) {
        var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (var k = 0; k < concepts.length; k++) {
          var relation = concepts[k];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept)
              (function() {
                var conceptStr = JSON.stringify(concept);
                var elementRoleRelation = elementRoles.find(function(relation2) {
                  return JSON.stringify(relation2[0]) === conceptStr;
                });
                var roles = void 0;
                if (elementRoleRelation)
                  roles = elementRoleRelation[1];
                else
                  roles = [];
                var isUnique = true;
                for (var _i = 0; _i < roles.length; _i++)
                  if (roles[_i] === key) {
                    isUnique = false;
                    break;
                  }
                if (isUnique)
                  roles.push(key);
                elementRoles.push([
                  concept,
                  roles
                ]);
              })();
          }
        }
      }
    }
    var elementRoleMap = {
      entries: function entries() {
        return elementRoles;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(elementRoles), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), _key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, _key, elementRoles);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key2) {
        var item = elementRoles.find(function(tuple) {
          return (0, _deepEqual.default)(key2, tuple[0]);
        });
        return item && item[1];
      },
      has: function has2(key2) {
        return !!this.get(key2);
      },
      keys: function keys2() {
        return elementRoles.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key2 = _ref2[0];
          return key2;
        });
      },
      values: function values() {
        return elementRoles.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementRoleMap, elementRoleMap.entries());
    exports12.default = _default;
  });
  unwrapExports(elementRoleMap_1);
  var roleElementMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1);
    var _rolesMap = _interopRequireDefault(rolesMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i3) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i3) || _unsupportedIterableToArray(arr, i3) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i3) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i3 && _arr.length === i3)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i3 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i3 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i3++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++)
        arr2[i3] = arr[i3];
      return arr2;
    }
    var roleElement = [];
    var keys = _rolesMap.default.keys();
    var _loop = function _loop2(i3) {
      var key = keys[i3];
      var role = _rolesMap.default.get(key);
      if (role) {
        var concepts = [].concat(role.baseConcepts, role.relatedConcepts);
        for (var k = 0; k < concepts.length; k++) {
          var relation = concepts[k];
          if (relation.module === "HTML") {
            var concept = relation.concept;
            if (concept) {
              var roleElementRelation = roleElement.find(function(item) {
                return item[0] === key;
              });
              var relationConcepts = void 0;
              if (roleElementRelation)
                relationConcepts = roleElementRelation[1];
              else
                relationConcepts = [];
              relationConcepts.push(concept);
              roleElement.push([
                key,
                relationConcepts
              ]);
            }
          }
        }
      }
    };
    for (var i2 = 0; i2 < keys.length; i2++)
      _loop(i2);
    var roleElementMap = {
      entries: function entries() {
        return roleElement;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(roleElement), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, roleElement);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = roleElement.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys2() {
        return roleElement.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return roleElement.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(roleElementMap, roleElementMap.entries());
    exports12.default = _default;
  });
  unwrapExports(roleElementMap_1);
  var lib = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.roles = exports12.roleElements = exports12.elementRoles = exports12.dom = exports12.aria = void 0;
    var _ariaPropsMap = _interopRequireDefault(ariaPropsMap_1);
    var _domMap = _interopRequireDefault(domMap_1);
    var _rolesMap = _interopRequireDefault(rolesMap_1);
    var _elementRoleMap = _interopRequireDefault(elementRoleMap_1);
    var _roleElementMap = _interopRequireDefault(roleElementMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var aria = _ariaPropsMap.default;
    exports12.aria = aria;
    var dom2 = _domMap.default;
    exports12.dom = dom2;
    var roles = _rolesMap.default;
    exports12.roles = roles;
    var elementRoles = _elementRoleMap.default;
    exports12.elementRoles = elementRoles;
    var roleElements = _roleElementMap.default;
    exports12.roleElements = roleElements;
  });
  unwrapExports(lib);
  var lib_1 = lib.roles;
  lib.roleElements;
  var lib_3 = lib.elementRoles;
  lib.dom;
  var lib_5 = lib.aria;
  var iteratorProxy_1$1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    function iteratorProxy() {
      var values = this;
      var index = 0;
      var iter = {
        "@@iterator": function iterator() {
          return iter;
        },
        next: function next() {
          if (index < values.length) {
            var value2 = values[index];
            index = index + 1;
            return {
              done: false,
              value: value2
            };
          } else
            return {
              done: true
            };
        }
      };
      return iter;
    }
    var _default = iteratorProxy;
    exports12.default = _default;
  });
  unwrapExports(iteratorProxy_1$1);
  var iterationDecorator_1$1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = iterationDecorator;
    var _iteratorProxy = _interopRequireDefault(iteratorProxy_1$1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function iterationDecorator(collection, entries) {
      if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol")
        Object.defineProperty(collection, Symbol.iterator, {
          value: _iteratorProxy.default.bind(entries)
        });
      return collection;
    }
  });
  unwrapExports(iterationDecorator_1$1);
  var AbbrRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var AbbrRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "abbr"
          }
        }
      ],
      type: "structure"
    };
    var _default = AbbrRole;
    exports12.default = _default;
  });
  unwrapExports(AbbrRole_1);
  var AlertDialogRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var AlertDialogRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "alertdialog"
          }
        }
      ],
      type: "window"
    };
    var _default = AlertDialogRole;
    exports12.default = _default;
  });
  unwrapExports(AlertDialogRole_1);
  var AlertRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var AlertRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "alert"
          }
        }
      ],
      type: "structure"
    };
    var _default = AlertRole;
    exports12.default = _default;
  });
  unwrapExports(AlertRole_1);
  var AnnotationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var AnnotationRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = AnnotationRole;
    exports12.default = _default;
  });
  unwrapExports(AnnotationRole_1);
  var ApplicationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ApplicationRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "application"
          }
        }
      ],
      type: "window"
    };
    var _default = ApplicationRole;
    exports12.default = _default;
  });
  unwrapExports(ApplicationRole_1);
  var ArticleRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ArticleRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "article"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "article"
          }
        }
      ],
      type: "structure"
    };
    var _default = ArticleRole;
    exports12.default = _default;
  });
  unwrapExports(ArticleRole_1);
  var AudioRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var AudioRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "audio"
          }
        }
      ],
      type: "widget"
    };
    var _default = AudioRole;
    exports12.default = _default;
  });
  unwrapExports(AudioRole_1);
  var BannerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var BannerRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "banner"
          }
        }
      ],
      type: "structure"
    };
    var _default = BannerRole;
    exports12.default = _default;
  });
  unwrapExports(BannerRole_1);
  var BlockquoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var BlockquoteRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "blockquote"
          }
        }
      ],
      type: "structure"
    };
    var _default = BlockquoteRole;
    exports12.default = _default;
  });
  unwrapExports(BlockquoteRole_1);
  var BusyIndicatorRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var BusyIndicatorRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            attributes: [
              {
                name: "aria-busy",
                value: "true"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = BusyIndicatorRole;
    exports12.default = _default;
  });
  unwrapExports(BusyIndicatorRole_1);
  var ButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ButtonRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "button"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "button"
          }
        }
      ],
      type: "widget"
    };
    var _default = ButtonRole;
    exports12.default = _default;
  });
  unwrapExports(ButtonRole_1);
  var CanvasRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var CanvasRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "canvas"
          }
        }
      ],
      type: "widget"
    };
    var _default = CanvasRole;
    exports12.default = _default;
  });
  unwrapExports(CanvasRole_1);
  var CaptionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var CaptionRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "caption"
          }
        }
      ],
      type: "structure"
    };
    var _default = CaptionRole;
    exports12.default = _default;
  });
  unwrapExports(CaptionRole_1);
  var CellRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var CellRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "cell"
          }
        },
        {
          module: "ARIA",
          concept: {
            name: "gridcell"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "td"
          }
        }
      ],
      type: "widget"
    };
    var _default = CellRole;
    exports12.default = _default;
  });
  unwrapExports(CellRole_1);
  var CheckBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var CheckBoxRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "checkbox"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "checkbox"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = CheckBoxRole;
    exports12.default = _default;
  });
  unwrapExports(CheckBoxRole_1);
  var ColorWellRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ColorWellRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "color"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = ColorWellRole;
    exports12.default = _default;
  });
  unwrapExports(ColorWellRole_1);
  var ColumnHeaderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ColumnHeaderRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "columnheader"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "th"
          }
        }
      ],
      type: "widget"
    };
    var _default = ColumnHeaderRole;
    exports12.default = _default;
  });
  unwrapExports(ColumnHeaderRole_1);
  var ColumnRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ColumnRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ColumnRole;
    exports12.default = _default;
  });
  unwrapExports(ColumnRole_1);
  var ComboBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ComboBoxRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "combobox"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "select"
          }
        }
      ],
      type: "widget"
    };
    var _default = ComboBoxRole;
    exports12.default = _default;
  });
  unwrapExports(ComboBoxRole_1);
  var ComplementaryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ComplementaryRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "complementary"
          }
        }
      ],
      type: "structure"
    };
    var _default = ComplementaryRole;
    exports12.default = _default;
  });
  unwrapExports(ComplementaryRole_1);
  var ContentInfoRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ContentInfoRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "structureinfo"
          }
        }
      ],
      type: "structure"
    };
    var _default = ContentInfoRole;
    exports12.default = _default;
  });
  unwrapExports(ContentInfoRole_1);
  var DateRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DateRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "date"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = DateRole;
    exports12.default = _default;
  });
  unwrapExports(DateRole_1);
  var DateTimeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DateTimeRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "datetime"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = DateTimeRole;
    exports12.default = _default;
  });
  unwrapExports(DateTimeRole_1);
  var DefinitionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DefinitionRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "dfn"
          }
        }
      ],
      type: "structure"
    };
    var _default = DefinitionRole;
    exports12.default = _default;
  });
  unwrapExports(DefinitionRole_1);
  var DescriptionListDetailRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DescriptionListDetailRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "dd"
          }
        }
      ],
      type: "structure"
    };
    var _default = DescriptionListDetailRole;
    exports12.default = _default;
  });
  unwrapExports(DescriptionListDetailRole_1);
  var DescriptionListRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DescriptionListRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "dl"
          }
        }
      ],
      type: "structure"
    };
    var _default = DescriptionListRole;
    exports12.default = _default;
  });
  unwrapExports(DescriptionListRole_1);
  var DescriptionListTermRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DescriptionListTermRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "dt"
          }
        }
      ],
      type: "structure"
    };
    var _default = DescriptionListTermRole;
    exports12.default = _default;
  });
  unwrapExports(DescriptionListTermRole_1);
  var DetailsRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DetailsRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "details"
          }
        }
      ],
      type: "structure"
    };
    var _default = DetailsRole;
    exports12.default = _default;
  });
  unwrapExports(DetailsRole_1);
  var DialogRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DialogRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "dialog"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "dialog"
          }
        }
      ],
      type: "window"
    };
    var _default = DialogRole;
    exports12.default = _default;
  });
  unwrapExports(DialogRole_1);
  var DirectoryRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DirectoryRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "directory"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "dir"
          }
        }
      ],
      type: "structure"
    };
    var _default = DirectoryRole;
    exports12.default = _default;
  });
  unwrapExports(DirectoryRole_1);
  var DisclosureTriangleRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DisclosureTriangleRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "summary"
          }
        }
      ],
      type: "widget"
    };
    var _default = DisclosureTriangleRole;
    exports12.default = _default;
  });
  unwrapExports(DisclosureTriangleRole_1);
  var DivRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DivRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "div"
          }
        }
      ],
      type: "generic"
    };
    var _default = DivRole;
    exports12.default = _default;
  });
  unwrapExports(DivRole_1);
  var DocumentRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var DocumentRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "document"
          }
        }
      ],
      type: "structure"
    };
    var _default = DocumentRole;
    exports12.default = _default;
  });
  unwrapExports(DocumentRole_1);
  var EmbeddedObjectRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var EmbeddedObjectRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "embed"
          }
        }
      ],
      type: "widget"
    };
    var _default = EmbeddedObjectRole;
    exports12.default = _default;
  });
  unwrapExports(EmbeddedObjectRole_1);
  var FeedRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var FeedRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "feed"
          }
        }
      ],
      type: "structure"
    };
    var _default = FeedRole;
    exports12.default = _default;
  });
  unwrapExports(FeedRole_1);
  var FigcaptionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var FigcaptionRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "figcaption"
          }
        }
      ],
      type: "structure"
    };
    var _default = FigcaptionRole;
    exports12.default = _default;
  });
  unwrapExports(FigcaptionRole_1);
  var FigureRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var FigureRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "figure"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "figure"
          }
        }
      ],
      type: "structure"
    };
    var _default = FigureRole;
    exports12.default = _default;
  });
  unwrapExports(FigureRole_1);
  var FooterRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var FooterRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "footer"
          }
        }
      ],
      type: "structure"
    };
    var _default = FooterRole;
    exports12.default = _default;
  });
  unwrapExports(FooterRole_1);
  var FormRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var FormRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "form"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "form"
          }
        }
      ],
      type: "structure"
    };
    var _default = FormRole;
    exports12.default = _default;
  });
  unwrapExports(FormRole_1);
  var GridRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var GridRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "grid"
          }
        }
      ],
      type: "widget"
    };
    var _default = GridRole;
    exports12.default = _default;
  });
  unwrapExports(GridRole_1);
  var GroupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var GroupRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "group"
          }
        }
      ],
      type: "structure"
    };
    var _default = GroupRole;
    exports12.default = _default;
  });
  unwrapExports(GroupRole_1);
  var HeadingRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var HeadingRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "heading"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h1"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h2"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h3"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h4"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h5"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "h6"
          }
        }
      ],
      type: "structure"
    };
    var _default = HeadingRole;
    exports12.default = _default;
  });
  unwrapExports(HeadingRole_1);
  var IframePresentationalRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var IframePresentationalRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = IframePresentationalRole;
    exports12.default = _default;
  });
  unwrapExports(IframePresentationalRole_1);
  var IframeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var IframeRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "iframe"
          }
        }
      ],
      type: "window"
    };
    var _default = IframeRole;
    exports12.default = _default;
  });
  unwrapExports(IframeRole_1);
  var IgnoredRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var IgnoredRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = IgnoredRole;
    exports12.default = _default;
  });
  unwrapExports(IgnoredRole_1);
  var ImageMapLinkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ImageMapLinkRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = ImageMapLinkRole;
    exports12.default = _default;
  });
  unwrapExports(ImageMapLinkRole_1);
  var ImageMapRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ImageMapRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "img",
            attributes: [
              {
                name: "usemap"
              }
            ]
          }
        }
      ],
      type: "structure"
    };
    var _default = ImageMapRole;
    exports12.default = _default;
  });
  unwrapExports(ImageMapRole_1);
  var ImageRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ImageRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "img"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "img"
          }
        }
      ],
      type: "structure"
    };
    var _default = ImageRole;
    exports12.default = _default;
  });
  unwrapExports(ImageRole_1);
  var InlineTextBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var InlineTextBoxRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "input"
          }
        }
      ],
      type: "widget"
    };
    var _default = InlineTextBoxRole;
    exports12.default = _default;
  });
  unwrapExports(InlineTextBoxRole_1);
  var InputTimeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var InputTimeRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "time"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = InputTimeRole;
    exports12.default = _default;
  });
  unwrapExports(InputTimeRole_1);
  var LabelRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var LabelRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "label"
          }
        }
      ],
      type: "structure"
    };
    var _default = LabelRole;
    exports12.default = _default;
  });
  unwrapExports(LabelRole_1);
  var LegendRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var LegendRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "legend"
          }
        }
      ],
      type: "structure"
    };
    var _default = LegendRole;
    exports12.default = _default;
  });
  unwrapExports(LegendRole_1);
  var LineBreakRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var LineBreakRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "br"
          }
        }
      ],
      type: "structure"
    };
    var _default = LineBreakRole;
    exports12.default = _default;
  });
  unwrapExports(LineBreakRole_1);
  var LinkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var LinkRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "link"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "a",
            attributes: [
              {
                name: "href"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = LinkRole;
    exports12.default = _default;
  });
  unwrapExports(LinkRole_1);
  var ListBoxOptionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ListBoxOptionRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "option"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "option"
          }
        }
      ],
      type: "widget"
    };
    var _default = ListBoxOptionRole;
    exports12.default = _default;
  });
  unwrapExports(ListBoxOptionRole_1);
  var ListBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ListBoxRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "listbox"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "datalist"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "select"
          }
        }
      ],
      type: "widget"
    };
    var _default = ListBoxRole;
    exports12.default = _default;
  });
  unwrapExports(ListBoxRole_1);
  var ListItemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ListItemRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "listitem"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "li"
          }
        }
      ],
      type: "structure"
    };
    var _default = ListItemRole;
    exports12.default = _default;
  });
  unwrapExports(ListItemRole_1);
  var ListMarkerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ListMarkerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ListMarkerRole;
    exports12.default = _default;
  });
  unwrapExports(ListMarkerRole_1);
  var ListRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ListRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "list"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "ul"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "ol"
          }
        }
      ],
      type: "structure"
    };
    var _default = ListRole;
    exports12.default = _default;
  });
  unwrapExports(ListRole_1);
  var LogRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var LogRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "log"
          }
        }
      ],
      type: "structure"
    };
    var _default = LogRole;
    exports12.default = _default;
  });
  unwrapExports(LogRole_1);
  var MainRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MainRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "main"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "main"
          }
        }
      ],
      type: "structure"
    };
    var _default = MainRole;
    exports12.default = _default;
  });
  unwrapExports(MainRole_1);
  var MarkRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MarkRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "mark"
          }
        }
      ],
      type: "structure"
    };
    var _default = MarkRole;
    exports12.default = _default;
  });
  unwrapExports(MarkRole_1);
  var MarqueeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MarqueeRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "marquee"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "marquee"
          }
        }
      ],
      type: "structure"
    };
    var _default = MarqueeRole;
    exports12.default = _default;
  });
  unwrapExports(MarqueeRole_1);
  var MathRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MathRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "math"
          }
        }
      ],
      type: "structure"
    };
    var _default = MathRole;
    exports12.default = _default;
  });
  unwrapExports(MathRole_1);
  var MenuBarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuBarRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "menubar"
          }
        }
      ],
      type: "structure"
    };
    var _default = MenuBarRole;
    exports12.default = _default;
  });
  unwrapExports(MenuBarRole_1);
  var MenuButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuButtonRole;
    exports12.default = _default;
  });
  unwrapExports(MenuButtonRole_1);
  var MenuItemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuItemRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "menuitem"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "menuitem"
          }
        }
      ],
      type: "widget"
    };
    var _default = MenuItemRole;
    exports12.default = _default;
  });
  unwrapExports(MenuItemRole_1);
  var MenuItemCheckBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuItemCheckBoxRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "menuitemcheckbox"
          }
        }
      ],
      type: "widget"
    };
    var _default = MenuItemCheckBoxRole;
    exports12.default = _default;
  });
  unwrapExports(MenuItemCheckBoxRole_1);
  var MenuItemRadioRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuItemRadioRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "menuitemradio"
          }
        }
      ],
      type: "widget"
    };
    var _default = MenuItemRadioRole;
    exports12.default = _default;
  });
  unwrapExports(MenuItemRadioRole_1);
  var MenuListOptionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuListOptionRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListOptionRole;
    exports12.default = _default;
  });
  unwrapExports(MenuListOptionRole_1);
  var MenuListPopupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuListPopupRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = MenuListPopupRole;
    exports12.default = _default;
  });
  unwrapExports(MenuListPopupRole_1);
  var MenuRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MenuRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "menu"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "menu"
          }
        }
      ],
      type: "structure"
    };
    var _default = MenuRole;
    exports12.default = _default;
  });
  unwrapExports(MenuRole_1);
  var MeterRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var MeterRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "meter"
          }
        }
      ],
      type: "structure"
    };
    var _default = MeterRole;
    exports12.default = _default;
  });
  unwrapExports(MeterRole_1);
  var NavigationRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var NavigationRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "navigation"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "nav"
          }
        }
      ],
      type: "structure"
    };
    var _default = NavigationRole;
    exports12.default = _default;
  });
  unwrapExports(NavigationRole_1);
  var NoneRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var NoneRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "none"
          }
        }
      ],
      type: "structure"
    };
    var _default = NoneRole;
    exports12.default = _default;
  });
  unwrapExports(NoneRole_1);
  var NoteRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var NoteRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "note"
          }
        }
      ],
      type: "structure"
    };
    var _default = NoteRole;
    exports12.default = _default;
  });
  unwrapExports(NoteRole_1);
  var OutlineRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var OutlineRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = OutlineRole;
    exports12.default = _default;
  });
  unwrapExports(OutlineRole_1);
  var ParagraphRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ParagraphRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "p"
          }
        }
      ],
      type: "structure"
    };
    var _default = ParagraphRole;
    exports12.default = _default;
  });
  unwrapExports(ParagraphRole_1);
  var PopUpButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var PopUpButtonRole = {
      relatedConcepts: [],
      type: "widget"
    };
    var _default = PopUpButtonRole;
    exports12.default = _default;
  });
  unwrapExports(PopUpButtonRole_1);
  var PreRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var PreRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "pre"
          }
        }
      ],
      type: "structure"
    };
    var _default = PreRole;
    exports12.default = _default;
  });
  unwrapExports(PreRole_1);
  var PresentationalRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var PresentationalRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "presentation"
          }
        }
      ],
      type: "structure"
    };
    var _default = PresentationalRole;
    exports12.default = _default;
  });
  unwrapExports(PresentationalRole_1);
  var ProgressIndicatorRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ProgressIndicatorRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "progressbar"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "progress"
          }
        }
      ],
      type: "structure"
    };
    var _default = ProgressIndicatorRole;
    exports12.default = _default;
  });
  unwrapExports(ProgressIndicatorRole_1);
  var RadioButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RadioButtonRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "radio"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "radio"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = RadioButtonRole;
    exports12.default = _default;
  });
  unwrapExports(RadioButtonRole_1);
  var RadioGroupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RadioGroupRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "radiogroup"
          }
        }
      ],
      type: "structure"
    };
    var _default = RadioGroupRole;
    exports12.default = _default;
  });
  unwrapExports(RadioGroupRole_1);
  var RegionRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RegionRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "region"
          }
        }
      ],
      type: "structure"
    };
    var _default = RegionRole;
    exports12.default = _default;
  });
  unwrapExports(RegionRole_1);
  var RootWebAreaRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RootWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RootWebAreaRole;
    exports12.default = _default;
  });
  unwrapExports(RootWebAreaRole_1);
  var RowHeaderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RowHeaderRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "rowheader"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "th",
            attributes: [
              {
                name: "scope",
                value: "row"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = RowHeaderRole;
    exports12.default = _default;
  });
  unwrapExports(RowHeaderRole_1);
  var RowRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RowRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "row"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "tr"
          }
        }
      ],
      type: "structure"
    };
    var _default = RowRole;
    exports12.default = _default;
  });
  unwrapExports(RowRole_1);
  var RubyRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RubyRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "ruby"
          }
        }
      ],
      type: "structure"
    };
    var _default = RubyRole;
    exports12.default = _default;
  });
  unwrapExports(RubyRole_1);
  var RulerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var RulerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = RulerRole;
    exports12.default = _default;
  });
  unwrapExports(RulerRole_1);
  var ScrollAreaRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ScrollAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = ScrollAreaRole;
    exports12.default = _default;
  });
  unwrapExports(ScrollAreaRole_1);
  var ScrollBarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ScrollBarRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "scrollbar"
          }
        }
      ],
      type: "widget"
    };
    var _default = ScrollBarRole;
    exports12.default = _default;
  });
  unwrapExports(ScrollBarRole_1);
  var SeamlessWebAreaRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SeamlessWebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SeamlessWebAreaRole;
    exports12.default = _default;
  });
  unwrapExports(SeamlessWebAreaRole_1);
  var SearchRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SearchRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "search"
          }
        }
      ],
      type: "structure"
    };
    var _default = SearchRole;
    exports12.default = _default;
  });
  unwrapExports(SearchRole_1);
  var SearchBoxRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SearchBoxRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "searchbox"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "search"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = SearchBoxRole;
    exports12.default = _default;
  });
  unwrapExports(SearchBoxRole_1);
  var SliderRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SliderRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "slider"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "range"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = SliderRole;
    exports12.default = _default;
  });
  unwrapExports(SliderRole_1);
  var SliderThumbRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SliderThumbRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SliderThumbRole;
    exports12.default = _default;
  });
  unwrapExports(SliderThumbRole_1);
  var SpinButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SpinButtonRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "spinbutton"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "number"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = SpinButtonRole;
    exports12.default = _default;
  });
  unwrapExports(SpinButtonRole_1);
  var SpinButtonPartRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SpinButtonPartRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SpinButtonPartRole;
    exports12.default = _default;
  });
  unwrapExports(SpinButtonPartRole_1);
  var SplitterRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SplitterRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "separator"
          }
        }
      ],
      type: "widget"
    };
    var _default = SplitterRole;
    exports12.default = _default;
  });
  unwrapExports(SplitterRole_1);
  var StaticTextRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var StaticTextRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = StaticTextRole;
    exports12.default = _default;
  });
  unwrapExports(StaticTextRole_1);
  var StatusRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var StatusRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "status"
          }
        }
      ],
      type: "structure"
    };
    var _default = StatusRole;
    exports12.default = _default;
  });
  unwrapExports(StatusRole_1);
  var SVGRootRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SVGRootRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = SVGRootRole;
    exports12.default = _default;
  });
  unwrapExports(SVGRootRole_1);
  var SwitchRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var SwitchRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "switch"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "checkbox"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = SwitchRole;
    exports12.default = _default;
  });
  unwrapExports(SwitchRole_1);
  var TabGroupRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TabGroupRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tablist"
          }
        }
      ],
      type: "structure"
    };
    var _default = TabGroupRole;
    exports12.default = _default;
  });
  unwrapExports(TabGroupRole_1);
  var TabRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TabRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tab"
          }
        }
      ],
      type: "widget"
    };
    var _default = TabRole;
    exports12.default = _default;
  });
  unwrapExports(TabRole_1);
  var TableHeaderContainerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TableHeaderContainerRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = TableHeaderContainerRole;
    exports12.default = _default;
  });
  unwrapExports(TableHeaderContainerRole_1);
  var TableRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TableRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "table"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "table"
          }
        }
      ],
      type: "structure"
    };
    var _default = TableRole;
    exports12.default = _default;
  });
  unwrapExports(TableRole_1);
  var TabListRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TabListRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tablist"
          }
        }
      ],
      type: "structure"
    };
    var _default = TabListRole;
    exports12.default = _default;
  });
  unwrapExports(TabListRole_1);
  var TabPanelRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TabPanelRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tabpanel"
          }
        }
      ],
      type: "structure"
    };
    var _default = TabPanelRole;
    exports12.default = _default;
  });
  unwrapExports(TabPanelRole_1);
  var TermRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TermRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "term"
          }
        }
      ],
      type: "structure"
    };
    var _default = TermRole;
    exports12.default = _default;
  });
  unwrapExports(TermRole_1);
  var TextFieldRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TextFieldRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "textbox"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input"
          }
        },
        {
          module: "HTML",
          concept: {
            name: "input",
            attributes: [
              {
                name: "type",
                value: "text"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = TextFieldRole;
    exports12.default = _default;
  });
  unwrapExports(TextFieldRole_1);
  var TimeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TimeRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "time"
          }
        }
      ],
      type: "structure"
    };
    var _default = TimeRole;
    exports12.default = _default;
  });
  unwrapExports(TimeRole_1);
  var TimerRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TimerRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "timer"
          }
        }
      ],
      type: "structure"
    };
    var _default = TimerRole;
    exports12.default = _default;
  });
  unwrapExports(TimerRole_1);
  var ToggleButtonRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ToggleButtonRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            attributes: [
              {
                name: "aria-pressed"
              }
            ]
          }
        }
      ],
      type: "widget"
    };
    var _default = ToggleButtonRole;
    exports12.default = _default;
  });
  unwrapExports(ToggleButtonRole_1);
  var ToolbarRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var ToolbarRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "toolbar"
          }
        }
      ],
      type: "structure"
    };
    var _default = ToolbarRole;
    exports12.default = _default;
  });
  unwrapExports(ToolbarRole_1);
  var TreeRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TreeRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tree"
          }
        }
      ],
      type: "widget"
    };
    var _default = TreeRole;
    exports12.default = _default;
  });
  unwrapExports(TreeRole_1);
  var TreeGridRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TreeGridRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "treegrid"
          }
        }
      ],
      type: "widget"
    };
    var _default = TreeGridRole;
    exports12.default = _default;
  });
  unwrapExports(TreeGridRole_1);
  var TreeItemRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var TreeItemRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "treeitem"
          }
        }
      ],
      type: "widget"
    };
    var _default = TreeItemRole;
    exports12.default = _default;
  });
  unwrapExports(TreeItemRole_1);
  var UserInterfaceTooltipRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var UserInterfaceTooltipRole = {
      relatedConcepts: [
        {
          module: "ARIA",
          concept: {
            name: "tooltip"
          }
        }
      ],
      type: "structure"
    };
    var _default = UserInterfaceTooltipRole;
    exports12.default = _default;
  });
  unwrapExports(UserInterfaceTooltipRole_1);
  var VideoRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var VideoRole = {
      relatedConcepts: [
        {
          module: "HTML",
          concept: {
            name: "video"
          }
        }
      ],
      type: "widget"
    };
    var _default = VideoRole;
    exports12.default = _default;
  });
  unwrapExports(VideoRole_1);
  var WebAreaRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var WebAreaRole = {
      relatedConcepts: [],
      type: "structure"
    };
    var _default = WebAreaRole;
    exports12.default = _default;
  });
  unwrapExports(WebAreaRole_1);
  var WindowRole_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var WindowRole = {
      relatedConcepts: [],
      type: "window"
    };
    var _default = WindowRole;
    exports12.default = _default;
  });
  unwrapExports(WindowRole_1);
  var AXObjectsMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
    var _AbbrRole = _interopRequireDefault(AbbrRole_1);
    var _AlertDialogRole = _interopRequireDefault(AlertDialogRole_1);
    var _AlertRole = _interopRequireDefault(AlertRole_1);
    var _AnnotationRole = _interopRequireDefault(AnnotationRole_1);
    var _ApplicationRole = _interopRequireDefault(ApplicationRole_1);
    var _ArticleRole = _interopRequireDefault(ArticleRole_1);
    var _AudioRole = _interopRequireDefault(AudioRole_1);
    var _BannerRole = _interopRequireDefault(BannerRole_1);
    var _BlockquoteRole = _interopRequireDefault(BlockquoteRole_1);
    var _BusyIndicatorRole = _interopRequireDefault(BusyIndicatorRole_1);
    var _ButtonRole = _interopRequireDefault(ButtonRole_1);
    var _CanvasRole = _interopRequireDefault(CanvasRole_1);
    var _CaptionRole = _interopRequireDefault(CaptionRole_1);
    var _CellRole = _interopRequireDefault(CellRole_1);
    var _CheckBoxRole = _interopRequireDefault(CheckBoxRole_1);
    var _ColorWellRole = _interopRequireDefault(ColorWellRole_1);
    var _ColumnHeaderRole = _interopRequireDefault(ColumnHeaderRole_1);
    var _ColumnRole = _interopRequireDefault(ColumnRole_1);
    var _ComboBoxRole = _interopRequireDefault(ComboBoxRole_1);
    var _ComplementaryRole = _interopRequireDefault(ComplementaryRole_1);
    var _ContentInfoRole = _interopRequireDefault(ContentInfoRole_1);
    var _DateRole = _interopRequireDefault(DateRole_1);
    var _DateTimeRole = _interopRequireDefault(DateTimeRole_1);
    var _DefinitionRole = _interopRequireDefault(DefinitionRole_1);
    var _DescriptionListDetailRole = _interopRequireDefault(DescriptionListDetailRole_1);
    var _DescriptionListRole = _interopRequireDefault(DescriptionListRole_1);
    var _DescriptionListTermRole = _interopRequireDefault(DescriptionListTermRole_1);
    var _DetailsRole = _interopRequireDefault(DetailsRole_1);
    var _DialogRole = _interopRequireDefault(DialogRole_1);
    var _DirectoryRole = _interopRequireDefault(DirectoryRole_1);
    var _DisclosureTriangleRole = _interopRequireDefault(DisclosureTriangleRole_1);
    var _DivRole = _interopRequireDefault(DivRole_1);
    var _DocumentRole = _interopRequireDefault(DocumentRole_1);
    var _EmbeddedObjectRole = _interopRequireDefault(EmbeddedObjectRole_1);
    var _FeedRole = _interopRequireDefault(FeedRole_1);
    var _FigcaptionRole = _interopRequireDefault(FigcaptionRole_1);
    var _FigureRole = _interopRequireDefault(FigureRole_1);
    var _FooterRole = _interopRequireDefault(FooterRole_1);
    var _FormRole = _interopRequireDefault(FormRole_1);
    var _GridRole = _interopRequireDefault(GridRole_1);
    var _GroupRole = _interopRequireDefault(GroupRole_1);
    var _HeadingRole = _interopRequireDefault(HeadingRole_1);
    var _IframePresentationalRole = _interopRequireDefault(IframePresentationalRole_1);
    var _IframeRole = _interopRequireDefault(IframeRole_1);
    var _IgnoredRole = _interopRequireDefault(IgnoredRole_1);
    var _ImageMapLinkRole = _interopRequireDefault(ImageMapLinkRole_1);
    var _ImageMapRole = _interopRequireDefault(ImageMapRole_1);
    var _ImageRole = _interopRequireDefault(ImageRole_1);
    var _InlineTextBoxRole = _interopRequireDefault(InlineTextBoxRole_1);
    var _InputTimeRole = _interopRequireDefault(InputTimeRole_1);
    var _LabelRole = _interopRequireDefault(LabelRole_1);
    var _LegendRole = _interopRequireDefault(LegendRole_1);
    var _LineBreakRole = _interopRequireDefault(LineBreakRole_1);
    var _LinkRole = _interopRequireDefault(LinkRole_1);
    var _ListBoxOptionRole = _interopRequireDefault(ListBoxOptionRole_1);
    var _ListBoxRole = _interopRequireDefault(ListBoxRole_1);
    var _ListItemRole = _interopRequireDefault(ListItemRole_1);
    var _ListMarkerRole = _interopRequireDefault(ListMarkerRole_1);
    var _ListRole = _interopRequireDefault(ListRole_1);
    var _LogRole = _interopRequireDefault(LogRole_1);
    var _MainRole = _interopRequireDefault(MainRole_1);
    var _MarkRole = _interopRequireDefault(MarkRole_1);
    var _MarqueeRole = _interopRequireDefault(MarqueeRole_1);
    var _MathRole = _interopRequireDefault(MathRole_1);
    var _MenuBarRole = _interopRequireDefault(MenuBarRole_1);
    var _MenuButtonRole = _interopRequireDefault(MenuButtonRole_1);
    var _MenuItemRole = _interopRequireDefault(MenuItemRole_1);
    var _MenuItemCheckBoxRole = _interopRequireDefault(MenuItemCheckBoxRole_1);
    var _MenuItemRadioRole = _interopRequireDefault(MenuItemRadioRole_1);
    var _MenuListOptionRole = _interopRequireDefault(MenuListOptionRole_1);
    var _MenuListPopupRole = _interopRequireDefault(MenuListPopupRole_1);
    var _MenuRole = _interopRequireDefault(MenuRole_1);
    var _MeterRole = _interopRequireDefault(MeterRole_1);
    var _NavigationRole = _interopRequireDefault(NavigationRole_1);
    var _NoneRole = _interopRequireDefault(NoneRole_1);
    var _NoteRole = _interopRequireDefault(NoteRole_1);
    var _OutlineRole = _interopRequireDefault(OutlineRole_1);
    var _ParagraphRole = _interopRequireDefault(ParagraphRole_1);
    var _PopUpButtonRole = _interopRequireDefault(PopUpButtonRole_1);
    var _PreRole = _interopRequireDefault(PreRole_1);
    var _PresentationalRole = _interopRequireDefault(PresentationalRole_1);
    var _ProgressIndicatorRole = _interopRequireDefault(ProgressIndicatorRole_1);
    var _RadioButtonRole = _interopRequireDefault(RadioButtonRole_1);
    var _RadioGroupRole = _interopRequireDefault(RadioGroupRole_1);
    var _RegionRole = _interopRequireDefault(RegionRole_1);
    var _RootWebAreaRole = _interopRequireDefault(RootWebAreaRole_1);
    var _RowHeaderRole = _interopRequireDefault(RowHeaderRole_1);
    var _RowRole = _interopRequireDefault(RowRole_1);
    var _RubyRole = _interopRequireDefault(RubyRole_1);
    var _RulerRole = _interopRequireDefault(RulerRole_1);
    var _ScrollAreaRole = _interopRequireDefault(ScrollAreaRole_1);
    var _ScrollBarRole = _interopRequireDefault(ScrollBarRole_1);
    var _SeamlessWebAreaRole = _interopRequireDefault(SeamlessWebAreaRole_1);
    var _SearchRole = _interopRequireDefault(SearchRole_1);
    var _SearchBoxRole = _interopRequireDefault(SearchBoxRole_1);
    var _SliderRole = _interopRequireDefault(SliderRole_1);
    var _SliderThumbRole = _interopRequireDefault(SliderThumbRole_1);
    var _SpinButtonRole = _interopRequireDefault(SpinButtonRole_1);
    var _SpinButtonPartRole = _interopRequireDefault(SpinButtonPartRole_1);
    var _SplitterRole = _interopRequireDefault(SplitterRole_1);
    var _StaticTextRole = _interopRequireDefault(StaticTextRole_1);
    var _StatusRole = _interopRequireDefault(StatusRole_1);
    var _SVGRootRole = _interopRequireDefault(SVGRootRole_1);
    var _SwitchRole = _interopRequireDefault(SwitchRole_1);
    var _TabGroupRole = _interopRequireDefault(TabGroupRole_1);
    var _TabRole = _interopRequireDefault(TabRole_1);
    var _TableHeaderContainerRole = _interopRequireDefault(TableHeaderContainerRole_1);
    var _TableRole = _interopRequireDefault(TableRole_1);
    var _TabListRole = _interopRequireDefault(TabListRole_1);
    var _TabPanelRole = _interopRequireDefault(TabPanelRole_1);
    var _TermRole = _interopRequireDefault(TermRole_1);
    var _TextFieldRole = _interopRequireDefault(TextFieldRole_1);
    var _TimeRole = _interopRequireDefault(TimeRole_1);
    var _TimerRole = _interopRequireDefault(TimerRole_1);
    var _ToggleButtonRole = _interopRequireDefault(ToggleButtonRole_1);
    var _ToolbarRole = _interopRequireDefault(ToolbarRole_1);
    var _TreeRole = _interopRequireDefault(TreeRole_1);
    var _TreeGridRole = _interopRequireDefault(TreeGridRole_1);
    var _TreeItemRole = _interopRequireDefault(TreeItemRole_1);
    var _UserInterfaceTooltipRole = _interopRequireDefault(UserInterfaceTooltipRole_1);
    var _VideoRole = _interopRequireDefault(VideoRole_1);
    var _WebAreaRole = _interopRequireDefault(WebAreaRole_1);
    var _WindowRole = _interopRequireDefault(WindowRole_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var AXObjects = [
      [
        "AbbrRole",
        _AbbrRole.default
      ],
      [
        "AlertDialogRole",
        _AlertDialogRole.default
      ],
      [
        "AlertRole",
        _AlertRole.default
      ],
      [
        "AnnotationRole",
        _AnnotationRole.default
      ],
      [
        "ApplicationRole",
        _ApplicationRole.default
      ],
      [
        "ArticleRole",
        _ArticleRole.default
      ],
      [
        "AudioRole",
        _AudioRole.default
      ],
      [
        "BannerRole",
        _BannerRole.default
      ],
      [
        "BlockquoteRole",
        _BlockquoteRole.default
      ],
      [
        "BusyIndicatorRole",
        _BusyIndicatorRole.default
      ],
      [
        "ButtonRole",
        _ButtonRole.default
      ],
      [
        "CanvasRole",
        _CanvasRole.default
      ],
      [
        "CaptionRole",
        _CaptionRole.default
      ],
      [
        "CellRole",
        _CellRole.default
      ],
      [
        "CheckBoxRole",
        _CheckBoxRole.default
      ],
      [
        "ColorWellRole",
        _ColorWellRole.default
      ],
      [
        "ColumnHeaderRole",
        _ColumnHeaderRole.default
      ],
      [
        "ColumnRole",
        _ColumnRole.default
      ],
      [
        "ComboBoxRole",
        _ComboBoxRole.default
      ],
      [
        "ComplementaryRole",
        _ComplementaryRole.default
      ],
      [
        "ContentInfoRole",
        _ContentInfoRole.default
      ],
      [
        "DateRole",
        _DateRole.default
      ],
      [
        "DateTimeRole",
        _DateTimeRole.default
      ],
      [
        "DefinitionRole",
        _DefinitionRole.default
      ],
      [
        "DescriptionListDetailRole",
        _DescriptionListDetailRole.default
      ],
      [
        "DescriptionListRole",
        _DescriptionListRole.default
      ],
      [
        "DescriptionListTermRole",
        _DescriptionListTermRole.default
      ],
      [
        "DetailsRole",
        _DetailsRole.default
      ],
      [
        "DialogRole",
        _DialogRole.default
      ],
      [
        "DirectoryRole",
        _DirectoryRole.default
      ],
      [
        "DisclosureTriangleRole",
        _DisclosureTriangleRole.default
      ],
      [
        "DivRole",
        _DivRole.default
      ],
      [
        "DocumentRole",
        _DocumentRole.default
      ],
      [
        "EmbeddedObjectRole",
        _EmbeddedObjectRole.default
      ],
      [
        "FeedRole",
        _FeedRole.default
      ],
      [
        "FigcaptionRole",
        _FigcaptionRole.default
      ],
      [
        "FigureRole",
        _FigureRole.default
      ],
      [
        "FooterRole",
        _FooterRole.default
      ],
      [
        "FormRole",
        _FormRole.default
      ],
      [
        "GridRole",
        _GridRole.default
      ],
      [
        "GroupRole",
        _GroupRole.default
      ],
      [
        "HeadingRole",
        _HeadingRole.default
      ],
      [
        "IframePresentationalRole",
        _IframePresentationalRole.default
      ],
      [
        "IframeRole",
        _IframeRole.default
      ],
      [
        "IgnoredRole",
        _IgnoredRole.default
      ],
      [
        "ImageMapLinkRole",
        _ImageMapLinkRole.default
      ],
      [
        "ImageMapRole",
        _ImageMapRole.default
      ],
      [
        "ImageRole",
        _ImageRole.default
      ],
      [
        "InlineTextBoxRole",
        _InlineTextBoxRole.default
      ],
      [
        "InputTimeRole",
        _InputTimeRole.default
      ],
      [
        "LabelRole",
        _LabelRole.default
      ],
      [
        "LegendRole",
        _LegendRole.default
      ],
      [
        "LineBreakRole",
        _LineBreakRole.default
      ],
      [
        "LinkRole",
        _LinkRole.default
      ],
      [
        "ListBoxOptionRole",
        _ListBoxOptionRole.default
      ],
      [
        "ListBoxRole",
        _ListBoxRole.default
      ],
      [
        "ListItemRole",
        _ListItemRole.default
      ],
      [
        "ListMarkerRole",
        _ListMarkerRole.default
      ],
      [
        "ListRole",
        _ListRole.default
      ],
      [
        "LogRole",
        _LogRole.default
      ],
      [
        "MainRole",
        _MainRole.default
      ],
      [
        "MarkRole",
        _MarkRole.default
      ],
      [
        "MarqueeRole",
        _MarqueeRole.default
      ],
      [
        "MathRole",
        _MathRole.default
      ],
      [
        "MenuBarRole",
        _MenuBarRole.default
      ],
      [
        "MenuButtonRole",
        _MenuButtonRole.default
      ],
      [
        "MenuItemRole",
        _MenuItemRole.default
      ],
      [
        "MenuItemCheckBoxRole",
        _MenuItemCheckBoxRole.default
      ],
      [
        "MenuItemRadioRole",
        _MenuItemRadioRole.default
      ],
      [
        "MenuListOptionRole",
        _MenuListOptionRole.default
      ],
      [
        "MenuListPopupRole",
        _MenuListPopupRole.default
      ],
      [
        "MenuRole",
        _MenuRole.default
      ],
      [
        "MeterRole",
        _MeterRole.default
      ],
      [
        "NavigationRole",
        _NavigationRole.default
      ],
      [
        "NoneRole",
        _NoneRole.default
      ],
      [
        "NoteRole",
        _NoteRole.default
      ],
      [
        "OutlineRole",
        _OutlineRole.default
      ],
      [
        "ParagraphRole",
        _ParagraphRole.default
      ],
      [
        "PopUpButtonRole",
        _PopUpButtonRole.default
      ],
      [
        "PreRole",
        _PreRole.default
      ],
      [
        "PresentationalRole",
        _PresentationalRole.default
      ],
      [
        "ProgressIndicatorRole",
        _ProgressIndicatorRole.default
      ],
      [
        "RadioButtonRole",
        _RadioButtonRole.default
      ],
      [
        "RadioGroupRole",
        _RadioGroupRole.default
      ],
      [
        "RegionRole",
        _RegionRole.default
      ],
      [
        "RootWebAreaRole",
        _RootWebAreaRole.default
      ],
      [
        "RowHeaderRole",
        _RowHeaderRole.default
      ],
      [
        "RowRole",
        _RowRole.default
      ],
      [
        "RubyRole",
        _RubyRole.default
      ],
      [
        "RulerRole",
        _RulerRole.default
      ],
      [
        "ScrollAreaRole",
        _ScrollAreaRole.default
      ],
      [
        "ScrollBarRole",
        _ScrollBarRole.default
      ],
      [
        "SeamlessWebAreaRole",
        _SeamlessWebAreaRole.default
      ],
      [
        "SearchRole",
        _SearchRole.default
      ],
      [
        "SearchBoxRole",
        _SearchBoxRole.default
      ],
      [
        "SliderRole",
        _SliderRole.default
      ],
      [
        "SliderThumbRole",
        _SliderThumbRole.default
      ],
      [
        "SpinButtonRole",
        _SpinButtonRole.default
      ],
      [
        "SpinButtonPartRole",
        _SpinButtonPartRole.default
      ],
      [
        "SplitterRole",
        _SplitterRole.default
      ],
      [
        "StaticTextRole",
        _StaticTextRole.default
      ],
      [
        "StatusRole",
        _StatusRole.default
      ],
      [
        "SVGRootRole",
        _SVGRootRole.default
      ],
      [
        "SwitchRole",
        _SwitchRole.default
      ],
      [
        "TabGroupRole",
        _TabGroupRole.default
      ],
      [
        "TabRole",
        _TabRole.default
      ],
      [
        "TableHeaderContainerRole",
        _TableHeaderContainerRole.default
      ],
      [
        "TableRole",
        _TableRole.default
      ],
      [
        "TabListRole",
        _TabListRole.default
      ],
      [
        "TabPanelRole",
        _TabPanelRole.default
      ],
      [
        "TermRole",
        _TermRole.default
      ],
      [
        "TextFieldRole",
        _TextFieldRole.default
      ],
      [
        "TimeRole",
        _TimeRole.default
      ],
      [
        "TimerRole",
        _TimerRole.default
      ],
      [
        "ToggleButtonRole",
        _ToggleButtonRole.default
      ],
      [
        "ToolbarRole",
        _ToolbarRole.default
      ],
      [
        "TreeRole",
        _TreeRole.default
      ],
      [
        "TreeGridRole",
        _TreeGridRole.default
      ],
      [
        "TreeItemRole",
        _TreeItemRole.default
      ],
      [
        "UserInterfaceTooltipRole",
        _UserInterfaceTooltipRole.default
      ],
      [
        "VideoRole",
        _VideoRole.default
      ],
      [
        "WebAreaRole",
        _WebAreaRole.default
      ],
      [
        "WindowRole",
        _WindowRole.default
      ]
    ];
    var AXObjectsMap = {
      entries: function entries() {
        return AXObjects;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator = _createForOfIteratorHelper(AXObjects), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], values = _step$value[1];
            fn.call(thisArg, values, key, AXObjects);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      get: function get(key) {
        var item = AXObjects.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return AXObjects.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjects.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectsMap, AXObjectsMap.entries());
    exports12.default = _default;
  });
  unwrapExports(AXObjectsMap_1);
  var AXObjectElementMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
    var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var AXObjectElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
    try {
      var _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts))
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                  return key === name;
                });
                if (index === -1) {
                  AXObjectElements.push([
                    name,
                    []
                  ]);
                  index = AXObjectElements.length - 1;
                }
                AXObjectElements[index][1].push(concept);
              }
            }
          });
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; )
        _loop();
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var AXObjectElementMap = {
      entries: function entries() {
        return AXObjectElements;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, AXObjectElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = AXObjectElements.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return AXObjectElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjectElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectElementMap, AXObjectElementMap.entries());
    exports12.default = _default;
  });
  unwrapExports(AXObjectElementMap_1);
  var AXObjectRoleMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
    var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var AXObjectRoleElements = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
    try {
      var _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts))
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "ARIA") {
              var concept = relation.concept;
              if (concept) {
                var index = AXObjectRoleElements.findIndex(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), key = _ref6[0];
                  return key === name;
                });
                if (index === -1) {
                  AXObjectRoleElements.push([
                    name,
                    []
                  ]);
                  index = AXObjectRoleElements.length - 1;
                }
                AXObjectRoleElements[index][1].push(concept);
              }
            }
          });
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; )
        _loop();
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var AXObjectRoleMap = {
      entries: function entries() {
        return AXObjectRoleElements;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(AXObjectRoleElements), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, AXObjectRoleElements);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = AXObjectRoleElements.find(function(tuple) {
          return tuple[0] === key ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return AXObjectRoleElements.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return AXObjectRoleElements.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(AXObjectRoleMap, AXObjectRoleMap.entries());
    exports12.default = _default;
  });
  unwrapExports(AXObjectRoleMap_1);
  var elementAXObjectMap_1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.default = void 0;
    var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
    var _deepEqual = _interopRequireDefault(deepEqual);
    var _iterationDecorator = _interopRequireDefault(iterationDecorator_1$1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i2 = 0;
          var F2 = function F3() {
          };
          return {
            s: F2,
            n: function n2() {
              if (i2 >= o.length)
                return {
                  done: true
                };
              return {
                done: false,
                value: o[i2++]
              };
            },
            e: function e(_e2) {
              throw _e2;
            },
            f: F2
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return {
        s: function s() {
          it = it.call(o);
        },
        n: function n2() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function e(_e3) {
          didErr = true;
          err = _e3;
        },
        f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        }
      };
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    var elementAXObjects = [];
    var _iterator = _createForOfIteratorHelper(_AXObjectsMap.default.entries()), _step;
    try {
      var _loop = function _loop2() {
        var _step$value = _slicedToArray(_step.value, 2), name = _step$value[0], def = _step$value[1];
        var relatedConcepts = def.relatedConcepts;
        if (Array.isArray(relatedConcepts))
          relatedConcepts.forEach(function(relation) {
            if (relation.module === "HTML") {
              var concept = relation.concept;
              if (concept != null) {
                var conceptStr = JSON.stringify(concept);
                var axObjects;
                var index = 0;
                for (; index < elementAXObjects.length; index++) {
                  var key = elementAXObjects[index][0];
                  if (JSON.stringify(key) === conceptStr) {
                    axObjects = elementAXObjects[index][1];
                    break;
                  }
                }
                if (!Array.isArray(axObjects))
                  axObjects = [];
                var loc = axObjects.findIndex(function(item) {
                  return item === name;
                });
                if (loc === -1)
                  axObjects.push(name);
                if (index < elementAXObjects.length)
                  elementAXObjects.splice(index, 1, [
                    concept,
                    axObjects
                  ]);
                else
                  elementAXObjects.push([
                    concept,
                    axObjects
                  ]);
              }
            }
          });
      };
      for (_iterator.s(); !(_step = _iterator.n()).done; )
        _loop();
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var elementAXObjectMap = {
      entries: function entries() {
        return elementAXObjects;
      },
      forEach: function forEach2(fn) {
        var thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var _iterator2 = _createForOfIteratorHelper(elementAXObjects), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], values = _step2$value[1];
            fn.call(thisArg, values, key, elementAXObjects);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      },
      get: function get(key) {
        var item = elementAXObjects.find(function(tuple) {
          return (0, _deepEqual.default)(key, tuple[0]) ? true : false;
        });
        return item && item[1];
      },
      has: function has2(key) {
        return !!this.get(key);
      },
      keys: function keys() {
        return elementAXObjects.map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 1), key = _ref2[0];
          return key;
        });
      },
      values: function values() {
        return elementAXObjects.map(function(_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2), values2 = _ref4[1];
          return values2;
        });
      }
    };
    var _default = (0, _iterationDecorator.default)(elementAXObjectMap, elementAXObjectMap.entries());
    exports12.default = _default;
  });
  unwrapExports(elementAXObjectMap_1);
  var lib$1 = createCommonjsModule(function(module, exports12) {
    Object.defineProperty(exports12, "__esModule", {
      value: true
    });
    exports12.elementAXObjects = exports12.AXObjects = exports12.AXObjectRoles = exports12.AXObjectElements = void 0;
    var _AXObjectElementMap = _interopRequireDefault(AXObjectElementMap_1);
    var _AXObjectRoleMap = _interopRequireDefault(AXObjectRoleMap_1);
    var _AXObjectsMap = _interopRequireDefault(AXObjectsMap_1);
    var _elementAXObjectMap = _interopRequireDefault(elementAXObjectMap_1);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AXObjectElements = _AXObjectElementMap.default;
    exports12.AXObjectElements = AXObjectElements;
    var AXObjectRoles = _AXObjectRoleMap.default;
    exports12.AXObjectRoles = AXObjectRoles;
    var AXObjects = _AXObjectsMap.default;
    exports12.AXObjects = AXObjects;
    var elementAXObjects = _elementAXObjectMap.default;
    exports12.elementAXObjects = elementAXObjects;
  });
  unwrapExports(lib$1);
  var lib_1$1 = lib$1.elementAXObjects;
  var lib_2$1 = lib$1.AXObjects;
  var lib_3$1 = lib$1.AXObjectRoles;
  lib$1.AXObjectElements;
  const non_abstract_roles = [
    ...lib_1.keys()
  ].filter((name) => !lib_1.get(name).abstract);
  const non_interactive_roles = new Set(non_abstract_roles.filter((name) => {
    const role = lib_1.get(name);
    return (
      // 'toolbar' does not descend from widget, but it does support
      // aria-activedescendant, thus in practice we treat it as a widget.
      // focusable tabpanel elements are recommended if any panels in a set contain content where the first element in the panel is not focusable.
      ![
        "toolbar",
        "tabpanel"
      ].includes(name) && !role.superClass.some((classes) => classes.includes("widget"))
    );
  }).concat(
    // The `progressbar` is descended from `widget`, but in practice, its
    // value is always `readonly`, so we treat it as a non-interactive role.
    "progressbar"
  ));
  const interactive_roles = new Set(non_abstract_roles.filter((name) => !non_interactive_roles.has(name)));
  function is_non_interactive_roles(role) {
    return non_interactive_roles.has(role);
  }
  function is_interactive_roles(role) {
    return interactive_roles.has(role);
  }
  const presentation_roles = /* @__PURE__ */ new Set([
    "presentation",
    "none"
  ]);
  function is_presentation_role(role) {
    return presentation_roles.has(role);
  }
  function is_hidden_from_screen_reader(tag_name, attribute_map) {
    var _a;
    if (tag_name === "input") {
      const type = (_a = attribute_map.get("type")) === null || _a === void 0 ? void 0 : _a.get_static_value();
      if (type && type === "hidden")
        return true;
    }
    const aria_hidden = attribute_map.get("aria-hidden");
    if (!aria_hidden)
      return false;
    if (!aria_hidden.is_static)
      return true;
    const aria_hidden_value = aria_hidden.get_static_value();
    return aria_hidden_value === true || aria_hidden_value === "true";
  }
  const non_interactive_element_role_schemas = [];
  lib_3.entries().forEach(([schema, roles]) => {
    if ([
      ...roles
    ].every((role) => non_interactive_roles.has(role)))
      non_interactive_element_role_schemas.push(schema);
  });
  const interactive_element_role_schemas = [];
  lib_3.entries().forEach(([schema, roles]) => {
    if ([
      ...roles
    ].every((role) => interactive_roles.has(role)))
      interactive_element_role_schemas.push(schema);
  });
  const interactive_ax_objects = new Set([
    ...lib_2$1.keys()
  ].filter((name) => lib_2$1.get(name).type === "widget"));
  const interactive_element_ax_object_schemas = [];
  lib_1$1.entries().forEach(([schema, ax_object]) => {
    if ([
      ...ax_object
    ].every((role) => interactive_ax_objects.has(role)))
      interactive_element_ax_object_schemas.push(schema);
  });
  function match_schema(schema, tag_name, attribute_map) {
    if (schema.name !== tag_name)
      return false;
    if (!schema.attributes)
      return true;
    return schema.attributes.every((schema_attribute) => {
      const attribute = attribute_map.get(schema_attribute.name);
      if (!attribute)
        return false;
      if (schema_attribute.value && schema_attribute.value !== attribute.get_static_value())
        return false;
      return true;
    });
  }
  function is_interactive_element(tag_name, attribute_map) {
    if (interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map)))
      return true;
    if (non_interactive_element_role_schemas.some((schema) => match_schema(schema, tag_name, attribute_map)))
      return false;
    if (interactive_element_ax_object_schemas.some((schema) => match_schema(schema, tag_name, attribute_map)))
      return true;
    return false;
  }
  function is_semantic_role_element(role, tag_name, attribute_map) {
    for (const [schema, ax_object] of lib_1$1.entries()) {
      if (schema.name === tag_name && (!schema.attributes || schema.attributes.every((attr) => attribute_map.has(attr.name) && attribute_map.get(attr.name).get_static_value() === attr.value)))
        for (const name of ax_object) {
          const roles = lib_3$1.get(name);
          if (roles)
            for (const { name: name2 } of roles) {
              if (name2 === role)
                return true;
            }
        }
    }
    return false;
  }
  const aria_attributes = "activedescendant atomic autocomplete busy checked colcount colindex colspan controls current describedby description details disabled dropeffect errormessage expanded flowto grabbed haspopup hidden invalid keyshortcuts label labelledby level live modal multiline multiselectable orientation owns placeholder posinset pressed readonly relevant required roledescription rowcount rowindex rowspan selected setsize sort valuemax valuemin valuenow valuetext".split(" ");
  const aria_attribute_set = new Set(aria_attributes);
  const aria_roles = lib_1.keys();
  const aria_role_set = new Set(aria_roles);
  const aria_role_abstract_set = new Set(lib_1.keys().filter((role) => lib_1.get(role).abstract));
  const a11y_required_attributes = {
    a: [
      "href"
    ],
    area: [
      "alt",
      "aria-label",
      "aria-labelledby"
    ],
    // html-has-lang
    html: [
      "lang"
    ],
    // iframe-has-title
    iframe: [
      "title"
    ],
    img: [
      "alt"
    ],
    object: [
      "title",
      "aria-label",
      "aria-labelledby"
    ]
  };
  const a11y_distracting_elements = /* @__PURE__ */ new Set([
    "blink",
    "marquee"
  ]);
  const a11y_required_content = /* @__PURE__ */ new Set([
    // anchor-has-content
    "a",
    // heading-has-content
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6"
  ]);
  const a11y_labelable = /* @__PURE__ */ new Set([
    "button",
    "input",
    "keygen",
    "meter",
    "output",
    "progress",
    "select",
    "textarea"
  ]);
  const a11y_nested_implicit_semantics = /* @__PURE__ */ new Map([
    [
      "header",
      "banner"
    ],
    [
      "footer",
      "contentinfo"
    ]
  ]);
  const a11y_implicit_semantics = /* @__PURE__ */ new Map([
    [
      "a",
      "link"
    ],
    [
      "aside",
      "complementary"
    ],
    [
      "body",
      "document"
    ],
    [
      "datalist",
      "listbox"
    ],
    [
      "dd",
      "definition"
    ],
    [
      "dfn",
      "term"
    ],
    [
      "details",
      "group"
    ],
    [
      "dt",
      "term"
    ],
    [
      "fieldset",
      "group"
    ],
    [
      "form",
      "form"
    ],
    [
      "h1",
      "heading"
    ],
    [
      "h2",
      "heading"
    ],
    [
      "h3",
      "heading"
    ],
    [
      "h4",
      "heading"
    ],
    [
      "h5",
      "heading"
    ],
    [
      "h6",
      "heading"
    ],
    [
      "hr",
      "separator"
    ],
    [
      "li",
      "listitem"
    ],
    [
      "menu",
      "list"
    ],
    [
      "nav",
      "navigation"
    ],
    [
      "ol",
      "list"
    ],
    [
      "optgroup",
      "group"
    ],
    [
      "output",
      "status"
    ],
    [
      "progress",
      "progressbar"
    ],
    [
      "section",
      "region"
    ],
    [
      "summary",
      "button"
    ],
    [
      "tbody",
      "rowgroup"
    ],
    [
      "textarea",
      "textbox"
    ],
    [
      "tfoot",
      "rowgroup"
    ],
    [
      "thead",
      "rowgroup"
    ],
    [
      "tr",
      "row"
    ],
    [
      "ul",
      "list"
    ]
  ]);
  const invisible_elements = /* @__PURE__ */ new Set([
    "meta",
    "html",
    "script",
    "style"
  ]);
  const valid_modifiers$1 = /* @__PURE__ */ new Set([
    "preventDefault",
    "stopPropagation",
    "capture",
    "once",
    "passive",
    "nonpassive",
    "self",
    "trusted"
  ]);
  const passive_events = /* @__PURE__ */ new Set([
    "wheel",
    "touchstart",
    "touchmove",
    "touchend",
    "touchcancel"
  ]);
  const react_attributes = /* @__PURE__ */ new Map([
    [
      "className",
      "class"
    ],
    [
      "htmlFor",
      "for"
    ]
  ]);
  const attributes_to_compact_whitespace = [
    "class",
    "style"
  ];
  function is_parent(parent, elements) {
    let check = false;
    while (parent) {
      const parent_name = parent.name;
      if (elements.includes(parent_name)) {
        check = true;
        break;
      }
      if (parent.type === "Element")
        break;
      parent = parent.parent;
    }
    return check;
  }
  function get_namespace(parent, element, explicit_namespace) {
    const parent_element = parent.find_nearest(/^Element/);
    if (!parent_element)
      return explicit_namespace || (is_svg(element.name) ? namespaces.svg : null);
    if (parent_element.namespace !== namespaces.foreign) {
      if (is_svg(element.name.toLowerCase()))
        return namespaces.svg;
      if (parent_element.name.toLowerCase() === "foreignobject")
        return null;
    }
    return parent_element.namespace;
  }
  function is_valid_aria_attribute_value(schema, value2) {
    switch (schema.type) {
      case "boolean":
        return typeof value2 === "boolean";
      case "string":
      case "id":
        return typeof value2 === "string";
      case "tristate":
        return typeof value2 === "boolean" || value2 === "mixed";
      case "integer":
      case "number":
        return typeof value2 !== "boolean" && isNaN(Number(value2)) === false;
      case "token":
        return (schema.values || []).indexOf(typeof value2 === "string" ? value2.toLowerCase() : value2) > -1;
      case "idlist":
        return typeof value2 === "string" && value2.split(regex_any_repeated_whitespaces).every((id2) => typeof id2 === "string");
      case "tokenlist":
        return typeof value2 === "string" && value2.split(regex_any_repeated_whitespaces).every((token) => (schema.values || []).indexOf(token.toLowerCase()) > -1);
      default:
        return false;
    }
  }
  const regex_any_repeated_whitespaces = /[\s]+/g;
  const regex_heading_tags = /^h[1-6]$/;
  const regex_illegal_attribute_character = /(^[0-9-.])|[\^$@%&#?!|()[\]{}^*+~;]/;
  class Element2 extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.attributes = [];
      this.actions = [];
      this.bindings = [];
      this.classes = [];
      this.styles = [];
      this.handlers = [];
      this.lets = [];
      this.intro = null;
      this.outro = null;
      this.animation = null;
      this.name = info.name;
      if (info.name === "svelte:element") {
        if (typeof info.tag !== "string")
          this.tag_expr = new Expression(component, this, scope2, info.tag);
        else
          this.tag_expr = new Expression(component, this, scope2, string_literal(info.tag));
      } else
        this.tag_expr = new Expression(component, this, scope2, string_literal(this.name));
      this.namespace = get_namespace(parent, this, component.namespace);
      if (this.namespace !== namespaces.foreign) {
        if (this.name === "pre" || this.name === "textarea") {
          const first = info.children[0];
          if (first && first.type === "Text")
            first.data = first.data.replace(regex_starts_with_newline, "");
        }
        if (this.name === "textarea") {
          if (info.children.length > 0) {
            const value_attribute = info.attributes.find((node2) => node2.name === "value");
            if (value_attribute) {
              component.error(value_attribute, compiler_errors.textarea_duplicate_value);
              return;
            }
            info.attributes.push({
              type: "Attribute",
              name: "value",
              value: info.children
            });
            info.children = [];
          }
        }
        if (this.name === "option") {
          const value_attribute = info.attributes.find((attribute) => attribute.name === "value");
          if (!value_attribute)
            info.attributes.push({
              type: "Attribute",
              name: "value",
              value: info.children,
              synthetic: true
            });
        }
      }
      const has_let = info.attributes.some((node2) => node2.type === "Let");
      if (has_let)
        scope2 = scope2.child();
      const order = [
        "Binding"
      ];
      info.attributes.sort((a, b2) => order.indexOf(a.type) - order.indexOf(b2.type));
      info.attributes.forEach((node2) => {
        switch (node2.type) {
          case "Action":
            this.actions.push(new Action(component, this, scope2, node2));
            break;
          case "Attribute":
          case "Spread":
            if (node2.name === "xmlns")
              this.namespace = node2.value[0].data;
            this.attributes.push(new Attribute(component, this, scope2, node2));
            break;
          case "Binding":
            this.bindings.push(new Binding(component, this, scope2, node2));
            break;
          case "Class":
            this.classes.push(new Class(component, this, scope2, node2));
            break;
          case "StyleDirective":
            this.styles.push(new StyleDirective(component, this, scope2, node2));
            break;
          case "EventHandler":
            this.handlers.push(new EventHandler(component, this, scope2, node2));
            break;
          case "Let": {
            const l = new Let(component, this, scope2, node2);
            this.lets.push(l);
            const dependencies = /* @__PURE__ */ new Set([
              l.name.name
            ]);
            l.names.forEach((name) => {
              scope2.add(name, dependencies, this);
            });
            break;
          }
          case "Transition": {
            const transition = new Transition(component, this, scope2, node2);
            if (node2.intro)
              this.intro = transition;
            if (node2.outro)
              this.outro = transition;
            break;
          }
          case "Animation":
            this.animation = new Animation(component, this, scope2, node2);
            break;
          default:
            throw new Error(`Not implemented: ${node2.type}`);
        }
      });
      this.scope = scope2;
      this.children = map_children(component, this, this.scope, info.children);
      this.validate();
      this.optimise();
      component.apply_stylesheet(this);
    }
    get is_dynamic_element() {
      return this.name === "svelte:element";
    }
    validate() {
      if (this.component.var_lookup.has(this.name) && this.component.var_lookup.get(this.name).imported && !is_svg(this.name) && !is_html(this.name))
        this.component.warn(this, compiler_warnings.component_name_lowercase(this.name));
      this.validate_attributes();
      this.validate_event_handlers();
      if (this.namespace === namespaces.foreign)
        this.validate_bindings_foreign();
      else {
        this.validate_attributes_a11y();
        this.validate_special_cases();
        this.validate_bindings();
        this.validate_content();
      }
    }
    validate_attributes() {
      const { component, parent } = this;
      this.attributes.forEach((attribute) => {
        if (attribute.is_spread)
          return;
        const name = attribute.name.toLowerCase();
        if (regex_illegal_attribute_character.test(name))
          return component.error(attribute, compiler_errors.illegal_attribute(name));
        if (name === "slot") {
          if (!attribute.is_static)
            return component.error(attribute, compiler_errors.invalid_slot_attribute);
          if (component.slot_outlets.has(name))
            return component.error(attribute, compiler_errors.duplicate_slot_attribute(name));
          if (!(parent.type === "SlotTemplate" || within_custom_element(parent)))
            return component.error(attribute, compiler_errors.invalid_slotted_content);
        }
        if (this.namespace !== namespaces.foreign) {
          if (name === "is")
            component.warn(attribute, compiler_warnings.avoid_is);
          if (react_attributes.has(attribute.name))
            component.warn(attribute, compiler_warnings.invalid_html_attribute(attribute.name, react_attributes.get(attribute.name)));
        }
      });
    }
    validate_attributes_a11y() {
      var _a;
      const { component, attributes, handlers: handlers2 } = this;
      const attribute_map = /* @__PURE__ */ new Map();
      const handlers_map = /* @__PURE__ */ new Map();
      attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
      handlers2.forEach((handler) => handlers_map.set(handler.name, handler));
      attributes.forEach((attribute) => {
        if (attribute.is_spread)
          return;
        const name = attribute.name.toLowerCase();
        if (name.startsWith("aria-")) {
          if (invisible_elements.has(this.name))
            component.warn(attribute, compiler_warnings.a11y_aria_attributes(this.name));
          const type = name.slice(5);
          if (!aria_attribute_set.has(type)) {
            const match = fuzzymatch(type, aria_attributes);
            component.warn(attribute, compiler_warnings.a11y_unknown_aria_attribute(type, match));
          }
          if (name === "aria-hidden" && regex_heading_tags.test(this.name))
            component.warn(attribute, compiler_warnings.a11y_hidden(this.name));
          let value2 = attribute.get_static_value();
          if (value2 === "true")
            value2 = true;
          if (value2 === "false")
            value2 = false;
          if (value2 !== null && value2 !== void 0 && lib_5.has(name)) {
            const schema = lib_5.get(name);
            if (!is_valid_aria_attribute_value(schema, value2))
              component.warn(attribute, compiler_warnings.a11y_incorrect_attribute_type(schema, name));
          }
        }
        if (name === "role") {
          if (invisible_elements.has(this.name))
            component.warn(attribute, compiler_warnings.a11y_misplaced_role(this.name));
          const value2 = attribute.get_static_value();
          if (typeof value2 === "string")
            value2.split(regex_any_repeated_whitespaces).forEach((current_role) => {
              if (current_role && aria_role_abstract_set.has(current_role))
                component.warn(attribute, compiler_warnings.a11y_no_abstract_role(current_role));
              else if (current_role && !aria_role_set.has(current_role)) {
                const match = fuzzymatch(current_role, aria_roles);
                component.warn(attribute, compiler_warnings.a11y_unknown_role(current_role, match));
              }
              const has_redundant_role = current_role === a11y_implicit_semantics.get(this.name);
              if (this.name === current_role || has_redundant_role)
                component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
              const is_parent_section_or_article = is_parent(this.parent, [
                "section",
                "article"
              ]);
              if (!is_parent_section_or_article) {
                const has_nested_redundant_role = current_role === a11y_nested_implicit_semantics.get(this.name);
                if (has_nested_redundant_role)
                  component.warn(attribute, compiler_warnings.a11y_no_redundant_roles(current_role));
              }
              if (!is_semantic_role_element(current_role, this.name, attribute_map)) {
                const role = lib_1.get(current_role);
                if (role) {
                  const required_role_props = Object.keys(role.requiredProps);
                  const has_missing_props = required_role_props.some((prop) => !attributes.find((a) => a.name === prop));
                  if (has_missing_props)
                    component.warn(attribute, compiler_warnings.a11y_role_has_required_aria_props(current_role, required_role_props));
                }
              }
              if (is_interactive_element(this.name, attribute_map) && (is_non_interactive_roles(current_role) || is_presentation_role(current_role)))
                component.warn(this, compiler_warnings.a11y_no_interactive_element_to_noninteractive_role(current_role, this.name));
            });
        }
        if (name === "accesskey")
          component.warn(attribute, compiler_warnings.a11y_accesskey);
        if (name === "autofocus")
          component.warn(attribute, compiler_warnings.a11y_autofocus);
        if (name === "scope" && this.name !== "th")
          component.warn(attribute, compiler_warnings.a11y_misplaced_scope);
        if (name === "tabindex") {
          const value2 = attribute.get_static_value();
          if (!isNaN(value2) && +value2 > 0)
            component.warn(attribute, compiler_warnings.a11y_positive_tabindex);
        }
      });
      if (handlers_map.has("click")) {
        const role = attribute_map.get("role");
        const is_non_presentation_role = (role === null || role === void 0 ? void 0 : role.is_static) && !is_presentation_role(role.get_static_value());
        if (!is_hidden_from_screen_reader(this.name, attribute_map) && (!role || is_non_presentation_role) && !is_interactive_element(this.name, attribute_map) && !this.attributes.find((attr) => attr.is_spread)) {
          const has_key_event = handlers_map.has("keydown") || handlers_map.has("keyup") || handlers_map.has("keypress");
          if (!has_key_event)
            component.warn(this, compiler_warnings.a11y_click_events_have_key_events());
        }
      }
      if (!is_interactive_element(this.name, attribute_map) && !is_interactive_roles((_a = attribute_map.get("role")) === null || _a === void 0 ? void 0 : _a.get_static_value())) {
        const tab_index = attribute_map.get("tabindex");
        if (tab_index && (!tab_index.is_static || Number(tab_index.get_static_value()) >= 0))
          component.warn(this, compiler_warnings.a11y_no_noninteractive_tabindex);
      }
    }
    validate_special_cases() {
      const { component, attributes, handlers: handlers2 } = this;
      const attribute_map = /* @__PURE__ */ new Map();
      const handlers_map = /* @__PURE__ */ new Map();
      attributes.forEach((attribute) => attribute_map.set(attribute.name, attribute));
      handlers2.forEach((handler) => handlers_map.set(handler.name, handler));
      if (this.name === "a") {
        const href_attribute = attribute_map.get("href") || attribute_map.get("xlink:href");
        const id_attribute = attribute_map.get("id");
        const name_attribute = attribute_map.get("name");
        const target_attribute = attribute_map.get("target");
        if (target_attribute && target_attribute.get_static_value() === "_blank" && href_attribute) {
          const href_static_value = href_attribute.get_static_value() ? href_attribute.get_static_value().toLowerCase() : null;
          if (href_static_value === null || href_static_value.match(/^(https?:)?\/\//i)) {
            const rel = attribute_map.get("rel");
            if (rel == null || rel.is_static) {
              const rel_values = rel ? rel.get_static_value().split(regex_any_repeated_whitespaces) : [];
              const expected_values = [
                "noreferrer"
              ];
              expected_values.forEach((expected_value) => {
                if (!rel || rel && rel_values.indexOf(expected_value) < 0)
                  component.warn(this, {
                    code: `security-anchor-rel-${expected_value}`,
                    message: `Security: Anchor with "target=_blank" should have rel attribute containing the value "${expected_value}"`
                  });
              });
            }
          }
        }
        if (href_attribute) {
          const href_value = href_attribute.get_static_value();
          if (href_value === "" || href_value === "#" || /^\W*javascript:/i.test(href_value))
            component.warn(href_attribute, compiler_warnings.a11y_invalid_attribute(href_attribute.name, href_value));
        } else {
          const id_attribute_valid = id_attribute && id_attribute.get_static_value() !== "";
          const name_attribute_valid = name_attribute && name_attribute.get_static_value() !== "";
          if (!id_attribute_valid && !name_attribute_valid)
            component.warn(this, compiler_warnings.a11y_missing_attribute("a", "an", "href"));
        }
      } else {
        const required_attributes = a11y_required_attributes[this.name];
        if (required_attributes) {
          const has_attribute = required_attributes.some((name) => attribute_map.has(name));
          if (!has_attribute)
            should_have_attribute(this, required_attributes);
        }
      }
      if (this.name === "input") {
        const type = attribute_map.get("type");
        if (type && type.get_static_value() === "image") {
          const required_attributes = [
            "alt",
            "aria-label",
            "aria-labelledby"
          ];
          const has_attribute = required_attributes.some((name) => attribute_map.has(name));
          if (!has_attribute)
            should_have_attribute(this, required_attributes, 'input type="image"');
        }
      }
      if (this.name === "img") {
        const alt_attribute = attribute_map.get("alt");
        const aria_hidden_attribute = attribute_map.get("aria-hidden");
        const aria_hidden_exist = aria_hidden_attribute && aria_hidden_attribute.get_static_value();
        if (alt_attribute && !aria_hidden_exist) {
          const alt_value = alt_attribute.get_static_value();
          if (/\b(image|picture|photo)\b/i.test(alt_value))
            component.warn(this, compiler_warnings.a11y_img_redundant_alt);
        }
      }
      if (this.name === "label") {
        const has_input_child = (children) => {
          if (children.some((child) => child instanceof Element2 && (a11y_labelable.has(child.name) || child.name === "slot")))
            return true;
          for (const child of children) {
            if (!("children" in child) || child.children.length === 0)
              continue;
            if (has_input_child(child.children))
              return true;
          }
          return false;
        };
        if (!attribute_map.has("for") && !has_input_child(this.children))
          component.warn(this, compiler_warnings.a11y_label_has_associated_control);
      }
      if (this.name === "video") {
        if (attribute_map.has("muted"))
          return;
        let has_caption;
        const track = this.children.find((i2) => i2.name === "track");
        if (track)
          has_caption = track.attributes.find((a) => a.name === "kind" && a.get_static_value() === "captions");
        if (!has_caption)
          component.warn(this, compiler_warnings.a11y_media_has_caption);
      }
      if (a11y_distracting_elements.has(this.name))
        component.warn(this, compiler_warnings.a11y_distracting_elements(this.name));
      if (this.name === "figcaption") {
        let { parent } = this;
        let is_figure_parent = false;
        while (parent) {
          if (parent.name === "figure") {
            is_figure_parent = true;
            break;
          }
          if (parent.type === "Element")
            break;
          parent = parent.parent;
        }
        if (!is_figure_parent)
          component.warn(this, compiler_warnings.a11y_structure_immediate);
      }
      if (this.name === "figure") {
        const children = this.children.filter((node2) => {
          if (node2.type === "Comment")
            return false;
          if (node2.type === "Text")
            return regex_non_whitespace_character.test(node2.data);
          return true;
        });
        const index = children.findIndex((child) => child.name === "figcaption");
        if (index !== -1 && index !== 0 && index !== children.length - 1)
          component.warn(children[index], compiler_warnings.a11y_structure_first_or_last);
      }
      if (handlers_map.has("mouseover") && !handlers_map.has("focus"))
        component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseover", "focus"));
      if (handlers_map.has("mouseout") && !handlers_map.has("blur"))
        component.warn(this, compiler_warnings.a11y_mouse_events_have_key_events("mouseout", "blur"));
    }
    validate_bindings_foreign() {
      this.bindings.forEach((binding) => {
        if (binding.name !== "this")
          return this.component.error(binding, compiler_errors.invalid_binding_foreign(binding.name));
      });
    }
    validate_bindings() {
      const { component } = this;
      const check_type_attribute = () => {
        const attribute = this.attributes.find((attribute2) => attribute2.name === "type");
        if (!attribute)
          return null;
        if (!attribute.is_static)
          return component.error(attribute, compiler_errors.invalid_type);
        const value2 = attribute.get_static_value();
        if (value2 === true)
          return component.error(attribute, compiler_errors.missing_type);
        return value2;
      };
      this.bindings.forEach((binding) => {
        const { name } = binding;
        if (name === "value") {
          if (this.name !== "input" && this.name !== "textarea" && this.name !== "select")
            return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "value"));
          if (this.name === "select") {
            const attribute = this.attributes.find((attribute2) => attribute2.name === "multiple");
            if (attribute && !attribute.is_static)
              return component.error(attribute, compiler_errors.dynamic_multiple_attribute);
          } else
            check_type_attribute();
        } else if (name === "checked" || name === "indeterminate") {
          if (this.name !== "input")
            return component.error(binding, compiler_errors.invalid_binding_elements(this.name, name));
          const type = check_type_attribute();
          if (type !== "checkbox")
            return component.error(binding, compiler_errors.invalid_binding_no_checkbox(name, type === "radio"));
        } else if (name === "group") {
          if (this.name !== "input")
            return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "group"));
          const type = check_type_attribute();
          if (type !== "checkbox" && type !== "radio")
            return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="checkbox"> or <input type="radio">', "group"));
        } else if (name === "files") {
          if (this.name !== "input")
            return component.error(binding, compiler_errors.invalid_binding_elements(this.name, "files"));
          const type = check_type_attribute();
          if (type !== "file")
            return component.error(binding, compiler_errors.invalid_binding_element_with('<input type="file">', "files"));
        } else if (name === "open") {
          if (this.name !== "details")
            return component.error(binding, compiler_errors.invalid_binding_element_with("<details>", name));
        } else if (name === "currentTime" || name === "duration" || name === "paused" || name === "buffered" || name === "seekable" || name === "played" || name === "volume" || name === "muted" || name === "playbackRate" || name === "seeking" || name === "ended") {
          if (this.name !== "audio" && this.name !== "video")
            return component.error(binding, compiler_errors.invalid_binding_element_with("audio> or <video>", name));
        } else if (name === "videoHeight" || name === "videoWidth") {
          if (this.name !== "video")
            return component.error(binding, compiler_errors.invalid_binding_element_with("<video>", name));
        } else if (regex_dimensions.test(name)) {
          if (this.name === "svg" && (name === "offsetWidth" || name === "offsetHeight"))
            return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `<svg>. Use '${name.replace("offset", "client")}' instead`));
          else if (is_svg(this.name))
            return component.error(binding, compiler_errors.invalid_binding_on(binding.name, "SVG elements"));
          else if (is_void(this.name))
            return component.error(binding, compiler_errors.invalid_binding_on(binding.name, `void elements like <${this.name}>. Use a wrapper element instead`));
        } else if (name === "textContent" || name === "innerHTML") {
          const contenteditable = this.attributes.find((attribute) => attribute.name === "contenteditable");
          if (!contenteditable)
            return component.error(binding, compiler_errors.missing_contenteditable_attribute);
          else if (contenteditable && !contenteditable.is_static)
            return component.error(contenteditable, compiler_errors.dynamic_contenteditable_attribute);
        } else if (name !== "this")
          return component.error(binding, compiler_errors.invalid_binding(binding.name));
      });
    }
    validate_content() {
      if (!a11y_required_content.has(this.name))
        return;
      if (this.bindings.some((binding) => [
        "textContent",
        "innerHTML"
      ].includes(binding.name)))
        return;
      if (this.children.length === 0)
        this.component.warn(this, compiler_warnings.a11y_missing_content(this.name));
    }
    validate_event_handlers() {
      const { component } = this;
      this.handlers.forEach((handler) => {
        if (handler.modifiers.has("passive") && handler.modifiers.has("preventDefault"))
          return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "preventDefault"));
        if (handler.modifiers.has("passive") && handler.modifiers.has("nonpassive"))
          return component.error(handler, compiler_errors.invalid_event_modifier_combination("passive", "nonpassive"));
        handler.modifiers.forEach((modifier) => {
          if (!valid_modifiers$1.has(modifier))
            return component.error(handler, compiler_errors.invalid_event_modifier(list$1(Array.from(valid_modifiers$1))));
          if (modifier === "passive") {
            if (passive_events.has(handler.name)) {
              if (handler.can_make_passive)
                component.warn(handler, compiler_warnings.redundant_event_modifier_for_touch);
            } else
              component.warn(handler, compiler_warnings.redundant_event_modifier_passive);
          }
          if (component.compile_options.legacy && (modifier === "once" || modifier === "passive"))
            return component.error(handler, compiler_errors.invalid_event_modifier_legacy(modifier));
        });
        if (passive_events.has(handler.name) && handler.can_make_passive && !handler.modifiers.has("preventDefault") && !handler.modifiers.has("nonpassive"))
          handler.modifiers.add("passive");
      });
    }
    is_media_node() {
      return this.name === "audio" || this.name === "video";
    }
    add_css_class() {
      if (this.attributes.some((attr) => attr.is_spread)) {
        this.needs_manual_style_scoping = true;
        return;
      }
      const { id: id2 } = this.component.stylesheet;
      const class_attribute = this.attributes.find((a) => a.name === "class");
      if (class_attribute && !class_attribute.is_true) {
        if (class_attribute.chunks.length === 1 && class_attribute.chunks[0].type === "Text")
          class_attribute.chunks[0].data += ` ${id2}`;
        else
          class_attribute.chunks.push(new Text(this.component, this, this.scope, {
            type: "Text",
            data: ` ${id2}`,
            synthetic: true
          }));
      } else
        this.attributes.push(new Attribute(this.component, this, this.scope, {
          type: "Attribute",
          name: "class",
          value: [
            {
              type: "Text",
              data: id2,
              synthetic: true
            }
          ]
        }));
    }
    get slot_template_name() {
      return this.attributes.find((attribute) => attribute.name === "slot").get_static_value();
    }
    optimise() {
      attributes_to_compact_whitespace.forEach((attribute_name) => {
        const attribute = this.attributes.find((a) => a.name === attribute_name);
        if (attribute && !attribute.is_true)
          attribute.chunks.forEach((chunk, index) => {
            if (chunk.type === "Text") {
              let data2 = chunk.data.replace(regex_any_repeated_whitespaces, " ");
              if (index === 0)
                data2 = data2.trimLeft();
              else if (index === attribute.chunks.length - 1)
                data2 = data2.trimRight();
              chunk.data = data2;
            }
          });
      });
    }
  }
  const regex_starts_with_vovel = /^[aeiou]/;
  function should_have_attribute(node2, attributes, name = node2.name) {
    const article = regex_starts_with_vovel.test(attributes[0]) ? "an" : "a";
    const sequence = attributes.length > 1 ? attributes.slice(0, -1).join(", ") + ` or ${attributes[attributes.length - 1]}` : attributes[0];
    node2.component.warn(node2, compiler_warnings.a11y_missing_attribute(name, article, sequence));
  }
  const regex_minus_sign = /-/;
  function within_custom_element(parent) {
    while (parent) {
      if (parent.type === "InlineComponent")
        return false;
      if (parent.type === "Element" && regex_minus_sign.test(parent.name))
        return true;
      parent = parent.parent;
    }
    return false;
  }
  const regex_return_characters = /\r/g;
  function hash(str) {
    str = str.replace(regex_return_characters, "");
    let hash2 = 5381;
    let i2 = str.length;
    while (i2--)
      hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
    return (hash2 >>> 0).toString(36);
  }
  class Head extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      if (info.attributes.length) {
        component.error(info.attributes[0], compiler_errors.invalid_attribute_head);
        return;
      }
      this.children = map_children(component, parent, scope2, info.children.filter((child) => {
        return child.type !== "Text" || regex_non_whitespace_character.test(child.data);
      }));
      if (this.children.length > 0)
        this.id = `svelte-${hash(this.component.source.slice(this.start, this.end))}`;
    }
  }
  class IfBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.scope = scope2.child();
      this.expression = new Expression(component, this, this.scope, info.expression);
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
      this.else = info.else ? new ElseBlock(component, this, scope2, info.else) : null;
      this.warn_if_empty_block();
    }
  }
  class InlineComponent extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.attributes = [];
      this.bindings = [];
      this.handlers = [];
      this.lets = [];
      this.css_custom_properties = [];
      if (info.name !== "svelte:component" && info.name !== "svelte:self") {
        const name = info.name.split(".")[0];
        component.warn_if_undefined(name, info, scope2);
        component.add_reference(this, name);
      }
      this.name = info.name;
      this.namespace = get_namespace$1(parent, component.namespace);
      this.expression = this.name === "svelte:component" ? new Expression(component, this, scope2, info.expression) : null;
      info.attributes.forEach((node2) => {
        switch (node2.type) {
          case "Action":
            return component.error(node2, compiler_errors.invalid_action);
          case "Attribute":
            if (node2.name.startsWith("--")) {
              this.css_custom_properties.push(new Attribute(component, this, scope2, node2));
              break;
            }
          case "Spread":
            this.attributes.push(new Attribute(component, this, scope2, node2));
            break;
          case "Binding":
            this.bindings.push(new Binding(component, this, scope2, node2));
            break;
          case "Class":
            return component.error(node2, compiler_errors.invalid_class);
          case "EventHandler":
            this.handlers.push(new EventHandler(component, this, scope2, node2));
            break;
          case "Let":
            this.lets.push(new Let(component, this, scope2, node2));
            break;
          case "Transition":
            return component.error(node2, compiler_errors.invalid_transition);
          case "StyleDirective":
            return component.error(node2, compiler_errors.invalid_component_style_directive);
          default:
            throw new Error(`Not implemented: ${node2.type}`);
        }
      });
      if (this.lets.length > 0) {
        this.scope = scope2.child();
        this.lets.forEach((l) => {
          const dependencies = /* @__PURE__ */ new Set([
            l.name.name
          ]);
          l.names.forEach((name) => {
            this.scope.add(name, dependencies, this);
          });
        });
      } else
        this.scope = scope2;
      this.handlers.forEach((handler) => {
        handler.modifiers.forEach((modifier) => {
          if (modifier !== "once")
            return component.error(handler, compiler_errors.invalid_event_modifier_component);
        });
      });
      const children = [];
      for (let i2 = info.children.length - 1; i2 >= 0; i2--) {
        const child = info.children[i2];
        if (child.type === "SlotTemplate") {
          children.push(child);
          info.children.splice(i2, 1);
        } else if ((child.type === "Element" || child.type === "InlineComponent" || child.type === "Slot") && child.attributes.find((attribute) => attribute.name === "slot")) {
          const slot_template = {
            start: child.start,
            end: child.end,
            type: "SlotTemplate",
            name: "svelte:fragment",
            attributes: [],
            children: [
              child
            ]
          };
          for (let i3 = child.attributes.length - 1; i3 >= 0; i3--) {
            const attribute = child.attributes[i3];
            if (attribute.type === "Let") {
              slot_template.attributes.push(attribute);
              child.attributes.splice(i3, 1);
            } else if (attribute.type === "Attribute" && attribute.name === "slot")
              slot_template.attributes.push(attribute);
          }
          for (let i3 = child.children.length - 1; i3 >= 0; i3--) {
            const child_child = child.children[i3];
            if (child_child.type === "ConstTag") {
              slot_template.children.push(child_child);
              child.children.splice(i3, 1);
            }
          }
          children.push(slot_template);
          info.children.splice(i2, 1);
        }
      }
      if (info.children.some((node2) => not_whitespace_text(node2)))
        children.push({
          start: info.start,
          end: info.end,
          type: "SlotTemplate",
          name: "svelte:fragment",
          attributes: [],
          children: info.children
        });
      this.children = map_children(component, this, this.scope, children);
    }
    get slot_template_name() {
      return this.attributes.find((attribute) => attribute.name === "slot").get_static_value();
    }
  }
  function not_whitespace_text(node2) {
    return !(node2.type === "Text" && regex_only_whitespaces.test(node2.data));
  }
  function get_namespace$1(parent, explicit_namespace) {
    const parent_element = parent.find_nearest(/^Element/);
    if (!parent_element)
      return explicit_namespace;
    return parent_element.namespace;
  }
  class KeyBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.expression = new Expression(component, this, scope2, info.expression);
      this.children = map_children(component, this, scope2, info.children);
      this.warn_if_empty_block();
    }
  }
  class Tag extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.expression = new Expression(component, this, scope2, info.expression);
      this.should_cache = info.expression.type !== "Identifier" || this.expression.dependencies.size && scope2.names.has(info.expression.name);
    }
  }
  class MustacheTag extends Tag {
  }
  class Options extends Node$1 {
  }
  class RawMustacheTag extends Tag {
  }
  class DebugTag extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.expressions = info.identifiers.map((node2) => {
        return new Expression(component, parent, scope2, node2);
      });
    }
  }
  class Slot extends Element2 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.values = /* @__PURE__ */ new Map();
      info.attributes.forEach((attr) => {
        if (attr.type !== "Attribute" && attr.type !== "Spread")
          return component.error(attr, compiler_errors.invalid_slot_directive);
        if (attr.name === "name") {
          if (attr.value.length !== 1 || attr.value[0].type !== "Text")
            return component.error(attr, compiler_errors.dynamic_slot_name);
          this.slot_name = attr.value[0].data;
          if (this.slot_name === "default")
            return component.error(attr, compiler_errors.invalid_slot_name);
        }
        this.values.set(attr.name, new Attribute(component, this, scope2, attr));
      });
      if (!this.slot_name)
        this.slot_name = "default";
      if (this.slot_name === "default")
        component.slots.forEach((slot) => {
          this.values.forEach((attribute, name) => {
            if (!slot.values.has(name))
              slot.values.set(name, attribute);
          });
        });
      else if (component.slots.has("default")) {
        const default_slot = component.slots.get("default");
        default_slot.values.forEach((attribute, name) => {
          if (!this.values.has(name))
            this.values.set(name, attribute);
        });
      }
      component.slots.set(this.slot_name, this);
    }
  }
  class SlotTemplate extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.lets = [];
      this.slot_template_name = "default";
      this.validate_slot_template_placement();
      scope2 = scope2.child();
      info.attributes.forEach((node2) => {
        switch (node2.type) {
          case "Let": {
            const l = new Let(component, this, scope2, node2);
            this.lets.push(l);
            const dependencies = /* @__PURE__ */ new Set([
              l.name.name
            ]);
            l.names.forEach((name) => {
              scope2.add(name, dependencies, this);
            });
            break;
          }
          case "Attribute":
            if (node2.name === "slot") {
              this.slot_attribute = new Attribute(component, this, scope2, node2);
              if (!this.slot_attribute.is_static)
                return component.error(node2, compiler_errors.invalid_slot_attribute);
              const value2 = this.slot_attribute.get_static_value();
              if (typeof value2 === "boolean")
                return component.error(node2, compiler_errors.invalid_slot_attribute_value_missing);
              this.slot_template_name = value2;
              break;
            }
            throw new Error(`Invalid attribute '${node2.name}' in <svelte:fragment>`);
          default:
            throw new Error(`Not implemented: ${node2.type}`);
        }
      });
      this.scope = scope2;
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, this);
    }
    validate_slot_template_placement() {
      if (this.parent.type !== "InlineComponent")
        return this.component.error(this, compiler_errors.invalid_slotted_content_fragment);
    }
  }
  class Title extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.children = map_children(component, parent, scope2, info.children);
      if (info.attributes.length > 0) {
        component.error(info.attributes[0], compiler_errors.illegal_attribute_title);
        return;
      }
      info.children.forEach((child) => {
        if (child.type !== "Text" && child.type !== "MustacheTag")
          return component.error(child, compiler_errors.illegal_structure_title);
      });
      this.should_cache = info.children.length === 1 ? info.children[0].type !== "Identifier" || scope2.names.has(info.children[0].name) : true;
    }
  }
  const valid_bindings = [
    "innerWidth",
    "innerHeight",
    "outerWidth",
    "outerHeight",
    "scrollX",
    "scrollY",
    "online"
  ];
  class Window extends Node$1 {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.handlers = [];
      this.bindings = [];
      this.actions = [];
      info.attributes.forEach((node2) => {
        if (node2.type === "EventHandler")
          this.handlers.push(new EventHandler(component, this, scope2, node2));
        else if (node2.type === "Binding") {
          if (node2.expression.type !== "Identifier") {
            const { parts } = flatten_reference(node2.expression);
            return component.error(node2.expression, compiler_errors.invalid_binding_window(parts));
          }
          if (!~valid_bindings.indexOf(node2.name)) {
            const match = node2.name === "width" ? "innerWidth" : node2.name === "height" ? "innerHeight" : fuzzymatch(node2.name, valid_bindings);
            if (match)
              return component.error(node2, compiler_errors.invalid_binding_on(node2.name, "<svelte:window>", ` (did you mean '${match}'?)`));
            else
              return component.error(node2, compiler_errors.invalid_binding_on(node2.name, "<svelte:window>", ` — valid bindings are ${list$1(valid_bindings)}`));
          }
          this.bindings.push(new Binding(component, this, scope2, node2));
        } else if (node2.type === "Action")
          this.actions.push(new Action(component, this, scope2, node2));
      });
    }
  }
  function push_array$1(array, items) {
    for (let i2 = 0; i2 < items.length; i2++)
      array.push(items[i2]);
  }
  function get_constructor(type) {
    switch (type) {
      case "AwaitBlock":
        return AwaitBlock;
      case "Body":
        return Body;
      case "Comment":
        return Comment$1;
      case "ConstTag":
        return ConstTag;
      case "EachBlock":
        return EachBlock;
      case "Element":
        return Element2;
      case "Head":
        return Head;
      case "IfBlock":
        return IfBlock;
      case "InlineComponent":
        return InlineComponent;
      case "KeyBlock":
        return KeyBlock;
      case "MustacheTag":
        return MustacheTag;
      case "Options":
        return Options;
      case "RawMustacheTag":
        return RawMustacheTag;
      case "DebugTag":
        return DebugTag;
      case "Slot":
        return Slot;
      case "SlotTemplate":
        return SlotTemplate;
      case "Text":
        return Text;
      case "Title":
        return Title;
      case "Window":
        return Window;
      default:
        throw new Error(`Not implemented: ${type}`);
    }
  }
  function map_children(component, parent, scope2, children) {
    let last = null;
    let ignores = [];
    return children.map((child) => {
      const constructor = get_constructor(child.type);
      const use_ignores = child.type !== "Text" && child.type !== "Comment" && ignores.length;
      if (use_ignores)
        component.push_ignores(ignores);
      const node2 = new constructor(component, parent, scope2, child);
      if (use_ignores)
        component.pop_ignores(), ignores = [];
      if (node2.type === "Comment" && node2.ignores.length)
        push_array$1(ignores, node2.ignores);
      if (last)
        last.next = node2;
      node2.prev = last;
      last = node2;
      return node2;
    });
  }
  function check_graph_for_cycles(edges) {
    const graph = edges.reduce((g2, edge) => {
      const [u, v] = edge;
      if (!g2.has(u))
        g2.set(u, []);
      if (!g2.has(v))
        g2.set(v, []);
      g2.get(u).push(v);
      return g2;
    }, /* @__PURE__ */ new Map());
    const visited = /* @__PURE__ */ new Set();
    const on_stack = /* @__PURE__ */ new Set();
    const cycles = [];
    function visit(v) {
      visited.add(v);
      on_stack.add(v);
      graph.get(v).forEach((w) => {
        if (!visited.has(w))
          visit(w);
        else if (on_stack.has(w))
          cycles.push([
            ...on_stack,
            w
          ]);
      });
      on_stack.delete(v);
    }
    graph.forEach((_, v) => {
      if (!visited.has(v))
        visit(v);
    });
    return cycles[0];
  }
  function get_const_tags(children, component, node2, parent) {
    const const_tags = [];
    const others = [];
    for (const child of children)
      if (child.type === "ConstTag")
        const_tags.push(child);
      else
        others.push(child);
    const consts_nodes = const_tags.map((tag2) => new ConstTag(component, node2, node2.scope, tag2));
    const sorted_consts_nodes = sort_consts_nodes(consts_nodes, component);
    sorted_consts_nodes.forEach((node3) => node3.parse_expression());
    const children_nodes = map_children(component, parent, node2.scope, others);
    return [
      sorted_consts_nodes,
      children_nodes
    ];
  }
  function sort_consts_nodes(consts_nodes, component) {
    const sorted_consts_nodes = [];
    const unsorted_consts_nodes = consts_nodes.map((node2) => {
      return {
        assignees: node2.assignees,
        dependencies: node2.dependencies,
        node: node2
      };
    });
    const lookup = /* @__PURE__ */ new Map();
    unsorted_consts_nodes.forEach((node2) => {
      node2.assignees.forEach((name) => {
        if (!lookup.has(name))
          lookup.set(name, []);
        lookup.get(name).push(node2);
      });
    });
    const cycle = check_graph_for_cycles(unsorted_consts_nodes.reduce((acc, node2) => {
      node2.assignees.forEach((v) => {
        node2.dependencies.forEach((w) => {
          if (!node2.assignees.has(w))
            acc.push([
              v,
              w
            ]);
        });
      });
      return acc;
    }, []));
    if (cycle && cycle.length) {
      const nodeList = lookup.get(cycle[0]);
      const node2 = nodeList[0];
      component.error(node2.node, compiler_errors.cyclical_const_tags(cycle));
    }
    const add_node = (node2) => {
      if (sorted_consts_nodes.includes(node2))
        return;
      node2.dependencies.forEach((name) => {
        if (node2.assignees.has(name))
          return;
        const earlier_nodes = lookup.get(name);
        if (earlier_nodes)
          earlier_nodes.forEach(add_node);
      });
      sorted_consts_nodes.push(node2);
    };
    unsorted_consts_nodes.forEach(add_node);
    return sorted_consts_nodes.map((node2) => node2.node);
  }
  class ThenBlock extends AbstractBlock {
    constructor(component, parent, scope2, info) {
      super(component, parent, scope2, info);
      this.scope = scope2.child();
      if (parent.then_node)
        parent.then_contexts.forEach((context) => {
          this.scope.add(context.key.name, parent.expression.dependencies, this);
        });
      [this.const_tags, this.children] = get_const_tags(info.children, component, this, parent);
      if (!info.skip)
        this.warn_if_empty_block();
    }
  }
  function add_const_tags(block, const_tags, ctx) {
    const const_tags_props = [];
    const_tags.forEach((const_tag, i2) => {
      const name = `#constants_${i2}`;
      const_tags_props.push(b`const ${name} = ${const_tag.expression.manipulate(block, ctx)}`);
      const_tag.contexts.forEach((context) => {
        const_tags_props.push(b`${ctx}[${block.renderer.context_lookup.get(context.key.name).index}] = ${context.default_modifier(context.modifier({
          type: "Identifier",
          name
        }), (name2) => block.renderer.context_lookup.has(name2) ? x`${ctx}[${block.renderer.context_lookup.get(name2).index}]` : {
          type: "Identifier",
          name: name2
        })};`);
      });
    });
    return const_tags_props;
  }
  function add_const_tags_context(renderer, const_tags) {
    const_tags.forEach((const_tag) => {
      const_tag.contexts.forEach((context) => {
        renderer.add_to_context(context.key.name, true);
      });
    });
  }
  class AwaitBlockBranch extends Wrapper {
    constructor(status, renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.var = null;
      this.status = status;
      this.block = block.child({
        comment: create_debugging_comment(node2, this.renderer.component),
        name: this.renderer.component.get_unique_name(`create_${status}_block`),
        type: status
      });
      this.add_context(parent.node[status + "_node"], parent.node[status + "_contexts"]);
      this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
      this.is_dynamic = this.block.dependencies.size > 0;
    }
    add_context(node2, contexts) {
      if (!node2)
        return;
      if (node2.type === "Identifier") {
        this.value = node2.name;
        this.renderer.add_to_context(this.value, true);
      } else {
        contexts.forEach((context) => {
          this.renderer.add_to_context(context.key.name, true);
        });
        this.value = this.block.parent.get_unique_name("value").name;
        this.value_contexts = contexts;
        this.renderer.add_to_context(this.value, true);
        this.is_destructured = true;
      }
      this.value_index = this.renderer.context_lookup.get(this.value).index;
      if (this.has_consts(this.node))
        add_const_tags_context(this.renderer, this.node.const_tags);
    }
    has_consts(node2) {
      return node2 instanceof ThenBlock || node2 instanceof CatchBlock;
    }
    render(block, parent_node, parent_nodes) {
      this.fragment.render(block, parent_node, parent_nodes);
      if (this.is_destructured || this.has_consts(this.node) && this.node.const_tags.length > 0)
        this.render_get_context();
    }
    render_get_context() {
      const props = this.is_destructured ? this.value_contexts.map((prop) => b`#ctx[${this.block.renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`#ctx[${this.value_index}]`), (name) => this.renderer.reference(name))};`) : null;
      const const_tags_props = this.has_consts(this.node) ? add_const_tags(this.block, this.node.const_tags, "#ctx") : null;
      const get_context2 = this.block.renderer.component.get_unique_name(`get_${this.status}_context`);
      this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${props}
				${const_tags_props}
			}
		`);
      this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
      if (this.block.has_update_method)
        this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
  class AwaitBlockWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.var = {
        type: "Identifier",
        name: "await_block"
      };
      this.cannot_use_innerhtml();
      this.not_static_content();
      block.add_dependencies(this.node.expression.dependencies);
      let is_dynamic2 = false;
      let has_intros = false;
      let has_outros = false;
      [
        "pending",
        "then",
        "catch"
      ].forEach((status) => {
        const child = this.node[status];
        const branch = new AwaitBlockBranch(status, renderer, block, this, child, strip_whitespace, next_sibling);
        renderer.blocks.push(branch.block);
        if (branch.is_dynamic) {
          is_dynamic2 = true;
          block.add_dependencies(branch.block.dependencies);
        }
        if (branch.block.has_intros)
          has_intros = true;
        if (branch.block.has_outros)
          has_outros = true;
        this[status] = branch;
      });
      [
        "pending",
        "then",
        "catch"
      ].forEach((status) => {
        this[status].block.has_update_method = is_dynamic2;
        this[status].block.has_intro_method = has_intros;
        this[status].block.has_outro_method = has_outros;
      });
      if (has_outros)
        block.add_outro();
    }
    render(block, parent_node, parent_nodes) {
      const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const update_mount_node = this.get_update_mount_node(anchor);
      const snippet = this.node.expression.manipulate(block);
      const info = block.get_unique_name("info");
      const promise = block.get_unique_name("promise");
      block.add_variable(promise);
      block.maintain_context = true;
      const info_props = x`{
			ctx: #ctx,
			current: null,
			token: null,
			hasCatch: ${this.catch.node.start !== null ? "true" : "false"},
			pending: ${this.pending.block.name},
			then: ${this.then.block.name},
			catch: ${this.catch.block.name},
			value: ${this.then.value_index},
			error: ${this.catch.value_index},
			blocks: ${this.pending.block.has_outro_method && x`[,,,]`}
		}`;
      block.chunks.init.push(b`
			let ${info} = ${info_props};
		`);
      block.chunks.init.push(b`
			@handle_promise(${promise} = ${snippet}, ${info});
		`);
      block.chunks.create.push(b`
			${info}.block.c();
		`);
      if (parent_nodes && this.renderer.options.hydratable)
        block.chunks.claim.push(b`
				${info}.block.l(${parent_nodes});
			`);
      const initial_mount_node = parent_node || "#target";
      const anchor_node = parent_node ? "null" : "#anchor";
      const has_transitions = this.pending.block.has_intro_method || this.pending.block.has_outro_method;
      block.chunks.mount.push(b`
			${info}.block.m(${initial_mount_node}, ${info}.anchor = ${anchor_node});
			${info}.mount = () => ${update_mount_node};
			${info}.anchor = ${anchor};
		`);
      if (has_transitions)
        block.chunks.intro.push(b`@transition_in(${info}.block);`);
      const dependencies = this.node.expression.dynamic_dependencies();
      const update_await_block_branch = b`@update_await_block_branch(${info}, #ctx, #dirty)`;
      if (dependencies.length > 0) {
        const condition = x`
				${block.renderer.dirty(dependencies)} &&
				${promise} !== (${promise} = ${snippet}) &&
				@handle_promise(${promise}, ${info})`;
        block.chunks.update.push(b`${info}.ctx = #ctx;`);
        if (this.pending.block.has_update_method)
          block.chunks.update.push(b`
					if (${condition}) {

					} else {
						${update_await_block_branch}
					}
				`);
        else
          block.chunks.update.push(b`
					${condition}
				`);
      } else if (this.pending.block.has_update_method)
        block.chunks.update.push(b`
					${update_await_block_branch}
				`);
      if (this.pending.block.has_outro_method)
        block.chunks.outro.push(b`
				for (let #i = 0; #i < 3; #i += 1) {
					const block = ${info}.blocks[#i];
					@transition_out(block);
				}
			`);
      block.chunks.destroy.push(b`
			${info}.block.d(${parent_node ? null : "detaching"});
			${info}.token = null;
			${info} = null;
		`);
      [
        this.pending,
        this.then,
        this.catch
      ].forEach((branch) => {
        branch.render(branch.block, null, x`#nodes`);
      });
    }
  }
  const TRUE = x`true`;
  const FALSE = x`false`;
  class EventHandlerWrapper {
    constructor(node2, parent) {
      this.node = node2;
      this.parent = parent;
      if (!node2.expression) {
        this.parent.renderer.add_to_context(node2.handler_name.name);
        this.parent.renderer.component.partly_hoisted.push(b`
				function ${node2.handler_name.name}(event) {
					@bubble.call(this, $$self, event);
				}
			`);
      }
    }
    get_snippet(block) {
      const snippet = this.node.expression ? this.node.expression.manipulate(block) : block.renderer.reference(this.node.handler_name);
      if (this.node.reassigned) {
        block.maintain_context = true;
        return x`function () { if (@is_function(${snippet})) ${snippet}.apply(this, arguments); }`;
      }
      return snippet;
    }
    render(block, target) {
      let snippet = this.get_snippet(block);
      if (this.node.modifiers.has("preventDefault"))
        snippet = x`@prevent_default(${snippet})`;
      if (this.node.modifiers.has("stopPropagation"))
        snippet = x`@stop_propagation(${snippet})`;
      if (this.node.modifiers.has("self"))
        snippet = x`@self(${snippet})`;
      if (this.node.modifiers.has("trusted"))
        snippet = x`@trusted(${snippet})`;
      const args = [];
      const opts = [
        "nonpassive",
        "passive",
        "once",
        "capture"
      ].filter((mod) => this.node.modifiers.has(mod));
      if (opts.length) {
        if (opts.length === 1 && opts[0] === "capture")
          args.push(TRUE);
        else
          args.push(x`{ ${opts.map((opt) => opt === "nonpassive" ? p`passive: false` : p`${opt}: true`)} }`);
      } else if (block.renderer.options.dev)
        args.push(FALSE);
      if (block.renderer.options.dev) {
        args.push(this.node.modifiers.has("preventDefault") ? TRUE : FALSE);
        args.push(this.node.modifiers.has("stopPropagation") ? TRUE : FALSE);
      }
      block.event_listeners.push(x`@listen(${target}, "${this.node.name}", ${snippet}, ${args})`);
    }
  }
  function add_event_handlers(block, target, handlers2) {
    handlers2.forEach((handler) => add_event_handler(block, target, handler));
  }
  function add_event_handler(block, target, handler) {
    handler.render(block, target);
  }
  function add_actions(block, target, actions) {
    actions.forEach((action) => add_action(block, target, action));
  }
  const regex_invalid_variable_identifier_characters = /[^a-zA-Z0-9_$]/g;
  function add_action(block, target, action) {
    const { expression, template_scope } = action;
    let snippet;
    let dependencies;
    if (expression) {
      snippet = expression.manipulate(block);
      dependencies = expression.dynamic_dependencies();
    }
    const id2 = block.get_unique_name(`${action.name.replace(regex_invalid_variable_identifier_characters, "_")}_action`);
    block.add_variable(id2);
    const [obj, ...properties2] = action.name.split(".");
    const fn = is_contextual(action.component, template_scope, obj) ? block.renderer.reference(obj) : obj;
    if (properties2.length) {
      const member_expression = properties2.reduce((lhs, rhs) => x`${lhs}.${rhs}`, fn);
      block.event_listeners.push(x`@action_destroyer(${id2} = ${member_expression}(${target}, ${snippet}))`);
    } else
      block.event_listeners.push(x`@action_destroyer(${id2} = ${fn}.call(null, ${target}, ${snippet}))`);
    if (dependencies && dependencies.length > 0) {
      let condition = x`${id2} && @is_function(${id2}.update)`;
      if (dependencies.length > 0)
        condition = x`${condition} && ${block.renderer.dirty(dependencies)}`;
      block.chunks.update.push(b`if (${condition}) ${id2}.update.call(null, ${snippet});`);
    }
  }
  class BodyWrapper extends Wrapper {
    constructor(renderer, block, parent, node2) {
      super(renderer, block, parent, node2);
      this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
    }
    render(block, _parent_node, _parent_nodes) {
      add_event_handlers(block, x`@_document.body`, this.handlers);
      add_actions(block, x`@_document.body`, this.node.actions);
    }
  }
  class DebugTagWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, _strip_whitespace, _next_sibling) {
      super(renderer, block, parent, node2);
    }
    render(block, _parent_node, _parent_nodes) {
      const { renderer } = this;
      const { component } = renderer;
      if (!renderer.options.dev)
        return;
      const { var_lookup } = component;
      const start = component.locate(this.node.start + 1);
      const end = {
        line: start.line,
        column: start.column + 6
      };
      const loc = {
        start,
        end
      };
      const debug = {
        type: "DebuggerStatement",
        loc
      };
      if (this.node.expressions.length === 0) {
        block.chunks.create.push(debug);
        block.chunks.update.push(debug);
      } else {
        const log = {
          type: "Identifier",
          name: "log",
          loc
        };
        const dependencies = /* @__PURE__ */ new Set();
        this.node.expressions.forEach((expression) => {
          add_to_set(dependencies, expression.dependencies);
        });
        const contextual_identifiers = this.node.expressions.filter((e) => {
          const variable = var_lookup.get(e.node.name);
          return !(variable && variable.hoistable);
        }).map((e) => e.node.name);
        const logged_identifiers = this.node.expressions.map((e) => p`${e.node.name}`);
        const debug_statements = b`
				${contextual_identifiers.map((name) => b`const ${name} = ${renderer.reference(name)};`)}
				@_console.${log}({ ${logged_identifiers} });
				debugger;`;
        if (dependencies.size) {
          const condition = renderer.dirty(Array.from(dependencies));
          block.chunks.update.push(b`
					if (${condition}) {
						${debug_statements}
					}
				`);
        }
        block.chunks.create.push(b`{
				${debug_statements}
			}`);
      }
    }
  }
  class ElseBlockWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.var = null;
      add_const_tags_context(renderer, this.node.const_tags);
      this.block = block.child({
        comment: create_debugging_comment(node2, this.renderer.component),
        name: this.renderer.component.get_unique_name("create_else_block"),
        type: "else"
      });
      this.fragment = new FragmentWrapper(renderer, this.block, this.node.children, parent, strip_whitespace, next_sibling);
      this.is_dynamic = this.block.dependencies.size > 0;
    }
  }
  class EachBlockWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.updates = [];
      this.var = {
        type: "Identifier",
        name: "each"
      };
      this.cannot_use_innerhtml();
      this.not_static_content();
      const { dependencies } = node2.expression;
      block.add_dependencies(dependencies);
      this.node.contexts.forEach((context) => {
        renderer.add_to_context(context.key.name, true);
      });
      add_const_tags_context(renderer, this.node.const_tags);
      this.block = block.child({
        comment: create_debugging_comment(this.node, this.renderer.component),
        name: renderer.component.get_unique_name("create_each_block"),
        type: "each",
        // @ts-ignore todo: probably error
        key: node2.key,
        bindings: new Map(block.bindings)
      });
      this.block.has_animation = this.node.has_animation;
      this.index_name = this.node.index ? {
        type: "Identifier",
        name: this.node.index
      } : renderer.component.get_unique_name(`${this.node.context}_index`);
      const fixed_length = node2.expression.node.type === "ArrayExpression" && node2.expression.node.elements.every((element) => element.type !== "SpreadElement") ? node2.expression.node.elements.length : null;
      let c2 = this.node.start + 2;
      while (renderer.component.source[c2] !== "e")
        c2 += 1;
      const start = renderer.component.locate(c2);
      const end = {
        line: start.line,
        column: start.column + 4
      };
      const length = {
        type: "Identifier",
        name: "length",
        loc: {
          start,
          end
        }
      };
      const each_block_value = renderer.component.get_unique_name(`${this.var.name}_value`);
      const iterations = block.get_unique_name(`${this.var.name}_blocks`);
      renderer.add_to_context(each_block_value.name, true);
      renderer.add_to_context(this.index_name.name, true);
      this.vars = {
        create_each_block: this.block.name,
        each_block_value,
        get_each_context: renderer.component.get_unique_name(`get_${this.var.name}_context`),
        iterations,
        fixed_length: (
          // optimisation for array literal
          fixed_length
        ),
        data_length: fixed_length === null ? x`${each_block_value}.${length}` : fixed_length,
        view_length: fixed_length === null ? x`${iterations}.length` : fixed_length
      };
      const object = get_object(node2.expression.node);
      const store = object.type === "Identifier" && object.name[0] === "$" ? object.name.slice(1) : null;
      node2.contexts.forEach((prop) => {
        this.block.bindings.set(prop.key.name, {
          object: this.vars.each_block_value,
          property: this.index_name,
          modifier: prop.modifier,
          snippet: prop.modifier(x`${this.vars.each_block_value}[${this.index_name}]`),
          store
        });
      });
      if (this.node.index)
        this.block.get_unique_name(this.node.index);
      renderer.blocks.push(this.block);
      this.fragment = new FragmentWrapper(renderer, this.block, node2.children, this, strip_whitespace, next_sibling);
      if (this.node.else) {
        this.else = new ElseBlockWrapper(renderer, block, this, this.node.else, strip_whitespace, next_sibling);
        renderer.blocks.push(this.else.block);
        if (this.else.is_dynamic)
          this.block.add_dependencies(this.else.block.dependencies);
      }
      block.add_dependencies(this.block.dependencies);
      if (this.block.has_outros || this.else && this.else.block.has_outros)
        block.add_outro();
    }
    render(block, parent_node, parent_nodes) {
      if (this.fragment.nodes.length === 0)
        return;
      const { renderer } = this;
      const { component } = renderer;
      const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
      const snippet = this.node.expression.manipulate(block);
      block.chunks.init.push(b`let ${this.vars.each_block_value} = ${snippet};`);
      if (this.renderer.options.dev)
        block.chunks.init.push(b`@validate_each_argument(${this.vars.each_block_value});`);
      const initial_anchor_node = {
        type: "Identifier",
        name: parent_node ? "null" : "#anchor"
      };
      const initial_mount_node = parent_node || {
        type: "Identifier",
        name: "#target"
      };
      const update_anchor_node = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || {
        type: "Identifier",
        name: "null"
      };
      const update_mount_node = this.get_update_mount_node(update_anchor_node);
      const args = {
        block,
        parent_node,
        parent_nodes,
        snippet,
        initial_anchor_node,
        initial_mount_node,
        update_anchor_node,
        update_mount_node
      };
      const all_dependencies = new Set(this.block.dependencies);
      this.node.expression.dynamic_dependencies().forEach((dependency) => {
        all_dependencies.add(dependency);
      });
      if (this.node.key)
        this.node.key.dynamic_dependencies().forEach((dependency) => {
          all_dependencies.add(dependency);
        });
      this.dependencies = all_dependencies;
      if (this.node.key)
        this.render_keyed(args);
      else
        this.render_unkeyed(args);
      if (this.block.has_intro_method || this.block.has_outro_method)
        block.chunks.intro.push(b`
				for (let #i = 0; #i < ${this.vars.data_length}; #i += 1) {
					@transition_in(${this.vars.iterations}[#i]);
				}
			`);
      if (needs_anchor)
        block.add_element(update_anchor_node, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
      if (this.else) {
        let else_ctx = x`#ctx`;
        if (this.else.node.const_tags.length > 0) {
          const get_ctx_name = this.renderer.component.get_unique_name("get_else_ctx");
          this.renderer.blocks.push(b`
					function ${get_ctx_name}(#ctx) {
						const child_ctx = #ctx.slice();
						${add_const_tags(block, this.else.node.const_tags, "child_ctx")}
						return child_ctx;
					}
				`);
          else_ctx = x`${get_ctx_name}(#ctx)`;
        }
        const each_block_else = component.get_unique_name(`${this.var.name}_else`);
        block.chunks.init.push(b`let ${each_block_else} = null;`);
        block.chunks.init.push(b`
				if (!${this.vars.data_length}) {
					${each_block_else} = ${this.else.block.name}(${else_ctx});
				}
			`);
        block.chunks.create.push(b`
				if (${each_block_else}) {
					${each_block_else}.c();
				}
			`);
        if (this.renderer.options.hydratable)
          block.chunks.claim.push(b`
					if (${each_block_else}) {
						${each_block_else}.l(${parent_nodes});
					}
				`);
        block.chunks.mount.push(b`
				if (${each_block_else}) {
					${each_block_else}.m(${initial_mount_node}, ${initial_anchor_node});
				}
			`);
        const has_transitions = !!(this.else.block.has_intro_method || this.else.block.has_outro_method);
        const destroy_block_else = this.else.block.has_outro_method ? b`
					@group_outros();
					@transition_out(${each_block_else}, 1, 1, () => {
						${each_block_else} = null;
					});
					@check_outros();` : b`
					${each_block_else}.d(1);
					${each_block_else} = null;`;
        if (this.else.block.has_update_method)
          this.updates.push(b`
					if (!${this.vars.data_length} && ${each_block_else}) {
						${each_block_else}.p(${else_ctx}, #dirty);
					} else if (!${this.vars.data_length}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					} else if (${each_block_else}) {
						${destroy_block_else};
					}
				`);
        else
          this.updates.push(b`
					if (${this.vars.data_length}) {
						if (${each_block_else}) {
							${destroy_block_else};
						}
					} else if (!${each_block_else}) {
						${each_block_else} = ${this.else.block.name}(${else_ctx});
						${each_block_else}.c();
						${has_transitions && b`@transition_in(${each_block_else}, 1);`}
						${each_block_else}.m(${update_mount_node}, ${update_anchor_node});
					}
				`);
        block.chunks.destroy.push(b`
				if (${each_block_else}) ${each_block_else}.d(${parent_node ? "" : "detaching"});
			`);
      }
      if (this.updates.length)
        block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(all_dependencies))}) {
					${this.updates}
				}
			`);
      this.fragment.render(this.block, null, x`#nodes`);
      if (this.else)
        this.else.fragment.render(this.else.block, null, x`#nodes`);
      this.context_props = this.node.contexts.map((prop) => b`child_ctx[${renderer.context_lookup.get(prop.key.name).index}] = ${prop.default_modifier(prop.modifier(x`list[i]`), (name) => renderer.context_lookup.has(name) ? x`child_ctx[${renderer.context_lookup.get(name).index}]` : {
        type: "Identifier",
        name
      })};`);
      if (this.node.has_binding)
        this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.vars.each_block_value.name).index}] = list;`);
      if (this.node.has_binding || this.node.has_index_binding || this.node.index)
        this.context_props.push(b`child_ctx[${renderer.context_lookup.get(this.index_name.name).index}] = i;`);
      renderer.blocks.push(b`
			function ${this.vars.get_each_context}(#ctx, list, i) {
				const child_ctx = #ctx.slice();
				${this.context_props}
				${add_const_tags(this.block, this.node.const_tags, "child_ctx")}
				return child_ctx;
			}
		`);
    }
    render_keyed({ block, parent_node, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {
      const { create_each_block, iterations, data_length, view_length } = this.vars;
      const get_key = block.get_unique_name("get_key");
      const lookup = block.get_unique_name(`${this.var.name}_lookup`);
      block.add_variable(iterations, x`[]`);
      block.add_variable(lookup, x`new @_Map()`);
      if (this.fragment.nodes[0].is_dom_node())
        this.block.first = this.fragment.nodes[0].var;
      else {
        this.block.first = this.block.get_unique_name("first");
        this.block.add_element(this.block.first, x`@empty()`, parent_nodes && x`@empty()`, null);
      }
      block.chunks.init.push(b`
			const ${get_key} = #ctx => ${this.node.key.manipulate(block)};

			${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
			for (let #i = 0; #i < ${data_length}; #i += 1) {
				let child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);
				let key = ${get_key}(child_ctx);
				${lookup}.set(key, ${iterations}[#i] = ${create_each_block}(key, child_ctx));
			}
		`);
      block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
      if (parent_nodes && this.renderer.options.hydratable)
        block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
      block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
      const dynamic = this.block.has_update_method;
      const destroy = this.node.has_animation ? this.block.has_outros ? "@fix_and_outro_and_destroy_block" : "@fix_and_destroy_block" : this.block.has_outros ? "@outro_and_destroy_block" : "@destroy_block";
      if (this.dependencies.size) {
        this.block.maintain_context = true;
        this.updates.push(b`
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				${this.block.has_outros && b`@group_outros();`}
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].r();`}
				${this.renderer.options.dev && b`@validate_each_keys(#ctx, ${this.vars.each_block_value}, ${this.vars.get_each_context}, ${get_key});`}
				${iterations} = @update_keyed_each(${iterations}, #dirty, ${get_key}, ${dynamic ? 1 : 0}, #ctx, ${this.vars.each_block_value}, ${lookup}, ${update_mount_node}, ${destroy}, ${create_each_block}, ${update_anchor_node}, ${this.vars.get_each_context});
				${this.node.has_animation && b`for (let #i = 0; #i < ${view_length}; #i += 1) ${iterations}[#i].a();`}
				${this.block.has_outros && b`@check_outros();`}
			`);
      }
      if (this.block.has_outros)
        block.chunks.outro.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
      block.chunks.destroy.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].d(${parent_node ? null : "detaching"});
			}
		`);
    }
    render_unkeyed({ block, parent_nodes, snippet, initial_anchor_node, initial_mount_node, update_anchor_node, update_mount_node }) {
      const { create_each_block, iterations, fixed_length, data_length, view_length } = this.vars;
      block.chunks.init.push(b`
			let ${iterations} = [];

			for (let #i = 0; #i < ${data_length}; #i += 1) {
				${iterations}[#i] = ${create_each_block}(${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i));
			}
		`);
      block.chunks.create.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].c();
			}
		`);
      if (parent_nodes && this.renderer.options.hydratable)
        block.chunks.claim.push(b`
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					${iterations}[#i].l(${parent_nodes});
				}
			`);
      block.chunks.mount.push(b`
			for (let #i = 0; #i < ${view_length}; #i += 1) {
				${iterations}[#i].m(${initial_mount_node}, ${initial_anchor_node});
			}
		`);
      if (this.dependencies.size) {
        const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
        const for_loop_body = this.block.has_update_method ? b`
					if (${iterations}[#i]) {
						${iterations}[#i].p(child_ctx, #dirty);
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
					} else {
						${iterations}[#i] = ${create_each_block}(child_ctx);
						${iterations}[#i].c();
						${has_transitions && b`@transition_in(${this.vars.iterations}[#i], 1);`}
						${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
					}
				` : has_transitions ? b`
						if (${iterations}[#i]) {
							@transition_in(${this.vars.iterations}[#i], 1);
						} else {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							@transition_in(${this.vars.iterations}[#i], 1);
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					` : b`
						if (!${iterations}[#i]) {
							${iterations}[#i] = ${create_each_block}(child_ctx);
							${iterations}[#i].c();
							${iterations}[#i].m(${update_mount_node}, ${update_anchor_node});
						}
					`;
        const start = this.block.has_update_method ? 0 : "#old_length";
        let remove_old_blocks;
        if (this.block.has_outros) {
          const out = block.get_unique_name("out");
          block.chunks.init.push(b`
					const ${out} = i => @transition_out(${iterations}[i], 1, 1, () => {
						${iterations}[i] = null;
					});
				`);
          remove_old_blocks = b`
					@group_outros();
					for (#i = ${data_length}; #i < ${view_length}; #i += 1) {
						${out}(#i);
					}
					@check_outros();
				`;
        } else
          remove_old_blocks = b`
					for (${this.block.has_update_method ? null : x`#i = ${data_length}`}; #i < ${this.block.has_update_method ? view_length : "#old_length"}; #i += 1) {
						${iterations}[#i].d(1);
					}
					${!fixed_length && b`${view_length} = ${data_length};`}
				`;
        const update = b`
				${!this.block.has_update_method && b`const #old_length = ${this.vars.each_block_value}.length;`}
				${this.vars.each_block_value} = ${snippet};
				${this.renderer.options.dev && b`@validate_each_argument(${this.vars.each_block_value});`}

				let #i;
				for (#i = ${start}; #i < ${data_length}; #i += 1) {
					const child_ctx = ${this.vars.get_each_context}(#ctx, ${this.vars.each_block_value}, #i);

					${for_loop_body}
				}

				${remove_old_blocks}
			`;
        this.updates.push(update);
      }
      if (this.block.has_outros)
        block.chunks.outro.push(b`
				${iterations} = ${iterations}.filter(@_Boolean);
				for (let #i = 0; #i < ${view_length}; #i += 1) {
					@transition_out(${iterations}[#i]);
				}
			`);
      block.chunks.destroy.push(b`@destroy_each(${iterations}, detaching);`);
    }
  }
  const regex_non_whitespace_characters$1 = /[\S\u00A0]/;
  class TextWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, data2) {
      super(renderer, block, parent, node2);
      this.skip = this.node.should_skip();
      this.data = data2;
      this.var = this.skip ? null : x`t`;
    }
    use_space() {
      if (this.renderer.component.component_options.preserveWhitespace)
        return false;
      if (regex_non_whitespace_characters$1.test(this.data))
        return false;
      return !this.node.within_pre();
    }
    render(block, parent_node, parent_nodes) {
      if (this.skip)
        return;
      const use_space = this.use_space();
      const string_literal2 = {
        type: "Literal",
        value: this.data,
        loc: {
          start: this.renderer.locate(this.node.start),
          end: this.renderer.locate(this.node.end)
        }
      };
      block.add_element(this.var, use_space ? x`@space()` : x`@text(${string_literal2})`, parent_nodes && (use_space ? x`@claim_space(${parent_nodes})` : x`@claim_text(${parent_nodes}, ${string_literal2})`), parent_node);
    }
  }
  const svg_attributes = "accent-height accumulate additive alignment-baseline allowReorder alphabetic amplitude arabic-form ascent attributeName attributeType autoReverse azimuth baseFrequency baseline-shift baseProfile bbox begin bias by calcMode cap-height class clip clipPathUnits clip-path clip-rule color color-interpolation color-interpolation-filters color-profile color-rendering contentScriptType contentStyleType cursor cx cy d decelerate descent diffuseConstant direction display divisor dominant-baseline dur dx dy edgeMode elevation enable-background end exponent externalResourcesRequired fill fill-opacity fill-rule filter filterRes filterUnits flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight format from fr fx fy g1 g2 glyph-name glyph-orientation-horizontal glyph-orientation-vertical glyphRef gradientTransform gradientUnits hanging height href horiz-adv-x horiz-origin-x id ideographic image-rendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength kerning keyPoints keySplines keyTimes lang lengthAdjust letter-spacing lighting-color limitingConeAngle local marker-end marker-mid marker-start markerHeight markerUnits markerWidth mask maskContentUnits maskUnits mathematical max media method min mode name numOctaves offset onabort onactivate onbegin onclick onend onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onrepeat onresize onscroll onunload opacity operator order orient orientation origin overflow overline-position overline-thickness panose-1 paint-order pathLength patternContentUnits patternTransform patternUnits pointer-events points pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits r radius refX refY rendering-intent repeatCount repeatDur requiredExtensions requiredFeatures restart result rotate rx ry scale seed shape-rendering slope spacing specularConstant specularExponent speed spreadMethod startOffset stdDeviation stemh stemv stitchTiles stop-color stop-opacity strikethrough-position strikethrough-thickness string stroke stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width style surfaceScale systemLanguage tabindex tableValues target targetX targetY text-anchor text-decoration text-rendering textLength to transform type u1 u2 underline-position underline-thickness unicode unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical values version vert-adv-y vert-origin-x vert-origin-y viewBox viewTarget visibility width widths word-spacing writing-mode x x-height x1 x2 xChannelSelector xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y y1 y2 yChannelSelector z zoomAndPan".split(" ");
  const svg_attribute_lookup = /* @__PURE__ */ new Map();
  svg_attributes.forEach((name) => {
    svg_attribute_lookup.set(name.toLowerCase(), name);
  });
  function fix_attribute_casing(name) {
    name = name.toLowerCase();
    return svg_attribute_lookup.get(name) || name;
  }
  function handle_select_value_binding(attr, dependencies) {
    const { parent } = attr;
    if (parent.node.name === "select") {
      parent.select_binding_dependencies = dependencies;
      dependencies.forEach((prop) => {
        parent.renderer.component.indirect_dependencies.set(prop, /* @__PURE__ */ new Set());
      });
    }
  }
  const boolean_attributes = /* @__PURE__ */ new Set([
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "itemscope",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]);
  const non_textlike_input_types = /* @__PURE__ */ new Set([
    "button",
    "checkbox",
    "color",
    "date",
    "datetime-local",
    "file",
    "hidden",
    "image",
    "radio",
    "range",
    "reset",
    "submit"
  ]);
  class BaseAttributeWrapper {
    constructor(parent, block, node2) {
      this.node = node2;
      this.parent = parent;
      if (node2.dependencies.size > 0) {
        parent.cannot_use_innerhtml();
        parent.not_static_content();
        block.add_dependencies(node2.dependencies);
      }
    }
    render(_block) {
    }
  }
  const regex_minus_sign$1 = /-/;
  const regex_invalid_variable_identifier_characters$1 = /[^a-zA-Z_$]/g;
  class AttributeWrapper extends BaseAttributeWrapper {
    constructor(parent, block, node2) {
      super(parent, block, node2);
      if (node2.dependencies.size > 0) {
        if (this.parent.node.name === "option" && node2.name === "value") {
          let select = this.parent;
          while (select && (select.node.type !== "Element" || select.node.name !== "select"))
            select = select.parent;
          if (select && select.select_binding_dependencies)
            select.select_binding_dependencies.forEach((prop) => {
              this.node.dependencies.forEach((dependency) => {
                this.parent.renderer.component.indirect_dependencies.get(prop).add(dependency);
              });
            });
        }
        if (node2.name === "value")
          handle_select_value_binding(this, node2.dependencies);
      }
      if (this.parent.node.namespace == namespaces.foreign) {
        this.name = this.node.name;
        this.metadata = this.get_metadata();
        this.is_indirectly_bound_value = false;
        this.property_name = null;
        this.is_select_value_attribute = false;
        this.is_input_value = false;
      } else {
        this.name = fix_attribute_casing(this.node.name);
        this.metadata = this.get_metadata();
        this.is_indirectly_bound_value = is_indirectly_bound_value(this);
        this.property_name = this.is_indirectly_bound_value ? "__value" : this.metadata && this.metadata.property_name;
        this.is_select_value_attribute = this.name === "value" && this.parent.node.name === "select";
        this.is_input_value = this.name === "value" && this.parent.node.name === "input";
      }
      this.is_src = this.name === "src" && (!this.parent.node.namespace || this.parent.node.namespace === namespaces.html);
      this.should_cache = should_cache(this);
    }
    render(block) {
      const element = this.parent;
      const { name, property_name, should_cache: should_cache2, is_indirectly_bound_value: is_indirectly_bound_value2 } = this;
      const method = regex_minus_sign$1.test(element.node.name) ? "@set_custom_element_data" : name.slice(0, 6) === "xlink:" ? "@xlink_attr" : "@attr";
      const is_legacy_input_type = element.renderer.component.compile_options.legacy && name === "type" && this.parent.node.name === "input";
      const dependencies = this.get_dependencies();
      const value2 = this.get_value(block);
      let updater;
      const init = this.get_init(block, value2);
      if (is_legacy_input_type) {
        block.chunks.hydrate.push(b`@set_input_type(${element.var}, ${init});`);
        updater = b`@set_input_type(${element.var}, ${should_cache2 ? this.last : value2});`;
      } else if (this.is_select_value_attribute) {
        const is_multiple_select = element.node.get_static_attribute_value("multiple");
        if (is_multiple_select)
          updater = b`@select_options(${element.var}, ${value2});`;
        else
          updater = b`@select_option(${element.var}, ${value2});`;
        block.chunks.mount.push(b`
				${updater}
			`);
      } else if (this.is_src) {
        block.chunks.hydrate.push(b`if (!@src_url_equal(${element.var}.src, ${init})) ${method}(${element.var}, "${name}", ${this.last});`);
        updater = b`${method}(${element.var}, "${name}", ${should_cache2 ? this.last : value2});`;
      } else if (property_name) {
        block.chunks.hydrate.push(b`${element.var}.${property_name} = ${init};`);
        updater = block.renderer.options.dev ? b`@prop_dev(${element.var}, "${property_name}", ${should_cache2 ? this.last : value2});` : b`${element.var}.${property_name} = ${should_cache2 ? this.last : value2};`;
      } else {
        block.chunks.hydrate.push(b`${method}(${element.var}, "${name}", ${init});`);
        updater = b`${method}(${element.var}, "${name}", ${should_cache2 ? this.last : value2});`;
      }
      if (is_indirectly_bound_value2) {
        const update_value = b`${element.var}.value = ${element.var}.__value;`;
        block.chunks.hydrate.push(update_value);
        updater = b`
				${updater}
				${update_value};
			`;
      }
      if (dependencies.length > 0) {
        const condition = this.get_dom_update_conditions(block, block.renderer.dirty(dependencies));
        block.chunks.update.push(b`
				if (${condition}) {
					${updater}
				}`);
      }
      if (name === "autofocus")
        block.autofocus = {
          element_var: element.var,
          condition_expression: this.node.is_true ? void 0 : value2
        };
    }
    get_init(block, value2) {
      this.last = this.should_cache && block.get_unique_name(`${this.parent.var.name}_${this.name.replace(regex_invalid_variable_identifier_characters$1, "_")}_value`);
      if (this.should_cache)
        block.add_variable(this.last);
      return this.should_cache ? x`${this.last} = ${value2}` : value2;
    }
    get_dom_update_conditions(block, dependency_condition) {
      const { property_name, should_cache: should_cache2, last } = this;
      const element = this.parent;
      const value2 = this.get_value(block);
      let condition = dependency_condition;
      if (should_cache2)
        condition = this.is_src ? x`${condition} && (!@src_url_equal(${element.var}.src, (${last} = ${value2})))` : x`${condition} && (${last} !== (${last} = ${value2}))`;
      if (this.is_input_value) {
        const type = element.node.get_static_attribute_value("type");
        if (type !== true && !non_textlike_input_types.has(type))
          condition = x`${condition} && ${element.var}.${property_name} !== ${should_cache2 ? last : value2}`;
      }
      if (block.has_outros)
        condition = x`!#current || ${condition}`;
      return condition;
    }
    get_dependencies() {
      const node_dependencies = this.node.get_dependencies();
      const dependencies = new Set(node_dependencies);
      node_dependencies.forEach((prop) => {
        const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
        if (indirect_dependencies)
          indirect_dependencies.forEach((indirect_dependency) => {
            dependencies.add(indirect_dependency);
          });
      });
      return Array.from(dependencies);
    }
    get_metadata() {
      if (this.parent.node.namespace)
        return null;
      const metadata = attribute_lookup[this.name];
      if (metadata && metadata.applies_to && !metadata.applies_to.includes(this.parent.node.name))
        return null;
      return metadata;
    }
    get_value(block) {
      if (this.node.is_true) {
        if (this.metadata && boolean_attributes.has(this.metadata.property_name.toLowerCase()))
          return x`true`;
        return x`""`;
      }
      if (this.node.chunks.length === 0)
        return x`""`;
      if (this.node.chunks.length === 1)
        return this.node.chunks[0].type === "Text" ? string_literal(this.node.chunks[0].data) : this.node.chunks[0].manipulate(block);
      let value2 = this.node.name === "class" ? this.get_class_name_text(block) : this.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
      if (this.node.chunks[0].type !== "Text")
        value2 = x`"" + ${value2}`;
      return value2;
    }
    get_class_name_text(block) {
      const scoped_css = this.node.chunks.some((chunk) => chunk.synthetic);
      const rendered = this.render_chunks(block);
      if (scoped_css && rendered.length === 2)
        rendered[0] = x`@null_to_empty(${rendered[0]})`;
      return rendered.reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    }
    render_chunks(block) {
      return this.node.chunks.map((chunk) => {
        if (chunk.type === "Text")
          return string_literal(chunk.data);
        return chunk.manipulate(block);
      });
    }
    stringify() {
      if (this.node.is_true)
        return "";
      const value2 = this.node.chunks;
      if (value2.length === 0)
        return '=""';
      return `="${value2.map((chunk) => {
        return chunk.type === "Text" ? chunk.data.replace(regex_double_quotes, '\\"') : `\${${chunk.manipulate()}}`;
      }).join("")}"`;
    }
  }
  const attribute_lookup = {
    allowfullscreen: {
      property_name: "allowFullscreen",
      applies_to: [
        "iframe"
      ]
    },
    allowpaymentrequest: {
      property_name: "allowPaymentRequest",
      applies_to: [
        "iframe"
      ]
    },
    async: {
      applies_to: [
        "script"
      ]
    },
    autofocus: {
      applies_to: [
        "button",
        "input",
        "keygen",
        "select",
        "textarea"
      ]
    },
    autoplay: {
      applies_to: [
        "audio",
        "video"
      ]
    },
    checked: {
      applies_to: [
        "input"
      ]
    },
    controls: {
      applies_to: [
        "audio",
        "video"
      ]
    },
    default: {
      applies_to: [
        "track"
      ]
    },
    defer: {
      applies_to: [
        "script"
      ]
    },
    disabled: {
      applies_to: [
        "button",
        "fieldset",
        "input",
        "keygen",
        "optgroup",
        "option",
        "select",
        "textarea"
      ]
    },
    formnovalidate: {
      property_name: "formNoValidate",
      applies_to: [
        "button",
        "input"
      ]
    },
    hidden: {},
    indeterminate: {
      applies_to: [
        "input"
      ]
    },
    ismap: {
      property_name: "isMap",
      applies_to: [
        "img"
      ]
    },
    loop: {
      applies_to: [
        "audio",
        "bgsound",
        "video"
      ]
    },
    multiple: {
      applies_to: [
        "input",
        "select"
      ]
    },
    muted: {
      applies_to: [
        "audio",
        "video"
      ]
    },
    nomodule: {
      property_name: "noModule",
      applies_to: [
        "script"
      ]
    },
    novalidate: {
      property_name: "noValidate",
      applies_to: [
        "form"
      ]
    },
    open: {
      applies_to: [
        "details",
        "dialog"
      ]
    },
    playsinline: {
      property_name: "playsInline",
      applies_to: [
        "video"
      ]
    },
    readonly: {
      property_name: "readOnly",
      applies_to: [
        "input",
        "textarea"
      ]
    },
    required: {
      applies_to: [
        "input",
        "select",
        "textarea"
      ]
    },
    reversed: {
      applies_to: [
        "ol"
      ]
    },
    selected: {
      applies_to: [
        "option"
      ]
    },
    value: {
      applies_to: [
        "button",
        "option",
        "input",
        "li",
        "meter",
        "progress",
        "param",
        "select",
        "textarea"
      ]
    }
  };
  Object.keys(attribute_lookup).forEach((name) => {
    const metadata = attribute_lookup[name];
    if (!metadata.property_name)
      metadata.property_name = name;
  });
  function should_cache(attribute) {
    return attribute.is_src || attribute.node.should_cache();
  }
  const regex_contains_checked_or_group = /checked|group/;
  function is_indirectly_bound_value(attribute) {
    const element = attribute.parent;
    return attribute.name === "value" && (element.node.name === "option" || // TODO check it's actually bound
    element.node.name === "input" && element.node.bindings.some((binding) => regex_contains_checked_or_group.test(binding.name)));
  }
  class StyleAttributeWrapper extends AttributeWrapper {
    render(block) {
      const style_props = optimize_style(this.node.chunks);
      if (!style_props)
        return super.render(block);
      style_props.forEach((prop) => {
        let value2;
        if (is_dynamic$1(prop.value)) {
          const prop_dependencies = /* @__PURE__ */ new Set();
          value2 = prop.value.map((chunk) => {
            if (chunk.type === "Text")
              return string_literal(chunk.data);
            else {
              add_to_set(prop_dependencies, chunk.dynamic_dependencies());
              return chunk.manipulate(block);
            }
          }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
          if (prop_dependencies.size) {
            let condition = block.renderer.dirty(Array.from(prop_dependencies));
            if (block.has_outros)
              condition = x`!#current || ${condition}`;
            const update = b`
						if (${condition}) {
							@set_style(${this.parent.var}, "${prop.key}", ${value2}, ${prop.important ? 1 : null});
						}`;
            block.chunks.update.push(update);
          }
        } else
          value2 = string_literal(prop.value[0].data);
        block.chunks.hydrate.push(b`@set_style(${this.parent.var}, "${prop.key}", ${value2}, ${prop.important ? 1 : null});`);
      });
    }
  }
  const regex_style_prop_key = /^\s*([\w-]+):\s*/;
  function optimize_style(value2) {
    const props = [];
    let chunks = value2.slice();
    while (chunks.length) {
      const chunk = chunks[0];
      if (chunk.type !== "Text")
        return null;
      const key_match = regex_style_prop_key.exec(chunk.data);
      if (!key_match)
        return null;
      const key = key_match[1];
      const offset = key_match.index + key_match[0].length;
      const remaining_data = chunk.data.slice(offset);
      if (remaining_data)
        chunks[0] = {
          start: chunk.start + offset,
          end: chunk.end,
          type: "Text",
          data: remaining_data
        };
      else
        chunks.shift();
      const result = get_style_value(chunks);
      props.push({
        key,
        value: result.value,
        important: result.important
      });
      chunks = result.chunks;
    }
    return props;
  }
  const regex_important_flag = /\s*!important\s*$/;
  const regex_semicolon_or_whitespace = /[;\s]/;
  function get_style_value(chunks) {
    const value2 = [];
    let in_url = false;
    let quote_mark = null;
    let escaped2 = false;
    let closed = false;
    while (chunks.length && !closed) {
      const chunk = chunks.shift();
      if (chunk.type === "Text") {
        let c2 = 0;
        while (c2 < chunk.data.length) {
          const char = chunk.data[c2];
          if (escaped2)
            escaped2 = false;
          else if (char === "\\")
            escaped2 = true;
          else if (char === quote_mark)
            quote_mark = null;
          else if (char === '"' || char === "'")
            quote_mark = char;
          else if (char === ")" && in_url)
            in_url = false;
          else if (char === "u" && chunk.data.slice(c2, c2 + 4) === "url(")
            in_url = true;
          else if (char === ";" && !in_url && !quote_mark) {
            closed = true;
            break;
          }
          c2 += 1;
        }
        if (c2 > 0)
          value2.push({
            type: "Text",
            start: chunk.start,
            end: chunk.start + c2,
            data: chunk.data.slice(0, c2)
          });
        while (regex_semicolon_or_whitespace.test(chunk.data[c2]))
          c2 += 1;
        const remaining_data = chunk.data.slice(c2);
        if (remaining_data) {
          chunks.unshift({
            start: chunk.start + c2,
            end: chunk.end,
            type: "Text",
            data: remaining_data
          });
          break;
        }
      } else
        value2.push(chunk);
    }
    let important = false;
    const last_chunk = value2[value2.length - 1];
    if (last_chunk && last_chunk.type === "Text" && regex_important_flag.test(last_chunk.data)) {
      important = true;
      last_chunk.data = last_chunk.data.replace(regex_important_flag, "");
      if (!last_chunk.data)
        value2.pop();
    }
    return {
      chunks,
      value: value2,
      important
    };
  }
  function is_dynamic$1(value2) {
    return value2.length > 1 || value2[0].type !== "Text";
  }
  class SpreadAttributeWrapper extends BaseAttributeWrapper {
  }
  function mark_each_block_bindings(parent, binding) {
    binding.expression.references.forEach((name) => {
      const each_block = parent.node.scope.get_owner(name);
      if (each_block)
        each_block.has_binding = true;
    });
    if (binding.name === "group") {
      const add_index_binding = (name) => {
        const each_block = parent.node.scope.get_owner(name);
        if (each_block.type === "EachBlock") {
          each_block.has_index_binding = true;
          for (const dep of each_block.expression.contextual_dependencies)
            add_index_binding(dep);
        }
      };
      for (const name of binding.expression.contextual_dependencies)
        add_index_binding(name);
    }
  }
  class BindingWrapper {
    constructor(block, node2, parent) {
      this.node = node2;
      this.parent = parent;
      const { dependencies } = this.node.expression;
      block.add_dependencies(dependencies);
      handle_select_value_binding(this, dependencies);
      if (node2.is_contextual)
        mark_each_block_bindings(this.parent, this.node);
      this.object = get_object(this.node.expression.node).name;
      this.handler = get_event_handler(this, parent.renderer, block, this.object, this.node.raw_expression);
      this.snippet = this.node.expression.manipulate(block);
      this.is_readonly = this.node.is_readonly;
      this.needs_lock = this.node.name === "currentTime";
    }
    get_dependencies() {
      const dependencies = new Set(this.node.expression.dependencies);
      this.node.expression.dependencies.forEach((prop) => {
        const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(prop);
        if (indirect_dependencies)
          indirect_dependencies.forEach((indirect_dependency) => {
            dependencies.add(indirect_dependency);
          });
      });
      return dependencies;
    }
    get_update_dependencies() {
      const object = this.object;
      const dependencies = /* @__PURE__ */ new Set();
      if (this.node.expression.template_scope.names.has(object))
        this.node.expression.template_scope.dependencies_for_name.get(object).forEach((name) => dependencies.add(name));
      else
        dependencies.add(object);
      const result = new Set(dependencies);
      dependencies.forEach((dependency) => {
        const indirect_dependencies = this.parent.renderer.component.indirect_dependencies.get(dependency);
        if (indirect_dependencies)
          indirect_dependencies.forEach((indirect_dependency) => {
            result.add(indirect_dependency);
          });
      });
      return result;
    }
    is_readonly_media_attribute() {
      return this.node.is_readonly_media_attribute();
    }
    render(block, lock) {
      if (this.is_readonly)
        return;
      const { parent } = this;
      const update_conditions = this.needs_lock ? [
        x`!${lock}`
      ] : [];
      const mount_conditions = [];
      const dependency_array = Array.from(this.get_dependencies());
      if (dependency_array.length > 0)
        update_conditions.push(block.renderer.dirty(dependency_array));
      if (parent.node.name === "input") {
        const type = parent.node.get_static_attribute_value("type");
        if (type === null || type === "" || type === "text" || type === "email" || type === "password")
          update_conditions.push(x`${parent.var}.${this.node.name} !== ${this.snippet}`);
        else if (type === "number")
          update_conditions.push(x`@to_number(${parent.var}.${this.node.name}) !== ${this.snippet}`);
      }
      let update_dom = get_dom_updater(parent, this);
      let mount_dom = update_dom;
      switch (this.node.name) {
        case "group": {
          const { binding_group, is_context, contexts, index, keypath } = get_binding_group(parent.renderer, this.node, block);
          block.renderer.add_to_context("$$binding_groups");
          if (is_context && !block.binding_group_initialised.has(keypath)) {
            if (contexts.length > 1) {
              let binding_group2 = x`${block.renderer.reference("$$binding_groups")}[${index}]`;
              for (const name of contexts.slice(0, -1)) {
                binding_group2 = x`${binding_group2}[${block.renderer.reference(name)}]`;
                block.chunks.init.push(b`${binding_group2} = ${binding_group2} || [];`);
              }
            }
            block.chunks.init.push(b`${binding_group(true)} = [];`);
            block.binding_group_initialised.add(keypath);
          }
          block.chunks.hydrate.push(b`${binding_group(true)}.push(${parent.var});`);
          block.chunks.destroy.push(b`${binding_group(true)}.splice(${binding_group(true)}.indexOf(${parent.var}), 1);`);
          break;
        }
        case "textContent":
          update_conditions.push(x`${this.snippet} !== ${parent.var}.textContent`);
          mount_conditions.push(x`${this.snippet} !== void 0`);
          break;
        case "innerHTML":
          update_conditions.push(x`${this.snippet} !== ${parent.var}.innerHTML`);
          mount_conditions.push(x`${this.snippet} !== void 0`);
          break;
        case "currentTime":
          update_conditions.push(x`!@_isNaN(${this.snippet})`);
          mount_dom = null;
          break;
        case "playbackRate":
        case "volume":
          update_conditions.push(x`!@_isNaN(${this.snippet})`);
          mount_conditions.push(x`!@_isNaN(${this.snippet})`);
          break;
        case "paused": {
          const last = block.get_unique_name(`${parent.var.name}_is_paused`);
          block.add_variable(last, x`true`);
          update_conditions.push(x`${last} !== (${last} = ${this.snippet})`);
          update_dom = b`${parent.var}[${last} ? "pause" : "play"]();`;
          mount_dom = null;
          break;
        }
        case "value":
          if (parent.node.get_static_attribute_value("type") === "file") {
            update_dom = null;
            mount_dom = null;
          }
      }
      if (update_dom) {
        if (update_conditions.length > 0) {
          const condition = update_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
          block.chunks.update.push(b`
					if (${condition}) {
						${update_dom}
					}
				`);
        } else
          block.chunks.update.push(update_dom);
      }
      if (mount_dom) {
        if (mount_conditions.length > 0) {
          const condition = mount_conditions.reduce((lhs, rhs) => x`${lhs} && ${rhs}`);
          block.chunks.mount.push(b`
					if (${condition}) {
						${mount_dom}
					}
				`);
        } else
          block.chunks.mount.push(mount_dom);
      }
    }
  }
  function get_dom_updater(element, binding) {
    const { node: node2 } = element;
    if (binding.is_readonly_media_attribute())
      return null;
    if (binding.node.name === "this")
      return null;
    if (node2.name === "select")
      return node2.get_static_attribute_value("multiple") === true ? b`@select_options(${element.var}, ${binding.snippet})` : b`@select_option(${element.var}, ${binding.snippet})`;
    if (binding.node.name === "group") {
      const type = node2.get_static_attribute_value("type");
      const condition = type === "checkbox" ? x`~${binding.snippet}.indexOf(${element.var}.__value)` : x`${element.var}.__value === ${binding.snippet}`;
      return b`${element.var}.checked = ${condition};`;
    }
    if (binding.node.name === "value")
      return b`@set_input_value(${element.var}, ${binding.snippet});`;
    return b`${element.var}.${binding.node.name} = ${binding.snippet};`;
  }
  function get_binding_group(renderer, value2, block) {
    const { parts } = flatten_reference(value2.raw_expression);
    let keypath = parts.join(".");
    const contexts = [];
    const contextual_dependencies = /* @__PURE__ */ new Set();
    const { template_scope } = value2.expression;
    const add_contextual_dependency = (dep) => {
      contextual_dependencies.add(dep);
      const owner = template_scope.get_owner(dep);
      if (owner.type === "EachBlock")
        for (const dep2 of owner.expression.contextual_dependencies)
          add_contextual_dependency(dep2);
    };
    for (const dep of value2.expression.contextual_dependencies)
      add_contextual_dependency(dep);
    for (const dep of contextual_dependencies) {
      const context = block.bindings.get(dep);
      let key;
      let name;
      if (context) {
        key = context.object.name;
        name = context.property.name;
      } else {
        key = dep;
        name = dep;
      }
      keypath = `${key}@${keypath}`;
      contexts.push(name);
    }
    if (!renderer.binding_groups.has(keypath)) {
      const index = renderer.binding_groups.size;
      contexts.forEach((context) => {
        renderer.add_to_context(context, true);
      });
      renderer.binding_groups.set(keypath, {
        binding_group: (to_reference = false) => {
          let binding_group = "$$binding_groups";
          let _secondary_indexes = contexts;
          if (to_reference) {
            binding_group = block.renderer.reference(binding_group);
            _secondary_indexes = _secondary_indexes.map((name) => block.renderer.reference(name));
          }
          if (_secondary_indexes.length > 0) {
            let obj = x`${binding_group}[${index}]`;
            _secondary_indexes.forEach((secondary_index) => {
              obj = x`${obj}[${secondary_index}]`;
            });
            return obj;
          } else
            return x`${binding_group}[${index}]`;
        },
        is_context: contexts.length > 0,
        contexts,
        index,
        keypath
      });
    }
    return renderer.binding_groups.get(keypath);
  }
  function get_event_handler(binding, renderer, block, name, lhs) {
    const contextual_dependencies = new Set(binding.node.expression.contextual_dependencies);
    const context = block.bindings.get(name);
    let set_store;
    if (context) {
      const { object, property, store, snippet } = context;
      lhs = replace_object(lhs, snippet);
      contextual_dependencies.add(object.name);
      contextual_dependencies.add(property.name);
      contextual_dependencies.delete(name);
      if (store)
        set_store = b`${store}.set(${`$${store}`});`;
    } else {
      const object = get_object(lhs);
      if (object.name[0] === "$") {
        const store = object.name.slice(1);
        set_store = b`${store}.set(${object.name});`;
      }
    }
    const value2 = get_value_from_dom(renderer, binding.parent, binding, block, contextual_dependencies);
    const mutation = b`
		${lhs} = ${value2};
		${set_store}
	`;
    return {
      uses_context: binding.node.is_contextual || binding.node.expression.uses_context,
      mutation,
      contextual_dependencies,
      lhs
    };
  }
  function get_value_from_dom(renderer, element, binding, block, contextual_dependencies) {
    const { node: node2 } = element;
    const { name } = binding.node;
    if (name === "this")
      return x`$$value`;
    if (node2.name === "select")
      return node2.get_static_attribute_value("multiple") === true ? x`@select_multiple_value(this)` : x`@select_value(this)`;
    const type = node2.get_static_attribute_value("type");
    if (name === "group") {
      if (type === "checkbox") {
        const { binding_group, contexts } = get_binding_group(renderer, binding.node, block);
        add_to_set(contextual_dependencies, contexts);
        return x`@get_binding_group_value(${binding_group()}, this.__value, this.checked)`;
      }
      return x`this.__value`;
    }
    if (type === "range" || type === "number")
      return x`@to_number(this.${name})`;
    if (name === "buffered" || name === "seekable" || name === "played")
      return x`@time_ranges_to_array(this.${name})`;
    return x`this.${name}`;
  }
  function compare_node(a, b2) {
    if (a === b2)
      return true;
    if (!a || !b2)
      return false;
    if (a.type !== b2.type)
      return false;
    switch (a.type) {
      case "Identifier":
        return a.name === b2.name;
      case "MemberExpression":
        return compare_node(a.object, b2.object) && compare_node(a.property, b2.property) && a.computed === b2.computed;
      case "Literal":
        return a.value === b2.value;
    }
  }
  function bind_this(component, block, binding, variable) {
    const fn = component.get_unique_name(`${variable.name}_binding`);
    block.renderer.add_to_context(fn.name);
    const callee = block.renderer.reference(fn.name);
    const { contextual_dependencies, mutation } = binding.handler;
    const dependencies = binding.get_update_dependencies();
    const body = b`
		${mutation}
		${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${block.renderer.invalidate(dep)};`)}
	`;
    if (contextual_dependencies.size) {
      const params = Array.from(contextual_dependencies).map((name) => ({
        type: "Identifier",
        name
      }));
      component.partly_hoisted.push(b`
			function ${fn}($$value, ${params}) {
				@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
					${body}
				});
			}
		`);
      const alias_map = /* @__PURE__ */ new Map();
      const args = [];
      for (let id2 of params) {
        const value2 = block.renderer.reference(id2.name);
        let found = false;
        if (block.variables.has(id2.name)) {
          let alias = id2.name;
          for (let i2 = 1; block.variables.has(alias) && !compare_node(block.variables.get(alias).init, value2); alias = `${id2.name}_${i2++}`)
            ;
          alias_map.set(alias, id2.name);
          id2 = {
            type: "Identifier",
            name: alias
          };
          found = block.variables.has(alias);
        }
        args.push(id2);
        if (!found)
          block.add_variable(id2, value2);
      }
      const assign = block.get_unique_name(`assign_${variable.name}`);
      const unassign = block.get_unique_name(`unassign_${variable.name}`);
      block.chunks.init.push(b`
			const ${assign} = () => ${callee}(${variable}, ${args});
			const ${unassign} = () => ${callee}(null, ${args});
		`);
      const condition = Array.from(args).map((name) => x`${name} !== ${block.renderer.reference(alias_map.get(name.name) || name.name)}`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
      block.chunks.update.push(b`
			if (${condition}) {
				${unassign}();
				${args.map((a) => b`${a} = ${block.renderer.reference(alias_map.get(a.name) || a.name)}`)};
				${assign}();
			}`);
      block.chunks.destroy.push(b`${unassign}();`);
      return b`${assign}();`;
    }
    component.partly_hoisted.push(b`
		function ${fn}($$value) {
			@binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				${body}
			});
		}
	`);
    block.chunks.destroy.push(b`${callee}(null);`);
    return b`${callee}(${variable});`;
  }
  class Tag$1 extends Wrapper {
    constructor(renderer, block, parent, node2) {
      super(renderer, block, parent, node2);
      this.cannot_use_innerhtml();
      if (!this.is_dependencies_static())
        this.not_static_content();
      block.add_dependencies(node2.expression.dependencies);
    }
    is_dependencies_static() {
      return this.node.expression.contextual_dependencies.size === 0 && this.node.expression.dynamic_dependencies().length === 0;
    }
    rename_this_method(block, update) {
      const dependencies = this.node.expression.dynamic_dependencies();
      let snippet = this.node.expression.manipulate(block);
      const value2 = this.node.should_cache && block.get_unique_name(`${this.var.name}_value`);
      const content = this.node.should_cache ? value2 : snippet;
      snippet = x`${snippet} + ""`;
      if (this.node.should_cache)
        block.add_variable(value2, snippet);
      if (dependencies.length > 0) {
        let condition = block.renderer.dirty(dependencies);
        if (block.has_outros)
          condition = x`!#current || ${condition}`;
        const update_cached_value = x`${value2} !== (${value2} = ${snippet})`;
        if (this.node.should_cache)
          condition = x`${condition} && ${update_cached_value}`;
        block.chunks.update.push(b`if (${condition}) ${update(content)}`);
      }
      return {
        init: content
      };
    }
  }
  class MustacheTagWrapper extends Tag$1 {
    constructor(renderer, block, parent, node2) {
      super(renderer, block, parent, node2);
      this.var = {
        type: "Identifier",
        name: "t"
      };
    }
    render(block, parent_node, parent_nodes) {
      const { init } = this.rename_this_method(block, (value2) => x`@set_data(${this.var}, ${value2})`);
      block.add_element(this.var, x`@text(${init})`, parent_nodes && x`@claim_text(${parent_nodes}, ${init})`, parent_node);
    }
  }
  class RawMustacheTagWrapper extends Tag$1 {
    constructor(renderer, block, parent, node2) {
      super(renderer, block, parent, node2);
      this.var = {
        type: "Identifier",
        name: "raw"
      };
      this.cannot_use_innerhtml();
      this.not_static_content();
    }
    render(block, parent_node, _parent_nodes) {
      const in_head = is_head(parent_node);
      const can_use_innerhtml = !in_head && parent_node && !this.prev && !this.next;
      if (can_use_innerhtml) {
        const insert = (content) => b`${parent_node}.innerHTML = ${content};`[0];
        const { init } = this.rename_this_method(block, (content) => insert(content));
        block.chunks.mount.push(insert(init));
      } else {
        const needs_anchor = in_head || (this.next ? !this.next.is_dom_node() : !this.parent || !this.parent.is_dom_node());
        const html_tag = block.get_unique_name("html_tag");
        const html_anchor = needs_anchor && block.get_unique_name("html_anchor");
        block.add_variable(html_tag);
        const { init } = this.rename_this_method(block, (content) => x`${html_tag}.p(${content})`);
        const update_anchor = needs_anchor ? html_anchor : this.next ? this.next.var : "null";
        const parent_element = this.node.find_nearest(/^Element/);
        const is_svg2 = parent_element && parent_element.namespace === namespaces.svg;
        block.chunks.create.push(b`${html_tag} = new @HtmlTag(${is_svg2 ? "true" : "false"});`);
        if (this.renderer.options.hydratable)
          block.chunks.claim.push(b`${html_tag} = @claim_html_tag(${_parent_nodes}, ${is_svg2 ? "true" : "false"});`);
        block.chunks.hydrate.push(b`${html_tag}.a = ${update_anchor};`);
        block.chunks.mount.push(b`${html_tag}.m(${init}, ${parent_node || "#target"}, ${parent_node ? null : "#anchor"});`);
        if (needs_anchor)
          block.add_element(html_anchor, x`@empty()`, x`@empty()`, parent_node);
        if (!parent_node || in_head)
          block.chunks.destroy.push(b`if (detaching) ${html_tag}.d();`);
      }
    }
  }
  const regex_contains_radio_or_checkbox_or_file = /radio|checkbox|file/;
  const regex_contains_radio_or_checkbox_or_range_or_file = /radio|checkbox|range|file/;
  const events = [
    {
      event_names: [
        "input"
      ],
      filter: (node2, _name) => node2.name === "textarea" || node2.name === "input" && !regex_contains_radio_or_checkbox_or_range_or_file.test(node2.get_static_attribute_value("type"))
    },
    {
      event_names: [
        "input"
      ],
      filter: (node2, name) => (name === "textContent" || name === "innerHTML") && node2.attributes.some((attribute) => attribute.name === "contenteditable")
    },
    {
      event_names: [
        "change"
      ],
      filter: (node2, _name) => node2.name === "select" || node2.name === "input" && regex_contains_radio_or_checkbox_or_file.test(node2.get_static_attribute_value("type"))
    },
    {
      event_names: [
        "change",
        "input"
      ],
      filter: (node2, _name) => node2.name === "input" && node2.get_static_attribute_value("type") === "range"
    },
    {
      event_names: [
        "elementresize"
      ],
      filter: (_node, name) => regex_dimensions.test(name)
    },
    // media events
    {
      event_names: [
        "timeupdate"
      ],
      filter: (node2, name) => node2.is_media_node() && (name === "currentTime" || name === "played" || name === "ended")
    },
    {
      event_names: [
        "durationchange"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "duration"
    },
    {
      event_names: [
        "play",
        "pause"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "paused"
    },
    {
      event_names: [
        "progress"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "buffered"
    },
    {
      event_names: [
        "loadedmetadata"
      ],
      filter: (node2, name) => node2.is_media_node() && (name === "buffered" || name === "seekable")
    },
    {
      event_names: [
        "volumechange"
      ],
      filter: (node2, name) => node2.is_media_node() && (name === "volume" || name === "muted")
    },
    {
      event_names: [
        "ratechange"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "playbackRate"
    },
    {
      event_names: [
        "seeking",
        "seeked"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "seeking"
    },
    {
      event_names: [
        "ended"
      ],
      filter: (node2, name) => node2.is_media_node() && name === "ended"
    },
    {
      event_names: [
        "resize"
      ],
      filter: (node2, name) => node2.is_media_node() && (name === "videoHeight" || name === "videoWidth")
    },
    // details event
    {
      event_names: [
        "toggle"
      ],
      filter: (node2, _name) => node2.name === "details"
    }
  ];
  const CHILD_DYNAMIC_ELEMENT_BLOCK = "child_dynamic_element";
  const regex_invalid_variable_identifier_characters$2 = /[^a-zA-Z0-9_$]/g;
  const regex_minus_signs = /-/g;
  class ElementWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.child_dynamic_element_block = null;
      this.child_dynamic_element = null;
      if (node2.is_dynamic_element && block.type !== CHILD_DYNAMIC_ELEMENT_BLOCK) {
        this.child_dynamic_element_block = block.child({
          comment: create_debugging_comment(node2, renderer.component),
          name: renderer.component.get_unique_name("create_dynamic_element"),
          type: CHILD_DYNAMIC_ELEMENT_BLOCK
        });
        renderer.blocks.push(this.child_dynamic_element_block);
        this.child_dynamic_element = new ElementWrapper(renderer, this.child_dynamic_element_block, parent, node2, strip_whitespace, next_sibling);
      }
      this.var = {
        type: "Identifier",
        name: node2.name.replace(regex_invalid_variable_identifier_characters$2, "_")
      };
      this.void = is_void(node2.name);
      this.class_dependencies = [];
      if (this.node.children.length)
        this.node.lets.forEach((l) => {
          extract_names(l.value || l.name).forEach((name) => {
            renderer.add_to_context(name, true);
          });
        });
      this.attributes = this.node.attributes.map((attribute) => {
        if (attribute.name === "style")
          return new StyleAttributeWrapper(this, block, attribute);
        if (attribute.type === "Spread")
          return new SpreadAttributeWrapper(this, block, attribute);
        return new AttributeWrapper(this, block, attribute);
      });
      this.bindings = this.node.bindings.map((binding) => new BindingWrapper(block, binding, this));
      this.event_handlers = this.node.handlers.map((event_handler) => new EventHandlerWrapper(event_handler, this));
      if (node2.intro || node2.outro) {
        if (node2.intro)
          block.add_intro(node2.intro.is_local);
        if (node2.outro)
          block.add_outro(node2.outro.is_local);
      }
      if (node2.animation)
        block.add_animation();
      block.add_dependencies(node2.tag_expr.dependencies);
      [
        node2.animation,
        node2.outro,
        ...node2.actions,
        ...node2.classes,
        ...node2.styles
      ].forEach((directive) => {
        if (directive && directive.expression)
          block.add_dependencies(directive.expression.dependencies);
      });
      node2.handlers.forEach((handler) => {
        if (handler.expression)
          block.add_dependencies(handler.expression.dependencies);
      });
      if (this.parent) {
        if (node2.actions.length > 0 || node2.animation || node2.bindings.length > 0 || node2.classes.length > 0 || node2.intro || node2.outro || node2.handlers.length > 0 || node2.styles.length > 0 || this.node.name === "option" || node2.tag_expr.dynamic_dependencies().length || renderer.options.dev) {
          this.parent.cannot_use_innerhtml();
          this.parent.not_static_content();
        }
      }
      this.fragment = new FragmentWrapper(renderer, block, node2.children, this, strip_whitespace, next_sibling);
    }
    render(block, parent_node, parent_nodes) {
      if (this.child_dynamic_element)
        this.render_dynamic_element(block, parent_node, parent_nodes);
      else
        this.render_element(block, parent_node, parent_nodes);
    }
    render_dynamic_element(block, parent_node, parent_nodes) {
      this.child_dynamic_element.render(this.child_dynamic_element_block, null, x`#nodes`);
      const previous_tag = block.get_unique_name("previous_tag");
      const tag2 = this.node.tag_expr.manipulate(block);
      block.add_variable(previous_tag, tag2);
      block.chunks.init.push(b`
			${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
			${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
			let ${this.var} = ${tag2} && ${this.child_dynamic_element_block.name}(#ctx);
		`);
      block.chunks.create.push(b`
			if (${this.var}) ${this.var}.c();
		`);
      if (this.renderer.options.hydratable)
        block.chunks.claim.push(b`
				if (${this.var}) ${this.var}.l(${parent_nodes});
			`);
      block.chunks.mount.push(b`
			if (${this.var}) ${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
		`);
      const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const has_transitions = !!(this.node.intro || this.node.outro);
      const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
      block.chunks.update.push(b`
			if (${tag2}) {
				if (!${previous_tag}) {
					${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
					${this.var}.c();
					${has_transitions && b`@transition_in(${this.var})`}
					${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
				} else if (${not_equal}(${previous_tag}, ${tag2})) {
					${this.var}.d(1);
					${this.renderer.options.dev && b`@validate_dynamic_element(${tag2});`}
					${this.renderer.options.dev && this.node.children.length > 0 && b`@validate_void_dynamic_element(${tag2});`}
					${this.var} = ${this.child_dynamic_element_block.name}(#ctx);
					${this.var}.c();
					${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			} else if (${previous_tag}) {
				${has_transitions ? b`
							@group_outros();
							@transition_out(${this.var}, 1, 1, () => {
								${this.var} = null;
							});
							@check_outros();
						` : b`
							${this.var}.d(1);
							${this.var} = null;
						`}
			}
			${previous_tag} = ${tag2};
		`);
      if (this.child_dynamic_element_block.has_intros)
        block.chunks.intro.push(b`@transition_in(${this.var});`);
      if (this.child_dynamic_element_block.has_outros)
        block.chunks.outro.push(b`@transition_out(${this.var});`);
      block.chunks.destroy.push(b`if (${this.var}) ${this.var}.d(detaching)`);
      if (this.node.animation) {
        const measurements = block.get_unique_name("measurements");
        block.add_variable(measurements);
        block.chunks.measure.push(b`${measurements} = ${this.var}.r()`);
        block.chunks.fix.push(b`${this.var}.f();`);
        block.chunks.animate.push(b`
				${this.var}.s(${measurements});
				${this.var}.a()
			`);
      }
    }
    is_dom_node() {
      return super.is_dom_node() && !this.child_dynamic_element;
    }
    render_element(block, parent_node, parent_nodes) {
      const { renderer } = this;
      if (this.node.name === "noscript")
        return;
      const node2 = this.var;
      const nodes = parent_nodes && block.get_unique_name(`${this.var.name}_nodes`);
      const children = x`@children(${this.node.name === "template" ? x`${node2}.content` : node2})`;
      block.add_variable(node2);
      const render_statement = this.get_render_statement(block);
      block.chunks.create.push(b`${node2} = ${render_statement};`);
      if (renderer.options.hydratable) {
        if (parent_nodes) {
          block.chunks.claim.push(b`
					${node2} = ${this.get_claim_statement(block, parent_nodes)};
				`);
          if (!this.void && this.node.children.length > 0)
            block.chunks.claim.push(b`
						var ${nodes} = ${children};
					`);
        } else
          block.chunks.claim.push(b`${node2} = ${render_statement};`);
      }
      if (parent_node) {
        const append = b`@append(${parent_node}, ${node2});`;
        append[0].expression.callee.loc = {
          start: this.renderer.locate(this.node.start),
          end: this.renderer.locate(this.node.end)
        };
        block.chunks.mount.push(append);
        if (is_head(parent_node))
          block.chunks.destroy.push(b`@detach(${node2});`);
      } else {
        const insert = b`@insert(#target, ${node2}, #anchor);`;
        insert[0].expression.callee.loc = {
          start: this.renderer.locate(this.node.start),
          end: this.renderer.locate(this.node.end)
        };
        block.chunks.mount.push(insert);
        block.chunks.destroy.push(b`if (detaching) @detach(${node2});`);
      }
      const can_use_textcontent = this.can_use_textcontent();
      const is_template = this.node.name === "template";
      const is_template_with_text_content = is_template && can_use_textcontent;
      if (!is_template_with_text_content && !this.node.namespace && (this.can_use_innerhtml || can_use_textcontent) && this.fragment.nodes.length > 0) {
        if (this.fragment.nodes.length === 1 && this.fragment.nodes[0].node.type === "Text")
          block.chunks.create.push(b`${node2}.textContent = ${string_literal(this.fragment.nodes[0].data)};`);
        else {
          const state = {
            quasi: {
              type: "TemplateElement",
              value: {
                raw: ""
              }
            }
          };
          const literal2 = {
            type: "TemplateLiteral",
            expressions: [],
            quasis: []
          };
          const can_use_raw_text = !this.can_use_innerhtml && can_use_textcontent;
          to_html(this.fragment.nodes, block, literal2, state, can_use_raw_text);
          literal2.quasis.push(state.quasi);
          block.chunks.create.push(b`${node2}.${this.can_use_innerhtml ? "innerHTML" : "textContent"} = ${literal2};`);
        }
      } else
        this.fragment.nodes.forEach((child) => {
          child.render(block, is_template ? x`${node2}.content` : node2, nodes);
        });
      const event_handler_or_binding_uses_context = this.bindings.some((binding) => binding.handler.uses_context) || this.node.handlers.some((handler) => handler.uses_context) || this.node.actions.some((action) => action.uses_context);
      if (event_handler_or_binding_uses_context)
        block.maintain_context = true;
      this.add_attributes(block);
      this.add_directives_in_order(block);
      this.add_transitions(block);
      this.add_animation(block);
      this.add_classes(block);
      this.add_styles(block);
      this.add_manual_style_scoping(block);
      if (nodes && this.renderer.options.hydratable && !this.void)
        block.chunks.claim.push(b`${this.node.children.length > 0 ? nodes : children}.forEach(@detach);`);
      if (renderer.options.dev) {
        const loc = renderer.locate(this.node.start);
        block.chunks.hydrate.push(b`@add_location(${this.var}, ${renderer.file_var}, ${loc.line - 1}, ${loc.column}, ${this.node.start});`);
      }
      block.renderer.dirty(this.node.tag_expr.dynamic_dependencies());
    }
    can_use_textcontent() {
      return this.is_static_content && this.fragment.nodes.every((node2) => node2.node.type === "Text" || node2.node.type === "MustacheTag");
    }
    get_render_statement(block) {
      const { name, namespace, tag_expr } = this.node;
      const reference = tag_expr.manipulate(block);
      if (namespace === namespaces.svg)
        return x`@svg_element(${reference})`;
      if (namespace)
        return x`@_document.createElementNS("${namespace}", "${name}")`;
      const is = this.attributes.find((attr) => attr.node.name === "is");
      if (is)
        return x`@element_is("${name}", ${is.render_chunks(block).reduce((lhs, rhs) => x`${lhs} + ${rhs}`)})`;
      return x`@element(${reference})`;
    }
    get_claim_statement(block, nodes) {
      const attributes = this.attributes.filter((attr) => !(attr instanceof SpreadAttributeWrapper) && !attr.property_name).map((attr) => p`${attr.name}: true`);
      let reference;
      if (this.node.tag_expr.node.type === "Literal") {
        if (this.node.namespace)
          reference = `"${this.node.tag_expr.node.value}"`;
        else
          reference = `"${(this.node.tag_expr.node.value || "").toUpperCase()}"`;
      } else if (this.node.namespace)
        reference = x`${this.node.tag_expr.manipulate(block)}`;
      else
        reference = x`(${this.node.tag_expr.manipulate(block)} || 'null').toUpperCase()`;
      if (this.node.namespace === namespaces.svg)
        return x`@claim_svg_element(${nodes}, ${reference}, { ${attributes} })`;
      else
        return x`@claim_element(${nodes}, ${reference}, { ${attributes} })`;
    }
    add_directives_in_order(block) {
      const binding_groups = events.map((event) => ({
        events: event.event_names,
        bindings: this.bindings.filter((binding) => binding.node.name !== "this").filter((binding) => event.filter(this.node, binding.node.name))
      })).filter((group) => group.bindings.length);
      const this_binding = this.bindings.find((b2) => b2.node.name === "this");
      function getOrder(item) {
        if (item instanceof EventHandlerWrapper)
          return item.node.start;
        else if (item instanceof BindingWrapper)
          return item.node.start;
        else if (item instanceof Action)
          return item.start;
        else
          return item.bindings[0].node.start;
      }
      [
        ...binding_groups,
        ...this.event_handlers,
        this_binding,
        ...this.node.actions
      ].filter(Boolean).sort((a, b2) => getOrder(a) - getOrder(b2)).forEach((item) => {
        if (item instanceof EventHandlerWrapper)
          add_event_handler(block, this.var, item);
        else if (item instanceof BindingWrapper)
          this.add_this_binding(block, item);
        else if (item instanceof Action)
          add_action(block, this.var, item);
        else
          this.add_bindings(block, item);
      });
    }
    add_bindings(block, binding_group) {
      const { renderer } = this;
      if (binding_group.bindings.length === 0)
        return;
      renderer.component.has_reactive_assignments = true;
      const lock = binding_group.bindings.some((binding) => binding.needs_lock) ? block.get_unique_name(`${this.var.name}_updating`) : null;
      if (lock)
        block.add_variable(lock, x`false`);
      const handler = renderer.component.get_unique_name(`${this.var.name}_${binding_group.events.join("_")}_handler`);
      renderer.add_to_context(handler.name);
      const needs_lock = binding_group.bindings.some((binding) => binding.needs_lock);
      const dependencies = /* @__PURE__ */ new Set();
      const contextual_dependencies = /* @__PURE__ */ new Set();
      binding_group.bindings.forEach((binding) => {
        add_to_set(dependencies, binding.get_update_dependencies());
        add_to_set(contextual_dependencies, binding.handler.contextual_dependencies);
        binding.render(block, lock);
      });
      let animation_frame;
      if (binding_group.events[0] === "timeupdate") {
        animation_frame = block.get_unique_name(`${this.var.name}_animationframe`);
        block.add_variable(animation_frame);
      }
      const has_local_function = contextual_dependencies.size > 0 || needs_lock || animation_frame;
      let callee = renderer.reference(handler);
      if (has_local_function) {
        const args = Array.from(contextual_dependencies).map((name) => renderer.reference(name));
        if (animation_frame)
          block.chunks.init.push(b`
					function ${handler}() {
						@_cancelAnimationFrame(${animation_frame});
						if (!${this.var}.paused) {
							${animation_frame} = @raf(${handler});
							${needs_lock && b`${lock} = true;`}
						}
						${callee}.call(${this.var}, ${args});
					}
				`);
        else
          block.chunks.init.push(b`
					function ${handler}() {
						${needs_lock && b`${lock} = true;`}
						${callee}.call(${this.var}, ${args});
					}
				`);
        callee = handler;
      }
      const params = Array.from(contextual_dependencies).map((name) => ({
        type: "Identifier",
        name
      }));
      this.renderer.component.partly_hoisted.push(b`
			function ${handler}(${params}) {
				${binding_group.bindings.map((b2) => b2.handler.mutation)}
				${Array.from(dependencies).filter((dep) => dep[0] !== "$").filter((dep) => !contextual_dependencies.has(dep)).map((dep) => b`${this.renderer.invalidate(dep)};`)}
			}
		`);
      binding_group.events.forEach((name) => {
        if (name === "elementresize") {
          const resize_listener = block.get_unique_name(`${this.var.name}_resize_listener`);
          block.add_variable(resize_listener);
          block.chunks.mount.push(b`${resize_listener} = @add_resize_listener(${this.var}, ${callee}.bind(${this.var}));`);
          block.chunks.destroy.push(b`${resize_listener}();`);
        } else
          block.event_listeners.push(x`@listen(${this.var}, "${name}", ${callee})`);
      });
      const some_initial_state_is_undefined = binding_group.bindings.map((binding) => x`${binding.snippet} === void 0`).reduce((lhs, rhs) => x`${lhs} || ${rhs}`);
      const should_initialise = this.node.name === "select" || binding_group.bindings.find((binding) => {
        return binding.node.name === "indeterminate" || binding.node.name === "textContent" || binding.node.name === "innerHTML" || binding.is_readonly_media_attribute();
      });
      if (should_initialise) {
        const callback = has_local_function ? handler : x`() => ${callee}.call(${this.var})`;
        block.chunks.hydrate.push(b`if (${some_initial_state_is_undefined}) @add_render_callback(${callback});`);
      }
      if (binding_group.events[0] === "elementresize")
        block.chunks.hydrate.push(b`@add_render_callback(() => ${callee}.call(${this.var}));`);
      if (lock)
        block.chunks.update.push(b`${lock} = false;`);
    }
    add_this_binding(block, this_binding) {
      const { renderer } = this;
      renderer.component.has_reactive_assignments = true;
      const binding_callback = bind_this(renderer.component, block, this_binding, this.var);
      block.chunks.mount.push(binding_callback);
    }
    add_attributes(block) {
      this.attributes.forEach((attribute) => {
        if (attribute.node.name === "class") {
          const dependencies = attribute.node.get_dependencies();
          push_array$1(this.class_dependencies, dependencies);
        }
      });
      if (this.node.attributes.some((attr) => attr.is_spread) || this.node.is_dynamic_element) {
        this.add_spread_attributes(block);
        return;
      }
      this.attributes.forEach((attribute) => {
        attribute.render(block);
      });
    }
    add_spread_attributes(block) {
      const levels = block.get_unique_name(`${this.var.name}_levels`);
      const data2 = block.get_unique_name(`${this.var.name}_data`);
      const initial_props = [];
      const updates = [];
      this.attributes.forEach((attr) => {
        const dependencies = attr.node.get_dependencies();
        const condition = dependencies.length > 0 ? block.renderer.dirty(dependencies) : null;
        if (attr instanceof SpreadAttributeWrapper) {
          const snippet = attr.node.expression.manipulate(block);
          initial_props.push(snippet);
          updates.push(condition ? x`${condition} && ${snippet}` : snippet);
        } else {
          const name = attr.property_name || attr.name;
          initial_props.push(x`{ ${name}: ${attr.get_init(block, attr.get_value(block))} }`);
          const snippet = x`{ ${name}: ${attr.should_cache ? attr.last : attr.get_value(block)} }`;
          updates.push(condition ? x`${attr.get_dom_update_conditions(block, condition)} && ${snippet}` : snippet);
        }
      });
      block.chunks.init.push(b`
			let ${levels} = [${initial_props}];

			let ${data2} = {};
			for (let #i = 0; #i < ${levels}.length; #i += 1) {
				${data2} = @assign(${data2}, ${levels}[#i]);
			}
		`);
      const fn = this.node.namespace === namespaces.svg ? x`@set_svg_attributes` : x`@set_attributes`;
      if (this.node.is_dynamic_element) {
        const tag2 = this.node.tag_expr.manipulate(block);
        const attr_update = this.node.namespace === namespaces.svg ? b`${fn}(${this.var}, ${data2});` : b`
					if (/-/.test(${tag2})) {
						@set_custom_element_data_map(${this.var}, ${data2});
					} else {
						${fn}(${this.var}, ${data2});
					}`;
        block.chunks.hydrate.push(attr_update);
        block.chunks.update.push(b`
				${data2} = @get_spread_update(${levels}, [${updates}]);
				${attr_update}`);
      } else {
        block.chunks.hydrate.push(b`${fn}(${this.var}, ${data2});`);
        block.chunks.update.push(b`
				${fn}(${this.var}, ${data2} = @get_spread_update(${levels}, [
					${updates}
				]));
			`);
      }
      if (this.node.name === "select") {
        const dependencies = /* @__PURE__ */ new Set();
        for (const attr of this.attributes)
          for (const dep of attr.node.dependencies)
            dependencies.add(dep);
        block.chunks.mount.push(b`
				(${data2}.multiple ? @select_options : @select_option)(${this.var}, ${data2}.value);
			`);
        block.chunks.update.push(b`
				if (${block.renderer.dirty(Array.from(dependencies))} && 'value' in ${data2}) (${data2}.multiple ? @select_options : @select_option)(${this.var}, ${data2}.value);
			`);
      } else if (this.node.name === "input" && this.attributes.find((attr) => attr.node.name === "value")) {
        const type = this.node.get_static_attribute_value("type");
        if (type === null || type === "" || type === "text" || type === "email" || type === "password") {
          block.chunks.mount.push(b`
					${this.var}.value = ${data2}.value;
				`);
          block.chunks.update.push(b`
					if ('value' in ${data2}) {
						${this.var}.value = ${data2}.value;
					}
				`);
        }
      }
      if ([
        "button",
        "input",
        "keygen",
        "select",
        "textarea"
      ].includes(this.node.name))
        block.chunks.mount.push(b`
				if (${this.var}.autofocus) ${this.var}.focus();
			`);
    }
    add_transitions(block) {
      const { intro, outro } = this.node;
      if (!intro && !outro)
        return;
      if (intro === outro) {
        const name = block.get_unique_name(`${this.var.name}_transition`);
        const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
        block.add_variable(name);
        const fn = this.renderer.reference(intro.name);
        const intro_block = b`
				@add_render_callback(() => {
					if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, true);
					${name}.run(1);
				});
			`;
        const outro_block = b`
				if (!${name}) ${name} = @create_bidirectional_transition(${this.var}, ${fn}, ${snippet}, false);
				${name}.run(0);
			`;
        if (intro.is_local) {
          block.chunks.intro.push(b`
					if (#local) {
						${intro_block}
					}
				`);
          block.chunks.outro.push(b`
					if (#local) {
						${outro_block}
					}
				`);
        } else {
          block.chunks.intro.push(intro_block);
          block.chunks.outro.push(outro_block);
        }
        block.chunks.destroy.push(b`if (detaching && ${name}) ${name}.end();`);
      } else {
        const intro_name = intro && block.get_unique_name(`${this.var.name}_intro`);
        const outro_name = outro && block.get_unique_name(`${this.var.name}_outro`);
        if (intro) {
          block.add_variable(intro_name);
          const snippet = intro.expression ? intro.expression.manipulate(block) : x`{}`;
          const fn = this.renderer.reference(intro.name);
          let intro_block;
          if (outro) {
            intro_block = b`
						@add_render_callback(() => {
							if (${outro_name}) ${outro_name}.end(1);
							${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
							${intro_name}.start();
						});
					`;
            block.chunks.outro.push(b`if (${intro_name}) ${intro_name}.invalidate();`);
          } else
            intro_block = b`
						if (!${intro_name}) {
							@add_render_callback(() => {
								${intro_name} = @create_in_transition(${this.var}, ${fn}, ${snippet});
								${intro_name}.start();
							});
						}
					`;
          if (intro.is_local)
            intro_block = b`
						if (#local) {
							${intro_block}
						}
					`;
          block.chunks.intro.push(intro_block);
        }
        if (outro) {
          block.add_variable(outro_name);
          const snippet = outro.expression ? outro.expression.manipulate(block) : x`{}`;
          const fn = this.renderer.reference(outro.name);
          if (!intro)
            block.chunks.intro.push(b`
						if (${outro_name}) ${outro_name}.end(1);
					`);
          let outro_block = b`
					${outro_name} = @create_out_transition(${this.var}, ${fn}, ${snippet});
				`;
          if (outro.is_local)
            outro_block = b`
						if (#local) {
							${outro_block}
						}
					`;
          block.chunks.outro.push(outro_block);
          block.chunks.destroy.push(b`if (detaching && ${outro_name}) ${outro_name}.end();`);
        }
      }
      if (intro && intro.expression && intro.expression.dependencies.size || outro && outro.expression && outro.expression.dependencies.size)
        block.maintain_context = true;
    }
    add_animation(block) {
      if (!this.node.animation)
        return;
      const { outro } = this.node;
      const rect = block.get_unique_name("rect");
      const stop_animation = block.get_unique_name("stop_animation");
      block.add_variable(rect);
      block.add_variable(stop_animation, x`@noop`);
      block.chunks.measure.push(b`
			${rect} = ${this.var}.getBoundingClientRect();
		`);
      if (block.type === CHILD_DYNAMIC_ELEMENT_BLOCK) {
        block.chunks.measure.push(b`return ${rect}`);
        block.chunks.restore_measurements.push(b`${rect} = #measurement;`);
      }
      block.chunks.fix.push(b`
			@fix_position(${this.var});
			${stop_animation}();
			${outro && b`@add_transform(${this.var}, ${rect});`}
		`);
      let params;
      if (this.node.animation.expression) {
        params = this.node.animation.expression.manipulate(block);
        if (this.node.animation.expression.dynamic_dependencies().length) {
          const params_var = block.get_unique_name("params");
          block.add_variable(params_var);
          block.chunks.measure.push(b`${params_var} = ${params};`);
          params = params_var;
        }
      } else
        params = x`{}`;
      const name = this.renderer.reference(this.node.animation.name);
      block.chunks.animate.push(b`
			${stop_animation}();
			${stop_animation} = @create_animation(${this.var}, ${rect}, ${name}, ${params});
		`);
    }
    add_classes(block) {
      const has_spread = this.node.attributes.some((attr) => attr.is_spread);
      this.node.classes.forEach((class_directive) => {
        const { expression, name } = class_directive;
        let snippet;
        let dependencies;
        if (expression) {
          snippet = expression.manipulate(block);
          dependencies = expression.dependencies;
        } else {
          snippet = name;
          dependencies = /* @__PURE__ */ new Set([
            name
          ]);
        }
        const updater = b`@toggle_class(${this.var}, "${name}", ${snippet});`;
        block.chunks.hydrate.push(updater);
        if (has_spread || this.node.is_dynamic_element)
          block.chunks.update.push(updater);
        else if (dependencies && dependencies.size > 0 || this.class_dependencies.length) {
          const all_dependencies = this.class_dependencies.concat(...dependencies);
          let condition = block.renderer.dirty(all_dependencies);
          if (block.has_outros)
            condition = x`!#current || ${condition}`;
          const any_dynamic_dependencies = all_dependencies.some((dep) => {
            const variable = this.renderer.component.var_lookup.get(dep);
            return !variable || is_dynamic(variable);
          });
          if (any_dynamic_dependencies)
            block.chunks.update.push(b`
						if (${condition}) {
							${updater}
						}
					`);
        }
      });
    }
    add_styles(block) {
      const has_spread = this.node.attributes.some((attr) => attr.is_spread);
      this.node.styles.forEach((style_directive) => {
        const { name, expression, should_cache: should_cache2, important } = style_directive;
        const snippet = expression.manipulate(block);
        let cached_snippet;
        if (should_cache2) {
          cached_snippet = block.get_unique_name(`style_${name.replace(regex_minus_signs, "_")}`);
          block.add_variable(cached_snippet, snippet);
        }
        const updater = b`@set_style(${this.var}, "${name}", ${should_cache2 ? cached_snippet : snippet}, ${important ? 1 : null})`;
        block.chunks.hydrate.push(updater);
        const dependencies = expression.dynamic_dependencies();
        if (has_spread)
          block.chunks.update.push(updater);
        else if (dependencies.length > 0) {
          if (should_cache2)
            block.chunks.update.push(b`
							if (${block.renderer.dirty(dependencies)} && (${cached_snippet} !== (${cached_snippet} = ${snippet}))) {
								${updater}
							}
					`);
          else
            block.chunks.update.push(b`
						if (${block.renderer.dirty(dependencies)}) {
							${updater}
						}
					`);
        }
      });
    }
    add_manual_style_scoping(block) {
      if (this.node.needs_manual_style_scoping) {
        const updater = b`@toggle_class(${this.var}, "${this.node.component.stylesheet.id}", true);`;
        block.chunks.hydrate.push(updater);
        block.chunks.update.push(updater);
      }
    }
  }
  const regex_backticks = /`/g;
  const regex_dollar_signs = /\$/g;
  function to_html(wrappers2, block, literal2, state, can_use_raw_text) {
    wrappers2.forEach((wrapper) => {
      if (wrapper instanceof TextWrapper) {
        if (wrapper.use_space())
          state.quasi.value.raw += " ";
        const parent = wrapper.node.parent;
        const raw = parent && (parent.name === "script" || parent.name === "style" || can_use_raw_text);
        state.quasi.value.raw += (raw ? wrapper.data : escape_html(wrapper.data)).replace(regex_backslashes, "\\\\").replace(regex_backticks, "\\`").replace(regex_dollar_signs, "\\$");
      } else if (wrapper instanceof MustacheTagWrapper || wrapper instanceof RawMustacheTagWrapper) {
        literal2.quasis.push(state.quasi);
        literal2.expressions.push(wrapper.node.expression.manipulate(block));
        state.quasi = {
          type: "TemplateElement",
          value: {
            raw: ""
          }
        };
      } else if (wrapper.node.name === "noscript")
        ;
      else {
        state.quasi.value.raw += `<${wrapper.node.name}`;
        const is_empty_textarea = wrapper.node.name === "textarea" && wrapper.fragment.nodes.length === 0;
        wrapper.attributes.forEach((attr) => {
          if (is_empty_textarea && attr.node.name === "value")
            return;
          state.quasi.value.raw += ` ${fix_attribute_casing(attr.node.name)}="`;
          to_html_for_attr_value(attr, block, literal2, state);
          state.quasi.value.raw += '"';
        });
        if (!wrapper.void) {
          state.quasi.value.raw += ">";
          if (wrapper.node.name === "pre") {
            const first = wrapper.fragment.nodes[0];
            if (first && first.node.type === "Text" && regex_starts_with_newline.test(first.node.data))
              state.quasi.value.raw += "\n";
          }
          if (is_empty_textarea) {
            const value_attribute = wrapper.attributes.find((attr) => attr.node.name === "value");
            if (value_attribute) {
              const first = value_attribute.node.chunks[0];
              if (first && first.type === "Text" && regex_starts_with_newline.test(first.data))
                state.quasi.value.raw += "\n";
              to_html_for_attr_value(value_attribute, block, literal2, state);
            }
          }
          to_html(wrapper.fragment.nodes, block, literal2, state);
          state.quasi.value.raw += `</${wrapper.node.name}>`;
        } else
          state.quasi.value.raw += "/>";
      }
    });
  }
  function to_html_for_attr_value(attr, block, literal2, state) {
    attr.node.chunks.forEach((chunk) => {
      if (chunk.type === "Text")
        state.quasi.value.raw += escape_html(chunk.data);
      else {
        literal2.quasis.push(state.quasi);
        literal2.expressions.push(chunk.manipulate(block));
        state.quasi = {
          type: "TemplateElement",
          value: {
            raw: ""
          }
        };
      }
    });
  }
  class HeadWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.can_use_innerhtml = false;
      this.fragment = new FragmentWrapper(renderer, block, node2.children, this, strip_whitespace, next_sibling);
    }
    render(block, _parent_node, _parent_nodes) {
      let nodes;
      if (this.renderer.options.hydratable && this.fragment.nodes.length) {
        nodes = block.get_unique_name("head_nodes");
        block.chunks.claim.push(b`const ${nodes} = @head_selector('${this.node.id}', @_document.head);`);
      }
      this.fragment.render(block, x`@_document.head`, nodes);
      if (nodes && this.renderer.options.hydratable)
        block.chunks.claim.push(b`${nodes}.forEach(@detach);`);
    }
  }
  function is_else_if(node2) {
    return node2 && node2.children.length === 1 && node2.children[0].type === "IfBlock";
  }
  class IfBlockBranch extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.var = null;
      const { expression } = node2;
      const is_else = !expression;
      if (expression) {
        this.dependencies = expression.dynamic_dependencies();
        let should_cache2 = false;
        walk(expression.node, {
          enter(node3) {
            if (node3.type === "CallExpression" || node3.type === "NewExpression")
              should_cache2 = true;
          }
        });
        if (should_cache2) {
          this.condition = block.get_unique_name("show_if");
          this.snippet = expression.manipulate(block);
        } else
          this.condition = expression.manipulate(block);
      }
      add_const_tags_context(renderer, this.node.const_tags);
      this.block = block.child({
        comment: create_debugging_comment(node2, parent.renderer.component),
        name: parent.renderer.component.get_unique_name(is_else ? "create_else_block" : "create_if_block"),
        type: node2.expression ? "if" : "else"
      });
      this.fragment = new FragmentWrapper(renderer, this.block, node2.children, parent, strip_whitespace, next_sibling);
      this.is_dynamic = this.block.dependencies.size > 0;
      if (node2.const_tags.length > 0)
        this.get_ctx_name = parent.renderer.component.get_unique_name(is_else ? "get_else_ctx" : "get_if_ctx");
    }
  }
  class IfBlockWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.needs_update = false;
      this.var = {
        type: "Identifier",
        name: "if_block"
      };
      this.cannot_use_innerhtml();
      this.not_static_content();
      this.branches = [];
      const blocks = [];
      let is_dynamic2 = false;
      let has_intros = false;
      let has_outros = false;
      const create_branches = (node3) => {
        const branch = new IfBlockBranch(renderer, block, this, node3, strip_whitespace, next_sibling);
        this.branches.push(branch);
        blocks.push(branch.block);
        block.add_dependencies(node3.expression.dependencies);
        if (branch.block.dependencies.size > 0) {
          is_dynamic2 = true;
          block.add_dependencies(branch.block.dependencies);
        }
        if (branch.dependencies && branch.dependencies.length > 0)
          this.needs_update = true;
        if (branch.block.has_intros)
          has_intros = true;
        if (branch.block.has_outros)
          has_outros = true;
        if (is_else_if(node3.else))
          create_branches(node3.else.children[0]);
        else if (node3.else) {
          const branch2 = new IfBlockBranch(renderer, block, this, node3.else, strip_whitespace, next_sibling);
          this.branches.push(branch2);
          blocks.push(branch2.block);
          if (branch2.block.dependencies.size > 0) {
            is_dynamic2 = true;
            block.add_dependencies(branch2.block.dependencies);
          }
          if (branch2.block.has_intros)
            has_intros = true;
          if (branch2.block.has_outros)
            has_outros = true;
        }
      };
      create_branches(this.node);
      blocks.forEach((block2) => {
        block2.has_update_method = is_dynamic2;
        block2.has_intro_method = has_intros;
        block2.has_outro_method = has_outros;
      });
      push_array$1(renderer.blocks, blocks);
    }
    render(block, parent_node, parent_nodes) {
      const name = this.var;
      const needs_anchor = this.next ? !this.next.is_dom_node() : !parent_node || !this.parent.is_dom_node();
      const anchor = needs_anchor ? block.get_unique_name(`${this.var.name}_anchor`) : this.next && this.next.var || "null";
      const has_else = !this.branches[this.branches.length - 1].condition;
      const if_exists_condition = has_else ? null : name;
      const dynamic = this.branches[0].block.has_update_method;
      const has_intros = this.branches[0].block.has_intro_method;
      const has_outros = this.branches[0].block.has_outro_method;
      const has_transitions = has_intros || has_outros;
      this.branches.forEach((branch) => {
        if (branch.get_ctx_name)
          this.renderer.blocks.push(b`
				function ${branch.get_ctx_name}(#ctx) {
					const child_ctx = #ctx.slice();
					${add_const_tags(block, branch.node.const_tags, "child_ctx")}
					return child_ctx;
				}
				`);
      });
      const vars = {
        name,
        anchor,
        if_exists_condition,
        has_else,
        has_transitions
      };
      const detaching = parent_node && !is_head(parent_node) ? null : "detaching";
      if (this.node.else) {
        this.branches.forEach((branch) => {
          if (branch.snippet)
            block.add_variable(branch.condition);
        });
        if (has_outros) {
          this.render_compound_with_outros(block, parent_node, parent_nodes, dynamic, vars, detaching);
          block.chunks.outro.push(b`@transition_out(${name});`);
        } else
          this.render_compound(block, parent_node, parent_nodes, dynamic, vars, detaching);
      } else {
        this.render_simple(block, parent_node, parent_nodes, dynamic, vars, detaching);
        if (has_outros)
          block.chunks.outro.push(b`@transition_out(${name});`);
      }
      if (if_exists_condition)
        block.chunks.create.push(b`if (${if_exists_condition}) ${name}.c();`);
      else
        block.chunks.create.push(b`${name}.c();`);
      if (parent_nodes && this.renderer.options.hydratable) {
        if (if_exists_condition)
          block.chunks.claim.push(b`if (${if_exists_condition}) ${name}.l(${parent_nodes});`);
        else
          block.chunks.claim.push(b`${name}.l(${parent_nodes});`);
      }
      if (has_intros || has_outros)
        block.chunks.intro.push(b`@transition_in(${name});`);
      if (needs_anchor)
        block.add_element(anchor, x`@empty()`, parent_nodes && x`@empty()`, parent_node);
      this.branches.forEach((branch) => {
        branch.fragment.render(branch.block, null, x`#nodes`);
      });
    }
    render_compound(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, if_exists_condition, has_transitions }, detaching) {
      const select_block_type = this.renderer.component.get_unique_name("select_block_type");
      const current_block_type = block.get_unique_name("current_block_type");
      const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
      const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
      const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type})` : x`#ctx`;
      const get_block = has_else ? x`${current_block_type}(${if_ctx})` : x`${current_block_type} && ${current_block_type}(${if_ctx})`;
      if (this.needs_update)
        block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ dependencies, condition, snippet }) => {
          return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
        })}
					${this.branches.map(({ condition, snippet, block: block2 }) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${block2.name};` : b`return ${block2.name};`)}
				}
			`);
      else
        block.chunks.init.push(b`
				function ${select_block_type}(#ctx, #dirty) {
					${this.branches.map(({ condition, snippet, block: block2 }) => condition ? b`if (${snippet || condition}) return ${block2.name};` : b`return ${block2.name};`)}
				}
			`);
      if (need_select_block_ctx) {
        if (this.branches.every((branch) => branch.get_ctx_name))
          block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ condition, get_ctx_name, block: block2 }) => {
            return condition ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
          }).filter(Boolean)}
					}
				`);
        else
          block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #type) {
						${this.branches.map(({ get_ctx_name, block: block2 }) => {
            return get_ctx_name ? b`if (#type === ${block2.name}) return ${get_ctx_name}(#ctx);` : null;
          }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
      block.chunks.init.push(b`
			let ${current_block_type} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
			let ${name} = ${get_block};
		`);
      const initial_mount_node = parent_node || "#target";
      const anchor_node = parent_node ? "null" : "#anchor";
      if (if_exists_condition)
        block.chunks.mount.push(b`if (${if_exists_condition}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
      else
        block.chunks.mount.push(b`${name}.m(${initial_mount_node}, ${anchor_node});`);
      if (this.needs_update) {
        const update_mount_node = this.get_update_mount_node(anchor);
        const change_block = b`
				${if_exists_condition ? b`if (${if_exists_condition}) ${name}.d(1)` : b`${name}.d(1)`};
				${name} = ${get_block};
				if (${name}) {
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
        if (dynamic)
          block.chunks.update.push(b`
					if (${current_block_type} === (${current_block_type} = ${select_block_type}(#ctx, #dirty)) && ${name}) {
						${name}.p(${if_ctx}, #dirty);
					} else {
						${change_block}
					}
				`);
        else
          block.chunks.update.push(b`
					if (${current_block_type} !== (${current_block_type} = ${select_block_type}(#ctx, #dirty))) {
						${change_block}
					}
				`);
      } else if (dynamic) {
        if (if_exists_condition)
          block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
        else
          block.chunks.update.push(b`${name}.p(${if_ctx}, #dirty);`);
      }
      if (if_exists_condition)
        block.chunks.destroy.push(b`
				if (${if_exists_condition}) {
					${name}.d(${detaching});
				}
			`);
      else
        block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
    }
    // if any of the siblings have outros, we need to keep references to the blocks
    // (TODO does this only apply to bidi transitions?)
    render_compound_with_outros(block, parent_node, _parent_nodes, dynamic, { name, anchor, has_else, has_transitions, if_exists_condition }, detaching) {
      const select_block_type = this.renderer.component.get_unique_name("select_block_type");
      const current_block_type_index = block.get_unique_name("current_block_type_index");
      const previous_block_index = block.get_unique_name("previous_block_index");
      const if_block_creators = block.get_unique_name("if_block_creators");
      const if_blocks = block.get_unique_name("if_blocks");
      const need_select_block_ctx = this.branches.some((branch) => branch.get_ctx_name);
      const select_block_ctx = need_select_block_ctx ? block.get_unique_name("select_block_ctx") : null;
      const if_ctx = select_block_ctx ? x`${select_block_ctx}(#ctx, ${current_block_type_index})` : x`#ctx`;
      const if_current_block_type_index = has_else ? (nodes) => nodes : (nodes) => b`if (~${current_block_type_index}) { ${nodes} }`;
      block.add_variable(current_block_type_index);
      block.add_variable(name);
      block.chunks.init.push(b`
			const ${if_block_creators} = [
				${this.branches.map((branch) => branch.block.name)}
			];

			const ${if_blocks} = [];

			${this.needs_update ? b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ dependencies, condition, snippet }) => {
        return b`${snippet && dependencies.length > 0 ? b`if (${block.renderer.dirty(dependencies)}) ${condition} = null;` : null}`;
      })}
						${this.branches.map(({ condition, snippet }, i2) => condition ? b`
								${snippet && b`if (${condition} == null) ${condition} = !!${snippet}`}
								if (${condition}) return ${i2};` : b`return ${i2};`)}
								${!has_else && b`return -1;`}
							}
						` : b`
					function ${select_block_type}(#ctx, #dirty) {
						${this.branches.map(({ condition, snippet }, i2) => condition ? b`if (${snippet || condition}) return ${i2};` : b`return ${i2};`)}
						${!has_else && b`return -1;`}
					}
				`}
		`);
      if (need_select_block_ctx) {
        if (this.branches.every((branch) => branch.get_ctx_name))
          block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ condition, get_ctx_name }, i2) => {
            return condition ? b`if (#index === ${i2}) return ${get_ctx_name}(#ctx);` : b`return ${get_ctx_name}(#ctx);`;
          }).filter(Boolean)}
					}
				`);
        else
          block.chunks.init.push(b`
					function ${select_block_ctx}(#ctx, #index) {
						${this.branches.map(({ get_ctx_name }, i2) => {
            return get_ctx_name ? b`if (#index === ${i2}) return ${get_ctx_name}(#ctx);` : null;
          }).filter(Boolean)}
						return #ctx;
					}
				`);
      }
      if (has_else)
        block.chunks.init.push(b`
				${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()});
				${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
			`);
      else
        block.chunks.init.push(b`
				if (~(${current_block_type_index} = ${select_block_type}(#ctx, ${this.renderer.get_initial_dirty()}))) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
				}
			`);
      const initial_mount_node = parent_node || "#target";
      const anchor_node = parent_node ? "null" : "#anchor";
      block.chunks.mount.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].m(${initial_mount_node}, ${anchor_node});`));
      if (this.needs_update) {
        const update_mount_node = this.get_update_mount_node(anchor);
        const destroy_old_block = b`
				@group_outros();
				@transition_out(${if_blocks}[${previous_block_index}], 1, 1, () => {
					${if_blocks}[${previous_block_index}] = null;
				});
				@check_outros();
			`;
        const create_new_block = b`
				${name} = ${if_blocks}[${current_block_type_index}];
				if (!${name}) {
					${name} = ${if_blocks}[${current_block_type_index}] = ${if_block_creators}[${current_block_type_index}](${if_ctx});
					${name}.c();
				} else {
					${dynamic && b`${name}.p(${if_ctx}, #dirty);`}
				}
				${has_transitions && b`@transition_in(${name}, 1);`}
				${name}.m(${update_mount_node}, ${anchor});
			`;
        const change_block = has_else ? b`
					${destroy_old_block}

					${create_new_block}
				` : b`
					if (${name}) {
						${destroy_old_block}
					}

					if (~${current_block_type_index}) {
						${create_new_block}
					} else {
						${name} = null;
					}
				`;
        block.chunks.update.push(b`
				let ${previous_block_index} = ${current_block_type_index};
				${current_block_type_index} = ${select_block_type}(#ctx, #dirty);
			`);
        if (dynamic)
          block.chunks.update.push(b`
					if (${current_block_type_index} === ${previous_block_index}) {
						${if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].p(${if_ctx}, #dirty);`)}
					} else {
						${change_block}
					}
				`);
        else
          block.chunks.update.push(b`
					if (${current_block_type_index} !== ${previous_block_index}) {
						${change_block}
					}
				`);
      } else if (dynamic) {
        if (if_exists_condition)
          block.chunks.update.push(b`if (${if_exists_condition}) ${name}.p(${if_ctx}, #dirty);`);
        else
          block.chunks.update.push(b`${name}.p(${if_ctx}, #dirty);`);
      }
      block.chunks.destroy.push(if_current_block_type_index(b`${if_blocks}[${current_block_type_index}].d(${detaching});`));
    }
    render_simple(block, parent_node, _parent_nodes, dynamic, { name, anchor, if_exists_condition, has_transitions }, detaching) {
      const branch = this.branches[0];
      const if_ctx = branch.get_ctx_name ? x`${branch.get_ctx_name}(#ctx)` : x`#ctx`;
      if (branch.snippet)
        block.add_variable(branch.condition, branch.snippet);
      block.chunks.init.push(b`
			let ${name} = ${branch.condition} && ${branch.block.name}(${if_ctx});
		`);
      const initial_mount_node = parent_node || "#target";
      const anchor_node = parent_node ? "null" : "#anchor";
      block.chunks.mount.push(b`if (${name}) ${name}.m(${initial_mount_node}, ${anchor_node});`);
      if (branch.dependencies.length > 0) {
        const update_mount_node = this.get_update_mount_node(anchor);
        const enter = b`
				if (${name}) {
					${dynamic && b`${name}.p(${if_ctx}, #dirty);`}
					${has_transitions && b`if (${block.renderer.dirty(branch.dependencies)}) {
									@transition_in(${name}, 1);
								}`}
				} else {
					${name} = ${branch.block.name}(${if_ctx});
					${name}.c();
					${has_transitions && b`@transition_in(${name}, 1);`}
					${name}.m(${update_mount_node}, ${anchor});
				}
			`;
        if (branch.snippet)
          block.chunks.update.push(b`if (${block.renderer.dirty(branch.dependencies)}) ${branch.condition} = ${branch.snippet}`);
        if (branch.block.has_outro_method)
          block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						@group_outros();
						@transition_out(${name}, 1, 1, () => {
							${name} = null;
						});
						@check_outros();
					}
				`);
        else
          block.chunks.update.push(b`
					if (${branch.condition}) {
						${enter}
					} else if (${name}) {
						${name}.d(1);
						${name} = null;
					}
				`);
      } else if (dynamic)
        block.chunks.update.push(b`
				if (${branch.condition}) ${name}.p(${if_ctx}, #dirty);
			`);
      if (if_exists_condition)
        block.chunks.destroy.push(b`
				if (${if_exists_condition}) ${name}.d(${detaching});
			`);
      else
        block.chunks.destroy.push(b`
				${name}.d(${detaching});
			`);
    }
  }
  class KeyBlockWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.var = {
        type: "Identifier",
        name: "key_block"
      };
      this.cannot_use_innerhtml();
      this.not_static_content();
      this.dependencies = node2.expression.dynamic_dependencies();
      if (this.dependencies.length) {
        block = block.child({
          comment: create_debugging_comment(node2, renderer.component),
          name: renderer.component.get_unique_name("create_key_block"),
          type: "key"
        });
        block.add_dependencies(node2.expression.dependencies);
        renderer.blocks.push(block);
      }
      this.block = block;
      this.fragment = new FragmentWrapper(renderer, this.block, node2.children, this, strip_whitespace, next_sibling);
    }
    render(block, parent_node, parent_nodes) {
      if (this.dependencies.length === 0)
        this.render_static_key(block, parent_node, parent_nodes);
      else
        this.render_dynamic_key(block, parent_node, parent_nodes);
    }
    render_static_key(_block, parent_node, parent_nodes) {
      this.fragment.render(this.block, parent_node, parent_nodes);
    }
    render_dynamic_key(block, parent_node, parent_nodes) {
      this.fragment.render(this.block, null, x`#nodes`);
      const has_transitions = !!(this.block.has_intro_method || this.block.has_outro_method);
      const dynamic = this.block.has_update_method;
      const previous_key = block.get_unique_name("previous_key");
      const snippet = this.node.expression.manipulate(block);
      block.add_variable(previous_key, snippet);
      const not_equal = this.renderer.component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
      const condition = x`${this.renderer.dirty(this.dependencies)} && ${not_equal}(${previous_key}, ${previous_key} = ${snippet})`;
      block.chunks.init.push(b`
			let ${this.var} = ${this.block.name}(#ctx);
		`);
      block.chunks.create.push(b`${this.var}.c();`);
      if (this.renderer.options.hydratable)
        block.chunks.claim.push(b`${this.var}.l(${parent_nodes});`);
      block.chunks.mount.push(b`${this.var}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});`);
      const anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
      const body = b`
			${has_transitions ? b`
						@group_outros();
						@transition_out(${this.var}, 1, 1, @noop);
						@check_outros();
					` : b`${this.var}.d(1);`}
			${this.var} = ${this.block.name}(#ctx);
			${this.var}.c();
			${has_transitions && b`@transition_in(${this.var}, 1)`}
			${this.var}.m(${this.get_update_mount_node(anchor)}, ${anchor});
		`;
      if (dynamic)
        block.chunks.update.push(b`
				if (${condition}) {
					${body}
				} else {
					${this.var}.p(#ctx, #dirty);
				}
			`);
      else
        block.chunks.update.push(b`
				if (${condition}) {
					${body}
				}
			`);
      if (has_transitions) {
        block.chunks.intro.push(b`@transition_in(${this.var})`);
        block.chunks.outro.push(b`@transition_out(${this.var})`);
      }
      block.chunks.destroy.push(b`${this.var}.d(detaching)`);
    }
  }
  function get_slot_definition(block, scope2, lets) {
    if (lets.length === 0)
      return {
        block,
        scope: scope2
      };
    const context_input = {
      type: "ObjectPattern",
      properties: lets.map((l) => ({
        type: "Property",
        kind: "init",
        key: l.name,
        value: l.value || l.name
      }))
    };
    const properties2 = [];
    const value_map = /* @__PURE__ */ new Map();
    lets.forEach((l) => {
      let value2;
      if (l.names.length > 1) {
        const unique_name = block.get_unique_name(l.names.join("_")).name;
        value_map.set(l.value, unique_name);
        value2 = {
          type: "Identifier",
          name: unique_name
        };
      } else
        value2 = l.value || l.name;
      properties2.push({
        type: "Property",
        kind: "init",
        key: l.name,
        value: value2
      });
    });
    const changes_input = {
      type: "ObjectPattern",
      properties: properties2
    };
    const names = /* @__PURE__ */ new Set();
    const names_lookup = /* @__PURE__ */ new Map();
    lets.forEach((l) => {
      l.names.forEach((name) => {
        names.add(name);
        if (value_map.has(l.value))
          names_lookup.set(name, value_map.get(l.value));
      });
    });
    const context = {
      type: "ObjectExpression",
      properties: Array.from(names).map((name) => p`${block.renderer.context_lookup.get(name).index}: ${name}`)
    };
    const { context_lookup } = block.renderer;
    const changes = {
      type: "ParenthesizedExpression",
      get expression() {
        if (block.renderer.context_overflow) {
          const grouped = [];
          Array.from(names).forEach((name) => {
            const i2 = context_lookup.get(name).index.value;
            const g2 = Math.floor(i2 / 31);
            const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
            if (!grouped[g2])
              grouped[g2] = [];
            grouped[g2].push({
              name: lookup_name,
              n: i2 % 31
            });
          });
          const elements = [];
          for (let g2 = 0; g2 < grouped.length; g2 += 1)
            elements[g2] = grouped[g2] ? grouped[g2].map(({ name, n: n2 }) => x`${name} ? ${1 << n2} : 0`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`) : x`0`;
          return {
            type: "ArrayExpression",
            elements
          };
        }
        return Array.from(names).map((name) => {
          const lookup_name = names_lookup.has(name) ? names_lookup.get(name) : name;
          const i2 = context_lookup.get(name).index.value;
          return x`${lookup_name} ? ${1 << i2} : 0`;
        }).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
      }
    };
    return {
      block,
      scope: scope2,
      get_context: x`${context_input} => ${context}`,
      get_changes: x`${changes_input} => ${changes}`
    };
  }
  class SlotTemplateWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      const { scope: scope2, lets, const_tags, slot_template_name } = this.node;
      lets.forEach((l) => {
        extract_names(l.value || l.name).forEach((name) => {
          renderer.add_to_context(name, true);
        });
      });
      add_const_tags_context(renderer, const_tags);
      this.block = block.child({
        comment: create_debugging_comment(this.node, this.renderer.component),
        name: this.renderer.component.get_unique_name(`create_${sanitize(slot_template_name)}_slot`),
        type: "slot"
      });
      this.renderer.blocks.push(this.block);
      const seen = new Set(lets.map((l) => l.name.name));
      this.parent.node.lets.forEach((l) => {
        if (!seen.has(l.name.name))
          lets.push(l);
      });
      this.parent.set_slot(slot_template_name, get_slot_definition(this.block, scope2, lets));
      this.fragment = new FragmentWrapper(renderer, this.block, node2.type === "SlotTemplate" ? node2.children : [
        node2
      ], this, strip_whitespace, next_sibling);
      this.block.parent.add_dependencies(this.block.dependencies);
    }
    render() {
      this.fragment.render(this.block, null, x`#nodes`);
      if (this.node.const_tags.length > 0)
        this.render_get_context();
    }
    render_get_context() {
      const get_context2 = this.block.renderer.component.get_unique_name("get_context");
      this.block.renderer.blocks.push(b`
			function ${get_context2}(#ctx) {
				${add_const_tags(this.block, this.node.const_tags, "#ctx")}
			}
		`);
      this.block.chunks.declarations.push(b`${get_context2}(#ctx)`);
      if (this.block.has_update_method)
        this.block.chunks.update.unshift(b`${get_context2}(#ctx)`);
    }
  }
  function string_to_member_expression(name) {
    const parts = name.split(".");
    let node2 = {
      type: "Identifier",
      name: parts[0]
    };
    for (let i2 = 1; i2 < parts.length; i2++)
      node2 = {
        type: "MemberExpression",
        object: node2,
        property: {
          type: "Identifier",
          name: parts[i2]
        }
      };
    return node2;
  }
  const regex_invalid_variable_identifier_characters$3 = /[^a-zA-Z_$]/g;
  class InlineComponentWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.slots = /* @__PURE__ */ new Map();
      this.children = [];
      this.cannot_use_innerhtml();
      this.not_static_content();
      if (this.node.expression)
        block.add_dependencies(this.node.expression.dependencies);
      this.node.attributes.forEach((attr) => {
        block.add_dependencies(attr.dependencies);
      });
      this.node.bindings.forEach((binding) => {
        if (binding.is_contextual)
          mark_each_block_bindings(this, binding);
        block.add_dependencies(binding.expression.dependencies);
      });
      this.node.handlers.forEach((handler) => {
        if (handler.expression)
          block.add_dependencies(handler.expression.dependencies);
      });
      this.node.css_custom_properties.forEach((attr) => {
        block.add_dependencies(attr.dependencies);
      });
      this.var = {
        type: "Identifier",
        name: (this.node.name === "svelte:self" ? renderer.component.name.name : this.node.name === "svelte:component" ? "switch_instance" : sanitize(this.node.name)).toLowerCase()
      };
      if (this.node.children.length) {
        this.node.lets.forEach((l) => {
          extract_names(l.value || l.name).forEach((name) => {
            renderer.add_to_context(name, true);
          });
        });
        this.children = this.node.children.map((child) => new SlotTemplateWrapper(renderer, block, this, child, strip_whitespace, next_sibling));
      }
      block.add_outro();
    }
    set_slot(name, slot_definition) {
      if (this.slots.has(name)) {
        if (name === "default")
          throw new Error('Found elements without slot attribute when using slot="default"');
        throw new Error(`Duplicate slot name "${name}" in <${this.node.name}>`);
      }
      this.slots.set(name, slot_definition);
    }
    warn_if_reactive() {
      const { name } = this.node;
      const variable = this.renderer.component.var_lookup.get(name);
      if (!variable)
        return;
      if (variable.reassigned || variable.export_name || variable.is_reactive_dependency)
        this.renderer.component.warn(this.node, compiler_warnings.reactive_component(name));
    }
    render(block, parent_node, parent_nodes) {
      this.warn_if_reactive();
      const { renderer } = this;
      const { component } = renderer;
      const name = this.var;
      block.add_variable(name);
      const component_opts = x`{}`;
      const statements = [];
      const updates = [];
      this.children.forEach((child) => {
        this.renderer.add_to_context("$$scope", true);
        child.render(block, null, x`#nodes`);
      });
      let props;
      const name_changes = block.get_unique_name(`${name.name}_changes`);
      const uses_spread = !!this.node.attributes.find((a) => a.is_spread);
      for (const slot of this.slots.keys())
        if (!this.slots.get(slot).block.has_content()) {
          this.renderer.remove_block(this.slots.get(slot).block);
          this.slots.delete(slot);
        }
      const has_css_custom_properties = this.node.css_custom_properties.length > 0;
      const is_svg_namespace = this.node.namespace === namespaces.svg;
      const css_custom_properties_wrapper_element = is_svg_namespace ? "g" : "div";
      const css_custom_properties_wrapper = has_css_custom_properties ? block.get_unique_name(css_custom_properties_wrapper_element) : null;
      if (has_css_custom_properties)
        block.add_variable(css_custom_properties_wrapper);
      const initial_props = this.slots.size > 0 ? [
        p`$$slots: {
					${Array.from(this.slots).map(([name2, slot]) => {
          return p`${name2}: [${slot.block.name}, ${slot.get_context || null}, ${slot.get_changes || null}]`;
        })}
				}`,
        p`$$scope: {
					ctx: #ctx
				}`
      ] : [];
      const attribute_object = uses_spread ? x`{ ${initial_props} }` : x`{
				${this.node.attributes.map((attr) => p`${attr.name}: ${attr.get_value(block)}`)},
				${initial_props}
			}`;
      if (this.node.attributes.length || this.node.bindings.length || initial_props.length) {
        if (!uses_spread && this.node.bindings.length === 0)
          component_opts.properties.push(p`props: ${attribute_object}`);
        else {
          props = block.get_unique_name(`${name.name}_props`);
          component_opts.properties.push(p`props: ${props}`);
        }
      }
      if (component.compile_options.dev)
        component_opts.properties.push(p`$$inline: true`);
      const fragment_dependencies = new Set(this.slots.size ? [
        "$$scope"
      ] : []);
      this.slots.forEach((slot) => {
        slot.block.dependencies.forEach((name2) => {
          const is_let = slot.scope.is_let(name2);
          const variable = renderer.component.var_lookup.get(name2);
          if (is_let || is_dynamic(variable))
            fragment_dependencies.add(name2);
        });
      });
      const dynamic_attributes = this.node.attributes.filter((a) => a.get_dependencies().length > 0);
      if (!uses_spread && (dynamic_attributes.length > 0 || this.node.bindings.length > 0 || fragment_dependencies.size > 0))
        updates.push(b`const ${name_changes} = {};`);
      if (this.node.attributes.length) {
        if (uses_spread) {
          const levels = block.get_unique_name(`${this.var.name}_spread_levels`);
          const initial_props2 = [];
          const changes = [];
          const all_dependencies = /* @__PURE__ */ new Set();
          this.node.attributes.forEach((attr) => {
            add_to_set(all_dependencies, attr.dependencies);
          });
          this.node.attributes.forEach((attr, i2) => {
            const { name: name2, dependencies } = attr;
            const condition = dependencies.size > 0 && dependencies.size !== all_dependencies.size ? renderer.dirty(Array.from(dependencies)) : null;
            const unchanged = dependencies.size === 0;
            let change_object;
            if (attr.is_spread) {
              const value2 = attr.expression.manipulate(block);
              initial_props2.push(value2);
              let value_object = value2;
              if (attr.expression.node.type !== "ObjectExpression")
                value_object = x`@get_spread_object(${value2})`;
              change_object = value_object;
            } else {
              const obj = x`{ ${name2}: ${attr.get_value(block)} }`;
              initial_props2.push(obj);
              change_object = obj;
            }
            changes.push(unchanged ? x`${levels}[${i2}]` : condition ? x`${condition} && ${change_object}` : change_object);
          });
          block.chunks.init.push(b`
					const ${levels} = [
						${initial_props2}
					];
				`);
          statements.push(b`
					for (let #i = 0; #i < ${levels}.length; #i += 1) {
						${props} = @assign(${props}, ${levels}[#i]);
					}
				`);
          if (all_dependencies.size) {
            const condition = renderer.dirty(Array.from(all_dependencies));
            updates.push(b`
						const ${name_changes} = ${condition} ? @get_spread_update(${levels}, [
							${changes}
						]) : {}
					`);
          } else
            updates.push(b`
						const ${name_changes} = {};
					`);
        } else
          dynamic_attributes.forEach((attribute) => {
            const dependencies = attribute.get_dependencies();
            if (dependencies.length > 0) {
              const condition = renderer.dirty(dependencies);
              updates.push(b`
							if (${condition}) ${name_changes}.${attribute.name} = ${attribute.get_value(block)};
						`);
            }
          });
      }
      if (fragment_dependencies.size > 0)
        updates.push(b`
				if (${renderer.dirty(Array.from(fragment_dependencies))}) {
					${name_changes}.$$scope = { dirty: #dirty, ctx: #ctx };
				}`);
      const munged_bindings = this.node.bindings.map((binding) => {
        component.has_reactive_assignments = true;
        if (binding.name === "this")
          return bind_this(component, block, new BindingWrapper(block, binding, this), this.var);
        const id2 = component.get_unique_name(`${this.var.name}_${binding.name}_binding`);
        renderer.add_to_context(id2.name);
        const callee = renderer.reference(id2);
        const updating = block.get_unique_name(`updating_${binding.name}`);
        block.add_variable(updating);
        const snippet = binding.expression.manipulate(block);
        statements.push(b`
				if (${snippet} !== void 0) {
					${props}.${binding.name} = ${snippet};
				}`);
        updates.push(b`
				if (!${updating} && ${renderer.dirty(Array.from(binding.expression.dependencies))}) {
					${updating} = true;
					${name_changes}.${binding.name} = ${snippet};
					@add_flush_callback(() => ${updating} = false);
				}
			`);
        const contextual_dependencies = Array.from(binding.expression.contextual_dependencies);
        const dependencies = Array.from(binding.expression.dependencies);
        let lhs = binding.raw_expression;
        if (binding.is_contextual && binding.expression.node.type === "Identifier") {
          const { name: name2 } = binding.expression.node;
          const { object, property, snippet: snippet2 } = block.bindings.get(name2);
          lhs = snippet2;
          contextual_dependencies.push(object.name, property.name);
        }
        const params = [
          x`#value`
        ];
        const args = [
          x`#value`
        ];
        if (contextual_dependencies.length > 0) {
          contextual_dependencies.forEach((name2) => {
            params.push({
              type: "Identifier",
              name: name2
            });
            renderer.add_to_context(name2, true);
            args.push(renderer.reference(name2));
          });
          block.maintain_context = true;
        }
        block.chunks.init.push(b`
				function ${id2}(#value) {
					${callee}(${args});
				}
			`);
        let invalidate_binding = b`
				${lhs} = #value;
				${renderer.invalidate(dependencies[0])};
			`;
        if (binding.expression.node.type === "MemberExpression")
          invalidate_binding = b`
					if ($$self.$$.not_equal(${lhs}, #value)) {
						${invalidate_binding}
					}
				`;
        const body = b`
				function ${id2}(${params}) {
					${invalidate_binding}
				}
			`;
        component.partly_hoisted.push(body);
        return b`@binding_callbacks.push(() => @bind(${this.var}, '${binding.name}', ${id2}, ${snippet}));`;
      });
      const munged_handlers = this.node.handlers.map((handler) => {
        const event_handler = new EventHandlerWrapper(handler, this);
        let snippet = event_handler.get_snippet(block);
        if (handler.modifiers.has("once"))
          snippet = x`@once(${snippet})`;
        return b`${name}.$on("${handler.name}", ${snippet});`;
      });
      const mount_target = has_css_custom_properties ? css_custom_properties_wrapper : parent_node || "#target";
      const mount_anchor = has_css_custom_properties ? "null" : parent_node ? "null" : "#anchor";
      const to_claim = parent_nodes && this.renderer.options.hydratable;
      let claim_nodes = parent_nodes;
      if (this.node.name === "svelte:component") {
        const switch_value = block.get_unique_name("switch_value");
        const switch_props = block.get_unique_name("switch_props");
        const snippet = this.node.expression.manipulate(block);
        if (has_css_custom_properties)
          this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
        block.chunks.init.push(b`
				var ${switch_value} = ${snippet};

				function ${switch_props}(#ctx) {
					${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
					${props && b`let ${props} = ${attribute_object};`}`}
					${statements}
					return ${component_opts};
				}

				if (${switch_value}) {
					${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

					${munged_bindings}
					${munged_handlers}
				}
			`);
        block.chunks.create.push(b`if (${name}) @create_component(${name}.$$.fragment);`);
        if (css_custom_properties_wrapper)
          this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
        block.chunks.mount.push(b`if (${name}) @mount_component(${name}, ${mount_target}, ${mount_anchor});`);
        if (to_claim) {
          if (css_custom_properties_wrapper)
            claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
          block.chunks.claim.push(b`if (${name}) @claim_component(${name}.$$.fragment, ${claim_nodes});`);
        }
        if (updates.length)
          block.chunks.update.push(b`
					${updates}
				`);
        const tmp_anchor = this.get_or_create_anchor(block, parent_node, parent_nodes);
        const anchor = has_css_custom_properties ? "null" : tmp_anchor;
        const update_mount_node = has_css_custom_properties ? css_custom_properties_wrapper : this.get_update_mount_node(tmp_anchor);
        const update_insert = css_custom_properties_wrapper && (tmp_anchor.name !== "null" ? b`@insert(${tmp_anchor}.parentNode, ${css_custom_properties_wrapper}, ${tmp_anchor});` : b`@insert(${parent_node}, ${css_custom_properties_wrapper}, ${tmp_anchor});`);
        block.chunks.update.push(b`
				if (${switch_value} !== (${switch_value} = ${snippet})) {
					if (${name}) {
						@group_outros();
						const old_component = ${name};
						@transition_out(old_component.$$.fragment, 1, 0, () => {
							@destroy_component(old_component, 1);
							${has_css_custom_properties ? b`@detach(${update_mount_node})` : null}
						});
						@check_outros();
					}

					if (${switch_value}) {
						${update_insert}
						${name} = @construct_svelte_component(${switch_value}, ${switch_props}(#ctx));

						${munged_bindings}
						${munged_handlers}

						@create_component(${name}.$$.fragment);
						@transition_in(${name}.$$.fragment, 1);
						@mount_component(${name}, ${update_mount_node}, ${anchor});
					} else {
						${name} = null;
					}
				} else if (${switch_value}) {
					${updates.length > 0 && b`${name}.$set(${name_changes});`}
				}
			`);
        block.chunks.intro.push(b`
				if (${name}) @transition_in(${name}.$$.fragment, #local);
			`);
        block.chunks.outro.push(b`if (${name}) @transition_out(${name}.$$.fragment, #local);`);
        block.chunks.destroy.push(b`if (${name}) @destroy_component(${name}, ${parent_node ? null : "detaching"});`);
      } else {
        const expression = this.node.name === "svelte:self" ? component.name : this.renderer.reference(string_to_member_expression(this.node.name));
        block.chunks.init.push(b`
				${(this.node.attributes.length > 0 || this.node.bindings.length > 0) && b`
				${props && b`let ${props} = ${attribute_object};`}`}
				${statements}
				${name} = new ${expression}(${component_opts});

				${munged_bindings}
				${munged_handlers}
			`);
        if (has_css_custom_properties)
          this.set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
        block.chunks.create.push(b`@create_component(${name}.$$.fragment);`);
        if (css_custom_properties_wrapper)
          this.create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper);
        block.chunks.mount.push(b`@mount_component(${name}, ${mount_target}, ${mount_anchor});`);
        if (to_claim) {
          if (css_custom_properties_wrapper)
            claim_nodes = this.create_css_custom_properties_wrapper_claim_chunk(block, claim_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace);
          block.chunks.claim.push(b`@claim_component(${name}.$$.fragment, ${claim_nodes});`);
        }
        block.chunks.intro.push(b`
				@transition_in(${name}.$$.fragment, #local);
			`);
        if (updates.length)
          block.chunks.update.push(b`
					${updates}
					${name}.$set(${name_changes});
				`);
        block.chunks.destroy.push(b`
				@destroy_component(${name}, ${parent_node ? null : "detaching"});
			`);
        block.chunks.outro.push(b`@transition_out(${name}.$$.fragment, #local);`);
      }
    }
    create_css_custom_properties_wrapper_mount_chunk(block, parent_node, css_custom_properties_wrapper) {
      if (parent_node) {
        block.chunks.mount.push(b`@append(${parent_node}, ${css_custom_properties_wrapper})`);
        if (is_head(parent_node))
          block.chunks.destroy.push(b`@detach(${css_custom_properties_wrapper});`);
      } else {
        block.chunks.mount.push(b`@insert(#target, ${css_custom_properties_wrapper}, #anchor);`);
        block.chunks.destroy.push(b`if (detaching && ${this.var}) @detach(${css_custom_properties_wrapper});`);
      }
    }
    create_css_custom_properties_wrapper_claim_chunk(block, parent_nodes, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
      const nodes = block.get_unique_name(`${css_custom_properties_wrapper.name}_nodes`);
      const claim_element = is_svg_namespace ? x`@claim_svg_element` : x`@claim_element`;
      block.chunks.claim.push(b`
			${css_custom_properties_wrapper} = ${claim_element}(${parent_nodes}, "${css_custom_properties_wrapper_element.toUpperCase()}", { style: true })
			var ${nodes} = @children(${css_custom_properties_wrapper});
		`);
      return nodes;
    }
    set_css_custom_properties(block, css_custom_properties_wrapper, css_custom_properties_wrapper_element, is_svg_namespace) {
      const element = is_svg_namespace ? x`@svg_element` : x`@element`;
      block.chunks.create.push(b`${css_custom_properties_wrapper} = ${element}("${css_custom_properties_wrapper_element}");`);
      if (!is_svg_namespace)
        block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "display", "contents");`);
      this.node.css_custom_properties.forEach((attr) => {
        const dependencies = attr.get_dependencies();
        const should_cache2 = attr.should_cache();
        const last = should_cache2 && block.get_unique_name(`${attr.name.replace(regex_invalid_variable_identifier_characters$3, "_")}_last`);
        if (should_cache2)
          block.add_variable(last);
        const value2 = attr.get_value(block);
        const init = should_cache2 ? x`${last} = ${value2}` : value2;
        block.chunks.hydrate.push(b`@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${init});`);
        if (dependencies.length > 0) {
          let condition = block.renderer.dirty(dependencies);
          if (should_cache2)
            condition = x`${condition} && (${last} !== (${last} = ${value2}))`;
          block.chunks.update.push(b`
					if (${condition}) {
						@set_style(${css_custom_properties_wrapper}, "${attr.name}", ${should_cache2 ? last : value2});
					}
				`);
        }
      });
    }
  }
  function get_slot_data(values, block = null) {
    return {
      type: "ObjectExpression",
      properties: Array.from(values.values()).filter((attribute) => attribute.name !== "name").map((attribute) => {
        if (attribute.is_spread) {
          const argument = get_spread_value(block, attribute);
          return {
            type: "SpreadElement",
            argument
          };
        }
        const value2 = get_value(block, attribute);
        return p`${attribute.name}: ${value2}`;
      })
    };
  }
  function get_value(block, attribute) {
    if (attribute.is_true)
      return x`true`;
    if (attribute.chunks.length === 0)
      return x`""`;
    let value2 = attribute.chunks.map((chunk) => chunk.type === "Text" ? string_literal(chunk.data) : block ? chunk.manipulate(block) : chunk.node).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
    if (attribute.chunks.length > 1 && attribute.chunks[0].type !== "Text")
      value2 = x`"" + ${value2}`;
    return value2;
  }
  function get_spread_value(block, attribute) {
    return block ? attribute.expression.manipulate(block) : attribute.expression.node;
  }
  class SlotWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, strip_whitespace, next_sibling) {
      super(renderer, block, parent, node2);
      this.fallback = null;
      this.var = {
        type: "Identifier",
        name: "slot"
      };
      this.dependencies = /* @__PURE__ */ new Set([
        "$$scope"
      ]);
      this.cannot_use_innerhtml();
      this.not_static_content();
      if (this.node.children.length) {
        this.fallback = block.child({
          comment: create_debugging_comment(this.node.children[0], this.renderer.component),
          name: this.renderer.component.get_unique_name("fallback_block"),
          type: "fallback"
        });
        renderer.blocks.push(this.fallback);
      }
      this.fragment = new FragmentWrapper(renderer, this.fallback, node2.children, this, strip_whitespace, next_sibling);
      this.node.values.forEach((attribute) => {
        add_to_set(this.dependencies, attribute.dependencies);
      });
      block.add_dependencies(this.dependencies);
      block.add_intro();
      block.add_outro();
    }
    render(block, parent_node, parent_nodes) {
      const { renderer } = this;
      const { slot_name } = this.node;
      if (this.slot_block)
        block = this.slot_block;
      let get_slot_changes_fn;
      let get_slot_spread_changes_fn;
      let get_slot_context_fn;
      if (this.node.values.size > 0) {
        get_slot_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_changes`);
        get_slot_context_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_context`);
        const changes = x`{}`;
        const spread_dynamic_dependencies = /* @__PURE__ */ new Set();
        this.node.values.forEach((attribute) => {
          if (attribute.type === "Spread")
            add_to_set(spread_dynamic_dependencies, Array.from(attribute.dependencies).filter((name) => this.is_dependency_dynamic(name)));
          else {
            const dynamic_dependencies2 = Array.from(attribute.dependencies).filter((name) => this.is_dependency_dynamic(name));
            if (dynamic_dependencies2.length > 0)
              changes.properties.push(p`${attribute.name}: ${renderer.dirty(dynamic_dependencies2)}`);
          }
        });
        renderer.blocks.push(b`
				const ${get_slot_changes_fn} = #dirty => ${changes};
				const ${get_slot_context_fn} = #ctx => ${get_slot_data(this.node.values, block)};
			`);
        if (spread_dynamic_dependencies.size) {
          get_slot_spread_changes_fn = renderer.component.get_unique_name(`get_${sanitize(slot_name)}_slot_spread_changes`);
          renderer.blocks.push(b`
					const ${get_slot_spread_changes_fn} = #dirty => ${renderer.dirty(Array.from(spread_dynamic_dependencies))};
				`);
        }
      } else {
        get_slot_changes_fn = "null";
        get_slot_context_fn = "null";
      }
      let has_fallback = !!this.fallback;
      if (this.fallback) {
        this.fragment.render(this.fallback, null, x`#nodes`);
        has_fallback = this.fallback.has_content();
        if (!has_fallback)
          renderer.remove_block(this.fallback);
      }
      const slot = block.get_unique_name(`${sanitize(slot_name)}_slot`);
      const slot_definition = block.get_unique_name(`${sanitize(slot_name)}_slot_template`);
      const slot_or_fallback = has_fallback ? block.get_unique_name(`${sanitize(slot_name)}_slot_or_fallback`) : slot;
      block.chunks.init.push(b`
			const ${slot_definition} = ${renderer.reference("#slots")}.${slot_name};
			const ${slot} = @create_slot(${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${get_slot_context_fn});
			${has_fallback ? b`const ${slot_or_fallback} = ${slot} || ${this.fallback.name}(#ctx);` : null}
		`);
      block.chunks.create.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.c();`);
      if (renderer.options.hydratable)
        block.chunks.claim.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.l(${parent_nodes});`);
      block.chunks.mount.push(b`
			if (${slot_or_fallback}) {
				${slot_or_fallback}.m(${parent_node || "#target"}, ${parent_node ? "null" : "#anchor"});
			}
		`);
      block.chunks.intro.push(b`@transition_in(${slot_or_fallback}, #local);`);
      block.chunks.outro.push(b`@transition_out(${slot_or_fallback}, #local);`);
      const dynamic_dependencies = Array.from(this.dependencies).filter((name) => this.is_dependency_dynamic(name));
      const fallback_dynamic_dependencies = has_fallback ? Array.from(this.fallback.dependencies).filter((name) => this.is_dependency_dynamic(name)) : [];
      let condition = renderer.dirty(dynamic_dependencies);
      if (block.has_outros)
        condition = x`!#current || ${condition}`;
      const all_dirty_conditions = [
        get_slot_spread_changes_fn ? x`${get_slot_spread_changes_fn}(#dirty)` : null,
        block.has_outros ? x`!#current` : null
      ].filter(Boolean);
      const all_dirty_condition = all_dirty_conditions.length ? all_dirty_conditions.reduce((condition1, condition2) => x`${condition1} || ${condition2}`) : null;
      let slot_update;
      if (all_dirty_condition) {
        const dirty = x`${all_dirty_condition} ? @get_all_dirty_from_scope(${renderer.reference("$$scope")}) : @get_slot_changes(${slot_definition}, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn})`;
        slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot_base(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, ${dirty}, ${get_slot_context_fn});
				}
			`;
      } else
        slot_update = b`
				if (${slot}.p && ${condition}) {
					@update_slot(${slot}, ${slot_definition}, #ctx, ${renderer.reference("$$scope")}, #dirty, ${get_slot_changes_fn}, ${get_slot_context_fn});
				}
			`;
      let fallback_condition = renderer.dirty(fallback_dynamic_dependencies);
      let fallback_dirty = x`#dirty`;
      if (block.has_outros) {
        fallback_condition = x`!#current || ${fallback_condition}`;
        fallback_dirty = x`!#current ? ${renderer.get_initial_dirty()} : ${fallback_dirty}`;
      }
      const fallback_update = has_fallback && fallback_dynamic_dependencies.length > 0 && b`
			if (${slot_or_fallback} && ${slot_or_fallback}.p && ${fallback_condition}) {
				${slot_or_fallback}.p(#ctx, ${fallback_dirty});
			}
		`;
      if (fallback_update)
        block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				} else {
					${fallback_update}
				}
			`);
      else
        block.chunks.update.push(b`
				if (${slot}) {
					${slot_update}
				}
			`);
      block.chunks.destroy.push(b`if (${slot_or_fallback}) ${slot_or_fallback}.d(detaching);`);
    }
    is_dependency_dynamic(name) {
      if (name === "$$scope")
        return true;
      if (this.node.scope.is_let(name))
        return true;
      if (is_reserved_keyword(name))
        return true;
      const variable = this.renderer.component.var_lookup.get(name);
      return is_dynamic(variable);
    }
  }
  class TitleWrapper extends Wrapper {
    constructor(renderer, block, parent, node2, _strip_whitespace, _next_sibling) {
      super(renderer, block, parent, node2);
    }
    render(block, _parent_node, _parent_nodes) {
      const is_dynamic2 = !!this.node.children.find((node2) => node2.type !== "Text");
      if (is_dynamic2) {
        let value2;
        const all_dependencies = /* @__PURE__ */ new Set();
        if (this.node.children.length === 1) {
          const { expression } = this.node.children[0];
          value2 = expression.manipulate(block);
          add_to_set(all_dependencies, expression.dependencies);
        } else {
          value2 = this.node.children.map((chunk) => {
            if (chunk.type === "Text")
              return string_literal(chunk.data);
            chunk.expression.dependencies.forEach((d) => {
              all_dependencies.add(d);
            });
            return chunk.expression.manipulate(block);
          }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
          if (this.node.children[0].type !== "Text")
            value2 = x`"" + ${value2}`;
        }
        const last = this.node.should_cache && block.get_unique_name("title_value");
        if (this.node.should_cache)
          block.add_variable(last);
        const init = this.node.should_cache ? x`${last} = ${value2}` : value2;
        block.chunks.init.push(b`@_document.title = ${init};`);
        const updater = b`@_document.title = ${this.node.should_cache ? last : value2};`;
        if (all_dependencies.size) {
          const dependencies = Array.from(all_dependencies);
          let condition = block.renderer.dirty(dependencies);
          if (block.has_outros)
            condition = x`!#current || ${condition}`;
          if (this.node.should_cache)
            condition = x`${condition} && (${last} !== (${last} = ${value2}))`;
          block.chunks.update.push(b`
					if (${condition}) {
						${updater}
					}`);
        }
      } else {
        const value2 = this.node.children.length > 0 ? string_literal(this.node.children[0].data) : x`""`;
        block.chunks.hydrate.push(b`@_document.title = ${value2};`);
      }
    }
  }
  const associated_events = {
    innerWidth: "resize",
    innerHeight: "resize",
    outerWidth: "resize",
    outerHeight: "resize",
    scrollX: "scroll",
    scrollY: "scroll"
  };
  const properties = {
    scrollX: "pageXOffset",
    scrollY: "pageYOffset"
  };
  const readonly = /* @__PURE__ */ new Set([
    "innerWidth",
    "innerHeight",
    "outerWidth",
    "outerHeight",
    "online"
  ]);
  class WindowWrapper extends Wrapper {
    constructor(renderer, block, parent, node2) {
      super(renderer, block, parent, node2);
      this.handlers = this.node.handlers.map((handler) => new EventHandlerWrapper(handler, this));
    }
    render(block, _parent_node, _parent_nodes) {
      const { renderer } = this;
      const { component } = renderer;
      const events2 = {};
      const bindings = {};
      add_actions(block, "@_window", this.node.actions);
      add_event_handlers(block, "@_window", this.handlers);
      this.node.bindings.forEach((binding) => {
        const binding_name = binding.expression.node.name;
        if (readonly.has(binding.name))
          renderer.readonly.add(binding_name);
        bindings[binding.name] = binding_name;
        if (binding.name === "online")
          return;
        const associated_event = associated_events[binding.name];
        const property = properties[binding.name] || binding.name;
        if (!events2[associated_event])
          events2[associated_event] = [];
        events2[associated_event].push({
          name: binding_name,
          value: property
        });
      });
      const scrolling = block.get_unique_name("scrolling");
      const clear_scrolling = block.get_unique_name("clear_scrolling");
      const scrolling_timeout = block.get_unique_name("scrolling_timeout");
      Object.keys(events2).forEach((event) => {
        const id2 = block.get_unique_name(`onwindow${event}`);
        const props = events2[event];
        renderer.add_to_context(id2.name);
        const fn = renderer.reference(id2.name);
        if (event === "scroll") {
          block.add_variable(scrolling, x`false`);
          block.add_variable(clear_scrolling, x`() => { ${scrolling} = false }`);
          block.add_variable(scrolling_timeout);
          const condition = bindings.scrollX && bindings.scrollY ? x`"${bindings.scrollX}" in this._state || "${bindings.scrollY}" in this._state` : x`"${bindings.scrollX || bindings.scrollY}" in this._state`;
          const scrollX = bindings.scrollX && x`this._state.${bindings.scrollX}`;
          const scrollY = bindings.scrollY && x`this._state.${bindings.scrollY}`;
          renderer.meta_bindings.push(b`
					if (${condition}) {
						@_scrollTo(${scrollX || "@_window.pageXOffset"}, ${scrollY || "@_window.pageYOffset"});
					}
					${scrollX && `${scrollX} = @_window.pageXOffset;`}
					${scrollY && `${scrollY} = @_window.pageYOffset;`}
				`);
          block.event_listeners.push(x`
					@listen(@_window, "${event}", () => {
						${scrolling} = true;
						@_clearTimeout(${scrolling_timeout});
						${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
						${fn}();
					})
				`);
        } else {
          props.forEach((prop) => {
            renderer.meta_bindings.push(b`this._state.${prop.name} = @_window.${prop.value};`);
          });
          block.event_listeners.push(x`
					@listen(@_window, "${event}", ${fn})
				`);
        }
        component.partly_hoisted.push(b`
				function ${id2}() {
					${props.map((prop) => renderer.invalidate(prop.name, x`${prop.name} = @_window.${prop.value}`))}
				}
			`);
        block.chunks.init.push(b`
				@add_render_callback(${fn});
			`);
        component.has_reactive_assignments = true;
      });
      if (bindings.scrollX || bindings.scrollY) {
        const condition = renderer.dirty([
          bindings.scrollX,
          bindings.scrollY
        ].filter(Boolean));
        const scrollX = bindings.scrollX ? renderer.reference(bindings.scrollX) : x`@_window.pageXOffset`;
        const scrollY = bindings.scrollY ? renderer.reference(bindings.scrollY) : x`@_window.pageYOffset`;
        block.chunks.update.push(b`
				if (${condition} && !${scrolling}) {
					${scrolling} = true;
					@_clearTimeout(${scrolling_timeout});
					@_scrollTo(${scrollX}, ${scrollY});
					${scrolling_timeout} = @_setTimeout(${clear_scrolling}, 100);
				}
			`);
      }
      if (bindings.online) {
        const id2 = block.get_unique_name("onlinestatuschanged");
        const name = bindings.online;
        renderer.add_to_context(id2.name);
        const reference = renderer.reference(id2.name);
        component.partly_hoisted.push(b`
				function ${id2}() {
					${renderer.invalidate(name, x`${name} = @_navigator.onLine`)}
				}
			`);
        block.chunks.init.push(b`
				@add_render_callback(${reference});
			`);
        block.event_listeners.push(x`@listen(@_window, "online", ${reference})`, x`@listen(@_window, "offline", ${reference})`);
        component.has_reactive_assignments = true;
      }
    }
  }
  function link(next, prev) {
    prev.next = next;
    if (next)
      next.prev = prev;
  }
  const wrappers = {
    AwaitBlock: AwaitBlockWrapper,
    Body: BodyWrapper,
    Comment: null,
    DebugTag: DebugTagWrapper,
    EachBlock: EachBlockWrapper,
    Element: ElementWrapper,
    Head: HeadWrapper,
    IfBlock: IfBlockWrapper,
    InlineComponent: InlineComponentWrapper,
    KeyBlock: KeyBlockWrapper,
    MustacheTag: MustacheTagWrapper,
    Options: null,
    RawMustacheTag: RawMustacheTagWrapper,
    Slot: SlotWrapper,
    SlotTemplate: SlotTemplateWrapper,
    Text: TextWrapper,
    Title: TitleWrapper,
    Window: WindowWrapper
  };
  function trimmable_at(child, next_sibling) {
    return next_sibling.node.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.node.prev.type === "EachBlock";
  }
  class FragmentWrapper {
    constructor(renderer, block, nodes, parent, strip_whitespace, next_sibling) {
      this.nodes = [];
      let last_child;
      let window_wrapper;
      let i2 = nodes.length;
      while (i2--) {
        const child = nodes[i2];
        if (!child.type)
          throw new Error("missing type");
        if (!(child.type in wrappers))
          throw new Error(`TODO implement ${child.type}`);
        if (child.type === "Window") {
          window_wrapper = new WindowWrapper(renderer, block, parent, child);
          continue;
        }
        if (child.type === "Text") {
          let { data: data2 } = child;
          if (this.nodes.length === 0) {
            const should_trim = next_sibling ? next_sibling.node.type === "Text" && regex_starts_with_whitespace.test(next_sibling.node.data) && trimmable_at(child, next_sibling) : !child.has_ancestor("EachBlock");
            if (should_trim && !child.keep_space()) {
              data2 = trim_end(data2);
              if (!data2)
                continue;
            }
          }
          if (last_child && last_child.node.type === "Text") {
            last_child.data = data2 + last_child.data;
            continue;
          }
          const wrapper = new TextWrapper(renderer, block, parent, child, data2);
          if (wrapper.skip)
            continue;
          this.nodes.unshift(wrapper);
          link(last_child, last_child = wrapper);
        } else {
          const Wrapper2 = wrappers[child.type];
          if (!Wrapper2)
            continue;
          const wrapper = new Wrapper2(renderer, block, parent, child, strip_whitespace, last_child || next_sibling);
          this.nodes.unshift(wrapper);
          link(last_child, last_child = wrapper);
        }
      }
      if (strip_whitespace) {
        const first = this.nodes[0];
        if (first && first.node.type === "Text" && !first.node.keep_space()) {
          first.data = trim_start(first.data);
          if (!first.data) {
            first.var = null;
            this.nodes.shift();
            if (this.nodes[0])
              this.nodes[0].prev = null;
          }
        }
      }
      if (window_wrapper) {
        this.nodes.unshift(window_wrapper);
        link(last_child, window_wrapper);
      }
    }
    render(block, parent_node, parent_nodes) {
      for (let i2 = 0; i2 < this.nodes.length; i2 += 1)
        this.nodes[i2].render(block, parent_node, parent_nodes);
    }
  }
  class Renderer {
    constructor(component, options) {
      this.context = [];
      this.initial_context = [];
      this.context_lookup = /* @__PURE__ */ new Map();
      this.blocks = [];
      this.readonly = /* @__PURE__ */ new Set();
      this.meta_bindings = [];
      this.binding_groups = /* @__PURE__ */ new Map();
      this.component = component;
      this.options = options;
      this.locate = component.locate;
      this.file_var = options.dev && this.component.get_unique_name("file");
      component.vars.filter((v) => !v.hoistable || v.export_name && !v.module).forEach((v) => this.add_to_context(v.name));
      component.vars.filter((v) => v.subscribable).forEach((v) => this.add_to_context(`$${v.name}`));
      reserved_keywords.forEach((keyword) => {
        if (component.var_lookup.has(keyword))
          this.add_to_context(keyword);
      });
      if (component.slots.size > 0) {
        this.add_to_context("$$scope");
        this.add_to_context("#slots");
      }
      if (this.binding_groups.size > 0)
        this.add_to_context("$$binding_groups");
      this.block = new Block({
        renderer: this,
        name: null,
        type: "component",
        key: null,
        bindings: /* @__PURE__ */ new Map(),
        dependencies: /* @__PURE__ */ new Set()
      });
      this.block.has_update_method = true;
      this.fragment = new FragmentWrapper(this, this.block, component.fragment.children, null, true, null);
      this.blocks.forEach((block) => {
        if (block instanceof Block)
          block.assign_variable_names();
      });
      this.block.assign_variable_names();
      this.fragment.render(this.block, null, x`#nodes`);
      this.context_overflow = this.context.length > 31;
      this.context.forEach((member) => {
        const { variable } = member;
        if (variable) {
          member.priority += 2;
          if (variable.mutated || variable.reassigned)
            member.priority += 4;
          if (variable.is_reactive_dependency && (variable.mutated || variable.reassigned))
            member.priority += 16;
          if (variable.export_name)
            member.priority += 32;
          if (variable.referenced)
            member.priority += 64;
        } else if (member.is_non_contextual)
          member.priority += 8;
        if (!member.is_contextual)
          member.priority += 1;
      });
      this.context.sort((a, b2) => b2.priority - a.priority || a.index.value - b2.index.value);
      this.context.forEach((member, i3) => member.index.value = i3);
      let i2 = this.context.length;
      while (i2--) {
        const member = this.context[i2];
        if (member.variable) {
          if (member.variable.referenced || member.variable.export_name || member.variable.is_reactive_dependency && (member.variable.mutated || member.variable.reassigned))
            break;
        } else if (member.is_non_contextual)
          break;
      }
      this.initial_context = this.context.slice(0, i2 + 1);
    }
    add_to_context(name, contextual = false) {
      if (!this.context_lookup.has(name)) {
        const member2 = {
          name,
          index: {
            type: "Literal",
            value: this.context.length
          },
          is_contextual: false,
          is_non_contextual: false,
          variable: null,
          priority: 0
        };
        this.context_lookup.set(name, member2);
        this.context.push(member2);
      }
      const member = this.context_lookup.get(name);
      if (contextual)
        member.is_contextual = true;
      else {
        member.is_non_contextual = true;
        member.variable = this.component.var_lookup.get(name);
      }
      return member;
    }
    invalidate(name, value2, main_execution_context = false) {
      return renderer_invalidate(this, name, value2, main_execution_context);
    }
    dirty(names, is_reactive_declaration = false) {
      const renderer = this;
      const dirty = is_reactive_declaration ? x`$$self.$$.dirty` : x`#dirty`;
      const get_bitmask = () => {
        const bitmask = [];
        names.forEach((name) => {
          const member = renderer.context_lookup.get(name);
          if (!member)
            return;
          if (member.index.value === -1)
            throw new Error("unset index");
          const value2 = member.index.value;
          const i2 = value2 / 31 | 0;
          const n2 = 1 << value2 % 31;
          if (!bitmask[i2])
            bitmask[i2] = {
              n: 0,
              names: []
            };
          bitmask[i2].n |= n2;
          bitmask[i2].names.push(name);
        });
        return bitmask;
      };
      return {
        // Using a ParenthesizedExpression allows us to create
        // the expression lazily. TODO would be better if
        // context was determined before rendering, so that
        // this indirection was unnecessary
        type: "ParenthesizedExpression",
        get expression() {
          const bitmask = get_bitmask();
          if (!bitmask.length)
            return x`${dirty} & /*${names.join(", ")}*/ 0`;
          if (renderer.context_overflow)
            return bitmask.map((b2, i2) => ({
              b: b2,
              i: i2
            })).filter(({ b: b2 }) => b2).map(({ b: b2, i: i2 }) => x`${dirty}[${i2}] & /*${b2.names.join(", ")}*/ ${b2.n}`).reduce((lhs, rhs) => x`${lhs} | ${rhs}`);
          return x`${dirty} & /*${names.join(", ")}*/ ${bitmask[0].n}`;
        }
      };
    }
    // NOTE: this method may be called before this.context_overflow / this.context is fully defined
    // therefore, they can only be evaluated later in a getter function
    get_initial_dirty() {
      const _this = this;
      const val = x`-1`;
      return {
        get type() {
          return _this.context_overflow ? "ArrayExpression" : "UnaryExpression";
        },
        // as [-1]
        get elements() {
          const elements = [];
          for (let i2 = 0; i2 < _this.context.length; i2 += 31)
            elements.push(val);
          return elements;
        },
        // as -1
        operator: val.operator,
        prefix: val.prefix,
        argument: val.argument
      };
    }
    reference(node2, ctx = "#ctx") {
      if (typeof node2 === "string")
        node2 = {
          type: "Identifier",
          name: node2
        };
      const { name, nodes } = flatten_reference(node2);
      const member = this.context_lookup.get(name);
      if (this.component.var_lookup.get(name))
        this.component.add_reference(node2, name);
      if (member !== void 0) {
        const replacement = x`/*${member.name}*/ ${ctx}[${member.index}]`;
        if (nodes[0].loc)
          replacement.object.loc = nodes[0].loc;
        nodes[0] = replacement;
        return nodes.reduce((lhs, rhs) => x`${lhs}.${rhs}`);
      }
      return node2;
    }
    remove_block(block) {
      this.blocks.splice(this.blocks.indexOf(block), 1);
    }
  }
  var charToInteger$1 = {};
  var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  for (var i$2 = 0; i$2 < chars$1.length; i$2++)
    charToInteger$1[chars$1.charCodeAt(i$2)] = i$2;
  function decode$3(mappings) {
    var decoded = [];
    var line = [];
    var segment = [
      0,
      0,
      0,
      0,
      0
    ];
    var j = 0;
    for (var i2 = 0, shift = 0, value2 = 0; i2 < mappings.length; i2++) {
      var c2 = mappings.charCodeAt(i2);
      if (c2 === 44) {
        segmentify$1(line, segment, j);
        j = 0;
      } else if (c2 === 59) {
        segmentify$1(line, segment, j);
        j = 0;
        decoded.push(line);
        line = [];
        segment[0] = 0;
      } else {
        var integer = charToInteger$1[c2];
        if (integer === void 0)
          throw new Error("Invalid character (" + String.fromCharCode(c2) + ")");
        var hasContinuationBit = integer & 32;
        integer &= 31;
        value2 += integer << shift;
        if (hasContinuationBit)
          shift += 5;
        else {
          var shouldNegate = value2 & 1;
          value2 >>>= 1;
          if (shouldNegate)
            value2 = value2 === 0 ? -2147483648 : -value2;
          segment[j] += value2;
          j++;
          value2 = shift = 0;
        }
      }
    }
    segmentify$1(line, segment, j);
    decoded.push(line);
    return decoded;
  }
  function segmentify$1(line, segment, j) {
    if (j === 4)
      line.push([
        segment[0],
        segment[1],
        segment[2],
        segment[3]
      ]);
    else if (j === 5)
      line.push([
        segment[0],
        segment[1],
        segment[2],
        segment[3],
        segment[4]
      ]);
    else if (j === 1)
      line.push([
        segment[0]
      ]);
  }
  function encode$1(decoded) {
    var sourceFileIndex = 0;
    var sourceCodeLine = 0;
    var sourceCodeColumn = 0;
    var nameIndex = 0;
    var mappings = "";
    for (var i2 = 0; i2 < decoded.length; i2++) {
      var line = decoded[i2];
      if (i2 > 0)
        mappings += ";";
      if (line.length === 0)
        continue;
      var generatedCodeColumn = 0;
      var lineMappings = [];
      for (var _i = 0, line_1 = line; _i < line_1.length; _i++) {
        var segment = line_1[_i];
        var segmentMappings = encodeInteger$1(segment[0] - generatedCodeColumn);
        generatedCodeColumn = segment[0];
        if (segment.length > 1) {
          segmentMappings += encodeInteger$1(segment[1] - sourceFileIndex) + encodeInteger$1(segment[2] - sourceCodeLine) + encodeInteger$1(segment[3] - sourceCodeColumn);
          sourceFileIndex = segment[1];
          sourceCodeLine = segment[2];
          sourceCodeColumn = segment[3];
        }
        if (segment.length === 5) {
          segmentMappings += encodeInteger$1(segment[4] - nameIndex);
          nameIndex = segment[4];
        }
        lineMappings.push(segmentMappings);
      }
      mappings += lineMappings.join(",");
    }
    return mappings;
  }
  function encodeInteger$1(num) {
    var result = "";
    num = num < 0 ? -num << 1 | 1 : num << 1;
    do {
      var clamped = num & 31;
      num >>>= 5;
      if (num > 0)
        clamped |= 32;
      result += chars$1[clamped];
    } while (num > 0);
    return result;
  }
  function defaults(target, source) {
    return Object.assign(/* @__PURE__ */ Object.create(null), source, target);
  }
  function decodeSourceMap(map) {
    if (typeof map === "string")
      map = JSON.parse(map);
    let { mappings } = map;
    if (typeof mappings === "string")
      mappings = decode$3(mappings);
    else
      mappings = mappings.map(cloneSegmentLine);
    mappings.forEach(sortSegments);
    return defaults({
      mappings
    }, map);
  }
  function cloneSegmentLine(segments) {
    return segments.slice();
  }
  function sortSegments(segments) {
    segments.sort(segmentComparator);
  }
  function segmentComparator(a, b2) {
    return a[0] - b2[0];
  }
  class OriginalSource {
    constructor(filename, content) {
      this.filename = filename;
      this.content = content;
    }
    /**
    * Tracing a `SourceMapSegment` ends when we get to an `OriginalSource`,
    * meaning this line/column location originated from this source file.
    */
    traceSegment(line, column, name) {
      return {
        column,
        line,
        name,
        source: this
      };
    }
  }
  const Url$1 = typeof URL !== "undefined" ? URL : URL$1;
  const parentRegex = /(^|\/)\.\.(?=\/|$)/g;
  function isAbsoluteUrl(url) {
    try {
      return new Url$1(url), true;
    } catch (e) {
      return false;
    }
  }
  function uniqInStr(str) {
    let uniq = String(Math.random()).slice(2);
    while (str.indexOf(uniq) > -1)
      uniq += uniq;
    return uniq;
  }
  function stripPathFilename(path) {
    path = normalizePath(path);
    const index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
  }
  function normalizeProtocolRelative(input, absoluteBase) {
    const { href, protocol } = new Url$1(input, absoluteBase);
    return href.slice(protocol.length);
  }
  function normalizeSimplePath(input) {
    const { href } = new Url$1(input, "https://foo.com/");
    return href.slice(16);
  }
  function normalizePath(input) {
    if (!parentRegex.test(input))
      return normalizeSimplePath(input);
    let total = 1;
    while (parentRegex.test(input))
      total++;
    const uniqDirectory = `z${uniqInStr(input)}/`;
    const search = new RegExp(`^(?:${uniqDirectory})*`);
    const relative = normalizeSimplePath(uniqDirectory.repeat(total) + input);
    return relative.replace(search, (all2) => {
      const leftover = all2.length / uniqDirectory.length;
      return "../".repeat(total - leftover);
    });
  }
  function resolve(input, base) {
    if (!base)
      base = "";
    if (isAbsoluteUrl(input))
      return new Url$1(input).href;
    if (base) {
      if (isAbsoluteUrl(base))
        return new Url$1(input, base).href;
      if (base.startsWith("//"))
        return normalizeProtocolRelative(input, `https:${base}`);
    }
    if (input.startsWith("//"))
      return normalizeProtocolRelative(input, "https://foo.com/");
    if (input.startsWith("/"))
      return "/" + normalizeSimplePath(input);
    const joined = stripPathFilename(base) + input;
    if (base.startsWith("/"))
      return "/" + normalizeSimplePath(joined);
    const relative = normalizePath(joined);
    if ((base || input).startsWith(".") && !relative.startsWith("."))
      return "./" + relative;
    return relative;
  }
  function resolve$1(input, base) {
    if (base && !base.endsWith("/"))
      base += "/";
    return resolve(input, base);
  }
  function binarySearch(haystack, needle, comparator) {
    let low = 0;
    let high = haystack.length - 1;
    while (low <= high) {
      const mid = low + (high - low >> 1);
      const cmp = comparator(haystack[mid], needle);
      if (cmp === 0)
        return mid;
      if (cmp < 0)
        low = mid + 1;
      else
        high = mid - 1;
    }
    return ~low;
  }
  class FastStringArray {
    constructor() {
      this.indexes = /* @__PURE__ */ Object.create(null);
      this.array = [];
    }
    /**
    * Puts `key` into the backing array, if it is not already present. Returns
    * the index of the `key` in the backing array.
    */
    put(key) {
      const { array, indexes } = this;
      let index = indexes[key];
      if (index === void 0) {
        index = indexes[key] = array.length;
        array.push(key);
      }
      return index;
    }
  }
  class SourceMapTree {
    constructor(map, sources) {
      this.map = map;
      this.sources = sources;
    }
    /**
    * traceMappings is only called on the root level SourceMapTree, and begins
    * the process of resolving each mapping in terms of the original source
    * files.
    */
    traceMappings() {
      const mappings = [];
      const names = new FastStringArray();
      const sources = new FastStringArray();
      const sourcesContent = [];
      const { mappings: rootMappings, names: rootNames } = this.map;
      for (let i2 = 0; i2 < rootMappings.length; i2++) {
        const segments = rootMappings[i2];
        const tracedSegments = [];
        for (let j = 0; j < segments.length; j++) {
          const segment = segments[j];
          if (segment.length === 1)
            continue;
          const source = this.sources[segment[1]];
          const traced = source.traceSegment(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
          if (!traced)
            continue;
          const { column, line, name } = traced;
          const { content, filename } = traced.source;
          const sourceIndex = sources.put(filename);
          sourcesContent[sourceIndex] = content;
          if (name)
            tracedSegments.push([
              segment[0],
              sourceIndex,
              line,
              column,
              names.put(name)
            ]);
          else
            tracedSegments.push([
              segment[0],
              sourceIndex,
              line,
              column
            ]);
        }
        mappings.push(tracedSegments);
      }
      return defaults({
        mappings,
        names: names.array,
        sources: sources.array,
        sourcesContent
      }, this.map);
    }
    /**
    * traceSegment is only called on children SourceMapTrees. It recurses down
    * into its own child SourceMapTrees, until we find the original source map.
    */
    traceSegment(line, column, name) {
      const { mappings, names } = this.map;
      if (line >= mappings.length)
        return null;
      const segments = mappings[line];
      if (segments.length === 0)
        return null;
      let index = binarySearch(segments, column, segmentComparator$1);
      if (index === -1)
        return null;
      if (index < 0)
        index = ~index - 1;
      const segment = segments[index];
      if (segment.length === 1)
        return null;
      const source = this.sources[segment[1]];
      return source.traceSegment(
        segment[2],
        segment[3],
        // A child map's recorded name for this segment takes precedence over the
        // parent's mapped name. Imagine a mangler changing the name over, etc.
        segment.length === 5 ? names[segment[4]] : name
      );
    }
  }
  function segmentComparator$1(segment, column) {
    return segment[0] - column;
  }
  function stripFilename(path) {
    if (!path)
      return "";
    const index = path.lastIndexOf("/");
    return path.slice(0, index + 1);
  }
  function asArray(value2) {
    if (Array.isArray(value2))
      return value2;
    return [
      value2
    ];
  }
  function buildSourceMapTree(input, loader, relativeRoot) {
    const maps = asArray(input).map(decodeSourceMap);
    const map = maps.pop();
    for (let i2 = 0; i2 < maps.length; i2++) {
      if (maps[i2].sources.length !== 1)
        throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
    const { sourceRoot, sources, sourcesContent } = map;
    const children = sources.map((sourceFile, i2) => {
      const uri = resolve$1(sourceFile || "", resolve$1(sourceRoot || "", stripFilename(relativeRoot)));
      const sourceMap = loader(uri);
      if (!sourceMap) {
        const sourceContent = sourcesContent ? sourcesContent[i2] : null;
        return new OriginalSource(uri, sourceContent);
      }
      return buildSourceMapTree(decodeSourceMap(sourceMap), loader, uri);
    });
    let tree = new SourceMapTree(map, children);
    for (let i2 = maps.length - 1; i2 >= 0; i2--)
      tree = new SourceMapTree(maps[i2], [
        tree
      ]);
    return tree;
  }
  class SourceMap {
    constructor(map, excludeContent) {
      this.version = 3;
      if ("file" in map)
        this.file = map.file;
      this.mappings = encode$1(map.mappings);
      this.names = map.names;
      this.sources = map.sources;
      if (!excludeContent && "sourcesContent" in map)
        this.sourcesContent = map.sourcesContent;
    }
    toString() {
      return JSON.stringify(this);
    }
  }
  function remapping(input, loader, excludeContent) {
    const graph = buildSourceMapTree(input, loader);
    return new SourceMap(graph.traceMappings(), !!excludeContent);
  }
  function last_line_length(s) {
    return s.length - s.lastIndexOf("\n") - 1;
  }
  function sourcemap_add_offset(map, offset, source_index) {
    if (map.mappings.length == 0)
      return;
    for (let line = 0; line < map.mappings.length; line++) {
      const segment_list = map.mappings[line];
      for (let segment = 0; segment < segment_list.length; segment++) {
        const seg = segment_list[segment];
        if (seg[1] === source_index) {
          if (seg[2] === 0)
            seg[3] += offset.column;
          seg[2] += offset.line;
        }
      }
    }
  }
  function merge_tables(this_table, other_table) {
    const new_table = this_table.slice();
    const idx_map = [];
    other_table = other_table || [];
    let val_changed = false;
    for (const [other_idx, other_val] of other_table.entries()) {
      const this_idx = this_table.indexOf(other_val);
      if (this_idx >= 0)
        idx_map[other_idx] = this_idx;
      else {
        const new_idx = new_table.length;
        new_table[new_idx] = other_val;
        idx_map[other_idx] = new_idx;
        val_changed = true;
      }
    }
    let idx_changed = val_changed;
    if (val_changed) {
      if (idx_map.find((val, idx) => val != idx) === void 0)
        idx_changed = false;
    }
    return [
      new_table,
      idx_map,
      val_changed,
      idx_changed
    ];
  }
  const regex_line_token = /([^\d\w\s]|\s+)/g;
  class MappedCode {
    constructor(string = "", map = null) {
      this.string = string;
      if (map)
        this.map = map;
      else
        this.map = {
          version: 3,
          mappings: [],
          sources: [],
          names: []
        };
    }
    /**
    * concat in-place (mutable), return this (chainable)
    * will also mutate the `other` object
    */
    concat(other) {
      if (other.string == "")
        return this;
      if (this.string == "") {
        this.string = other.string;
        this.map = other.map;
        return this;
      }
      const column_offset = last_line_length(this.string);
      this.string += other.string;
      const m1 = this.map;
      const m2 = other.map;
      if (m2.mappings.length == 0)
        return this;
      const [sources, new_source_idx, sources_changed, sources_idx_changed] = merge_tables(m1.sources, m2.sources);
      const [names, new_name_idx, names_changed, names_idx_changed] = merge_tables(m1.names, m2.names);
      if (sources_changed)
        m1.sources = sources;
      if (names_changed)
        m1.names = names;
      if (sources_idx_changed && names_idx_changed)
        for (let line = 0; line < m2.mappings.length; line++) {
          const segment_list = m2.mappings[line];
          for (let segment = 0; segment < segment_list.length; segment++) {
            const seg = segment_list[segment];
            if (seg[1] >= 0)
              seg[1] = new_source_idx[seg[1]];
            if (seg[4] >= 0)
              seg[4] = new_name_idx[seg[4]];
          }
        }
      else if (sources_idx_changed)
        for (let line = 0; line < m2.mappings.length; line++) {
          const segment_list = m2.mappings[line];
          for (let segment = 0; segment < segment_list.length; segment++) {
            const seg = segment_list[segment];
            if (seg[1] >= 0)
              seg[1] = new_source_idx[seg[1]];
          }
        }
      else if (names_idx_changed)
        for (let line = 0; line < m2.mappings.length; line++) {
          const segment_list = m2.mappings[line];
          for (let segment = 0; segment < segment_list.length; segment++) {
            const seg = segment_list[segment];
            if (seg[4] >= 0)
              seg[4] = new_name_idx[seg[4]];
          }
        }
      if (m2.mappings.length > 0 && column_offset > 0) {
        const first_line = m2.mappings[0];
        for (let i2 = 0; i2 < first_line.length; i2++)
          first_line[i2][0] += column_offset;
      }
      push_array$1(m1.mappings[m1.mappings.length - 1], m2.mappings.shift());
      push_array$1(m1.mappings, m2.mappings);
      return this;
    }
    static from_processed(string, map) {
      const line_count = string.split("\n").length;
      if (map) {
        const missing_lines = line_count - map.mappings.length;
        for (let i2 = 0; i2 < missing_lines; i2++)
          map.mappings.push([]);
        return new MappedCode(string, map);
      }
      if (string == "")
        return new MappedCode();
      map = {
        version: 3,
        names: [],
        sources: [],
        mappings: []
      };
      for (let i2 = 0; i2 < line_count; i2++)
        map.mappings.push([]);
      return new MappedCode(string, map);
    }
    static from_source({ source, file_basename, get_location }) {
      let offset = get_location(0);
      if (!offset)
        offset = {
          line: 0,
          column: 0
        };
      const map = {
        version: 3,
        names: [],
        sources: [
          file_basename
        ],
        mappings: []
      };
      if (source == "")
        return new MappedCode(source, map);
      const line_list = source.split("\n");
      for (let line = 0; line < line_list.length; line++) {
        map.mappings.push([]);
        const token_list = line_list[line].split(regex_line_token);
        for (let token = 0, column = 0; token < token_list.length; token++) {
          if (token_list[token] == "")
            continue;
          map.mappings[line].push([
            column,
            0,
            offset.line + line,
            column
          ]);
          column += token_list[token].length;
        }
      }
      const segment_list = map.mappings[0];
      for (let segment = 0; segment < segment_list.length; segment++)
        segment_list[segment][3] += offset.column;
      return new MappedCode(source, map);
    }
  }
  function combine_sourcemaps(filename, sourcemap_list) {
    if (sourcemap_list.length == 0)
      return null;
    let map_idx = 1;
    const map = sourcemap_list.slice(0, -1).find((m) => m.sources.length !== 1) === void 0 ? remapping(
      // only the oldest sourcemap can have multiple sources
      sourcemap_list,
      () => null,
      true
      // skip optional field `sourcesContent`
    ) : remapping(sourcemap_list[0], function loader(sourcefile) {
      if (sourcefile === filename && sourcemap_list[map_idx])
        return sourcemap_list[map_idx++];
      else
        return null;
    }, true);
    if (!map.file)
      delete map.file;
    if (!map.sources.length)
      map.sources = [
        filename
      ];
    return map;
  }
  const b64enc = typeof btoa == "function" ? btoa : (b2) => Buffer.from(b2).toString("base64");
  const b64dec = typeof atob == "function" ? atob : (a) => Buffer.from(a, "base64").toString();
  function apply_preprocessor_sourcemap(filename, svelte_map, preprocessor_map_input) {
    if (!svelte_map || !preprocessor_map_input)
      return svelte_map;
    const preprocessor_map = typeof preprocessor_map_input === "string" ? JSON.parse(preprocessor_map_input) : preprocessor_map_input;
    const result_map = combine_sourcemaps(filename, [
      svelte_map,
      preprocessor_map
    ]);
    Object.defineProperties(result_map, {
      toString: {
        enumerable: false,
        value: function toString4() {
          return JSON.stringify(this);
        }
      },
      toUrl: {
        enumerable: false,
        value: function toUrl() {
          return "data:application/json;charset=utf-8;base64," + b64enc(this.toString());
        }
      }
    });
    return result_map;
  }
  const regex_data_uri = /data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(\S*)/;
  function parse_attached_sourcemap(processed, tag_name) {
    const r_in = "[#@]\\s*sourceMappingURL\\s*=\\s*(\\S*)";
    const regex2 = tag_name == "script" ? new RegExp("(?://" + r_in + ")|(?:/\\*" + r_in + "\\s*\\*/)$") : new RegExp("/\\*" + r_in + "\\s*\\*/$");
    function log_warning(message) {
      const code_start = processed.code.length < 100 ? processed.code : processed.code.slice(0, 100) + " [...]";
      console.warn(`warning: ${message}. processed.code = ${JSON.stringify(code_start)}`);
    }
    processed.code = processed.code.replace(regex2, (_, match1, match2) => {
      const map_url = tag_name == "script" ? match1 || match2 : match1;
      const map_data = (map_url.match(regex_data_uri) || [])[1];
      if (map_data) {
        if (processed.map) {
          log_warning("Not implemented. Found sourcemap in both processed.code and processed.map. Please update your preprocessor to return only one sourcemap.");
          return "";
        }
        processed.map = b64dec(map_data);
        return "";
      }
      if (!processed.map)
        log_warning(`Found sourcemap path ${JSON.stringify(map_url)} in processed.code, but no sourcemap data. Please update your preprocessor to return sourcemap data directly.`);
      return "";
    });
  }
  function check_enable_sourcemap(enable_sourcemap, namespace) {
    return typeof enable_sourcemap === "boolean" ? enable_sourcemap : enable_sourcemap[namespace];
  }
  function dom(component, options) {
    const { name } = component;
    const renderer = new Renderer(component, options);
    const { block } = renderer;
    block.has_outro_method = true;
    if (options.customElement)
      block.chunks.create.push(b`this.c = @noop;`);
    const body = [];
    if (renderer.file_var) {
      const file = component.file ? x`"${component.file}"` : x`undefined`;
      body.push(b`const ${renderer.file_var} = ${file};`);
    }
    const css = component.stylesheet.render(options.filename, !options.customElement);
    const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
    if (css_sourcemap_enabled)
      css.map = apply_preprocessor_sourcemap(options.filename, css.map, options.sourcemap);
    else
      css.map = null;
    const styles = css_sourcemap_enabled && component.stylesheet.has_styles && options.dev ? `${css.code}
/*# sourceMappingURL=${css.map.toUrl()} */` : css.code;
    const add_css = component.get_unique_name("add_css");
    const should_add_css = !options.customElement && !!styles && options.css === "injected";
    if (should_add_css)
      body.push(b`
			function ${add_css}(target) {
				@append_styles(target, "${component.stylesheet.id}", "${styles}");
			}
		`);
    const blocks = renderer.blocks.slice().reverse();
    push_array$1(body, blocks.map((block2) => {
      if (block2.render)
        return block2.render();
      return block2;
    }));
    if (options.dev && !options.hydratable)
      block.chunks.claim.push(b`throw new @_Error("options.hydrate only works if the component was compiled with the \`hydratable: true\` option");`);
    const uses_slots = component.var_lookup.has("$$slots");
    let compute_slots;
    if (uses_slots)
      compute_slots = b`
			const $$slots = @compute_slots(#slots);
		`;
    const uses_props = component.var_lookup.has("$$props");
    const uses_rest = component.var_lookup.has("$$restProps");
    const $$props = uses_props || uses_rest ? "$$new_props" : "$$props";
    const props = component.vars.filter((variable) => !variable.module && variable.export_name);
    const writable_props = props.filter((variable) => variable.writable);
    const omit_props_names = component.get_unique_name("omit_props_names");
    const compute_rest = x`@compute_rest_props($$props, ${omit_props_names.name})`;
    const rest = uses_rest ? b`
		const ${omit_props_names.name} = [${props.map((prop) => `"${prop.export_name}"`).join(",")}];
		let $$restProps = ${compute_rest};
	` : null;
    const set = uses_props || uses_rest || writable_props.length > 0 || component.slots.size > 0 ? x`
			${$$props} => {
				${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`)}
				${uses_rest && !uses_props && x`$$props = @assign(@assign({}, $$props), @exclude_internal_props($$new_props))`}
				${uses_rest && renderer.invalidate("$$restProps", x`$$restProps = ${compute_rest}`)}
				${writable_props.map((prop) => b`if ('${prop.export_name}' in ${$$props}) ${renderer.invalidate(prop.name, x`${prop.name} = ${$$props}.${prop.export_name}`)};`)}
				${component.slots.size > 0 && b`if ('$$scope' in ${$$props}) ${renderer.invalidate("$$scope", x`$$scope = ${$$props}.$$scope`)};`}
			}
		` : null;
    const accessors = [];
    const not_equal = component.component_options.immutable ? x`@not_equal` : x`@safe_not_equal`;
    let missing_props_check;
    let inject_state;
    let capture_state;
    let props_inject;
    props.forEach((prop) => {
      const variable = component.var_lookup.get(prop.name);
      if (!variable.writable || component.component_options.accessors)
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: {
            type: "Identifier",
            name: prop.export_name
          },
          value: x`function() {
					return ${prop.hoistable ? prop.name : x`this.$$.ctx[${renderer.context_lookup.get(prop.name).index}]`}
				}`
        });
      else if (component.compile_options.dev)
        accessors.push({
          type: "MethodDefinition",
          kind: "get",
          key: {
            type: "Identifier",
            name: prop.export_name
          },
          value: x`function() {
					throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
        });
      if (component.component_options.accessors) {
        if (variable.writable && !renderer.readonly.has(prop.name))
          accessors.push({
            type: "MethodDefinition",
            kind: "set",
            key: {
              type: "Identifier",
              name: prop.export_name
            },
            value: x`function(${prop.name}) {
						this.$$set({ ${prop.export_name}: ${prop.name} });
						@flush();
					}`
          });
        else if (component.compile_options.dev)
          accessors.push({
            type: "MethodDefinition",
            kind: "set",
            key: {
              type: "Identifier",
              name: prop.export_name
            },
            value: x`function(value) {
						throw new @_Error("<${component.tag}>: Cannot set read-only property '${prop.export_name}'");
					}`
          });
      } else if (component.compile_options.dev)
        accessors.push({
          type: "MethodDefinition",
          kind: "set",
          key: {
            type: "Identifier",
            name: prop.export_name
          },
          value: x`function(value) {
					throw new @_Error("<${component.tag}>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
				}`
        });
    });
    component.instance_exports_from.forEach((exports_from) => {
      const import_declaration = Object.assign(Object.assign({}, exports_from), {
        type: "ImportDeclaration",
        specifiers: [],
        source: exports_from.source
      });
      component.imports.push(import_declaration);
      exports_from.specifiers.forEach((specifier) => {
        if (component.component_options.accessors) {
          const name2 = component.get_unique_name(specifier.exported.name);
          import_declaration.specifiers.push(Object.assign(Object.assign({}, specifier), {
            type: "ImportSpecifier",
            imported: specifier.local,
            local: name2
          }));
          accessors.push({
            type: "MethodDefinition",
            kind: "get",
            key: {
              type: "Identifier",
              name: specifier.exported.name
            },
            value: x`function() {
						return ${name2}
					}`
          });
        } else if (component.compile_options.dev)
          accessors.push({
            type: "MethodDefinition",
            kind: "get",
            key: {
              type: "Identifier",
              name: specifier.exported.name
            },
            value: x`function() {
						throw new @_Error("<${component.tag}>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
					}`
          });
      });
    });
    if (component.compile_options.dev) {
      const expected = props.filter((prop) => prop.writable && !prop.initialised);
      if (expected.length)
        missing_props_check = b`
				$$self.$$.on_mount.push(function () {
					${expected.map((prop) => b`
					if (${prop.name} === undefined && !(('${prop.export_name}' in $$props) || $$self.$$.bound[$$self.$$.props['${prop.export_name}']])) {
						@_console.warn("<${component.tag}> was created without expected prop '${prop.export_name}'");
					}`)}
				});
			`;
      const capturable_vars = component.vars.filter((v) => !v.internal && !v.global && !v.name.startsWith("$$"));
      if (capturable_vars.length > 0)
        capture_state = x`() => ({ ${capturable_vars.map((prop) => p`${prop.name}`)} })`;
      const injectable_vars = capturable_vars.filter((v) => !v.module && v.writable && v.name[0] !== "$");
      if (uses_props || injectable_vars.length > 0) {
        inject_state = x`
				${$$props} => {
					${uses_props && renderer.invalidate("$$props", x`$$props = @assign(@assign({}, $$props), $$new_props)`)}
					${injectable_vars.map((v) => b`if ('${v.name}' in $$props) ${renderer.invalidate(v.name, x`${v.name} = ${$$props}.${v.name}`)};`)}
				}
			`;
        props_inject = b`
				if ($$props && "$$inject" in $$props) {
					$$self.$inject_state($$props.$$inject);
				}
			`;
      }
    }
    if (component.ast.instance) {
      let scope2 = component.instance_scope;
      const map = component.instance_scope_map;
      let execution_context = null;
      walk(component.ast.instance.content, {
        enter(node2) {
          if (map.has(node2)) {
            scope2 = map.get(node2);
            if (!execution_context && !scope2.block)
              execution_context = node2;
          } else if (!execution_context && node2.type === "LabeledStatement" && node2.label.name === "$")
            execution_context = node2;
        },
        leave(node2) {
          if (map.has(node2))
            scope2 = scope2.parent;
          if (execution_context === node2)
            execution_context = null;
          if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
            const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
            const names = new Set(extract_names(assignee));
            this.replace(invalidate(renderer, scope2, node2, names, execution_context === null));
          }
        }
      });
      component.rewrite_props(({ name: name2, reassigned, export_name }) => {
        const value2 = `$${name2}`;
        const i2 = renderer.context_lookup.get(`$${name2}`).index;
        const insert = reassigned || export_name ? b`${`$$subscribe_${name2}`}()` : b`@component_subscribe($$self, ${name2}, #value => $$invalidate(${i2}, ${value2} = #value))`;
        if (component.compile_options.dev)
          return b`@validate_store(${name2}, '${name2}'); ${insert}`;
        return insert;
      });
    }
    const args = [
      x`$$self`
    ];
    const has_invalidate = props.length > 0 || component.has_reactive_assignments || component.slots.size > 0 || capture_state || inject_state;
    if (has_invalidate)
      args.push(x`$$props`, x`$$invalidate`);
    else if (component.compile_options.dev)
      args.push(x`$$props`);
    const has_create_fragment = component.compile_options.dev || block.has_content();
    if (has_create_fragment)
      body.push(b`
			function create_fragment(#ctx) {
				${block.get_contents()}
			}
		`);
    body.push(b`
		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}
	`);
    const filtered_props = props.filter((prop) => {
      const variable = component.var_lookup.get(prop.name);
      if (variable.hoistable)
        return false;
      return prop.name[0] !== "$";
    });
    const reactive_stores = component.vars.filter((variable) => variable.name[0] === "$" && variable.name[1] !== "$");
    const instance_javascript = component.extract_javascript(component.ast.instance);
    const has_definition = component.compile_options.dev || instance_javascript && instance_javascript.length > 0 || filtered_props.length > 0 || uses_props || component.partly_hoisted.length > 0 || renderer.initial_context.length > 0 || component.reactive_declarations.length > 0 || capture_state || inject_state;
    const definition = has_definition ? component.alias("instance") : {
      type: "Literal",
      value: null
    };
    const reactive_store_subscriptions = reactive_stores.filter((store) => {
      const variable = component.var_lookup.get(store.name.slice(1));
      return !variable || variable.hoistable;
    }).map(({ name: name2 }) => b`
			${component.compile_options.dev && b`@validate_store(${name2.slice(1)}, '${name2.slice(1)}');`}
			@component_subscribe($$self, ${name2.slice(1)}, $$value => $$invalidate(${renderer.context_lookup.get(name2).index}, ${name2} = $$value));
		`);
    const resubscribable_reactive_store_unsubscribers = reactive_stores.filter((store) => {
      const variable = component.var_lookup.get(store.name.slice(1));
      return variable && (variable.reassigned || variable.export_name);
    }).map(({ name: name2 }) => b`$$self.$$.on_destroy.push(() => ${`$$unsubscribe_${name2.slice(1)}`}());`);
    if (has_definition) {
      const reactive_declarations = [];
      const fixed_reactive_declarations = [];
      component.reactive_declarations.forEach((d) => {
        const dependencies = Array.from(d.dependencies);
        const uses_rest_or_props = !!dependencies.find((n2) => n2 === "$$props" || n2 === "$$restProps");
        const writable = dependencies.filter((n2) => {
          const variable = component.var_lookup.get(n2);
          return variable && (variable.export_name || variable.mutated || variable.reassigned);
        });
        const condition = !uses_rest_or_props && writable.length > 0 && renderer.dirty(writable, true);
        let statement = d.node;
        if (condition)
          statement = b`if (${condition}) { ${statement} }`[0];
        if (condition || uses_rest_or_props)
          reactive_declarations.push(statement);
        else
          fixed_reactive_declarations.push(statement);
      });
      const injected = Array.from(component.injected_reactive_declaration_vars).filter((name2) => {
        const variable = component.var_lookup.get(name2);
        return variable.injected && variable.name[0] !== "$";
      });
      const reactive_store_declarations = reactive_stores.map((variable) => {
        const $name = variable.name;
        const name2 = $name.slice(1);
        const store = component.var_lookup.get(name2);
        if (store && (store.reassigned || store.export_name)) {
          const unsubscribe = `$$unsubscribe_${name2}`;
          const subscribe = `$$subscribe_${name2}`;
          const i2 = renderer.context_lookup.get($name).index;
          return b`let ${$name}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${name2}, $$value => $$invalidate(${i2}, ${$name} = $$value)), ${name2})`;
        }
        return b`let ${$name};`;
      });
      let unknown_props_check;
      if (component.compile_options.dev && !(uses_props || uses_rest))
        unknown_props_check = b`
				const writable_props = [${writable_props.map((prop) => x`'${prop.export_name}'`)}];
				@_Object.keys($$props).forEach(key => {
					if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') @_console.warn(\`<${component.tag}> was created with unknown prop '\${key}'\`);
				});
			`;
      const return_value = {
        type: "ArrayExpression",
        elements: renderer.initial_context.map((member) => ({
          type: "Identifier",
          name: member.name
        }))
      };
      body.push(b`
			function ${definition}(${args}) {
				${injected.map((name2) => b`let ${name2};`)}

				${rest}

				${reactive_store_declarations}

				${reactive_store_subscriptions}

				${resubscribable_reactive_store_unsubscribers}

				${component.slots.size || component.compile_options.dev || uses_slots ? b`let { $$slots: #slots = {}, $$scope } = $$props;` : null}
				${component.compile_options.dev && b`@validate_slots('${component.tag}', #slots, [${[
        ...component.slots.keys()
      ].map((key) => `'${key}'`).join(",")}]);`}
				${compute_slots}

				${instance_javascript}

				${missing_props_check}
				${unknown_props_check}

				${renderer.binding_groups.size > 0 && b`const $$binding_groups = [${[
        ...renderer.binding_groups.keys()
      ].map((_) => x`[]`)}];`}

				${component.partly_hoisted}

				${set && b`$$self.$$set = ${set};`}

				${capture_state && b`$$self.$capture_state = ${capture_state};`}

				${inject_state && b`$$self.$inject_state = ${inject_state};`}

				${props_inject}

				${reactive_declarations.length > 0 && b`
				$$self.$$.update = () => {
					${reactive_declarations}
				};
				`}

				${fixed_reactive_declarations}

				${uses_props && b`$$props = @exclude_internal_props($$props);`}

				return ${return_value};
			}
		`);
    }
    const prop_indexes = x`{
		${props.filter((v) => v.export_name && !v.module).map((v) => p`${v.export_name}: ${renderer.context_lookup.get(v.name).index}`)}
	}`;
    let dirty;
    if (renderer.context_overflow) {
      dirty = x`[]`;
      for (let i2 = 0; i2 < renderer.context.length; i2 += 31)
        dirty.elements.push(x`-1`);
    }
    if (options.customElement) {
      let init_props = x`@attribute_to_object(this.attributes)`;
      if (uses_slots)
        init_props = x`{ ...${init_props}, $$slots: @get_custom_elements_slots(this) }`;
      const declaration = b`
			class ${name} extends @SvelteElement {
				constructor(options) {
					super();

					${css.code && b`this.shadowRoot.innerHTML = \`<style>${css.code.replace(regex_backslashes, "\\\\")}${css_sourcemap_enabled && options.dev ? `
/*# sourceMappingURL=${css.map.toUrl()} */` : ""}</style>\`;`}

					@init(this, { target: this.shadowRoot, props: ${init_props}, customElement: true }, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, null, ${dirty});

					if (options) {
						if (options.target) {
							@insert(options.target, this, options.anchor);
						}

						${(props.length > 0 || uses_props || uses_rest) && b`
						if (options.props) {
							this.$set(options.props);
							@flush();
						}`}
					}
				}
			}
		`[0];
      if (props.length > 0)
        declaration.body.body.push({
          type: "MethodDefinition",
          kind: "get",
          static: true,
          computed: false,
          key: {
            type: "Identifier",
            name: "observedAttributes"
          },
          value: x`function() {
					return [${props.map((prop) => x`"${prop.export_name}"`)}];
				}`
        });
      push_array$1(declaration.body.body, accessors);
      body.push(declaration);
      if (component.tag != null)
        body.push(b`
				@_customElements.define("${component.tag}", ${name});
			`);
    } else {
      const superclass = {
        type: "Identifier",
        name: options.dev ? "@SvelteComponentDev" : "@SvelteComponent"
      };
      const optional_parameters = [];
      if (should_add_css)
        optional_parameters.push(add_css);
      else if (dirty)
        optional_parameters.push(x`null`);
      if (dirty)
        optional_parameters.push(dirty);
      const declaration = b`
			class ${name} extends ${superclass} {
				constructor(options) {
					super(${options.dev && "options"});
					@init(this, options, ${definition}, ${has_create_fragment ? "create_fragment" : "null"}, ${not_equal}, ${prop_indexes}, ${optional_parameters});
					${options.dev && b`@dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "${name.name}", options, id: create_fragment.name });`}
				}
			}
		`[0];
      push_array$1(declaration.body.body, accessors);
      body.push(declaration);
    }
    return {
      js: flatten(body),
      css
    };
  }
  function get_const_tags$1(const_tags) {
    if (const_tags.length === 0)
      return null;
    return {
      type: "VariableDeclaration",
      kind: "let",
      declarations: const_tags.map((const_tag) => {
        const assignment = const_tag.node.expression;
        return {
          type: "VariableDeclarator",
          id: assignment.left,
          init: assignment.right
        };
      })
    };
  }
  function AwaitBlock$1(node2, renderer, options) {
    renderer.push();
    renderer.render(node2.pending.children, options);
    const pending = renderer.pop();
    renderer.push();
    renderer.render(node2.then.children, options);
    const then = renderer.pop();
    renderer.add_expression(x`
		function(__value) {
			if (@is_promise(__value)) {
				__value.then(null, @noop);
				return ${pending};
			}
			return (function(${node2.then_node ? node2.then_node : ""}) { ${get_const_tags$1(node2.then.const_tags)}; return ${then}; }(__value));
		}(${node2.expression.node})
	`);
  }
  function Comment$2(node2, renderer, options) {
    if (options.preserveComments)
      renderer.add_string(`<!--${node2.data}-->`);
  }
  function DebugTag$1(node2, renderer, options) {
    if (!options.dev)
      return;
    const filename = options.filename || null;
    const { line, column } = options.locate(node2.start + 1);
    const obj = x`{
		${node2.expressions.map((e) => p`${e.node.name}`)}
	}`;
    renderer.add_expression(x`@debug(${filename ? x`"${filename}"` : x`null`}, ${line - 1}, ${column}, ${obj})`);
  }
  function EachBlock$1(node2, renderer, options) {
    const args = [
      node2.context_node
    ];
    if (node2.index)
      args.push({
        type: "Identifier",
        name: node2.index
      });
    renderer.push();
    renderer.render(node2.children, options);
    const result = renderer.pop();
    const consequent = x`@each(${node2.expression.node}, (${args}) => { ${get_const_tags$1(node2.const_tags)}; return ${result} })`;
    if (node2.else) {
      renderer.push();
      renderer.render(node2.else.children, options);
      let alternate = renderer.pop();
      if (node2.else.const_tags.length > 0)
        alternate = x`(() => { ${get_const_tags$1(node2.else.const_tags)}; return ${alternate} })()`;
      renderer.add_expression(x`${node2.expression.node}.length ? ${consequent} : ${alternate}`);
    } else
      renderer.add_expression(consequent);
  }
  function get_class_attribute_value(attribute) {
    if (attribute.chunks.length === 2 && attribute.chunks[1].synthetic) {
      const value2 = attribute.chunks[0].node;
      return x`@escape(@null_to_empty(${value2}), true) + "${attribute.chunks[1].data}"`;
    }
    return get_attribute_value(attribute);
  }
  function get_attribute_value(attribute) {
    if (attribute.chunks.length === 0)
      return x`""`;
    return attribute.chunks.map((chunk) => {
      return chunk.type === "Text" ? string_literal(chunk.data.replace(regex_double_quotes, "&quot;")) : x`@escape(${chunk.node}, true)`;
    }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  }
  function get_attribute_expression(attribute) {
    if (attribute.chunks.length === 1 && attribute.chunks[0].type === "Expression")
      return attribute.chunks[0].node;
    return get_attribute_value(attribute);
  }
  function remove_whitespace_children(children, next) {
    const nodes = [];
    let last_child;
    let i2 = children.length;
    while (i2--) {
      const child = children[i2];
      if (child.type === "Text") {
        if (child.should_skip())
          continue;
        let { data: data2 } = child;
        if (nodes.length === 0) {
          const should_trim = next ? next.type === "Text" && regex_starts_with_whitespace.test(next.data) && trimmable_at$1(child, next) : !child.has_ancestor("EachBlock");
          if (should_trim && !child.keep_space()) {
            data2 = trim_end(data2);
            if (!data2)
              continue;
          }
        }
        if (last_child && last_child.type === "Text") {
          last_child.data = data2 + last_child.data;
          continue;
        }
        nodes.unshift(child);
        link(last_child, last_child = child);
      } else {
        nodes.unshift(child);
        link(last_child, last_child = child);
      }
    }
    const first = nodes[0];
    if (first && first.type === "Text" && !first.keep_space()) {
      first.data = trim_start(first.data);
      if (!first.data) {
        first.var = null;
        nodes.shift();
        if (nodes[0])
          nodes[0].prev = null;
      }
    }
    return nodes;
  }
  function trimmable_at$1(child, next_sibling) {
    return next_sibling.find_nearest(/EachBlock/) === child.find_nearest(/EachBlock/) || next_sibling.prev.type === "EachBlock";
  }
  function Element$1(node2, renderer, options) {
    const children = remove_whitespace_children(node2.children, node2.next);
    let node_contents;
    const contenteditable = node2.name !== "textarea" && node2.name !== "input" && node2.attributes.some((attribute) => attribute.name === "contenteditable");
    if (node2.is_dynamic_element)
      renderer.push();
    renderer.add_string("<");
    add_tag_name();
    const class_expression_list = node2.classes.map((class_directive) => {
      const { expression, name } = class_directive;
      const snippet = expression ? expression.node : x`#ctx.${name}`;
      return x`${snippet} ? "${name}" : ""`;
    });
    if (node2.needs_manual_style_scoping)
      class_expression_list.push(x`"${node2.component.stylesheet.id}"`);
    const class_expression = class_expression_list.length > 0 && class_expression_list.reduce((lhs, rhs) => x`${lhs} + ' ' + ${rhs}`);
    const style_expression_list = node2.styles.map((style_directive) => {
      let { name, important, expression: { node: expression } } = style_directive;
      if (important)
        expression = x`${expression} + ' !important'`;
      return p`"${name}": ${expression}`;
    });
    const style_expression = style_expression_list.length > 0 && x`{ ${style_expression_list} }`;
    if (node2.attributes.some((attr) => attr.is_spread)) {
      const args = [];
      node2.attributes.forEach((attribute) => {
        if (attribute.is_spread)
          args.push(x`@escape_object(${attribute.expression.node})`);
        else {
          const attr_name = node2.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
          const name = attribute.name.toLowerCase();
          if (name === "value" && node2.name.toLowerCase() === "textarea")
            node_contents = get_attribute_value(attribute);
          else if (attribute.is_true)
            args.push(x`{ ${attr_name}: true }`);
          else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text")
            args.push(x`{ ${attr_name}: ${attribute.chunks[0].node} || null }`);
          else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
            const snippet = attribute.chunks[0].node;
            args.push(x`{ ${attr_name}: @escape_attribute_value(${snippet}) }`);
          } else
            args.push(x`{ ${attr_name}: ${get_attribute_value(attribute)} }`);
        }
      });
      renderer.add_expression(x`@spread([${args}], { classes: ${class_expression}, styles: ${style_expression} })`);
    } else {
      let add_class_attribute = !!class_expression;
      let add_style_attribute = !!style_expression;
      node2.attributes.forEach((attribute) => {
        const name = attribute.name.toLowerCase();
        const attr_name = node2.namespace === namespaces.foreign ? attribute.name : fix_attribute_casing(attribute.name);
        if (name === "value" && node2.name.toLowerCase() === "textarea")
          node_contents = get_attribute_value(attribute);
        else if (attribute.is_true)
          renderer.add_string(` ${attr_name}`);
        else if (boolean_attributes.has(name) && attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          renderer.add_string(" ");
          renderer.add_expression(x`${attribute.chunks[0].node} ? "${attr_name}" : ""`);
        } else if (name === "class" && class_expression) {
          add_class_attribute = false;
          renderer.add_string(` ${attr_name}="`);
          renderer.add_expression(x`[${get_class_attribute_value(attribute)}, ${class_expression}].join(' ').trim()`);
          renderer.add_string('"');
        } else if (name === "style" && style_expression) {
          add_style_attribute = false;
          renderer.add_expression(x`@add_styles(@merge_ssr_styles(${get_attribute_value(attribute)}, ${style_expression}))`);
        } else if (attribute.chunks.length === 1 && attribute.chunks[0].type !== "Text") {
          const snippet = attribute.chunks[0].node;
          renderer.add_expression(x`@add_attribute("${attr_name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
        } else {
          renderer.add_string(` ${attr_name}="`);
          renderer.add_expression((name === "class" ? get_class_attribute_value : get_attribute_value)(attribute));
          renderer.add_string('"');
        }
      });
      if (add_class_attribute)
        renderer.add_expression(x`@add_classes((${class_expression}).trim())`);
      if (add_style_attribute)
        renderer.add_expression(x`@add_styles(${style_expression})`);
    }
    node2.bindings.forEach((binding) => {
      const { name, expression } = binding;
      if (binding.is_readonly)
        return;
      if (name === "group") {
        const value_attribute = node2.attributes.find(({ name: name2 }) => name2 === "value");
        if (value_attribute) {
          const value2 = get_attribute_expression(value_attribute);
          const type = node2.get_static_attribute_value("type");
          const bound2 = expression.node;
          const condition = type === "checkbox" ? x`~${bound2}.indexOf(${value2})` : x`${value2} === ${bound2}`;
          renderer.add_expression(x`${condition} ? @add_attribute("checked", true, 1) : ""`);
        }
      } else if (contenteditable && (name === "textContent" || name === "innerHTML"))
        node_contents = expression.node;
      else if (binding.name === "value" && node2.name === "textarea") {
        const snippet = expression.node;
        node_contents = x`${snippet} || ""`;
      } else if (binding.name === "value" && node2.name === "select")
        ;
      else {
        const snippet = expression.node;
        renderer.add_expression(x`@add_attribute("${name}", ${snippet}, ${boolean_attributes.has(name) ? 1 : 0})`);
      }
    });
    renderer.add_string(">");
    if (node_contents !== void 0) {
      if (contenteditable) {
        renderer.push();
        renderer.render(children, options);
        const result = renderer.pop();
        renderer.add_expression(x`($$value => $$value === void 0 ? ${result} : $$value)(${node_contents})`);
      } else {
        if (node2.name === "textarea") {
          const value_attribute = node2.attributes.find(({ name }) => name === "value");
          if (value_attribute) {
            const first = value_attribute.chunks[0];
            if (first && first.type === "Text" && regex_starts_with_newline.test(first.data))
              renderer.add_string("\n");
          }
        }
        renderer.add_expression(node_contents);
      }
      add_close_tag();
    } else {
      if (node2.name === "pre") {
        const first = children[0];
        if (first && first.type === "Text" && regex_starts_with_newline.test(first.data))
          renderer.add_string("\n");
      }
      if (node2.is_dynamic_element)
        renderer.push();
      renderer.render(children, options);
      if (node2.is_dynamic_element) {
        const children2 = renderer.pop();
        renderer.add_expression(x`@is_void(#tag) ? '' : ${children2}`);
      }
      add_close_tag();
    }
    if (node2.is_dynamic_element) {
      let content = renderer.pop();
      if (options.dev && node2.children.length > 0)
        content = x`(() => { @validate_void_dynamic_element(#tag); return ${content}; })()`;
      renderer.add_expression(x`((#tag) => {
			${options.dev && x`@validate_dynamic_element(#tag)`}
			return #tag ? ${content} : '';
		})(${node2.tag_expr.node})`);
    }
    function add_close_tag() {
      if (node2.tag_expr.node.type === "Literal") {
        if (!is_void(node2.tag_expr.node.value)) {
          renderer.add_string("</");
          add_tag_name();
          renderer.add_string(">");
        }
        return;
      }
      renderer.add_expression(x`@is_void(#tag) ? '' : \`</\${#tag}>\``);
    }
    function add_tag_name() {
      if (node2.tag_expr.node.type === "Literal")
        renderer.add_string(node2.tag_expr.node.value);
      else
        renderer.add_expression(node2.tag_expr.node);
    }
  }
  function Head$1(node2, renderer, options) {
    const head_options = Object.assign(Object.assign({}, options), {
      head_id: node2.id
    });
    renderer.push();
    renderer.render(node2.children, head_options);
    const result = renderer.pop();
    let expression = result;
    if (options.hydratable) {
      const start_comment = `HEAD_${node2.id}_START`;
      const end_comment = `HEAD_${node2.id}_END`;
      expression = x`'<!-- ${start_comment} -->' + ${expression} + '<!-- ${end_comment} -->'`;
    }
    renderer.add_expression(x`$$result.head += ${expression}, ""`);
  }
  function HtmlTag(node2, renderer, options) {
    if (options.hydratable)
      renderer.add_string("<!-- HTML_TAG_START -->");
    renderer.add_expression(node2.expression.node);
    if (options.hydratable)
      renderer.add_string("<!-- HTML_TAG_END -->");
  }
  function IfBlock$1(node2, renderer, options) {
    const condition = node2.expression.node;
    renderer.push();
    renderer.render(node2.children, options);
    let consequent = renderer.pop();
    if (node2.const_tags.length > 0)
      consequent = x`(() => { ${get_const_tags$1(node2.const_tags)}; return ${consequent} })()`;
    renderer.push();
    if (node2.else)
      renderer.render(node2.else.children, options);
    let alternate = renderer.pop();
    if (node2.else && node2.else.const_tags.length > 0)
      alternate = x`(() => { ${get_const_tags$1(node2.else.const_tags)}; return ${alternate} })()`;
    renderer.add_expression(x`${condition} ? ${consequent} : ${alternate}`);
  }
  function get_prop_value(attribute) {
    if (attribute.is_true)
      return x`true`;
    if (attribute.chunks.length === 0)
      return x`''`;
    return attribute.chunks.map((chunk) => {
      if (chunk.type === "Text")
        return string_literal(chunk.data);
      return chunk.node;
    }).reduce((lhs, rhs) => x`${lhs} + ${rhs}`);
  }
  function InlineComponent$1(node2, renderer, options) {
    const binding_props = [];
    const binding_fns = [];
    node2.bindings.forEach((binding) => {
      renderer.has_bindings = true;
      const snippet = binding.expression.node;
      binding_props.push(p`${binding.name}: ${snippet}`);
      binding_fns.push(p`${binding.name}: $$value => { ${snippet} = $$value; $$settled = false }`);
    });
    const uses_spread = node2.attributes.find((attr) => attr.is_spread);
    let props;
    if (uses_spread)
      props = x`@_Object.assign(${node2.attributes.map((attribute) => {
        if (attribute.is_spread)
          return attribute.expression.node;
        else
          return x`{ ${attribute.name}: ${get_prop_value(attribute)} }`;
      }).concat(binding_props.map((p2) => x`{ ${p2} }`))})`;
    else
      props = x`{
			${node2.attributes.map((attribute) => p`${attribute.name}: ${get_prop_value(attribute)}`)},
			${binding_props}
		}`;
    const bindings = x`{
		${binding_fns}
	}`;
    const expression = node2.name === "svelte:self" ? renderer.name : node2.name === "svelte:component" ? x`(${node2.expression.node}) || @missing_component` : node2.name.split(".").reduce((lhs, rhs) => x`${lhs}.${rhs}`);
    const slot_fns = [];
    const children = node2.children;
    if (children.length) {
      const slot_scopes = /* @__PURE__ */ new Map();
      renderer.render(children, Object.assign({}, options, {
        slot_scopes
      }));
      slot_scopes.forEach(({ input, output, statements }, name) => {
        slot_fns.push(p`${name}: (${input}) => { ${statements}; return ${output}; }`);
      });
    }
    const slots = x`{
		${slot_fns}
	}`;
    if (node2.css_custom_properties.length > 0) {
      if (node2.namespace === namespaces.svg)
        renderer.add_string('<g style="');
      else
        renderer.add_string('<div style="display: contents; ');
      node2.css_custom_properties.forEach((attr, index) => {
        renderer.add_string(`${attr.name}:`);
        renderer.add_expression(get_attribute_value(attr));
        renderer.add_string(";");
        if (index < node2.css_custom_properties.length - 1)
          renderer.add_string(" ");
      });
      renderer.add_string('">');
    }
    renderer.add_expression(x`@validate_component(${expression}, "${node2.name}").$$render($$result, ${props}, ${bindings}, ${slots})`);
    if (node2.css_custom_properties.length > 0) {
      if (node2.namespace === namespaces.svg)
        renderer.add_string("</g>");
      else
        renderer.add_string("</div>");
    }
  }
  function KeyBlock$1(node2, renderer, options) {
    renderer.render(node2.children, options);
  }
  function get_slot_scope(lets) {
    if (lets.length === 0)
      return null;
    return {
      type: "ObjectPattern",
      properties: lets.map((l) => {
        return {
          type: "Property",
          kind: "init",
          method: false,
          shorthand: false,
          computed: false,
          key: l.name,
          value: l.value || l.name
        };
      })
    };
  }
  function Slot$1(node2, renderer, options) {
    const slot_data = get_slot_data(node2.values);
    const slot = node2.get_static_attribute_value("slot");
    const nearest_inline_component = node2.find_nearest(/InlineComponent/);
    if (slot && nearest_inline_component)
      renderer.push();
    renderer.push();
    renderer.render(node2.children, options);
    const result = renderer.pop();
    renderer.add_expression(x`
		#slots.${node2.slot_name}
			? #slots.${node2.slot_name}(${slot_data})
			: ${result}
	`);
    if (slot && nearest_inline_component) {
      const lets = node2.lets;
      const seen = new Set(lets.map((l) => l.name.name));
      nearest_inline_component.lets.forEach((l) => {
        if (!seen.has(l.name.name))
          lets.push(l);
      });
      options.slot_scopes.set(slot, {
        input: get_slot_scope(node2.lets),
        output: renderer.pop()
      });
    }
  }
  function SlotTemplate$1(node2, renderer, options) {
    const parent_inline_component = node2.parent;
    const children = remove_whitespace_children(node2 instanceof SlotTemplate ? node2.children : [
      node2
    ], node2.next);
    renderer.push();
    renderer.render(children, options);
    const lets = node2.lets;
    const seen = new Set(lets.map((l) => l.name.name));
    parent_inline_component.lets.forEach((l) => {
      if (!seen.has(l.name.name))
        lets.push(l);
    });
    const slot_fragment_content = renderer.pop();
    if (!is_empty_template_literal(slot_fragment_content)) {
      if (options.slot_scopes.has(node2.slot_template_name)) {
        if (node2.slot_template_name === "default")
          throw new Error('Found elements without slot attribute when using slot="default"');
        throw new Error(`Duplicate slot name "${node2.slot_template_name}" in <${parent_inline_component.name}>`);
      }
      options.slot_scopes.set(node2.slot_template_name, {
        input: get_slot_scope(node2.lets),
        output: slot_fragment_content,
        statements: get_const_tags$1(node2.const_tags)
      });
    }
  }
  function is_empty_template_literal(template_literal) {
    return template_literal.expressions.length === 0 && template_literal.quasis.length === 1 && template_literal.quasis[0].value.raw === "";
  }
  function Tag$2(node2, renderer, _options) {
    const snippet = node2.expression.node;
    renderer.add_expression(node2.parent && node2.parent.type === "Element" && node2.parent.name === "style" ? snippet : x`@escape(${snippet})`);
  }
  function Text$1(node2, renderer, _options) {
    let text2 = node2.data;
    if (!node2.parent || node2.parent.type !== "Element" || node2.parent.name !== "script" && node2.parent.name !== "style")
      text2 = escape_html(text2);
    renderer.add_string(text2);
  }
  function Title$1(node2, renderer, options) {
    renderer.push();
    renderer.add_string("<title>");
    renderer.render(node2.children, options);
    renderer.add_string("</title>");
    const result = renderer.pop();
    renderer.add_expression(x`$$result.title = ${result}, ""`);
  }
  function noop() {
  }
  const handlers$1 = {
    AwaitBlock: AwaitBlock$1,
    Body: noop,
    Comment: Comment$2,
    DebugTag: DebugTag$1,
    EachBlock: EachBlock$1,
    Element: Element$1,
    Head: Head$1,
    IfBlock: IfBlock$1,
    InlineComponent: InlineComponent$1,
    KeyBlock: KeyBlock$1,
    MustacheTag: Tag$2,
    Options: noop,
    RawMustacheTag: HtmlTag,
    Slot: Slot$1,
    SlotTemplate: SlotTemplate$1,
    Text: Text$1,
    Title: Title$1,
    Window: noop
  };
  class Renderer$1 {
    constructor({ name }) {
      this.has_bindings = false;
      this.stack = [];
      this.targets = [];
      this.name = name;
      this.push();
    }
    add_string(str) {
      this.current.value += escape_template(str);
    }
    add_expression(node2) {
      this.literal.quasis.push({
        type: "TemplateElement",
        value: {
          raw: this.current.value,
          cooked: null
        },
        tail: false
      });
      this.literal.expressions.push(node2);
      this.current.value = "";
    }
    push() {
      const current = this.current = {
        value: ""
      };
      const literal2 = this.literal = {
        type: "TemplateLiteral",
        expressions: [],
        quasis: []
      };
      this.stack.push({
        current,
        literal: literal2
      });
    }
    pop() {
      this.literal.quasis.push({
        type: "TemplateElement",
        value: {
          raw: this.current.value,
          cooked: null
        },
        tail: true
      });
      const popped = this.stack.pop();
      const last = this.stack[this.stack.length - 1];
      if (last) {
        this.literal = last.literal;
        this.current = last.current;
      }
      return popped.literal;
    }
    render(nodes, options) {
      nodes.forEach((node2) => {
        const handler = handlers$1[node2.type];
        if (!handler)
          throw new Error(`No handler for '${node2.type}' nodes`);
        handler(node2, this, options);
      });
    }
  }
  function ssr(component, options) {
    const renderer = new Renderer$1({
      name: component.name
    });
    const { name } = component;
    renderer.render(trim(component.fragment.children), Object.assign({
      locate: component.locate
    }, options));
    const literal2 = renderer.pop();
    const css = options.customElement ? {
      code: null,
      map: null
    } : component.stylesheet.render(options.filename, true);
    const uses_rest = component.var_lookup.has("$$restProps");
    const props = component.vars.filter((variable) => !variable.module && variable.export_name);
    const rest = uses_rest ? b`let $$restProps = @compute_rest_props($$props, [${props.map((prop) => `"${prop.export_name}"`).join(",")}]);` : null;
    const uses_slots = component.var_lookup.has("$$slots");
    const slots = uses_slots ? b`let $$slots = @compute_slots(#slots);` : null;
    const reactive_stores = component.vars.filter((variable) => variable.name[0] === "$" && variable.name[1] !== "$");
    const reactive_store_subscriptions = reactive_stores.filter((store) => {
      const variable = component.var_lookup.get(store.name.slice(1));
      return !variable || variable.hoistable;
    }).map(({ name: name2 }) => {
      const store_name = name2.slice(1);
      return b`
				${component.compile_options.dev && b`@validate_store(${store_name}, '${store_name}');`}
				${`$$unsubscribe_${store_name}`} = @subscribe(${store_name}, #value => ${name2} = #value)
			`;
    });
    const reactive_store_unsubscriptions = reactive_stores.map(({ name: name2 }) => b`${`$$unsubscribe_${name2.slice(1)}`}()`);
    const reactive_store_declarations = reactive_stores.map(({ name: name2 }) => {
      const store_name = name2.slice(1);
      const store = component.var_lookup.get(store_name);
      if (store && store.reassigned) {
        const unsubscribe = `$$unsubscribe_${store_name}`;
        const subscribe = `$$subscribe_${store_name}`;
        return b`let ${name2}, ${unsubscribe} = @noop, ${subscribe} = () => (${unsubscribe}(), ${unsubscribe} = @subscribe(${store_name}, $$value => ${name2} = $$value), ${store_name})`;
      }
      return b`let ${name2}, ${`$$unsubscribe_${store_name}`};`;
    });
    if (component.ast.instance) {
      let scope2 = component.instance_scope;
      const map = component.instance_scope_map;
      walk(component.ast.instance.content, {
        enter(node2) {
          if (map.has(node2))
            scope2 = map.get(node2);
        },
        leave(node2) {
          if (map.has(node2))
            scope2 = scope2.parent;
          if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
            const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
            const names = new Set(extract_names(assignee));
            const to_invalidate = /* @__PURE__ */ new Set();
            for (const name2 of names) {
              const variable = component.var_lookup.get(name2);
              if (variable && !variable.hoistable && !variable.global && !variable.module && (variable.subscribable || variable.name[0] === "$"))
                to_invalidate.add(variable.name);
            }
            if (to_invalidate.size)
              this.replace(invalidate({
                component
              }, scope2, node2, to_invalidate, true));
          }
        }
      });
    }
    component.rewrite_props(({ name: name2, reassigned }) => {
      const value2 = `$${name2}`;
      let insert = reassigned ? b`${`$$subscribe_${name2}`}()` : b`${`$$unsubscribe_${name2}`} = @subscribe(${name2}, #value => $${value2} = #value)`;
      if (component.compile_options.dev)
        insert = b`@validate_store(${name2}, '${name2}'); ${insert}`;
      return insert;
    });
    const instance_javascript = component.extract_javascript(component.ast.instance);
    const parent_bindings = instance_javascript ? component.vars.filter((variable) => !variable.module && variable.export_name).map((prop) => {
      return b`if ($$props.${prop.export_name} === void 0 && $$bindings.${prop.export_name} && ${prop.name} !== void 0) $$bindings.${prop.export_name}(${prop.name});`;
    }) : [];
    const injected = Array.from(component.injected_reactive_declaration_vars).filter((name2) => {
      const variable = component.var_lookup.get(name2);
      return variable.injected;
    });
    const reactive_declarations = component.reactive_declarations.map((d) => {
      const body = d.node.body;
      let statement = b`${body}`;
      if (!d.declaration)
        statement = b`$: { ${statement} }`;
      return statement;
    });
    const main = renderer.has_bindings ? b`
			let $$settled;
			let $$rendered;

			do {
				$$settled = true;

				${reactive_declarations}

				$$rendered = ${literal2};
			} while (!$$settled);

			${reactive_store_unsubscriptions}

			return $$rendered;
		` : b`
			${reactive_declarations}

			${reactive_store_unsubscriptions}

			return ${literal2};`;
    const blocks = [
      ...injected.map((name2) => b`let ${name2};`),
      rest,
      slots,
      ...reactive_store_declarations,
      ...reactive_store_subscriptions,
      instance_javascript,
      ...parent_bindings,
      css.code && b`$$result.css.add(#css);`,
      main
    ].filter(Boolean);
    const css_sourcemap_enabled = check_enable_sourcemap(options.enableSourcemap, "css");
    const js = b`
		${css.code ? b`
		const #css = {
			code: "${css.code}",
			map: ${css_sourcemap_enabled && css.map ? string_literal(css.map.toString()) : "null"}
		};` : null}

		${component.extract_javascript(component.ast.module)}

		${component.fully_hoisted}

		const ${name} = @create_ssr_component(($$result, $$props, $$bindings, #slots) => {
			${blocks}
		});
	`;
    return {
      js,
      css
    };
  }
  function trim(nodes) {
    let start = 0;
    for (; start < nodes.length; start += 1) {
      const node2 = nodes[start];
      if (node2.type !== "Text")
        break;
      node2.data = node2.data.replace(/^\s+/, "");
      if (node2.data)
        break;
    }
    let end = nodes.length;
    for (; end > start; end -= 1) {
      const node2 = nodes[end - 1];
      if (node2.type !== "Text")
        break;
      node2.data = node2.data.trimRight();
      if (node2.data)
        break;
    }
    return nodes.slice(start, end);
  }
  var globals = /* @__PURE__ */ new Set([
    "AbortController",
    "AbortSignal",
    "AbstractRange",
    "ActiveXObject",
    "AggregateError",
    "AnalyserNode",
    "Animation",
    "AnimationEffect",
    "AnimationEvent",
    "AnimationPlaybackEvent",
    "AnimationTimeline",
    "Array",
    "ArrayBuffer",
    "Atomics",
    "Attr",
    "Audio",
    "AudioBuffer",
    "AudioBufferSourceNode",
    "AudioContext",
    "AudioDestinationNode",
    "AudioListener",
    "AudioNode",
    "AudioParam",
    "AudioParamMap",
    "AudioProcessingEvent",
    "AudioScheduledSourceNode",
    "AudioWorklet",
    "AudioWorkletNode",
    "AuthenticatorAssertionResponse",
    "AuthenticatorAttestationResponse",
    "AuthenticatorResponse",
    "BarProp",
    "BaseAudioContext",
    "BeforeUnloadEvent",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "BiquadFilterNode",
    "Blob",
    "BlobEvent",
    "Boolean",
    "BroadcastChannel",
    "ByteLengthQueuingStrategy",
    "CDATASection",
    "CSS",
    "CSSAnimation",
    "CSSConditionRule",
    "CSSCounterStyleRule",
    "CSSFontFaceRule",
    "CSSGroupingRule",
    "CSSImportRule",
    "CSSKeyframeRule",
    "CSSKeyframesRule",
    "CSSMediaRule",
    "CSSNamespaceRule",
    "CSSPageRule",
    "CSSRule",
    "CSSRuleList",
    "CSSStyleDeclaration",
    "CSSStyleRule",
    "CSSStyleSheet",
    "CSSSupportsRule",
    "CSSTransition",
    "Cache",
    "CacheStorage",
    "CanvasCaptureMediaStreamTrack",
    "CanvasGradient",
    "CanvasPattern",
    "CanvasRenderingContext2D",
    "ChannelMergerNode",
    "ChannelSplitterNode",
    "CharacterData",
    "ClientRect",
    "Clipboard",
    "ClipboardEvent",
    "ClipboardItem",
    "CloseEvent",
    "Comment",
    "CompositionEvent",
    "ConstantSourceNode",
    "ConvolverNode",
    "CountQueuingStrategy",
    "Credential",
    "CredentialsContainer",
    "Crypto",
    "CryptoKey",
    "CustomElementRegistry",
    "CustomEvent",
    "DOMException",
    "DOMImplementation",
    "DOMMatrix",
    "DOMMatrixReadOnly",
    "DOMParser",
    "DOMPoint",
    "DOMPointReadOnly",
    "DOMQuad",
    "DOMRect",
    "DOMRectList",
    "DOMRectReadOnly",
    "DOMStringList",
    "DOMStringMap",
    "DOMTokenList",
    "DataTransfer",
    "DataTransferItem",
    "DataTransferItemList",
    "DataView",
    "Date",
    "DelayNode",
    "DeviceMotionEvent",
    "DeviceOrientationEvent",
    "Document",
    "DocumentFragment",
    "DocumentTimeline",
    "DocumentType",
    "DragEvent",
    "DynamicsCompressorNode",
    "Element",
    "ElementInternals",
    "Enumerator",
    "Error",
    "ErrorEvent",
    "EvalError",
    "Event",
    "EventCounts",
    "EventSource",
    "EventTarget",
    "External",
    "File",
    "FileList",
    "FileReader",
    "FileSystem",
    "FileSystemDirectoryEntry",
    "FileSystemDirectoryHandle",
    "FileSystemDirectoryReader",
    "FileSystemEntry",
    "FileSystemFileEntry",
    "FileSystemFileHandle",
    "FileSystemHandle",
    "FinalizationRegistry",
    "Float32Array",
    "Float64Array",
    "FocusEvent",
    "FontFace",
    "FontFaceSet",
    "FontFaceSetLoadEvent",
    "FormData",
    "FormDataEvent",
    "Function",
    "GainNode",
    "Gamepad",
    "GamepadButton",
    "GamepadEvent",
    "GamepadHapticActuator",
    "Geolocation",
    "GeolocationCoordinates",
    "GeolocationPosition",
    "GeolocationPositionError",
    "HTMLAllCollection",
    "HTMLAnchorElement",
    "HTMLAreaElement",
    "HTMLAudioElement",
    "HTMLBRElement",
    "HTMLBaseElement",
    "HTMLBodyElement",
    "HTMLButtonElement",
    "HTMLCanvasElement",
    "HTMLCollection",
    "HTMLDListElement",
    "HTMLDataElement",
    "HTMLDataListElement",
    "HTMLDetailsElement",
    "HTMLDialogElement",
    "HTMLDirectoryElement",
    "HTMLDivElement",
    "HTMLDocument",
    "HTMLElement",
    "HTMLEmbedElement",
    "HTMLFieldSetElement",
    "HTMLFontElement",
    "HTMLFormControlsCollection",
    "HTMLFormElement",
    "HTMLFrameElement",
    "HTMLFrameSetElement",
    "HTMLHRElement",
    "HTMLHeadElement",
    "HTMLHeadingElement",
    "HTMLHtmlElement",
    "HTMLIFrameElement",
    "HTMLImageElement",
    "HTMLInputElement",
    "HTMLLIElement",
    "HTMLLabelElement",
    "HTMLLegendElement",
    "HTMLLinkElement",
    "HTMLMapElement",
    "HTMLMarqueeElement",
    "HTMLMediaElement",
    "HTMLMenuElement",
    "HTMLMetaElement",
    "HTMLMeterElement",
    "HTMLModElement",
    "HTMLOListElement",
    "HTMLObjectElement",
    "HTMLOptGroupElement",
    "HTMLOptionElement",
    "HTMLOptionsCollection",
    "HTMLOutputElement",
    "HTMLParagraphElement",
    "HTMLParamElement",
    "HTMLPictureElement",
    "HTMLPreElement",
    "HTMLProgressElement",
    "HTMLQuoteElement",
    "HTMLScriptElement",
    "HTMLSelectElement",
    "HTMLSlotElement",
    "HTMLSourceElement",
    "HTMLSpanElement",
    "HTMLStyleElement",
    "HTMLTableCaptionElement",
    "HTMLTableCellElement",
    "HTMLTableColElement",
    "HTMLTableElement",
    "HTMLTableRowElement",
    "HTMLTableSectionElement",
    "HTMLTemplateElement",
    "HTMLTextAreaElement",
    "HTMLTimeElement",
    "HTMLTitleElement",
    "HTMLTrackElement",
    "HTMLUListElement",
    "HTMLUnknownElement",
    "HTMLVideoElement",
    "HashChangeEvent",
    "Headers",
    "History",
    "IDBCursor",
    "IDBCursorWithValue",
    "IDBDatabase",
    "IDBFactory",
    "IDBIndex",
    "IDBKeyRange",
    "IDBObjectStore",
    "IDBOpenDBRequest",
    "IDBRequest",
    "IDBTransaction",
    "IDBVersionChangeEvent",
    "IIRFilterNode",
    "IdleDeadline",
    "Image",
    "ImageBitmap",
    "ImageBitmapRenderingContext",
    "ImageData",
    "Infinity",
    "InputDeviceInfo",
    "InputEvent",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "InternalError",
    "IntersectionObserver",
    "IntersectionObserverEntry",
    "Intl",
    "JSON",
    "KeyboardEvent",
    "KeyframeEffect",
    "Location",
    "Lock",
    "LockManager",
    "Map",
    "Math",
    "MathMLElement",
    "MediaCapabilities",
    "MediaDeviceInfo",
    "MediaDevices",
    "MediaElementAudioSourceNode",
    "MediaEncryptedEvent",
    "MediaError",
    "MediaKeyMessageEvent",
    "MediaKeySession",
    "MediaKeyStatusMap",
    "MediaKeySystemAccess",
    "MediaKeys",
    "MediaList",
    "MediaMetadata",
    "MediaQueryList",
    "MediaQueryListEvent",
    "MediaRecorder",
    "MediaRecorderErrorEvent",
    "MediaSession",
    "MediaSource",
    "MediaStream",
    "MediaStreamAudioDestinationNode",
    "MediaStreamAudioSourceNode",
    "MediaStreamTrack",
    "MediaStreamTrackEvent",
    "MessageChannel",
    "MessageEvent",
    "MessagePort",
    "MimeType",
    "MimeTypeArray",
    "MouseEvent",
    "MutationEvent",
    "MutationObserver",
    "MutationRecord",
    "NaN",
    "NamedNodeMap",
    "NavigationPreloadManager",
    "Navigator",
    "NetworkInformation",
    "Node",
    "NodeFilter",
    "NodeIterator",
    "NodeList",
    "Notification",
    "Number",
    "Object",
    "OfflineAudioCompletionEvent",
    "OfflineAudioContext",
    "Option",
    "OscillatorNode",
    "OverconstrainedError",
    "PageTransitionEvent",
    "PannerNode",
    "Path2D",
    "PaymentAddress",
    "PaymentMethodChangeEvent",
    "PaymentRequest",
    "PaymentRequestUpdateEvent",
    "PaymentResponse",
    "Performance",
    "PerformanceEntry",
    "PerformanceEventTiming",
    "PerformanceMark",
    "PerformanceMeasure",
    "PerformanceNavigation",
    "PerformanceNavigationTiming",
    "PerformanceObserver",
    "PerformanceObserverEntryList",
    "PerformancePaintTiming",
    "PerformanceResourceTiming",
    "PerformanceServerTiming",
    "PerformanceTiming",
    "PeriodicWave",
    "PermissionStatus",
    "Permissions",
    "PictureInPictureWindow",
    "Plugin",
    "PluginArray",
    "PointerEvent",
    "PopStateEvent",
    "ProcessingInstruction",
    "ProgressEvent",
    "Promise",
    "PromiseRejectionEvent",
    "Proxy",
    "PublicKeyCredential",
    "PushManager",
    "PushSubscription",
    "PushSubscriptionOptions",
    "RTCCertificate",
    "RTCDTMFSender",
    "RTCDTMFToneChangeEvent",
    "RTCDataChannel",
    "RTCDataChannelEvent",
    "RTCDtlsTransport",
    "RTCEncodedAudioFrame",
    "RTCEncodedVideoFrame",
    "RTCError",
    "RTCErrorEvent",
    "RTCIceCandidate",
    "RTCIceTransport",
    "RTCPeerConnection",
    "RTCPeerConnectionIceErrorEvent",
    "RTCPeerConnectionIceEvent",
    "RTCRtpReceiver",
    "RTCRtpSender",
    "RTCRtpTransceiver",
    "RTCSctpTransport",
    "RTCSessionDescription",
    "RTCStatsReport",
    "RTCTrackEvent",
    "RadioNodeList",
    "Range",
    "RangeError",
    "ReadableByteStreamController",
    "ReadableStream",
    "ReadableStreamBYOBReader",
    "ReadableStreamBYOBRequest",
    "ReadableStreamDefaultController",
    "ReadableStreamDefaultReader",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "RemotePlayback",
    "Request",
    "ResizeObserver",
    "ResizeObserverEntry",
    "ResizeObserverSize",
    "Response",
    "SVGAElement",
    "SVGAngle",
    "SVGAnimateElement",
    "SVGAnimateMotionElement",
    "SVGAnimateTransformElement",
    "SVGAnimatedAngle",
    "SVGAnimatedBoolean",
    "SVGAnimatedEnumeration",
    "SVGAnimatedInteger",
    "SVGAnimatedLength",
    "SVGAnimatedLengthList",
    "SVGAnimatedNumber",
    "SVGAnimatedNumberList",
    "SVGAnimatedPreserveAspectRatio",
    "SVGAnimatedRect",
    "SVGAnimatedString",
    "SVGAnimatedTransformList",
    "SVGAnimationElement",
    "SVGCircleElement",
    "SVGClipPathElement",
    "SVGComponentTransferFunctionElement",
    "SVGCursorElement",
    "SVGDefsElement",
    "SVGDescElement",
    "SVGElement",
    "SVGEllipseElement",
    "SVGFEBlendElement",
    "SVGFEColorMatrixElement",
    "SVGFEComponentTransferElement",
    "SVGFECompositeElement",
    "SVGFEConvolveMatrixElement",
    "SVGFEDiffuseLightingElement",
    "SVGFEDisplacementMapElement",
    "SVGFEDistantLightElement",
    "SVGFEDropShadowElement",
    "SVGFEFloodElement",
    "SVGFEFuncAElement",
    "SVGFEFuncBElement",
    "SVGFEFuncGElement",
    "SVGFEFuncRElement",
    "SVGFEGaussianBlurElement",
    "SVGFEImageElement",
    "SVGFEMergeElement",
    "SVGFEMergeNodeElement",
    "SVGFEMorphologyElement",
    "SVGFEOffsetElement",
    "SVGFEPointLightElement",
    "SVGFESpecularLightingElement",
    "SVGFESpotLightElement",
    "SVGFETileElement",
    "SVGFETurbulenceElement",
    "SVGFilterElement",
    "SVGForeignObjectElement",
    "SVGGElement",
    "SVGGeometryElement",
    "SVGGradientElement",
    "SVGGraphicsElement",
    "SVGImageElement",
    "SVGLength",
    "SVGLengthList",
    "SVGLineElement",
    "SVGLinearGradientElement",
    "SVGMPathElement",
    "SVGMarkerElement",
    "SVGMaskElement",
    "SVGMatrix",
    "SVGMetadataElement",
    "SVGNumber",
    "SVGNumberList",
    "SVGPathElement",
    "SVGPatternElement",
    "SVGPoint",
    "SVGPointList",
    "SVGPolygonElement",
    "SVGPolylineElement",
    "SVGPreserveAspectRatio",
    "SVGRadialGradientElement",
    "SVGRect",
    "SVGRectElement",
    "SVGSVGElement",
    "SVGScriptElement",
    "SVGSetElement",
    "SVGStopElement",
    "SVGStringList",
    "SVGStyleElement",
    "SVGSwitchElement",
    "SVGSymbolElement",
    "SVGTSpanElement",
    "SVGTextContentElement",
    "SVGTextElement",
    "SVGTextPathElement",
    "SVGTextPositioningElement",
    "SVGTitleElement",
    "SVGTransform",
    "SVGTransformList",
    "SVGUnitTypes",
    "SVGUseElement",
    "SVGViewElement",
    "SafeArray",
    "Screen",
    "ScreenOrientation",
    "ScriptProcessorNode",
    "SecurityPolicyViolationEvent",
    "Selection",
    "ServiceWorker",
    "ServiceWorkerContainer",
    "ServiceWorkerRegistration",
    "Set",
    "ShadowRoot",
    "SharedArrayBuffer",
    "SharedWorker",
    "SourceBuffer",
    "SourceBufferList",
    "SpeechRecognitionAlternative",
    "SpeechRecognitionErrorEvent",
    "SpeechRecognitionResult",
    "SpeechRecognitionResultList",
    "SpeechSynthesis",
    "SpeechSynthesisErrorEvent",
    "SpeechSynthesisEvent",
    "SpeechSynthesisUtterance",
    "SpeechSynthesisVoice",
    "StaticRange",
    "StereoPannerNode",
    "Storage",
    "StorageEvent",
    "StorageManager",
    "String",
    "StyleMedia",
    "StyleSheet",
    "StyleSheetList",
    "SubmitEvent",
    "SubtleCrypto",
    "Symbol",
    "SyntaxError",
    "Text",
    "TextDecoder",
    "TextDecoderStream",
    "TextEncoder",
    "TextEncoderStream",
    "TextMetrics",
    "TextTrack",
    "TextTrackCue",
    "TextTrackCueList",
    "TextTrackList",
    "TimeRanges",
    "Touch",
    "TouchEvent",
    "TouchList",
    "TrackEvent",
    "TransformStream",
    "TransformStreamDefaultController",
    "TransitionEvent",
    "TreeWalker",
    "TypeError",
    "UIEvent",
    "URIError",
    "URL",
    "URLSearchParams",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "VBArray",
    "VTTCue",
    "VTTRegion",
    "ValidityState",
    "VarDate",
    "VideoColorSpace",
    "VideoPlaybackQuality",
    "VisualViewport",
    "WSH",
    "WScript",
    "WaveShaperNode",
    "WeakMap",
    "WeakRef",
    "WeakSet",
    "WebAssembly",
    "WebGL2RenderingContext",
    "WebGLActiveInfo",
    "WebGLBuffer",
    "WebGLContextEvent",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLQuery",
    "WebGLRenderbuffer",
    "WebGLRenderingContext",
    "WebGLSampler",
    "WebGLShader",
    "WebGLShaderPrecisionFormat",
    "WebGLSync",
    "WebGLTexture",
    "WebGLTransformFeedback",
    "WebGLUniformLocation",
    "WebGLVertexArrayObject",
    "WebKitCSSMatrix",
    "WebSocket",
    "WheelEvent",
    "Window",
    "Worker",
    "Worklet",
    "WritableStream",
    "WritableStreamDefaultController",
    "WritableStreamDefaultWriter",
    "XMLDocument",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload",
    "XMLSerializer",
    "XPathEvaluator",
    "XPathExpression",
    "XPathResult",
    "XSLTProcessor",
    "addEventListener",
    "alert",
    "atob",
    "blur",
    "btoa",
    "caches",
    "cancelAnimationFrame",
    "cancelIdleCallback",
    "captureEvents",
    "clearInterval",
    "clearTimeout",
    "clientInformation",
    "close",
    "closed",
    "confirm",
    "console",
    "createImageBitmap",
    "crossOriginIsolated",
    "crypto",
    "customElements",
    "decodeURI",
    "decodeURIComponent",
    "devicePixelRatio",
    "dispatchEvent",
    "document",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "eval",
    "event",
    "external",
    "fetch",
    "focus",
    "frameElement",
    "frames",
    "getComputedStyle",
    "getSelection",
    "global",
    "globalThis",
    "history",
    "importScripts",
    "indexedDB",
    "innerHeight",
    "innerWidth",
    "isFinite",
    "isNaN",
    "isSecureContext",
    "length",
    "localStorage",
    "location",
    "locationbar",
    "matchMedia",
    "menubar",
    "moveBy",
    "moveTo",
    "name",
    "navigator",
    "onabort",
    "onafterprint",
    "onanimationcancel",
    "onanimationend",
    "onanimationiteration",
    "onanimationstart",
    "onauxclick",
    "onbeforeprint",
    "onbeforeunload",
    "onblur",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextmenu",
    "oncuechange",
    "ondblclick",
    "ondevicemotion",
    "ondeviceorientation",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "ongamepadconnected",
    "ongamepaddisconnected",
    "ongotpointercapture",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onlostpointercapture",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onorientationchange",
    "onpagehide",
    "onpageshow",
    "onpause",
    "onplay",
    "onplaying",
    "onpointercancel",
    "onpointerdown",
    "onpointerenter",
    "onpointerleave",
    "onpointermove",
    "onpointerout",
    "onpointerover",
    "onpointerup",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onrejectionhandled",
    "onreset",
    "onresize",
    "onscroll",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onselectionchange",
    "onselectstart",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "ontouchcancel",
    "ontouchend",
    "ontouchmove",
    "ontouchstart",
    "ontransitioncancel",
    "ontransitionend",
    "ontransitionrun",
    "ontransitionstart",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwebkitanimationend",
    "onwebkitanimationiteration",
    "onwebkitanimationstart",
    "onwebkittransitionend",
    "onwheel",
    "open",
    "opener",
    "orientation",
    "origin",
    "outerHeight",
    "outerWidth",
    "pageXOffset",
    "pageYOffset",
    "parent",
    "parseFloat",
    "parseInt",
    "performance",
    "personalbar",
    "postMessage",
    "print",
    "process",
    "prompt",
    "queueMicrotask",
    "releaseEvents",
    "removeEventListener",
    "reportError",
    "requestAnimationFrame",
    "requestIdleCallback",
    "resizeBy",
    "resizeTo",
    "screen",
    "screenLeft",
    "screenTop",
    "screenX",
    "screenY",
    "scroll",
    "scrollBy",
    "scrollTo",
    "scrollX",
    "scrollY",
    "scrollbars",
    "self",
    "sessionStorage",
    "setInterval",
    "setTimeout",
    "speechSynthesis",
    "status",
    "statusbar",
    "stop",
    "structuredClone",
    "toString",
    "toolbar",
    "top",
    "undefined",
    "unescape",
    "visualViewport",
    "webkitURL",
    "window"
  ]);
  const wrappers$1 = {
    esm,
    cjs
  };
  function create_module(program, format, name, banner, sveltePath = "svelte", helpers, globals2, imports, module_exports, exports_from) {
    const internal_path = `${sveltePath}/internal`;
    helpers.sort((a, b2) => a.name < b2.name ? -1 : 1);
    globals2.sort((a, b2) => a.name < b2.name ? -1 : 1);
    const formatter = wrappers$1[format];
    if (!formatter)
      throw new Error(`options.format is invalid (must be ${list$1(Object.keys(wrappers$1))})`);
    return formatter(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from);
  }
  function edit_source(source, sveltePath) {
    return source === "svelte" || source.startsWith("svelte/") ? source.replace("svelte", sveltePath) : source;
  }
  function get_internal_globals(globals2, helpers) {
    return globals2.length > 0 && {
      type: "VariableDeclaration",
      kind: "const",
      declarations: [
        {
          type: "VariableDeclarator",
          id: {
            type: "ObjectPattern",
            properties: globals2.map((g2) => ({
              type: "Property",
              method: false,
              shorthand: false,
              computed: false,
              key: {
                type: "Identifier",
                name: g2.name
              },
              value: g2.alias,
              kind: "init"
            }))
          },
          init: helpers.find(({ name }) => name === "globals").alias
        }
      ]
    };
  }
  function esm(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from) {
    const import_declaration = {
      type: "ImportDeclaration",
      specifiers: helpers.map((h) => ({
        type: "ImportSpecifier",
        local: h.alias,
        imported: {
          type: "Identifier",
          name: h.name
        }
      })),
      source: {
        type: "Literal",
        value: internal_path
      }
    };
    const internal_globals = get_internal_globals(globals2, helpers);
    function rewrite_import(node2) {
      const value2 = edit_source(node2.source.value, sveltePath);
      if (node2.source.value !== value2) {
        node2.source.value = value2;
        node2.source.raw = null;
      }
    }
    imports.forEach(rewrite_import);
    exports_from.forEach(rewrite_import);
    const exports12 = module_exports.length > 0 && {
      type: "ExportNamedDeclaration",
      specifiers: module_exports.map((x2) => ({
        type: "Specifier",
        local: {
          type: "Identifier",
          name: x2.name
        },
        exported: {
          type: "Identifier",
          name: x2.as
        }
      }))
    };
    program.body = b`
		/* ${banner} */

		${import_declaration}
		${internal_globals}
		${imports}
		${exports_from}

		${program.body}

		export default ${name};
		${exports12}
	`;
  }
  function cjs(program, name, banner, sveltePath, internal_path, helpers, globals2, imports, module_exports, exports_from) {
    const internal_requires = {
      type: "VariableDeclaration",
      kind: "const",
      declarations: [
        {
          type: "VariableDeclarator",
          id: {
            type: "ObjectPattern",
            properties: helpers.map((h) => ({
              type: "Property",
              method: false,
              shorthand: false,
              computed: false,
              key: {
                type: "Identifier",
                name: h.name
              },
              value: h.alias,
              kind: "init"
            }))
          },
          init: x`require("${internal_path}")`
        }
      ]
    };
    const internal_globals = get_internal_globals(globals2, helpers);
    const user_requires = imports.map((node2) => {
      const init = x`require("${edit_source(node2.source.value, sveltePath)}")`;
      if (node2.specifiers.length === 0)
        return b`${init};`;
      return {
        type: "VariableDeclaration",
        kind: "const",
        declarations: [
          {
            type: "VariableDeclarator",
            id: node2.specifiers[0].type === "ImportNamespaceSpecifier" ? {
              type: "Identifier",
              name: node2.specifiers[0].local.name
            } : {
              type: "ObjectPattern",
              properties: node2.specifiers.map((s) => ({
                type: "Property",
                method: false,
                shorthand: false,
                computed: false,
                key: s.type === "ImportSpecifier" ? s.imported : {
                  type: "Identifier",
                  name: "default"
                },
                value: s.local,
                kind: "init"
              }))
            },
            init
          }
        ]
      };
    });
    const exports12 = module_exports.map((x2) => b`exports.${{
      type: "Identifier",
      name: x2.as
    }} = ${{
      type: "Identifier",
      name: x2.name
    }};`);
    const user_exports_from = exports_from.map((node2) => {
      const init = x`require("${edit_source(node2.source.value, sveltePath)}")`;
      return node2.specifiers.map((specifier) => {
        return b`exports.${specifier.exported} = ${init}.${specifier.local};`;
      });
    });
    program.body = b`
		/* ${banner} */

		"use strict";
		${internal_requires}
		${internal_globals}
		${user_requires}
		${user_exports_from}

		${program.body}

		exports.default = ${name};
		${exports12}
	`;
  }
  var Chunk = function Chunk2(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    Object.defineProperties(this, {
      previous: {
        writable: true,
        value: null
      },
      next: {
        writable: true,
        value: null
      }
    });
  };
  Chunk.prototype.appendLeft = function appendLeft(content) {
    this.outro += content;
  };
  Chunk.prototype.appendRight = function appendRight(content) {
    this.intro = this.intro + content;
  };
  Chunk.prototype.clone = function clone2() {
    var chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  };
  Chunk.prototype.contains = function contains(index) {
    return this.start < index && index < this.end;
  };
  Chunk.prototype.eachNext = function eachNext(fn) {
    var chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  };
  Chunk.prototype.eachPrevious = function eachPrevious(fn) {
    var chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  };
  Chunk.prototype.edit = function edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  };
  Chunk.prototype.prependLeft = function prependLeft(content) {
    this.outro = content + this.outro;
  };
  Chunk.prototype.prependRight = function prependRight(content) {
    this.intro = content + this.intro;
  };
  Chunk.prototype.split = function split(index) {
    var sliceIndex = index - this.start;
    var originalBefore = this.original.slice(0, sliceIndex);
    var originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    var newChunk = new Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else
      this.content = originalBefore;
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  };
  Chunk.prototype.toString = function toString4() {
    return this.intro + this.content + this.outro;
  };
  Chunk.prototype.trimEnd = function trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    var trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content)
        this.split(this.start + trimmed.length).edit("", void 0, true);
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  };
  Chunk.prototype.trimStart = function trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    var trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  };
  var btoa$2 = function() {
    throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
  };
  if (typeof window !== "undefined" && typeof window.btoa === "function")
    btoa$2 = function(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    };
  else if (typeof Buffer === "function")
    btoa$2 = function(str) {
      return Buffer.from(str, "utf-8").toString("base64");
    };
  var SourceMap$1 = function SourceMap2(properties2) {
    this.version = 3;
    this.file = properties2.file;
    this.sources = properties2.sources;
    this.sourcesContent = properties2.sourcesContent;
    this.names = properties2.names;
    this.mappings = encode(properties2.mappings);
  };
  SourceMap$1.prototype.toString = function toString4() {
    return JSON.stringify(this);
  };
  SourceMap$1.prototype.toUrl = function toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa$2(this.toString());
  };
  function guessIndent(code) {
    var lines = code.split("\n");
    var tabbed = lines.filter(function(line) {
      return /^\t+/.test(line);
    });
    var spaced = lines.filter(function(line) {
      return /^ {2,}/.test(line);
    });
    if (tabbed.length === 0 && spaced.length === 0)
      return null;
    if (tabbed.length >= spaced.length)
      return "	";
    var min = spaced.reduce(function(previous, current) {
      var numSpaces = /^ +/.exec(current)[0].length;
      return Math.min(numSpaces, previous);
    }, Infinity);
    return new Array(min + 1).join(" ");
  }
  function getRelativePath(from, to) {
    var fromParts = from.split(/[/\\]/);
    var toParts = to.split(/[/\\]/);
    fromParts.pop();
    while (fromParts[0] === toParts[0]) {
      fromParts.shift();
      toParts.shift();
    }
    if (fromParts.length) {
      var i2 = fromParts.length;
      while (i2--)
        fromParts[i2] = "..";
    }
    return fromParts.concat(toParts).join("/");
  }
  var toString$2 = Object.prototype.toString;
  function isObject(thing) {
    return toString$2.call(thing) === "[object Object]";
  }
  function getLocator$1(source) {
    var originalLines = source.split("\n");
    var lineOffsets = [];
    for (var i2 = 0, pos = 0; i2 < originalLines.length; i2++) {
      lineOffsets.push(pos);
      pos += originalLines[i2].length + 1;
    }
    return function locate2(index) {
      var i3 = 0;
      var j = lineOffsets.length;
      while (i3 < j) {
        var m = i3 + j >> 1;
        if (index < lineOffsets[m])
          j = m;
        else
          i3 = m + 1;
      }
      var line = i3 - 1;
      var column = index - lineOffsets[line];
      return {
        line,
        column
      };
    };
  }
  var Mappings = function Mappings2(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  };
  Mappings.prototype.addEdit = function addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      var segment = [
        this.generatedCodeColumn,
        sourceIndex,
        loc.line,
        loc.column
      ];
      if (nameIndex >= 0)
        segment.push(nameIndex);
      this.rawSegments.push(segment);
    } else if (this.pending)
      this.rawSegments.push(this.pending);
    this.advance(content);
    this.pending = null;
  };
  Mappings.prototype.addUneditedChunk = function addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    var originalCharIndex = chunk.start;
    var first = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first || sourcemapLocations[originalCharIndex])
        this.rawSegments.push([
          this.generatedCodeColumn,
          sourceIndex,
          loc.line,
          loc.column
        ]);
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
      }
      originalCharIndex += 1;
      first = false;
    }
    this.pending = [
      this.generatedCodeColumn,
      sourceIndex,
      loc.line,
      loc.column
    ];
  };
  Mappings.prototype.advance = function advance(str) {
    if (!str)
      return;
    var lines = str.split("\n");
    if (lines.length > 1) {
      for (var i2 = 0; i2 < lines.length - 1; i2++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  };
  var n = "\n";
  var warned = {
    insertLeft: false,
    insertRight: false,
    storeName: false
  };
  var MagicString = function MagicString2(string, options) {
    if (options === void 0)
      options = {};
    var chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: {
        writable: true,
        value: string
      },
      outro: {
        writable: true,
        value: ""
      },
      intro: {
        writable: true,
        value: ""
      },
      firstChunk: {
        writable: true,
        value: chunk
      },
      lastChunk: {
        writable: true,
        value: chunk
      },
      lastSearchedChunk: {
        writable: true,
        value: chunk
      },
      byStart: {
        writable: true,
        value: {}
      },
      byEnd: {
        writable: true,
        value: {}
      },
      filename: {
        writable: true,
        value: options.filename
      },
      indentExclusionRanges: {
        writable: true,
        value: options.indentExclusionRanges
      },
      sourcemapLocations: {
        writable: true,
        value: {}
      },
      storedNames: {
        writable: true,
        value: {}
      },
      indentStr: {
        writable: true,
        value: guessIndent(string)
      }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  };
  MagicString.prototype.addSourcemapLocation = function addSourcemapLocation(char) {
    this.sourcemapLocations[char] = true;
  };
  MagicString.prototype.append = function append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  };
  MagicString.prototype.appendLeft = function appendLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk)
      chunk.appendLeft(content);
    else
      this.intro += content;
    return this;
  };
  MagicString.prototype.appendRight = function appendRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk)
      chunk.appendRight(content);
    else
      this.outro += content;
    return this;
  };
  MagicString.prototype.clone = function clone2() {
    var cloned = new MagicString(this.original, {
      filename: this.filename
    });
    var originalChunk = this.firstChunk;
    var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      var nextOriginalChunk = originalChunk.next;
      var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges)
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    Object.keys(this.sourcemapLocations).forEach(function(loc) {
      cloned.sourcemapLocations[loc] = true;
    });
    return cloned;
  };
  MagicString.prototype.generateDecodedMap = function generateDecodedMap(options) {
    var this$1$1 = this;
    options = options || {};
    var sourceIndex = 0;
    var names = Object.keys(this.storedNames);
    var mappings = new Mappings(options.hires);
    var locate2 = getLocator$1(this.original);
    if (this.intro)
      mappings.advance(this.intro);
    this.firstChunk.eachNext(function(chunk) {
      var loc = locate2(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited)
        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);
      else
        mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : null,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : null
      ],
      sourcesContent: options.includeContent ? [
        this.original
      ] : [
        null
      ],
      names,
      mappings: mappings.raw
    };
  };
  MagicString.prototype.generateMap = function generateMap(options) {
    return new SourceMap$1(this.generateDecodedMap(options));
  };
  MagicString.prototype.getIndentString = function getIndentString() {
    return this.indentStr === null ? "	" : this.indentStr;
  };
  MagicString.prototype.indent = function indent(indentStr, options) {
    var pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    indentStr = indentStr !== void 0 ? indentStr : this.indentStr || "	";
    if (indentStr === "")
      return this;
    options = options || {};
    var isExcluded = {};
    if (options.exclude) {
      var exclusions = typeof options.exclude[0] === "number" ? [
        options.exclude
      ] : options.exclude;
      exclusions.forEach(function(exclusion) {
        for (var i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1)
          isExcluded[i2] = true;
      });
    }
    var shouldIndentNextCharacter = options.indentStart !== false;
    var replacer = function(match) {
      if (shouldIndentNextCharacter)
        return "" + indentStr + match;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    var charIndex = 0;
    var chunk = this.firstChunk;
    while (chunk) {
      var end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length)
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            var char = this.original[charIndex];
            if (char === "\n")
              shouldIndentNextCharacter = true;
            else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start)
                chunk.prependRight(indentStr);
              else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  };
  MagicString.prototype.insert = function insert() {
    throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
  };
  MagicString.prototype.insertLeft = function insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn("magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead");
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  };
  MagicString.prototype.insertRight = function insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn("magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead");
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  };
  MagicString.prototype.move = function move(start, end, index) {
    if (index >= start && index <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index);
    var first = this.byStart[start];
    var last = this.byEnd[end];
    var oldLeft = first.previous;
    var oldRight = last.next;
    var newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk)
      return this;
    var newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first;
    if (newRight)
      newRight.previous = last;
    if (!first.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first;
    if (!newRight)
      this.lastChunk = last;
    return this;
  };
  MagicString.prototype.overwrite = function overwrite(start, end, content, options) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error("Cannot overwrite a zero-length range – use appendLeft or prependRight instead");
    this._split(start);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn("The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string");
        warned.storeName = true;
      }
      options = {
        storeName: true
      };
    }
    var storeName = options !== void 0 ? options.storeName : false;
    var contentOnly = options !== void 0 ? options.contentOnly : false;
    if (storeName) {
      var original = this.original.slice(start, end);
      this.storedNames[original] = true;
    }
    var first = this.byStart[start];
    var last = this.byEnd[end];
    if (first) {
      if (end > first.end && first.next !== this.byStart[first.end])
        throw new Error("Cannot overwrite across a split point");
      first.edit(content, storeName, contentOnly);
      if (first !== last) {
        var chunk = first.next;
        while (chunk !== last) {
          chunk.edit("", false);
          chunk = chunk.next;
        }
        chunk.edit("", false);
      }
    } else {
      var newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  };
  MagicString.prototype.prepend = function prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  };
  MagicString.prototype.prependLeft = function prependLeft(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    var chunk = this.byEnd[index];
    if (chunk)
      chunk.prependLeft(content);
    else
      this.intro = content + this.intro;
    return this;
  };
  MagicString.prototype.prependRight = function prependRight(index, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index);
    var chunk = this.byStart[index];
    if (chunk)
      chunk.prependRight(content);
    else
      this.outro = content + this.outro;
    return this;
  };
  MagicString.prototype.remove = function remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    var chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  };
  MagicString.prototype.lastChar = function lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    var chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  };
  MagicString.prototype.lastLine = function lastLine() {
    var lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    var lineStr = this.outro;
    var chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  };
  MagicString.prototype.slice = function slice2(start, end) {
    if (start === void 0)
      start = 0;
    if (end === void 0)
      end = this.original.length;
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    var result = "";
    var chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end)
        return result;
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error("Cannot use replaced character " + start + " as slice start anchor.");
    var startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start))
        result += chunk.intro;
      var containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error("Cannot use replaced character " + end + " as slice end anchor.");
      var sliceStart = startChunk === chunk ? start - chunk.start : 0;
      var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end))
        result += chunk.outro;
      if (containsEnd)
        break;
      chunk = chunk.next;
    }
    return result;
  };
  MagicString.prototype.snip = function snip(start, end) {
    var clone2 = this.clone();
    clone2.remove(0, start);
    clone2.remove(end, clone2.original.length);
    return clone2;
  };
  MagicString.prototype._split = function _split(index) {
    if (this.byStart[index] || this.byEnd[index])
      return;
    var chunk = this.lastSearchedChunk;
    var searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index))
        return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  };
  MagicString.prototype._splitChunk = function _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      var loc = getLocator$1(this.original)(index);
      throw new Error("Cannot split a chunk that has already been edited (" + loc.line + ":" + loc.column + ' – "' + chunk.original + '")');
    }
    var newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  };
  MagicString.prototype.toString = function toString4() {
    var str = this.intro;
    var chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  };
  MagicString.prototype.isEmpty = function isEmpty() {
    var chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  };
  MagicString.prototype.length = function length() {
    var chunk = this.firstChunk;
    var length2 = 0;
    do
      length2 += chunk.intro.length + chunk.content.length + chunk.outro.length;
    while (chunk = chunk.next);
    return length2;
  };
  MagicString.prototype.trimLines = function trimLines() {
    return this.trim("[\\r\\n]");
  };
  MagicString.prototype.trim = function trim2(charType) {
    return this.trimStart(charType).trimEnd(charType);
  };
  MagicString.prototype.trimEndAborted = function trimEndAborted(charType) {
    var rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    var chunk = this.lastChunk;
    do {
      var end = chunk.end;
      var aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  };
  MagicString.prototype.trimEnd = function trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  };
  MagicString.prototype.trimStartAborted = function trimStartAborted(charType) {
    var rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    var chunk = this.firstChunk;
    do {
      var end = chunk.end;
      var aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  };
  MagicString.prototype.trimStart = function trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  };
  const UNKNOWN = {};
  function gather_possible_values(node2, set) {
    if (node2.type === "Literal")
      set.add(node2.value);
    else if (node2.type === "ConditionalExpression") {
      gather_possible_values(node2.consequent, set);
      gather_possible_values(node2.alternate, set);
    } else
      set.add(UNKNOWN);
  }
  var BlockAppliesToNode;
  (function(BlockAppliesToNode2) {
    BlockAppliesToNode2[BlockAppliesToNode2["NotPossible"] = 0] = "NotPossible";
    BlockAppliesToNode2[BlockAppliesToNode2["Possible"] = 1] = "Possible";
    BlockAppliesToNode2[BlockAppliesToNode2["UnknownSelectorType"] = 2] = "UnknownSelectorType";
  })(BlockAppliesToNode || (BlockAppliesToNode = {}));
  var NodeExist;
  (function(NodeExist2) {
    NodeExist2[NodeExist2["Probably"] = 1] = "Probably";
    NodeExist2[NodeExist2["Definitely"] = 2] = "Definitely";
  })(NodeExist || (NodeExist = {}));
  const whitelist_attribute_selector = /* @__PURE__ */ new Map([
    [
      "details",
      /* @__PURE__ */ new Set([
        "open"
      ])
    ],
    [
      "dialog",
      /* @__PURE__ */ new Set([
        "open"
      ])
    ]
  ]);
  const regex_is_single_css_selector = /[^\\],(?!([^([]+[^\\]|[^([\\])[)\]])/;
  class Selector {
    constructor(node2, stylesheet) {
      this.node = node2;
      this.stylesheet = stylesheet;
      this.blocks = group_selectors(node2);
      let i2 = this.blocks.length;
      while (i2 > 0) {
        if (!this.blocks[i2 - 1].global)
          break;
        i2 -= 1;
      }
      this.local_blocks = this.blocks.slice(0, i2);
      const host_only = this.blocks.length === 1 && this.blocks[0].host;
      const root_only = this.blocks.length === 1 && this.blocks[0].root;
      this.used = this.local_blocks.length === 0 || host_only || root_only;
    }
    apply(node2) {
      const to_encapsulate = [];
      apply_selector(this.local_blocks.slice(), node2, to_encapsulate);
      if (to_encapsulate.length > 0) {
        to_encapsulate.forEach(({ node: node3, block }) => {
          this.stylesheet.nodes_with_css_class.add(node3);
          block.should_encapsulate = true;
        });
        this.used = true;
      }
    }
    minify(code) {
      let c2 = null;
      this.blocks.forEach((block, i2) => {
        if (i2 > 0) {
          if (block.start - c2 > 1)
            code.overwrite(c2, block.start, block.combinator.name || " ");
        }
        c2 = block.end;
      });
    }
    transform(code, attr, max_amount_class_specificity_increased) {
      const amount_class_specificity_to_increase = max_amount_class_specificity_increased - this.blocks.filter((block) => block.should_encapsulate).length;
      function remove_global_pseudo_class(selector2) {
        const first = selector2.children[0];
        const last = selector2.children[selector2.children.length - 1];
        code.remove(selector2.start, first.start).remove(last.end, selector2.end);
      }
      function encapsulate_block(block, attr2) {
        for (const selector2 of block.selectors)
          if (selector2.type === "PseudoClassSelector" && selector2.name === "global")
            remove_global_pseudo_class(selector2);
        let i2 = block.selectors.length;
        while (i2--) {
          const selector2 = block.selectors[i2];
          if (selector2.type === "PseudoElementSelector" || selector2.type === "PseudoClassSelector") {
            if (selector2.name !== "root" && selector2.name !== "host") {
              if (i2 === 0)
                code.prependRight(selector2.start, attr2);
            }
            continue;
          }
          if (selector2.type === "TypeSelector" && selector2.name === "*")
            code.overwrite(selector2.start, selector2.end, attr2);
          else
            code.appendLeft(selector2.end, attr2);
          break;
        }
      }
      this.blocks.forEach((block, index) => {
        if (block.global)
          remove_global_pseudo_class(block.selectors[0]);
        if (block.should_encapsulate)
          encapsulate_block(block, index === this.blocks.length - 1 ? attr.repeat(amount_class_specificity_to_increase + 1) : attr);
      });
    }
    validate(component) {
      let start = 0;
      let end = this.blocks.length;
      for (; start < end; start += 1) {
        if (!this.blocks[start].global)
          break;
      }
      for (; end > start; end -= 1) {
        if (!this.blocks[end - 1].global)
          break;
      }
      for (let i2 = start; i2 < end; i2 += 1) {
        if (this.blocks[i2].global)
          return component.error(this.blocks[i2].selectors[0], compiler_errors.css_invalid_global);
      }
      this.validate_global_with_multiple_selectors(component);
      this.validate_invalid_combinator_without_selector(component);
    }
    validate_global_with_multiple_selectors(component) {
      if (this.blocks.length === 1 && this.blocks[0].selectors.length === 1)
        return;
      for (const block of this.blocks)
        for (const selector2 of block.selectors) {
          if (selector2.type === "PseudoClassSelector" && selector2.name === "global") {
            if (regex_is_single_css_selector.test(selector2.children[0].value))
              component.error(selector2, compiler_errors.css_invalid_global_selector);
          }
        }
    }
    validate_invalid_combinator_without_selector(component) {
      for (let i2 = 0; i2 < this.blocks.length; i2++) {
        const block = this.blocks[i2];
        if (block.combinator && block.selectors.length === 0)
          component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
        if (!block.combinator && block.selectors.length === 0)
          component.error(this.node, compiler_errors.css_invalid_selector(component.source.slice(this.node.start, this.node.end)));
      }
    }
    get_amount_class_specificity_increased() {
      let count = 0;
      for (const block of this.blocks)
        if (block.should_encapsulate)
          count++;
      return count;
    }
  }
  function apply_selector(blocks, node2, to_encapsulate) {
    const block = blocks.pop();
    if (!block)
      return false;
    if (!node2)
      return block.global && blocks.every((block2) => block2.global) || block.host && blocks.length === 0;
    switch (block_might_apply_to_node(block, node2)) {
      case BlockAppliesToNode.NotPossible:
        return false;
      case BlockAppliesToNode.UnknownSelectorType:
        to_encapsulate.push({
          node: node2,
          block
        });
        return true;
    }
    if (block.combinator) {
      if (block.combinator.type === "Combinator" && block.combinator.name === " ") {
        for (const ancestor_block of blocks) {
          if (ancestor_block.global)
            continue;
          if (ancestor_block.host) {
            to_encapsulate.push({
              node: node2,
              block
            });
            return true;
          }
          let parent = node2;
          while (parent = get_element_parent(parent))
            if (block_might_apply_to_node(ancestor_block, parent) !== BlockAppliesToNode.NotPossible)
              to_encapsulate.push({
                node: parent,
                block: ancestor_block
              });
          if (to_encapsulate.length) {
            to_encapsulate.push({
              node: node2,
              block
            });
            return true;
          }
        }
        if (blocks.every((block2) => block2.global)) {
          to_encapsulate.push({
            node: node2,
            block
          });
          return true;
        }
        return false;
      } else if (block.combinator.name === ">") {
        const has_global_parent = blocks.every((block2) => block2.global);
        if (has_global_parent || apply_selector(blocks, get_element_parent(node2), to_encapsulate)) {
          to_encapsulate.push({
            node: node2,
            block
          });
          return true;
        }
        return false;
      } else if (block.combinator.name === "+" || block.combinator.name === "~") {
        const siblings = get_possible_element_siblings(node2, block.combinator.name === "+");
        let has_match = false;
        const has_global = blocks.some((block2) => block2.global);
        if (has_global) {
          if (siblings.size === 0 && get_element_parent(node2) !== null)
            return false;
          to_encapsulate.push({
            node: node2,
            block
          });
          return true;
        }
        for (const possible_sibling of siblings.keys())
          if (apply_selector(blocks.slice(), possible_sibling, to_encapsulate)) {
            to_encapsulate.push({
              node: node2,
              block
            });
            has_match = true;
          }
        return has_match;
      }
      to_encapsulate.push({
        node: node2,
        block
      });
      return true;
    }
    to_encapsulate.push({
      node: node2,
      block
    });
    return true;
  }
  const regex_backslash_and_following_character = /\\(.)/g;
  function block_might_apply_to_node(block, node2) {
    let i2 = block.selectors.length;
    while (i2--) {
      const selector2 = block.selectors[i2];
      const name = typeof selector2.name === "string" && selector2.name.replace(regex_backslash_and_following_character, "$1");
      if (selector2.type === "PseudoClassSelector" && (name === "host" || name === "root"))
        return BlockAppliesToNode.NotPossible;
      if (block.selectors.length === 1 && selector2.type === "PseudoClassSelector" && name === "global")
        return BlockAppliesToNode.NotPossible;
      if (selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector")
        continue;
      if (selector2.type === "ClassSelector") {
        if (!attribute_matches(node2, "class", name, "~=", false) && !node2.classes.some((c2) => c2.name === name))
          return BlockAppliesToNode.NotPossible;
      } else if (selector2.type === "IdSelector") {
        if (!attribute_matches(node2, "id", name, "=", false))
          return BlockAppliesToNode.NotPossible;
      } else if (selector2.type === "AttributeSelector") {
        if (!(whitelist_attribute_selector.has(node2.name.toLowerCase()) && whitelist_attribute_selector.get(node2.name.toLowerCase()).has(selector2.name.name.toLowerCase())) && !attribute_matches(node2, selector2.name.name, selector2.value && unquote(selector2.value), selector2.matcher, selector2.flags))
          return BlockAppliesToNode.NotPossible;
      } else if (selector2.type === "TypeSelector") {
        if (node2.name.toLowerCase() !== name.toLowerCase() && name !== "*" && !node2.is_dynamic_element)
          return BlockAppliesToNode.NotPossible;
      } else
        return BlockAppliesToNode.UnknownSelectorType;
    }
    return BlockAppliesToNode.Possible;
  }
  function test_attribute(operator, expected_value, case_insensitive, value2) {
    if (case_insensitive) {
      expected_value = expected_value.toLowerCase();
      value2 = value2.toLowerCase();
    }
    switch (operator) {
      case "=":
        return value2 === expected_value;
      case "~=":
        return value2.split(/\s/).includes(expected_value);
      case "|=":
        return `${value2}-`.startsWith(`${expected_value}-`);
      case "^=":
        return value2.startsWith(expected_value);
      case "$=":
        return value2.endsWith(expected_value);
      case "*=":
        return value2.includes(expected_value);
      default:
        throw new Error("this shouldn't happen");
    }
  }
  function attribute_matches(node2, name, expected_value, operator, case_insensitive) {
    const spread = node2.attributes.find((attr2) => attr2.type === "Spread");
    if (spread)
      return true;
    if (node2.bindings.some((binding) => binding.name === name))
      return true;
    const attr = node2.attributes.find((attr2) => attr2.name === name);
    if (!attr)
      return false;
    if (attr.is_true)
      return operator === null;
    if (!expected_value)
      return true;
    if (attr.chunks.length === 1) {
      const value2 = attr.chunks[0];
      if (!value2)
        return false;
      if (value2.type === "Text")
        return test_attribute(operator, expected_value, case_insensitive, value2.data);
    }
    const possible_values = /* @__PURE__ */ new Set();
    let prev_values = [];
    for (const chunk of attr.chunks) {
      const current_possible_values = /* @__PURE__ */ new Set();
      if (chunk.type === "Text")
        current_possible_values.add(chunk.data);
      else
        gather_possible_values(chunk.node, current_possible_values);
      if (current_possible_values.has(UNKNOWN))
        return true;
      if (prev_values.length > 0) {
        const start_with_space = [];
        const remaining = [];
        current_possible_values.forEach((current_possible_value) => {
          if (regex_starts_with_whitespace.test(current_possible_value))
            start_with_space.push(current_possible_value);
          else
            remaining.push(current_possible_value);
        });
        if (remaining.length > 0) {
          if (start_with_space.length > 0)
            prev_values.forEach((prev_value) => possible_values.add(prev_value));
          const combined = [];
          prev_values.forEach((prev_value) => {
            remaining.forEach((value2) => {
              combined.push(prev_value + value2);
            });
          });
          prev_values = combined;
          start_with_space.forEach((value2) => {
            if (regex_ends_with_whitespace.test(value2))
              possible_values.add(value2);
            else
              prev_values.push(value2);
          });
          continue;
        } else {
          prev_values.forEach((prev_value) => possible_values.add(prev_value));
          prev_values = [];
        }
      }
      current_possible_values.forEach((current_possible_value) => {
        if (regex_ends_with_whitespace.test(current_possible_value))
          possible_values.add(current_possible_value);
        else
          prev_values.push(current_possible_value);
      });
      if (prev_values.length < current_possible_values.size)
        prev_values.push(" ");
      if (prev_values.length > 20)
        return true;
    }
    prev_values.forEach((prev_value) => possible_values.add(prev_value));
    if (possible_values.has(UNKNOWN))
      return true;
    for (const value2 of possible_values) {
      if (test_attribute(operator, expected_value, case_insensitive, value2))
        return true;
    }
    return false;
  }
  function unquote(value2) {
    if (value2.type === "Identifier")
      return value2.name;
    const str = value2.value;
    if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"')
      return str.slice(1, str.length - 1);
    return str;
  }
  function get_element_parent(node2) {
    let parent = node2;
    while ((parent = parent.parent) && parent.type !== "Element")
      ;
    return parent;
  }
  function get_possible_element_siblings(node2, adjacent_only) {
    const result = /* @__PURE__ */ new Map();
    let prev = node2;
    while (prev = prev.prev) {
      if (prev.type === "Element") {
        if (!prev.attributes.find((attr) => attr.type === "Attribute" && attr.name.toLowerCase() === "slot"))
          result.set(prev, NodeExist.Definitely);
        if (adjacent_only)
          break;
      } else if (prev.type === "EachBlock" || prev.type === "IfBlock" || prev.type === "AwaitBlock") {
        const possible_last_child = get_possible_last_child(prev, adjacent_only);
        add_to_map(possible_last_child, result);
        if (adjacent_only && has_definite_elements(possible_last_child))
          return result;
      }
    }
    if (!prev || !adjacent_only) {
      let parent = node2;
      let skip_each_for_last_child = node2.type === "ElseBlock";
      while ((parent = parent.parent) && (parent.type === "EachBlock" || parent.type === "IfBlock" || parent.type === "ElseBlock" || parent.type === "AwaitBlock")) {
        const possible_siblings = get_possible_element_siblings(parent, adjacent_only);
        add_to_map(possible_siblings, result);
        if (parent.type === "EachBlock") {
          if (skip_each_for_last_child)
            skip_each_for_last_child = false;
          else
            add_to_map(get_possible_last_child(parent, adjacent_only), result);
        } else if (parent.type === "ElseBlock") {
          skip_each_for_last_child = true;
          parent = parent.parent;
        }
        if (adjacent_only && has_definite_elements(possible_siblings))
          break;
      }
    }
    return result;
  }
  function get_possible_last_child(block, adjacent_only) {
    const result = /* @__PURE__ */ new Map();
    if (block.type === "EachBlock") {
      const each_result = loop_child(block.children, adjacent_only);
      const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
      const not_exhaustive = !has_definite_elements(else_result);
      if (not_exhaustive) {
        mark_as_probably(each_result);
        mark_as_probably(else_result);
      }
      add_to_map(each_result, result);
      add_to_map(else_result, result);
    } else if (block.type === "IfBlock") {
      const if_result = loop_child(block.children, adjacent_only);
      const else_result = block.else ? loop_child(block.else.children, adjacent_only) : /* @__PURE__ */ new Map();
      const not_exhaustive = !has_definite_elements(if_result) || !has_definite_elements(else_result);
      if (not_exhaustive) {
        mark_as_probably(if_result);
        mark_as_probably(else_result);
      }
      add_to_map(if_result, result);
      add_to_map(else_result, result);
    } else if (block.type === "AwaitBlock") {
      const pending_result = block.pending ? loop_child(block.pending.children, adjacent_only) : /* @__PURE__ */ new Map();
      const then_result = block.then ? loop_child(block.then.children, adjacent_only) : /* @__PURE__ */ new Map();
      const catch_result = block.catch ? loop_child(block.catch.children, adjacent_only) : /* @__PURE__ */ new Map();
      const not_exhaustive = !has_definite_elements(pending_result) || !has_definite_elements(then_result) || !has_definite_elements(catch_result);
      if (not_exhaustive) {
        mark_as_probably(pending_result);
        mark_as_probably(then_result);
        mark_as_probably(catch_result);
      }
      add_to_map(pending_result, result);
      add_to_map(then_result, result);
      add_to_map(catch_result, result);
    }
    return result;
  }
  function has_definite_elements(result) {
    if (result.size === 0)
      return false;
    for (const exist of result.values()) {
      if (exist === NodeExist.Definitely)
        return true;
    }
    return false;
  }
  function add_to_map(from, to) {
    from.forEach((exist, element) => {
      to.set(element, higher_existence(exist, to.get(element)));
    });
  }
  function higher_existence(exist1, exist2) {
    if (exist1 === void 0 || exist2 === void 0)
      return exist1 || exist2;
    return exist1 > exist2 ? exist1 : exist2;
  }
  function mark_as_probably(result) {
    for (const key of result.keys())
      result.set(key, NodeExist.Probably);
  }
  function loop_child(children, adjacent_only) {
    const result = /* @__PURE__ */ new Map();
    for (let i2 = children.length - 1; i2 >= 0; i2--) {
      const child = children[i2];
      if (child.type === "Element") {
        result.set(child, NodeExist.Definitely);
        if (adjacent_only)
          break;
      } else if (child.type === "EachBlock" || child.type === "IfBlock" || child.type === "AwaitBlock") {
        const child_result = get_possible_last_child(child, adjacent_only);
        add_to_map(child_result, result);
        if (adjacent_only && has_definite_elements(child_result))
          break;
      }
    }
    return result;
  }
  class Block$1 {
    constructor(combinator) {
      this.combinator = combinator;
      this.host = false;
      this.root = false;
      this.selectors = [];
      this.start = null;
      this.end = null;
      this.should_encapsulate = false;
    }
    add(selector2) {
      if (this.selectors.length === 0) {
        this.start = selector2.start;
        this.host = selector2.type === "PseudoClassSelector" && selector2.name === "host";
      }
      this.root = this.root || selector2.type === "PseudoClassSelector" && selector2.name === "root";
      this.selectors.push(selector2);
      this.end = selector2.end;
    }
    get global() {
      return this.selectors.length >= 1 && this.selectors[0].type === "PseudoClassSelector" && this.selectors[0].name === "global" && this.selectors.every((selector2) => selector2.type === "PseudoClassSelector" || selector2.type === "PseudoElementSelector");
    }
  }
  function group_selectors(selector2) {
    let block = new Block$1(null);
    const blocks = [
      block
    ];
    selector2.children.forEach((child) => {
      if (child.type === "WhiteSpace" || child.type === "Combinator") {
        block = new Block$1(child);
        blocks.push(block);
      } else
        block.add(child);
    });
    return blocks;
  }
  const regex_css_browser_prefix = /^-((webkit)|(moz)|(o)|(ms))-/;
  function remove_css_prefix(name) {
    return name.replace(regex_css_browser_prefix, "");
  }
  const is_keyframes_node = (node2) => remove_css_prefix(node2.name) === "keyframes";
  const at_rule_has_declaration = ({ block }) => block && block.children && block.children.find((node2) => node2.type === "Declaration");
  function minify_declarations(code, start, declarations) {
    let c2 = start;
    declarations.forEach((declaration, i2) => {
      const separator = i2 > 0 ? ";" : "";
      if (declaration.node.start - c2 > separator.length)
        code.overwrite(c2, declaration.node.start, separator);
      declaration.minify(code);
      c2 = declaration.node.end;
    });
    return c2;
  }
  class Rule {
    constructor(node2, stylesheet, parent) {
      this.node = node2;
      this.parent = parent;
      this.selectors = node2.prelude.children.map((node3) => new Selector(node3, stylesheet));
      this.declarations = node2.block.children.map((node3) => new Declaration(node3));
    }
    apply(node2) {
      this.selectors.forEach((selector2) => selector2.apply(node2));
    }
    is_used(dev) {
      if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
        return true;
      if (this.declarations.length === 0)
        return dev;
      return this.selectors.some((s) => s.used);
    }
    minify(code, _dev) {
      let c2 = this.node.start;
      let started = false;
      this.selectors.forEach((selector2) => {
        if (selector2.used) {
          const separator = started ? "," : "";
          if (selector2.node.start - c2 > separator.length)
            code.overwrite(c2, selector2.node.start, separator);
          selector2.minify(code);
          c2 = selector2.node.end;
          started = true;
        }
      });
      code.remove(c2, this.node.block.start);
      c2 = this.node.block.start + 1;
      c2 = minify_declarations(code, c2, this.declarations);
      code.remove(c2, this.node.block.end - 1);
    }
    transform(code, id2, keyframes, max_amount_class_specificity_increased) {
      if (this.parent && this.parent.node.type === "Atrule" && is_keyframes_node(this.parent.node))
        return true;
      const attr = `.${id2}`;
      this.selectors.forEach((selector2) => selector2.transform(code, attr, max_amount_class_specificity_increased));
      this.declarations.forEach((declaration) => declaration.transform(code, keyframes));
    }
    validate(component) {
      this.selectors.forEach((selector2) => {
        selector2.validate(component);
      });
    }
    warn_on_unused_selector(handler) {
      this.selectors.forEach((selector2) => {
        if (!selector2.used)
          handler(selector2);
      });
    }
    get_max_amount_class_specificity_increased() {
      return Math.max(...this.selectors.map((selector2) => selector2.get_amount_class_specificity_increased()));
    }
  }
  class Declaration {
    constructor(node2) {
      this.node = node2;
    }
    transform(code, keyframes) {
      const property = this.node.property && remove_css_prefix(this.node.property.toLowerCase());
      if (property === "animation" || property === "animation-name")
        this.node.value.children.forEach((block) => {
          if (block.type === "Identifier") {
            const name = block.name;
            if (keyframes.has(name))
              code.overwrite(block.start, block.end, keyframes.get(name));
          }
        });
    }
    minify(code) {
      if (!this.node.property)
        return;
      const c2 = this.node.start + this.node.property.length;
      const first = this.node.value.children ? this.node.value.children[0] : this.node.value;
      if (first.type === "Raw" && regex_only_whitespaces.test(first.value))
        return;
      let start = first.start;
      while (regex_whitespace.test(code.original[start]))
        start += 1;
      if (start - c2 > 1)
        code.overwrite(c2, start, ":");
    }
  }
  class Atrule {
    constructor(node2) {
      this.node = node2;
      this.children = [];
      this.declarations = [];
    }
    apply(node2) {
      if (this.node.name === "media" || this.node.name === "supports" || this.node.name === "layer")
        this.children.forEach((child) => {
          child.apply(node2);
        });
      else if (is_keyframes_node(this.node))
        this.children.forEach((rule) => {
          rule.selectors.forEach((selector2) => {
            selector2.used = true;
          });
        });
    }
    is_used(_dev) {
      return true;
    }
    minify(code, dev) {
      if (this.node.name === "media") {
        const expression_char = code.original[this.node.prelude.start];
        let c2 = this.node.start + (expression_char === "(" ? 6 : 7);
        if (this.node.prelude.start > c2)
          code.remove(c2, this.node.prelude.start);
        this.node.prelude.children.forEach((query) => {
          c2 = query.end;
        });
        code.remove(c2, this.node.block.start);
      } else if (this.node.name === "supports") {
        let c2 = this.node.start + 9;
        if (this.node.prelude.start - c2 > 1)
          code.overwrite(c2, this.node.prelude.start, " ");
        this.node.prelude.children.forEach((query) => {
          c2 = query.end;
        });
        code.remove(c2, this.node.block.start);
      } else {
        let c2 = this.node.start + this.node.name.length + 1;
        if (this.node.prelude) {
          if (this.node.prelude.start - c2 > 1)
            code.overwrite(c2, this.node.prelude.start, " ");
          c2 = this.node.prelude.end;
        }
        if (this.node.block && this.node.block.start - c2 > 0)
          code.remove(c2, this.node.block.start);
      }
      if (this.node.block) {
        let c2 = this.node.block.start + 1;
        if (this.declarations.length) {
          c2 = minify_declarations(code, c2, this.declarations);
          if (this.children.length)
            c2++;
        }
        this.children.forEach((child) => {
          if (child.is_used(dev)) {
            code.remove(c2, child.node.start);
            child.minify(code, dev);
            c2 = child.node.end;
          }
        });
        code.remove(c2, this.node.block.end - 1);
      }
    }
    transform(code, id2, keyframes, max_amount_class_specificity_increased) {
      if (is_keyframes_node(this.node))
        this.node.prelude.children.forEach(({ type, name, start, end }) => {
          if (type === "Identifier") {
            if (name.startsWith("-global-")) {
              code.remove(start, start + 8);
              this.children.forEach((rule) => {
                rule.selectors.forEach((selector2) => {
                  selector2.used = true;
                });
              });
            } else
              code.overwrite(start, end, keyframes.get(name));
          }
        });
      this.children.forEach((child) => {
        child.transform(code, id2, keyframes, max_amount_class_specificity_increased);
      });
    }
    validate(component) {
      this.children.forEach((child) => {
        child.validate(component);
      });
    }
    warn_on_unused_selector(handler) {
      if (this.node.name !== "media")
        return;
      this.children.forEach((child) => {
        child.warn_on_unused_selector(handler);
      });
    }
    get_max_amount_class_specificity_increased() {
      return Math.max(...this.children.map((rule) => rule.get_max_amount_class_specificity_increased()));
    }
  }
  const get_default_css_hash = ({ css, hash: hash2 }) => {
    return `svelte-${hash2(css)}`;
  };
  class Stylesheet {
    constructor({ source, ast, component_name, filename, dev, get_css_hash = get_default_css_hash }) {
      this.children = [];
      this.keyframes = /* @__PURE__ */ new Map();
      this.nodes_with_css_class = /* @__PURE__ */ new Set();
      this.source = source;
      this.ast = ast;
      this.filename = filename;
      this.dev = dev;
      if (ast.css && ast.css.children.length) {
        this.id = get_css_hash({
          filename,
          name: component_name,
          css: ast.css.content.styles,
          hash
        });
        this.has_styles = true;
        const stack = [];
        let depth = 0;
        let current_atrule = null;
        walk(ast.css, {
          enter: (node2) => {
            if (node2.type === "Atrule") {
              const atrule2 = new Atrule(node2);
              stack.push(atrule2);
              if (current_atrule)
                current_atrule.children.push(atrule2);
              else if (depth <= 1)
                this.children.push(atrule2);
              if (is_keyframes_node(node2))
                node2.prelude.children.forEach((expression) => {
                  if (expression.type === "Identifier" && !expression.name.startsWith("-global-"))
                    this.keyframes.set(expression.name, `${this.id}-${expression.name}`);
                });
              else if (at_rule_has_declaration(node2)) {
                const at_rule_declarations = node2.block.children.filter((node3) => node3.type === "Declaration").map((node3) => new Declaration(node3));
                push_array$1(atrule2.declarations, at_rule_declarations);
              }
              current_atrule = atrule2;
            }
            if (node2.type === "Rule") {
              const rule = new Rule(node2, this, current_atrule);
              if (current_atrule)
                current_atrule.children.push(rule);
              else if (depth <= 1)
                this.children.push(rule);
            }
            depth += 1;
          },
          leave: (node2) => {
            if (node2.type === "Atrule") {
              stack.pop();
              current_atrule = stack[stack.length - 1];
            }
            depth -= 1;
          }
        });
      } else
        this.has_styles = false;
    }
    apply(node2) {
      if (!this.has_styles)
        return;
      for (let i2 = 0; i2 < this.children.length; i2 += 1) {
        const child = this.children[i2];
        child.apply(node2);
      }
    }
    reify() {
      this.nodes_with_css_class.forEach((node2) => {
        node2.add_css_class();
      });
    }
    render(file, should_transform_selectors) {
      if (!this.has_styles)
        return {
          code: null,
          map: null
        };
      const code = new MagicString(this.source);
      walk(this.ast.css, {
        enter: (node2) => {
          code.addSourcemapLocation(node2.start);
          code.addSourcemapLocation(node2.end);
        }
      });
      if (should_transform_selectors) {
        const max = Math.max(...this.children.map((rule) => rule.get_max_amount_class_specificity_increased()));
        this.children.forEach((child) => {
          child.transform(code, this.id, this.keyframes, max);
        });
      }
      let c2 = 0;
      this.children.forEach((child) => {
        if (child.is_used(this.dev)) {
          code.remove(c2, child.node.start);
          child.minify(code, this.dev);
          c2 = child.node.end;
        }
      });
      code.remove(c2, this.source.length);
      return {
        code: code.toString(),
        map: code.generateMap({
          includeContent: true,
          source: this.filename,
          file
        })
      };
    }
    validate(component) {
      this.children.forEach((child) => {
        child.validate(component);
      });
    }
    warn_on_unused_selectors(component) {
      const ignores = !this.ast.css ? [] : extract_ignores_above_position(this.ast.css.start, this.ast.html.children);
      component.push_ignores(ignores);
      this.children.forEach((child) => {
        child.warn_on_unused_selector((selector2) => {
          component.warn(selector2.node, compiler_warnings.css_unused_selector(this.source.slice(selector2.node.start, selector2.node.end)));
        });
      });
      component.pop_ignores();
    }
  }
  const test = typeof process !== "undefined" && process.env.TEST;
  class TemplateScope {
    constructor(parent) {
      this.owners = /* @__PURE__ */ new Map();
      this.parent = parent;
      this.names = new Set(parent ? parent.names : []);
      this.dependencies_for_name = new Map(parent ? parent.dependencies_for_name : []);
    }
    add(name, dependencies, owner) {
      this.names.add(name);
      this.dependencies_for_name.set(name, dependencies);
      this.owners.set(name, owner);
      return this;
    }
    child() {
      const child = new TemplateScope(this);
      return child;
    }
    is_top_level(name) {
      return !this.parent || !this.names.has(name) && this.parent.is_top_level(name);
    }
    get_owner(name) {
      return this.owners.get(name) || this.parent && this.parent.get_owner(name);
    }
    is_let(name) {
      const owner = this.get_owner(name);
      return owner && (owner.type === "Element" || owner.type === "InlineComponent" || owner.type === "SlotTemplate");
    }
    is_await(name) {
      const owner = this.get_owner(name);
      return owner && (owner.type === "ThenBlock" || owner.type === "CatchBlock");
    }
    is_const(name) {
      const owner = this.get_owner(name);
      return owner && owner.type === "ConstTag";
    }
  }
  class Fragment extends Node$1 {
    constructor(component, info) {
      const scope2 = new TemplateScope();
      super(component, null, scope2, info);
      this.scope = scope2;
      this.children = map_children(component, this, scope2, info.children);
    }
  }
  var internal_exports = /* @__PURE__ */ new Set([
    "HtmlTag",
    "HtmlTagHydration",
    "SvelteComponent",
    "SvelteComponentDev",
    "SvelteComponentTyped",
    "SvelteElement",
    "action_destroyer",
    "add_attribute",
    "add_classes",
    "add_flush_callback",
    "add_location",
    "add_render_callback",
    "add_resize_listener",
    "add_styles",
    "add_transform",
    "afterUpdate",
    "append",
    "append_dev",
    "append_empty_stylesheet",
    "append_hydration",
    "append_hydration_dev",
    "append_styles",
    "assign",
    "attr",
    "attr_dev",
    "attribute_to_object",
    "beforeUpdate",
    "bind",
    "binding_callbacks",
    "blank_object",
    "bubble",
    "check_outros",
    "children",
    "claim_component",
    "claim_element",
    "claim_html_tag",
    "claim_space",
    "claim_svg_element",
    "claim_text",
    "clear_loops",
    "component_subscribe",
    "compute_rest_props",
    "compute_slots",
    "construct_svelte_component",
    "construct_svelte_component_dev",
    "createEventDispatcher",
    "create_animation",
    "create_bidirectional_transition",
    "create_component",
    "create_in_transition",
    "create_out_transition",
    "create_slot",
    "create_ssr_component",
    "current_component",
    "custom_event",
    "dataset_dev",
    "debug",
    "destroy_block",
    "destroy_component",
    "destroy_each",
    "detach",
    "detach_after_dev",
    "detach_before_dev",
    "detach_between_dev",
    "detach_dev",
    "dirty_components",
    "dispatch_dev",
    "each",
    "element",
    "element_is",
    "empty",
    "end_hydrating",
    "escape",
    "escape_attribute_value",
    "escape_object",
    "exclude_internal_props",
    "fix_and_destroy_block",
    "fix_and_outro_and_destroy_block",
    "fix_position",
    "flush",
    "getAllContexts",
    "getContext",
    "get_all_dirty_from_scope",
    "get_binding_group_value",
    "get_current_component",
    "get_custom_elements_slots",
    "get_root_for_style",
    "get_slot_changes",
    "get_spread_object",
    "get_spread_update",
    "get_store_value",
    "globals",
    "group_outros",
    "handle_promise",
    "hasContext",
    "has_prop",
    "head_selector",
    "identity",
    "init",
    "insert",
    "insert_dev",
    "insert_hydration",
    "insert_hydration_dev",
    "intros",
    "invalid_attribute_name_character",
    "is_client",
    "is_crossorigin",
    "is_empty",
    "is_function",
    "is_promise",
    "is_void",
    "listen",
    "listen_dev",
    "loop",
    "loop_guard",
    "merge_ssr_styles",
    "missing_component",
    "mount_component",
    "noop",
    "not_equal",
    "now",
    "null_to_empty",
    "object_without_properties",
    "onDestroy",
    "onMount",
    "once",
    "outro_and_destroy_block",
    "prevent_default",
    "prop_dev",
    "query_selector_all",
    "raf",
    "run",
    "run_all",
    "safe_not_equal",
    "schedule_update",
    "select_multiple_value",
    "select_option",
    "select_options",
    "select_value",
    "self",
    "setContext",
    "set_attributes",
    "set_current_component",
    "set_custom_element_data",
    "set_custom_element_data_map",
    "set_data",
    "set_data_dev",
    "set_input_type",
    "set_input_value",
    "set_now",
    "set_raf",
    "set_store_value",
    "set_style",
    "set_svg_attributes",
    "space",
    "spread",
    "src_url_equal",
    "start_hydrating",
    "stop_propagation",
    "subscribe",
    "svg_element",
    "text",
    "tick",
    "time_ranges_to_array",
    "to_number",
    "toggle_class",
    "transition_in",
    "transition_out",
    "trusted",
    "update_await_block_branch",
    "update_keyed_each",
    "update_slot",
    "update_slot_base",
    "validate_component",
    "validate_dynamic_element",
    "validate_each_argument",
    "validate_each_keys",
    "validate_slots",
    "validate_store",
    "validate_void_dynamic_element",
    "xlink_attr"
  ]);
  function is_used_as_reference(node2, parent) {
    if (!is_reference(node2, parent))
      return false;
    if (!parent)
      return true;
    switch (parent.type) {
      case "VariableDeclarator":
        return node2 !== parent.id;
      case "FunctionDeclaration":
      case "ImportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ExportSpecifier":
        return false;
      default:
        return true;
    }
  }
  const regex_leading_directory_separator = /^[/\\]/;
  const regex_starts_with_term_export = /^Export/;
  const regex_contains_term_function = /Function/;
  class Component {
    constructor(ast, source, name, compile_options, stats, warnings) {
      this.ignore_stack = [];
      this.vars = [];
      this.var_lookup = /* @__PURE__ */ new Map();
      this.imports = [];
      this.exports_from = [];
      this.instance_exports_from = [];
      this.hoistable_nodes = /* @__PURE__ */ new Set();
      this.node_for_declaration = /* @__PURE__ */ new Map();
      this.partly_hoisted = [];
      this.fully_hoisted = [];
      this.reactive_declarations = [];
      this.reactive_declaration_nodes = /* @__PURE__ */ new Set();
      this.has_reactive_assignments = false;
      this.injected_reactive_declaration_vars = /* @__PURE__ */ new Set();
      this.helpers = /* @__PURE__ */ new Map();
      this.globals = /* @__PURE__ */ new Map();
      this.indirect_dependencies = /* @__PURE__ */ new Map();
      this.elements = [];
      this.aliases = /* @__PURE__ */ new Map();
      this.used_names = /* @__PURE__ */ new Set();
      this.globally_used_names = /* @__PURE__ */ new Set();
      this.slots = /* @__PURE__ */ new Map();
      this.slot_outlets = /* @__PURE__ */ new Set();
      this.name = {
        type: "Identifier",
        name
      };
      this.stats = stats;
      this.warnings = warnings;
      this.ast = ast;
      this.source = source;
      this.compile_options = compile_options;
      this.original_ast = clone({
        html: ast.html,
        css: ast.css,
        instance: ast.instance,
        module: ast.module
      });
      this.file = compile_options.filename && (typeof process !== "undefined" ? compile_options.filename.replace(process.cwd(), "").replace(regex_leading_directory_separator, "") : compile_options.filename);
      this.locate = getLocator(this.source, {
        offsetLine: 1
      });
      this.stylesheet = new Stylesheet({
        source,
        ast,
        filename: compile_options.filename,
        component_name: name,
        dev: compile_options.dev,
        get_css_hash: compile_options.cssHash
      });
      this.stylesheet.validate(this);
      this.component_options = process_component_options(this, this.ast.html.children);
      this.namespace = namespaces[this.component_options.namespace] || this.component_options.namespace;
      if (compile_options.customElement) {
        if (this.component_options.tag === void 0 && compile_options.tag === void 0) {
          const svelteOptions = ast.html.children.find((child) => child.name === "svelte:options") || {
            start: 0,
            end: 0
          };
          this.warn(svelteOptions, compiler_warnings.custom_element_no_tag);
        }
        this.tag = this.component_options.tag || compile_options.tag;
      } else
        this.tag = this.name.name;
      this.walk_module_js();
      this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
      this.walk_instance_js_pre_template();
      this.pop_ignores();
      this.fragment = new Fragment(this, ast.html);
      this.name = this.get_unique_name(name);
      this.push_ignores(this.ast.instance ? extract_ignores_above_position(this.ast.instance.start, this.ast.html.children) : []);
      this.walk_instance_js_post_template();
      this.pop_ignores();
      this.elements.forEach((element) => this.stylesheet.apply(element));
      if (!compile_options.customElement)
        this.stylesheet.reify();
      this.stylesheet.warn_on_unused_selectors(this);
    }
    add_var(node2, variable, add_to_lookup = true) {
      this.vars.push(variable);
      if (add_to_lookup) {
        if (this.var_lookup.has(variable.name)) {
          const exists_var = this.var_lookup.get(variable.name);
          if (exists_var.module && exists_var.imported)
            this.error(node2, compiler_errors.illegal_variable_declaration);
        }
        this.var_lookup.set(variable.name, variable);
      }
    }
    add_reference(node2, name) {
      const variable = this.var_lookup.get(name);
      if (variable)
        variable.referenced = true;
      else if (is_reserved_keyword(name))
        this.add_var(node2, {
          name,
          injected: true,
          referenced: true
        });
      else if (name[0] === "$") {
        this.add_var(node2, {
          name,
          injected: true,
          referenced: true,
          mutated: true,
          writable: true
        });
        const subscribable_name = name.slice(1);
        const variable2 = this.var_lookup.get(subscribable_name);
        if (variable2) {
          variable2.referenced = true;
          variable2.subscribable = true;
        }
      } else {
        if (this.compile_options.varsReport === "full")
          this.add_var(node2, {
            name,
            referenced: true
          }, false);
        this.used_names.add(name);
      }
    }
    alias(name) {
      if (!this.aliases.has(name))
        this.aliases.set(name, this.get_unique_name(name));
      return this.aliases.get(name);
    }
    apply_stylesheet(element) {
      this.elements.push(element);
    }
    global(name) {
      const alias = this.alias(name);
      this.globals.set(name, alias);
      return alias;
    }
    generate(result) {
      let js = null;
      let css = null;
      if (result) {
        const { compile_options, name } = this;
        const { format = "esm" } = compile_options;
        const banner = `${this.file ? `${this.file} ` : ""}generated by Svelte v${"3.55.0"}`;
        const program = {
          type: "Program",
          body: result.js
        };
        walk(program, {
          enter: (node2, parent, key) => {
            if (node2.type === "Identifier") {
              if (node2.name[0] === "@") {
                if (node2.name[1] === "_") {
                  const alias = this.global(node2.name.slice(2));
                  node2.name = alias.name;
                } else {
                  let name2 = node2.name.slice(1);
                  if (compile_options.hydratable) {
                    if (internal_exports.has(`${name2}_hydration`))
                      name2 += "_hydration";
                    else if (internal_exports.has(`${name2}Hydration`))
                      name2 += "Hydration";
                  }
                  if (compile_options.dev) {
                    if (internal_exports.has(`${name2}_dev`))
                      name2 += "_dev";
                    else if (internal_exports.has(`${name2}Dev`))
                      name2 += "Dev";
                  }
                  const alias = this.alias(name2);
                  this.helpers.set(name2, alias);
                  node2.name = alias.name;
                }
              } else if (node2.name[0] !== "#" && !is_valid(node2.name)) {
                const literal2 = {
                  type: "Literal",
                  value: node2.name
                };
                if (parent.type === "Property" && key === "key")
                  parent.key = literal2;
                else if (parent.type === "MemberExpression" && key === "property") {
                  parent.property = literal2;
                  parent.computed = true;
                }
              }
            }
          }
        });
        const referenced_globals = Array.from(this.globals, ([name2, alias]) => name2 !== alias.name && {
          name: name2,
          alias
        }).filter(Boolean);
        if (referenced_globals.length)
          this.helpers.set("globals", this.alias("globals"));
        const imported_helpers = Array.from(this.helpers, ([name2, alias]) => ({
          name: name2,
          alias
        }));
        create_module(program, format, name, banner, compile_options.sveltePath, imported_helpers, referenced_globals, this.imports, this.vars.filter((variable) => variable.module && variable.export_name).map((variable) => ({
          name: variable.name,
          as: variable.export_name
        })), this.exports_from);
        css = compile_options.customElement ? {
          code: null,
          map: null
        } : result.css;
        const js_sourcemap_enabled = check_enable_sourcemap(compile_options.enableSourcemap, "js");
        if (!js_sourcemap_enabled) {
          js = print(program);
          js.map = null;
        } else {
          const sourcemap_source_filename = get_sourcemap_source_filename(compile_options);
          js = print(program, {
            sourceMapSource: sourcemap_source_filename
          });
          js.map.sources = [
            sourcemap_source_filename
          ];
          js.map.sourcesContent = [
            this.source
          ];
          js.map = apply_preprocessor_sourcemap(sourcemap_source_filename, js.map, compile_options.sourcemap);
        }
      }
      return {
        js,
        css,
        ast: this.original_ast,
        warnings: this.warnings,
        vars: this.get_vars_report(),
        stats: this.stats.render()
      };
    }
    get_unique_name(name, scope2) {
      if (test)
        name = `${name}$`;
      let alias = name;
      for (let i2 = 1; reserved.has(alias) || this.var_lookup.has(alias) || this.used_names.has(alias) || this.globally_used_names.has(alias) || scope2 && scope2.has(alias); alias = `${name}_${i2++}`)
        ;
      this.used_names.add(alias);
      return {
        type: "Identifier",
        name: alias
      };
    }
    get_unique_name_maker() {
      const local_used_names = /* @__PURE__ */ new Set();
      function add(name) {
        local_used_names.add(name);
      }
      reserved.forEach(add);
      internal_exports.forEach(add);
      this.var_lookup.forEach((_value, key) => add(key));
      return (name) => {
        if (test)
          name = `${name}$`;
        let alias = name;
        for (let i2 = 1; this.used_names.has(alias) || local_used_names.has(alias); alias = `${name}_${i2++}`)
          ;
        local_used_names.add(alias);
        this.globally_used_names.add(alias);
        return {
          type: "Identifier",
          name: alias
        };
      };
    }
    get_vars_report() {
      const { compile_options, vars } = this;
      const vars_report = compile_options.varsReport === false ? [] : compile_options.varsReport === "full" ? vars : vars.filter((v) => !v.global && !v.internal);
      return vars_report.map((v) => ({
        name: v.name,
        export_name: v.export_name || null,
        injected: v.injected || false,
        module: v.module || false,
        mutated: v.mutated || false,
        reassigned: v.reassigned || false,
        referenced: v.referenced || false,
        writable: v.writable || false,
        referenced_from_script: v.referenced_from_script || false
      }));
    }
    error(pos, e) {
      if (this.compile_options.errorMode === "warn")
        this.warn(pos, e);
      else
        error(e.message, {
          name: "ValidationError",
          code: e.code,
          source: this.source,
          start: pos.start,
          end: pos.end,
          filename: this.compile_options.filename
        });
    }
    warn(pos, warning) {
      if (this.ignores && this.ignores.has(warning.code))
        return;
      const start = this.locate(pos.start);
      const end = this.locate(pos.end);
      const frame = get_code_frame(this.source, start.line - 1, start.column);
      this.warnings.push({
        code: warning.code,
        message: warning.message,
        frame,
        start,
        end,
        pos: pos.start,
        filename: this.compile_options.filename,
        toString: () => `${warning.message} (${start.line}:${start.column})
${frame}`
      });
    }
    extract_imports(node2) {
      this.imports.push(node2);
    }
    extract_exports(node2, module_script = false) {
      const ignores = extract_svelte_ignore_from_comments(node2);
      if (ignores.length)
        this.push_ignores(ignores);
      const result = this._extract_exports(node2, module_script);
      if (ignores.length)
        this.pop_ignores();
      return result;
    }
    _extract_exports(node2, module_script) {
      if (node2.type === "ExportDefaultDeclaration")
        return this.error(node2, compiler_errors.default_export);
      if (node2.type === "ExportNamedDeclaration") {
        if (node2.source) {
          if (module_script)
            this.exports_from.push(node2);
          else
            this.instance_exports_from.push(node2);
          return null;
        }
        if (node2.declaration) {
          if (node2.declaration.type === "VariableDeclaration")
            node2.declaration.declarations.forEach((declarator) => {
              extract_names(declarator.id).forEach((name) => {
                const variable = this.var_lookup.get(name);
                variable.export_name = name;
                if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable))
                  this.warn(declarator, compiler_warnings.unused_export_let(this.name.name, name));
              });
            });
          else {
            const { name } = node2.declaration.id;
            const variable = this.var_lookup.get(name);
            variable.export_name = name;
          }
          return node2.declaration;
        } else {
          node2.specifiers.forEach((specifier) => {
            const variable = this.var_lookup.get(specifier.local.name);
            if (variable) {
              variable.export_name = specifier.exported.name;
              if (!module_script && variable.writable && !(variable.referenced || variable.referenced_from_script || variable.subscribable))
                this.warn(specifier, compiler_warnings.unused_export_let(this.name.name, specifier.exported.name));
            }
          });
          return null;
        }
      }
    }
    extract_javascript(script) {
      if (!script)
        return null;
      return script.content.body.filter((node2) => {
        if (!node2)
          return false;
        if (this.hoistable_nodes.has(node2))
          return false;
        if (this.reactive_declaration_nodes.has(node2))
          return false;
        if (node2.type === "ImportDeclaration")
          return false;
        if (node2.type === "ExportDeclaration" && node2.specifiers.length > 0)
          return false;
        return true;
      });
    }
    walk_module_js() {
      const component = this;
      const script = this.ast.module;
      if (!script)
        return;
      walk(script.content, {
        enter(node2) {
          if (node2.type === "LabeledStatement" && node2.label.name === "$")
            component.warn(node2, compiler_warnings.module_script_reactive_declaration);
        }
      });
      const { scope: scope2, globals: globals2 } = create_scopes(script.content);
      this.module_scope = scope2;
      scope2.declarations.forEach((node2, name) => {
        if (name[0] === "$")
          return this.error(node2, compiler_errors.illegal_declaration);
        const writable = node2.type === "VariableDeclaration" && (node2.kind === "var" || node2.kind === "let");
        const imported = node2.type.startsWith("Import");
        this.add_var(node2, {
          name,
          module: true,
          hoistable: true,
          writable,
          imported
        });
      });
      globals2.forEach((node2, name) => {
        if (name[0] === "$")
          return this.error(node2, compiler_errors.illegal_subscription);
        else
          this.add_var(node2, {
            name,
            global: true,
            hoistable: true
          });
      });
      const { body } = script.content;
      let i2 = body.length;
      while (--i2 >= 0) {
        const node2 = body[i2];
        if (node2.type === "ImportDeclaration") {
          this.extract_imports(node2);
          body.splice(i2, 1);
        }
        if (regex_starts_with_term_export.test(node2.type)) {
          const replacement = this.extract_exports(node2, true);
          if (replacement)
            body[i2] = replacement;
          else
            body.splice(i2, 1);
        }
      }
    }
    walk_instance_js_pre_template() {
      const script = this.ast.instance;
      if (!script)
        return;
      script.content.body.forEach((node2) => {
        if (node2.type !== "LabeledStatement")
          return;
        if (node2.body.type !== "ExpressionStatement")
          return;
        const { expression } = node2.body;
        if (expression.type !== "AssignmentExpression")
          return;
        if (expression.left.type === "MemberExpression")
          return;
        extract_names(expression.left).forEach((name) => {
          if (!this.var_lookup.has(name) && name[0] !== "$")
            this.injected_reactive_declaration_vars.add(name);
        });
      });
      const { scope: instance_scope, map, globals: globals2 } = create_scopes(script.content);
      this.instance_scope = instance_scope;
      this.instance_scope_map = map;
      instance_scope.declarations.forEach((node2, name) => {
        if (name[0] === "$")
          return this.error(node2, compiler_errors.illegal_declaration);
        const writable = node2.type === "VariableDeclaration" && (node2.kind === "var" || node2.kind === "let");
        const imported = node2.type.startsWith("Import");
        this.add_var(node2, {
          name,
          initialised: instance_scope.initialised_declarations.has(name),
          writable,
          imported
        });
        this.node_for_declaration.set(name, node2);
      });
      const global_keys = Array.from(globals2.keys());
      const sorted_globals = [
        ...global_keys.filter((key) => key[0] !== "$"),
        ...global_keys.filter((key) => key[0] === "$")
      ];
      sorted_globals.forEach((name) => {
        if (this.var_lookup.has(name))
          return;
        const node2 = globals2.get(name);
        if (this.injected_reactive_declaration_vars.has(name))
          this.add_var(node2, {
            name,
            injected: true,
            writable: true,
            reassigned: true,
            initialised: true
          });
        else if (is_reserved_keyword(name))
          this.add_var(node2, {
            name,
            injected: true
          });
        else if (name[0] === "$") {
          if (name === "$" || name[1] === "$")
            return this.error(node2, compiler_errors.illegal_global(name));
          this.add_var(node2, {
            name,
            injected: true,
            mutated: true,
            writable: true
          });
          this.add_reference(node2, name.slice(1));
          const variable = this.var_lookup.get(name.slice(1));
          if (variable) {
            variable.subscribable = true;
            variable.referenced_from_script = true;
          }
        } else
          this.add_var(node2, {
            name,
            global: true,
            hoistable: true
          });
      });
      this.track_references_and_mutations();
    }
    walk_instance_js_post_template() {
      const script = this.ast.instance;
      if (!script)
        return;
      this.post_template_walk();
      this.hoist_instance_declarations();
      this.extract_reactive_declarations();
    }
    post_template_walk() {
      const script = this.ast.instance;
      if (!script)
        return;
      const component = this;
      const { content } = script;
      const { instance_scope, instance_scope_map: map } = this;
      let scope2 = instance_scope;
      const to_remove = [];
      const remove = (parent, prop, index) => {
        to_remove.unshift([
          parent,
          prop,
          index
        ]);
      };
      let scope_updated = false;
      const current_function_stack = [];
      let current_function = null;
      walk(content, {
        enter(node2, parent, prop, index) {
          if (node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression")
            current_function_stack.push(current_function = node2);
          if (map.has(node2))
            scope2 = map.get(node2);
          let deep = false;
          let names;
          if (node2.type === "AssignmentExpression") {
            deep = node2.left.type === "MemberExpression";
            names = deep ? [
              get_object(node2.left).name
            ] : extract_names(node2.left);
          } else if (node2.type === "UpdateExpression") {
            deep = node2.argument.type === "MemberExpression";
            const { name } = get_object(node2.argument);
            names = [
              name
            ];
          }
          if (names)
            names.forEach((name) => {
              let current_scope = scope2;
              let declaration;
              while (current_scope) {
                if (current_scope.declarations.has(name)) {
                  declaration = current_scope.declarations.get(name);
                  break;
                }
                current_scope = current_scope.parent;
              }
              if (declaration && declaration.kind === "const" && !deep)
                component.error(node2, {
                  code: "assignment-to-const",
                  message: "You are assigning to a const"
                });
            });
          if (node2.type === "ImportDeclaration") {
            component.extract_imports(node2);
            remove(parent, prop, index);
            return this.skip();
          }
          if (regex_starts_with_term_export.test(node2.type)) {
            const replacement = component.extract_exports(node2);
            if (replacement)
              this.replace(replacement);
            else
              remove(parent, prop, index);
            return this.skip();
          }
          component.warn_on_undefined_store_value_references(node2, parent, prop, scope2);
        },
        leave(node2) {
          if (node2.type === "FunctionDeclaration" || node2.type === "FunctionExpression") {
            current_function_stack.pop();
            current_function = current_function_stack[current_function_stack.length - 1];
          }
          if (component.compile_options.dev && component.compile_options.loopGuardTimeout > 0 && (!current_function || !current_function.generator && !current_function.async)) {
            const to_replace_for_loop_protect = component.loop_protect(node2, scope2, component.compile_options.loopGuardTimeout);
            if (to_replace_for_loop_protect) {
              this.replace(to_replace_for_loop_protect);
              scope_updated = true;
            }
          }
          if (map.has(node2))
            scope2 = scope2.parent;
        }
      });
      for (const [parent, prop, index] of to_remove)
        if (parent) {
          if (index !== null)
            parent[prop].splice(index, 1);
          else
            delete parent[prop];
        }
      if (scope_updated) {
        const { scope: scope3, map: map2 } = create_scopes(script.content);
        this.instance_scope = scope3;
        this.instance_scope_map = map2;
      }
    }
    track_references_and_mutations() {
      const script = this.ast.instance;
      if (!script)
        return;
      const component = this;
      const { content } = script;
      const { instance_scope, module_scope, instance_scope_map: map } = this;
      let scope2 = instance_scope;
      walk(content, {
        enter(node2, parent) {
          if (map.has(node2))
            scope2 = map.get(node2);
          if (node2.type === "AssignmentExpression" || node2.type === "UpdateExpression") {
            const assignee = node2.type === "AssignmentExpression" ? node2.left : node2.argument;
            const names = extract_names(assignee);
            const deep = assignee.type === "MemberExpression";
            names.forEach((name) => {
              const scope_owner = scope2.find_owner(name);
              if (scope_owner !== null ? scope_owner === instance_scope : module_scope && module_scope.has(name)) {
                const variable = component.var_lookup.get(name);
                variable[deep ? "mutated" : "reassigned"] = true;
              }
            });
          }
          if (is_used_as_reference(node2, parent)) {
            const object = get_object(node2);
            if (scope2.find_owner(object.name) === instance_scope) {
              const variable = component.var_lookup.get(object.name);
              variable.referenced_from_script = true;
            }
          }
        },
        leave(node2) {
          if (map.has(node2))
            scope2 = scope2.parent;
        }
      });
    }
    warn_on_undefined_store_value_references(node2, parent, prop, scope2) {
      if (node2.type === "LabeledStatement" && node2.label.name === "$" && parent.type !== "Program")
        this.warn(node2, compiler_warnings.non_top_level_reactive_declaration);
      if (is_reference(node2, parent)) {
        const object = get_object(node2);
        const { name } = object;
        if (name[0] === "$") {
          if (!scope2.has(name))
            this.warn_if_undefined(name, object, null);
          if (name[1] !== "$" && scope2.has(name.slice(1)) && scope2.find_owner(name.slice(1)) !== this.instance_scope) {
            if (!(regex_contains_term_function.test(parent.type) && prop === "params" || parent.type === "VariableDeclarator" && prop === "id"))
              return this.error(node2, compiler_errors.contextual_store);
          }
        }
      }
    }
    loop_protect(node2, scope2, timeout) {
      if (node2.type === "WhileStatement" || node2.type === "ForStatement" || node2.type === "DoWhileStatement") {
        const guard = this.get_unique_name("guard", scope2);
        this.used_names.add(guard.name);
        const before = b`const ${guard} = @loop_guard(${timeout})`;
        const inside = b`${guard}();`;
        if (node2.body.type !== "BlockStatement")
          node2.body = {
            type: "BlockStatement",
            body: [
              node2.body
            ]
          };
        node2.body.body.push(inside[0]);
        return {
          type: "BlockStatement",
          body: [
            before[0],
            node2
          ]
        };
      }
      return null;
    }
    rewrite_props(get_insert) {
      if (!this.ast.instance)
        return;
      const component = this;
      const { instance_scope, instance_scope_map: map } = this;
      let scope2 = instance_scope;
      walk(this.ast.instance.content, {
        enter(node2) {
          if (regex_contains_term_function.test(node2.type))
            return this.skip();
          if (map.has(node2))
            scope2 = map.get(node2);
          if (node2.type === "ExportNamedDeclaration" && node2.declaration)
            return this.replace(node2.declaration);
          if (node2.type === "VariableDeclaration") {
            if (node2.kind === "var" || scope2 === instance_scope) {
              let add_new_props = function(exported2, local, default_value) {
                props.push({
                  type: "Property",
                  method: false,
                  shorthand: false,
                  computed: false,
                  kind: "init",
                  key: exported2,
                  value: default_value ? {
                    type: "AssignmentPattern",
                    left: local,
                    right: default_value
                  } : local
                });
              };
              const inserts = [];
              const props = [];
              for (let index = 0; index < node2.declarations.length; index++) {
                const declarator = node2.declarations[index];
                if (declarator.id.type !== "Identifier") {
                  let get_new_name = function(local) {
                    const variable = component.var_lookup.get(local.name);
                    if (variable.subscribable)
                      inserts.push(get_insert(variable));
                    if (variable.export_name && variable.writable) {
                      const alias_name = component.get_unique_name(local.name);
                      add_new_props({
                        type: "Identifier",
                        name: variable.export_name
                      }, local, alias_name);
                      return alias_name;
                    }
                    return local;
                  }, rename_identifiers = function(param) {
                    switch (param.type) {
                      case "ObjectPattern": {
                        const handle_prop = (prop) => {
                          if (prop.type === "RestElement")
                            rename_identifiers(prop);
                          else if (prop.value.type === "Identifier")
                            prop.value = get_new_name(prop.value);
                          else
                            rename_identifiers(prop.value);
                        };
                        param.properties.forEach(handle_prop);
                        break;
                      }
                      case "ArrayPattern": {
                        const handle_element = (element, index2, array) => {
                          if (element) {
                            if (element.type === "Identifier")
                              array[index2] = get_new_name(element);
                            else
                              rename_identifiers(element);
                          }
                        };
                        param.elements.forEach(handle_element);
                        break;
                      }
                      case "RestElement":
                        param.argument = get_new_name(param.argument);
                        break;
                      case "AssignmentPattern":
                        if (param.left.type === "Identifier")
                          param.left = get_new_name(param.left);
                        else
                          rename_identifiers(param.left);
                        break;
                    }
                  };
                  rename_identifiers(declarator.id);
                } else {
                  const { name } = declarator.id;
                  const variable = component.var_lookup.get(name);
                  const is_props = variable.export_name && variable.writable;
                  if (is_props) {
                    add_new_props({
                      type: "Identifier",
                      name: variable.export_name
                    }, declarator.id, declarator.init);
                    node2.declarations.splice(index--, 1);
                  }
                  if (variable.subscribable && (is_props || declarator.init))
                    inserts.push(get_insert(variable));
                }
              }
              this.replace(b`
							${node2.declarations.length ? node2 : null}
							${props.length > 0 && b`let { ${props} } = $$props;`}
							${inserts}
						`);
              return this.skip();
            }
          }
        },
        leave(node2) {
          if (map.has(node2))
            scope2 = scope2.parent;
        }
      });
    }
    hoist_instance_declarations() {
      const { hoistable_nodes, var_lookup, injected_reactive_declaration_vars, imports } = this;
      const top_level_function_declarations = /* @__PURE__ */ new Map();
      const { body } = this.ast.instance.content;
      for (let i2 = 0; i2 < body.length; i2 += 1) {
        const node2 = body[i2];
        if (node2.type === "VariableDeclaration") {
          const all_hoistable = node2.declarations.every((d) => {
            if (!d.init)
              return false;
            if (d.init.type !== "Literal")
              return false;
            if (node2.kind !== "const" && this.compile_options.dev)
              return false;
            const { name } = d.id;
            const v = this.var_lookup.get(name);
            if (v.reassigned)
              return false;
            if (v.export_name)
              return false;
            if (this.var_lookup.get(name).reassigned)
              return false;
            if (this.vars.find((variable) => variable.name === name && variable.module))
              return false;
            return true;
          });
          if (all_hoistable) {
            node2.declarations.forEach((d) => {
              const variable = this.var_lookup.get(d.id.name);
              variable.hoistable = true;
            });
            hoistable_nodes.add(node2);
            body.splice(i2--, 1);
            this.fully_hoisted.push(node2);
          }
        }
        if (node2.type === "ExportNamedDeclaration" && node2.declaration && node2.declaration.type === "FunctionDeclaration")
          top_level_function_declarations.set(node2.declaration.id.name, node2);
        if (node2.type === "FunctionDeclaration")
          top_level_function_declarations.set(node2.id.name, node2);
      }
      const checked = /* @__PURE__ */ new Set();
      const walking = /* @__PURE__ */ new Set();
      const is_hoistable = (fn_declaration) => {
        if (fn_declaration.type === "ExportNamedDeclaration")
          fn_declaration = fn_declaration.declaration;
        const instance_scope = this.instance_scope;
        let scope2 = this.instance_scope;
        const map = this.instance_scope_map;
        let hoistable = true;
        walking.add(fn_declaration);
        walk(fn_declaration, {
          enter(node2, parent) {
            if (!hoistable)
              return this.skip();
            if (map.has(node2))
              scope2 = map.get(node2);
            if (is_reference(node2, parent)) {
              const { name } = flatten_reference(node2);
              const owner = scope2.find_owner(name);
              if (injected_reactive_declaration_vars.has(name))
                hoistable = false;
              else if (name[0] === "$" && !owner)
                hoistable = false;
              else if (owner === instance_scope) {
                const variable = var_lookup.get(name);
                if (variable.reassigned || variable.mutated)
                  hoistable = false;
                if (name === fn_declaration.id.name)
                  return;
                if (variable.hoistable)
                  return;
                if (top_level_function_declarations.has(name)) {
                  const other_declaration = top_level_function_declarations.get(name);
                  if (walking.has(other_declaration))
                    hoistable = false;
                  else if (other_declaration.type === "ExportNamedDeclaration" && walking.has(other_declaration.declaration))
                    hoistable = false;
                  else if (!is_hoistable(other_declaration))
                    hoistable = false;
                } else
                  hoistable = false;
              }
              this.skip();
            }
          },
          leave(node2) {
            if (map.has(node2))
              scope2 = scope2.parent;
          }
        });
        checked.add(fn_declaration);
        walking.delete(fn_declaration);
        return hoistable;
      };
      for (const [name, node2] of top_level_function_declarations)
        if (is_hoistable(node2)) {
          const variable = this.var_lookup.get(name);
          variable.hoistable = true;
          hoistable_nodes.add(node2);
          const i2 = body.indexOf(node2);
          body.splice(i2, 1);
          this.fully_hoisted.push(node2);
        }
      for (const { specifiers } of imports)
        for (const specifier of specifiers) {
          const variable = var_lookup.get(specifier.local.name);
          if (!variable.mutated || variable.subscribable)
            variable.hoistable = true;
        }
    }
    extract_reactive_declarations() {
      const component = this;
      const unsorted_reactive_declarations = [];
      this.ast.instance.content.body.forEach((node2) => {
        const ignores = extract_svelte_ignore_from_comments(node2);
        if (ignores.length)
          this.push_ignores(ignores);
        if (node2.type === "LabeledStatement" && node2.label.name === "$") {
          this.reactive_declaration_nodes.add(node2);
          const assignees = /* @__PURE__ */ new Set();
          const assignee_nodes = /* @__PURE__ */ new Set();
          const dependencies = /* @__PURE__ */ new Set();
          const module_dependencies = /* @__PURE__ */ new Set();
          let scope2 = this.instance_scope;
          const map = this.instance_scope_map;
          walk(node2.body, {
            enter(node3, parent) {
              if (map.has(node3))
                scope2 = map.get(node3);
              if (node3.type === "AssignmentExpression") {
                const left = get_object(node3.left);
                extract_identifiers(left).forEach((node4) => {
                  assignee_nodes.add(node4);
                  assignees.add(node4.name);
                });
                if (node3.operator !== "=")
                  dependencies.add(left.name);
              } else if (node3.type === "UpdateExpression") {
                const identifier = get_object(node3.argument);
                assignees.add(identifier.name);
              } else if (is_reference(node3, parent)) {
                const identifier = get_object(node3);
                if (!assignee_nodes.has(identifier)) {
                  const { name } = identifier;
                  const owner = scope2.find_owner(name);
                  const variable = component.var_lookup.get(name);
                  let should_add_as_dependency = true;
                  if (variable) {
                    variable.is_reactive_dependency = true;
                    if (variable.module && variable.writable) {
                      should_add_as_dependency = false;
                      module_dependencies.add(name);
                    }
                  }
                  const is_writable_or_mutated = variable && (variable.writable || variable.mutated);
                  if (should_add_as_dependency && (!owner || owner === component.instance_scope) && (name[0] === "$" || is_writable_or_mutated))
                    dependencies.add(name);
                }
                this.skip();
              }
            },
            leave(node3) {
              if (map.has(node3))
                scope2 = scope2.parent;
            }
          });
          if (module_dependencies.size > 0 && dependencies.size === 0)
            component.warn(node2.body, compiler_warnings.module_script_variable_reactive_declaration(Array.from(module_dependencies)));
          const { expression } = node2.body;
          const declaration = expression && expression.left;
          unsorted_reactive_declarations.push({
            assignees,
            dependencies,
            node: node2,
            declaration
          });
        }
        if (ignores.length)
          this.pop_ignores();
      });
      const lookup = /* @__PURE__ */ new Map();
      unsorted_reactive_declarations.forEach((declaration) => {
        declaration.assignees.forEach((name) => {
          if (!lookup.has(name))
            lookup.set(name, []);
          lookup.get(name).push(declaration);
        });
      });
      const cycle = check_graph_for_cycles(unsorted_reactive_declarations.reduce((acc, declaration) => {
        declaration.assignees.forEach((v) => {
          declaration.dependencies.forEach((w) => {
            if (!declaration.assignees.has(w))
              acc.push([
                v,
                w
              ]);
          });
        });
        return acc;
      }, []));
      if (cycle && cycle.length) {
        const declarationList = lookup.get(cycle[0]);
        const declaration = declarationList[0];
        return this.error(declaration.node, compiler_errors.cyclical_reactive_declaration(cycle));
      }
      const add_declaration = (declaration) => {
        if (this.reactive_declarations.includes(declaration))
          return;
        declaration.dependencies.forEach((name) => {
          if (declaration.assignees.has(name))
            return;
          const earlier_declarations = lookup.get(name);
          if (earlier_declarations)
            earlier_declarations.forEach(add_declaration);
        });
        this.reactive_declarations.push(declaration);
      };
      unsorted_reactive_declarations.forEach(add_declaration);
    }
    warn_if_undefined(name, node2, template_scope) {
      if (name[0] === "$") {
        if (name === "$" || name[1] === "$" && !is_reserved_keyword(name))
          return this.error(node2, compiler_errors.illegal_global(name));
        this.has_reactive_assignments = true;
        if (is_reserved_keyword(name))
          return;
        name = name.slice(1);
      }
      if (this.var_lookup.has(name) && !this.var_lookup.get(name).global)
        return;
      if (template_scope && template_scope.names.has(name))
        return;
      if (globals.has(name) && node2.type !== "InlineComponent")
        return;
      this.warn(node2, compiler_warnings.missing_declaration(name, !!this.ast.instance));
    }
    push_ignores(ignores) {
      this.ignores = new Set(this.ignores || []);
      add_to_set(this.ignores, ignores);
      this.ignore_stack.push(this.ignores);
    }
    pop_ignores() {
      this.ignore_stack.pop();
      this.ignores = this.ignore_stack[this.ignore_stack.length - 1];
    }
  }
  const regex_valid_tag_name = /^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/;
  function process_component_options(component, nodes) {
    const component_options = {
      immutable: component.compile_options.immutable || false,
      accessors: "accessors" in component.compile_options ? component.compile_options.accessors : !!component.compile_options.customElement,
      preserveWhitespace: !!component.compile_options.preserveWhitespace,
      namespace: component.compile_options.namespace
    };
    const node2 = nodes.find((node3) => node3.name === "svelte:options");
    function get_value2(attribute, { code, message }) {
      const { value: value2 } = attribute;
      const chunk = value2[0];
      if (!chunk)
        return true;
      if (value2.length > 1)
        return component.error(attribute, {
          code,
          message
        });
      if (chunk.type === "Text")
        return chunk.data;
      if (chunk.expression.type !== "Literal")
        return component.error(attribute, {
          code,
          message
        });
      return chunk.expression.value;
    }
    if (node2)
      node2.attributes.forEach((attribute) => {
        if (attribute.type === "Attribute") {
          const { name } = attribute;
          switch (name) {
            case "tag": {
              const tag2 = get_value2(attribute, compiler_errors.invalid_tag_attribute);
              if (typeof tag2 !== "string" && tag2 !== null)
                return component.error(attribute, compiler_errors.invalid_tag_attribute);
              if (tag2 && !regex_valid_tag_name.test(tag2))
                return component.error(attribute, compiler_errors.invalid_tag_property);
              if (tag2 && !component.compile_options.customElement)
                component.warn(attribute, compiler_warnings.missing_custom_element_compile_options);
              component_options.tag = tag2;
              break;
            }
            case "namespace": {
              const ns = get_value2(attribute, compiler_errors.invalid_namespace_attribute);
              if (typeof ns !== "string")
                return component.error(attribute, compiler_errors.invalid_namespace_attribute);
              if (valid_namespaces.indexOf(ns) === -1) {
                const match = fuzzymatch(ns, valid_namespaces);
                return component.error(attribute, compiler_errors.invalid_namespace_property(ns, match));
              }
              component_options.namespace = ns;
              break;
            }
            case "accessors":
            case "immutable":
            case "preserveWhitespace": {
              const value2 = get_value2(attribute, compiler_errors.invalid_attribute_value(name));
              if (typeof value2 !== "boolean")
                return component.error(attribute, compiler_errors.invalid_attribute_value(name));
              component_options[name] = value2;
              break;
            }
            default:
              return component.error(attribute, compiler_errors.invalid_options_attribute_unknown);
          }
        } else
          return component.error(attribute, compiler_errors.invalid_options_attribute);
      });
    return component_options;
  }
  function get_relative_path(from, to) {
    const from_parts = from.split(/[/\\]/);
    const to_parts = to.split(/[/\\]/);
    from_parts.pop();
    while (from_parts[0] === to_parts[0]) {
      from_parts.shift();
      to_parts.shift();
    }
    if (from_parts.length) {
      let i2 = from_parts.length;
      while (i2--)
        from_parts[i2] = "..";
    }
    return from_parts.concat(to_parts).join("/");
  }
  function get_basename(filename) {
    return filename.split(/[/\\]/).pop();
  }
  function get_sourcemap_source_filename(compile_options) {
    if (!compile_options.filename)
      return null;
    return compile_options.outputFilename ? get_relative_path(compile_options.outputFilename, compile_options.filename) : get_basename(compile_options.filename);
  }
  const regex_percentage_characters = /%/g;
  const regex_file_ending = /\.[^.]+$/;
  const regex_repeated_invalid_variable_identifier_characters = /[^a-zA-Z_$0-9]+/g;
  const regex_starts_with_digit = /^(\d)/;
  function get_name_from_filename(filename) {
    if (!filename)
      return null;
    const parts = filename.split(/[/\\]/).map(encodeURI);
    if (parts.length > 1) {
      const index_match = parts[parts.length - 1].match(/^index(\.\w+)/);
      if (index_match) {
        parts.pop();
        parts[parts.length - 1] += index_match[1];
      }
    }
    const base = parts.pop().replace(regex_percentage_characters, "u").replace(regex_file_ending, "").replace(regex_repeated_invalid_variable_identifier_characters, "_").replace(regex_starts_with_underscore, "").replace(regex_ends_with_underscore, "").replace(regex_starts_with_digit, "_$1");
    if (!base)
      throw new Error(`Could not derive component name from file ${filename}`);
    return base[0].toUpperCase() + base.slice(1);
  }
  const valid_options = [
    "format",
    "name",
    "filename",
    "sourcemap",
    "enableSourcemap",
    "generate",
    "errorMode",
    "varsReport",
    "outputFilename",
    "cssOutputFilename",
    "sveltePath",
    "dev",
    "accessors",
    "immutable",
    "hydratable",
    "legacy",
    "customElement",
    "namespace",
    "tag",
    "css",
    "loopGuardTimeout",
    "preserveComments",
    "preserveWhitespace",
    "cssHash"
  ];
  const valid_css_values = [
    true,
    false,
    "injected",
    "external",
    "none"
  ];
  const regex_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
  const regex_starts_with_lowercase_character = /^[a-z]/;
  function validate_options(options, warnings) {
    const { name, filename, loopGuardTimeout, dev, namespace, css } = options;
    Object.keys(options).forEach((key) => {
      if (!valid_options.includes(key)) {
        const match = fuzzymatch(key, valid_options);
        let message = `Unrecognized option '${key}'`;
        if (match)
          message += ` (did you mean '${match}'?)`;
        throw new Error(message);
      }
    });
    if (name && !regex_valid_identifier.test(name))
      throw new Error(`options.name must be a valid identifier (got '${name}')`);
    if (name && regex_starts_with_lowercase_character.test(name)) {
      const message = "options.name should be capitalised";
      warnings.push({
        code: "options-lowercase-name",
        message,
        filename,
        toString: () => message
      });
    }
    if (loopGuardTimeout && !dev) {
      const message = "options.loopGuardTimeout is for options.dev = true only";
      warnings.push({
        code: "options-loop-guard-timeout",
        message,
        filename,
        toString: () => message
      });
    }
    if (valid_css_values.indexOf(css) === -1)
      throw new Error(`options.css must be true, false, 'injected', 'external', or 'none' (got '${css}')`);
    if (css === true || css === false)
      options.css = css === true ? "injected" : "external";
    if (namespace && valid_namespaces.indexOf(namespace) === -1) {
      const match = fuzzymatch(namespace, valid_namespaces);
      if (match)
        throw new Error(`Invalid namespace '${namespace}' (did you mean '${match}'?)`);
      else
        throw new Error(`Invalid namespace '${namespace}'`);
    }
  }
  function compile(source, options = {}) {
    options = Object.assign({
      generate: "dom",
      dev: false,
      enableSourcemap: true,
      css: "injected"
    }, options);
    const stats = new Stats();
    const warnings = [];
    validate_options(options, warnings);
    stats.start("parse");
    const ast = parse$I(source, options);
    stats.stop("parse");
    stats.start("create component");
    const component = new Component(ast, source, options.name || get_name_from_filename(options.filename) || "Component", options, stats, warnings);
    stats.stop("create component");
    const result = options.generate === false ? null : options.generate === "ssr" ? ssr(component, options) : dom(component, options);
    return component.generate(result);
  }
  function decoded_sourcemap_from_generator(generator) {
    let previous_generated_line = 1;
    const converted_mappings = [
      []
    ];
    let result_line;
    let result_segment;
    let mapping;
    const source_idx = generator._sources.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
    const name_idx = generator._names.toArray().reduce((acc, val, idx) => (acc[val] = idx, acc), {});
    const mappings = generator._mappings.toArray();
    result_line = converted_mappings[0];
    for (let i2 = 0, len = mappings.length; i2 < len; i2++) {
      mapping = mappings[i2];
      if (mapping.generatedLine > previous_generated_line) {
        while (mapping.generatedLine > previous_generated_line) {
          converted_mappings.push([]);
          previous_generated_line++;
        }
        result_line = converted_mappings[mapping.generatedLine - 1];
      } else if (i2 > 0) {
        const previous_mapping = mappings[i2 - 1];
        if (
          // sorted by selectivity
          mapping.generatedColumn === previous_mapping.generatedColumn && mapping.originalColumn === previous_mapping.originalColumn && mapping.name === previous_mapping.name && mapping.generatedLine === previous_mapping.generatedLine && mapping.originalLine === previous_mapping.originalLine && mapping.source === previous_mapping.source
        )
          continue;
      }
      result_line.push([
        mapping.generatedColumn
      ]);
      result_segment = result_line[result_line.length - 1];
      if (mapping.source != null) {
        result_segment.push(...[
          source_idx[mapping.source],
          mapping.originalLine - 1,
          mapping.originalColumn
        ]);
        if (mapping.name != null)
          result_segment.push(name_idx[mapping.name]);
      }
    }
    const map = {
      version: generator._version,
      sources: generator._sources.toArray(),
      names: generator._names.toArray(),
      mappings: converted_mappings
    };
    if (generator._file != null)
      map.file = generator._file;
    return map;
  }
  function decode_map(processed) {
    let decoded_map = typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map;
    if (typeof decoded_map.mappings === "string")
      decoded_map.mappings = decode(decoded_map.mappings);
    if (decoded_map._mappings && decoded_map.constructor.name === "SourceMapGenerator")
      decoded_map = decoded_sourcemap_from_generator(decoded_map);
    return decoded_map;
  }
  function slice_source(code_slice, offset, { file_basename, filename, get_location }) {
    return {
      source: code_slice,
      get_location: (index) => get_location(index + offset),
      file_basename,
      filename
    };
  }
  function calculate_replacements(re2, get_replacement, source) {
    const replacements = [];
    source.replace(re2, (...match) => {
      replacements.push(get_replacement(...match).then((replacement) => {
        const matched_string = match[0];
        const offset = match[match.length - 2];
        return {
          offset,
          length: matched_string.length,
          replacement
        };
      }));
      return "";
    });
    return Promise.all(replacements);
  }
  function perform_replacements(replacements, source) {
    const out = new MappedCode();
    let last_end = 0;
    for (const { offset, length, replacement } of replacements) {
      const unchanged_prefix = MappedCode.from_source(slice_source(source.source.slice(last_end, offset), last_end, source));
      out.concat(unchanged_prefix).concat(replacement);
      last_end = offset + length;
    }
    const unchanged_suffix = MappedCode.from_source(slice_source(source.source.slice(last_end), last_end, source));
    return out.concat(unchanged_suffix);
  }
  async function replace_in_code(regex2, get_replacement, location) {
    const replacements = await calculate_replacements(regex2, get_replacement, location.source);
    return perform_replacements(replacements, location);
  }
  const regex_filepath_separator = /[/\\]/;
  function get_file_basename(filename) {
    return filename.split(regex_filepath_separator).pop();
  }
  class PreprocessResult {
    constructor(source, filename) {
      this.source = source;
      this.filename = filename;
      this.sourcemap_list = [];
      this.dependencies = [];
      this.update_source({
        string: source
      });
      this.file_basename = filename == null ? null : get_file_basename(filename);
    }
    update_source({ string: source, map, dependencies }) {
      if (source != null) {
        this.source = source;
        this.get_location = getLocator(source);
      }
      if (map)
        this.sourcemap_list.unshift(map);
      if (dependencies)
        this.dependencies.push(...dependencies);
    }
    to_processed() {
      const map = combine_sourcemaps(this.file_basename, this.sourcemap_list);
      return {
        // TODO return separated output, in future version where svelte.compile supports it:
        // style: { code: styleCode, map: styleMap },
        // script { code: scriptCode, map: scriptMap },
        // markup { code: markupCode, map: markupMap },
        code: this.source,
        dependencies: [
          ...new Set(this.dependencies)
        ],
        map,
        toString: () => this.source
      };
    }
  }
  function processed_content_to_code(processed, location, file_basename) {
    let decoded_map;
    if (processed.map) {
      decoded_map = decode_map(processed);
      if (decoded_map.sources) {
        const source_index = decoded_map.sources.indexOf(file_basename);
        if (source_index !== -1)
          sourcemap_add_offset(decoded_map, location, source_index);
      }
    }
    return MappedCode.from_processed(processed.code, decoded_map);
  }
  function processed_tag_to_code(processed, tag_name, attributes, source) {
    const { file_basename, get_location } = source;
    const build_mapped_code = (code, offset) => MappedCode.from_source(slice_source(code, offset, source));
    const tag_open = `<${tag_name}${attributes || ""}>`;
    const tag_close = `</${tag_name}>`;
    const tag_open_code = build_mapped_code(tag_open, 0);
    const tag_close_code = build_mapped_code(tag_close, tag_open.length + source.source.length);
    parse_attached_sourcemap(processed, tag_name);
    const content_code = processed_content_to_code(processed, get_location(tag_open.length), file_basename);
    return tag_open_code.concat(content_code).concat(tag_close_code);
  }
  const regex_quoted_value = /^['"](.*)['"]$/;
  function parse_tag_attributes(str) {
    return str.split(regex_whitespaces).filter(Boolean).reduce((attrs, attr) => {
      var _a;
      const i2 = attr.indexOf("=");
      const [key, value2] = i2 > 0 ? [
        attr.slice(0, i2),
        attr.slice(i2 + 1)
      ] : [
        attr
      ];
      const [, unquoted] = value2 && value2.match(regex_quoted_value) || [];
      return Object.assign(Object.assign({}, attrs), {
        [key]: (_a = unquoted !== null && unquoted !== void 0 ? unquoted : value2) !== null && _a !== void 0 ? _a : true
      });
    }, {});
  }
  const regex_style_tags = /<!--[^]*?-->|<style(\s[^]*?)?(?:>([^]*?)<\/style>|\/>)/gi;
  const regex_script_tags = /<!--[^]*?-->|<script(\s[^]*?)?(?:>([^]*?)<\/script>|\/>)/gi;
  async function process_tag(tag_name, preprocessor, source) {
    const { filename, source: markup } = source;
    const tag_regex = tag_name === "style" ? regex_style_tags : regex_script_tags;
    const dependencies = [];
    async function process_single_tag(tag_with_content, attributes = "", content = "", tag_offset) {
      const no_change = () => MappedCode.from_source(slice_source(tag_with_content, tag_offset, source));
      if (!attributes && !content)
        return no_change();
      const processed = await preprocessor({
        content: content || "",
        attributes: parse_tag_attributes(attributes || ""),
        markup,
        filename
      });
      if (!processed)
        return no_change();
      if (processed.dependencies)
        dependencies.push(...processed.dependencies);
      if (!processed.map && processed.code === content)
        return no_change();
      return processed_tag_to_code(processed, tag_name, attributes, slice_source(content, tag_offset, source));
    }
    const { string, map } = await replace_in_code(tag_regex, process_single_tag, source);
    return {
      string,
      map,
      dependencies
    };
  }
  async function process_markup(process1, source) {
    const processed = await process1({
      content: source.source,
      filename: source.filename
    });
    if (processed)
      return {
        string: processed.code,
        map: processed.map ? typeof processed.map === "string" ? JSON.parse(processed.map) : processed.map : void 0,
        dependencies: processed.dependencies
      };
    else
      return {};
  }
  async function preprocess(source, preprocessor, options) {
    const filename = options && options.filename || preprocessor.filename;
    const preprocessors = preprocessor ? Array.isArray(preprocessor) ? preprocessor : [
      preprocessor
    ] : [];
    const markup = preprocessors.map((p2) => p2.markup).filter(Boolean);
    const script = preprocessors.map((p2) => p2.script).filter(Boolean);
    const style = preprocessors.map((p2) => p2.style).filter(Boolean);
    const result = new PreprocessResult(source, filename);
    for (const process1 of markup)
      result.update_source(await process_markup(process1, result));
    for (const process1 of script)
      result.update_source(await process_tag("script", process1, result));
    for (const preprocess2 of style)
      result.update_source(await process_tag("style", preprocess2, result));
    return result.to_processed();
  }
  const VERSION = "3.55.0";
  exports1.VERSION = VERSION;
  exports1.compile = compile;
  exports1.parse = parse$I;
  exports1.preprocess = preprocess;
  exports1.walk = walk;
  Object.defineProperty(exports1, "__esModule", {
    value: true
  });
});
var $560639d49e3c9a19$var$bail_1 = $560639d49e3c9a19$var$bail;
function $560639d49e3c9a19$var$bail(err) {
  if (err)
    throw err;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var $560639d49e3c9a19$var$isBuffer = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var $560639d49e3c9a19$var$hasOwn = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$toStr = Object.prototype.toString;
var $560639d49e3c9a19$var$defineProperty = Object.defineProperty;
var $560639d49e3c9a19$var$gOPD = Object.getOwnPropertyDescriptor;
var $560639d49e3c9a19$var$isArray = function isArray(arr) {
  if (typeof Array.isArray === "function")
    return Array.isArray(arr);
  return $560639d49e3c9a19$var$toStr.call(arr) === "[object Array]";
};
var $560639d49e3c9a19$var$isPlainObject = function isPlainObject(obj) {
  if (!obj || $560639d49e3c9a19$var$toStr.call(obj) !== "[object Object]")
    return false;
  var hasOwnConstructor = $560639d49e3c9a19$var$hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $560639d49e3c9a19$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf)
    return false;
  var key;
  for (key in obj)
    ;
  return typeof key === "undefined" || $560639d49e3c9a19$var$hasOwn.call(obj, key);
};
var $560639d49e3c9a19$var$setProperty = function setProperty(target, options) {
  if ($560639d49e3c9a19$var$defineProperty && options.name === "__proto__")
    $560639d49e3c9a19$var$defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  else
    target[options.name] = options.newValue;
};
var $560639d49e3c9a19$var$getProperty = function getProperty(obj, name) {
  if (name === "__proto__") {
    if (!$560639d49e3c9a19$var$hasOwn.call(obj, name))
      return void 0;
    else if ($560639d49e3c9a19$var$gOPD)
      return $560639d49e3c9a19$var$gOPD(obj, name).value;
  }
  return obj[name];
};
var $560639d49e3c9a19$var$extend$2 = function extend() {
  var options, name, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function")
    target = {};
  for (; i < length; ++i) {
    options = arguments[i];
    if (options != null)
      for (name in options) {
        src = $560639d49e3c9a19$var$getProperty(target, name);
        copy = $560639d49e3c9a19$var$getProperty(options, name);
        if (target !== copy) {
          if (deep && copy && ($560639d49e3c9a19$var$isPlainObject(copy) || (copyIsArray = $560639d49e3c9a19$var$isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && $560639d49e3c9a19$var$isArray(src) ? src : [];
            } else
              clone = src && $560639d49e3c9a19$var$isPlainObject(src) ? src : {};
            $560639d49e3c9a19$var$setProperty(target, {
              name,
              newValue: extend(deep, clone, copy)
            });
          } else if (typeof copy !== "undefined")
            $560639d49e3c9a19$var$setProperty(target, {
              name,
              newValue: copy
            });
        }
      }
  }
  return target;
};
var $560639d49e3c9a19$var$isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
var $560639d49e3c9a19$var$slice$3 = [].slice;
var $560639d49e3c9a19$var$wrap_1$1 = $560639d49e3c9a19$var$wrap$2;
function $560639d49e3c9a19$var$wrap$2(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = $560639d49e3c9a19$var$slice$3.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result;
    if (callback2)
      params.push(done);
    try {
      result = fn.apply(null, params);
    } catch (error) {
      if (callback2 && invoked)
        throw error;
      return done(error);
    }
    if (!callback2) {
      if (result && typeof result.then === "function")
        result.then(then, done);
      else if (result instanceof Error)
        done(result);
      else
        then(result);
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value) {
    done(null, value);
  }
}
var $560639d49e3c9a19$var$trough_1 = $560639d49e3c9a19$var$trough;
$560639d49e3c9a19$var$trough.wrap = $560639d49e3c9a19$var$wrap_1$1;
var $560639d49e3c9a19$var$slice$2 = [].slice;
function $560639d49e3c9a19$var$trough() {
  var fns = [];
  var middleware = {};
  middleware.run = run;
  middleware.use = use;
  return middleware;
  function run() {
    var index = -1;
    var input = $560639d49e3c9a19$var$slice$2.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function")
      throw new Error("Expected function as last argument, not " + done);
    next.apply(null, [
      null
    ].concat(input));
    function next(err) {
      var fn = fns[++index];
      var params = $560639d49e3c9a19$var$slice$2.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length)
        if (values[pos] === null || values[pos] === void 0)
          values[pos] = input[pos];
      input = values;
      if (fn)
        $560639d49e3c9a19$var$wrap_1$1(fn, next).apply(null, input);
      else
        done.apply(null, [
          null
        ].concat(input));
    }
  }
  function use(fn) {
    if (typeof fn !== "function")
      throw new Error("Expected `fn` to be a function, not " + fn);
    fns.push(fn);
    return middleware;
  }
}
var $560639d49e3c9a19$var$own$f = {}.hasOwnProperty;
var $560639d49e3c9a19$var$unistUtilStringifyPosition = $560639d49e3c9a19$var$stringify$4;
function $560639d49e3c9a19$var$stringify$4(value) {
  if (!value || typeof value !== "object")
    return "";
  if ($560639d49e3c9a19$var$own$f.call(value, "position") || $560639d49e3c9a19$var$own$f.call(value, "type"))
    return $560639d49e3c9a19$var$position$1(value.position);
  if ($560639d49e3c9a19$var$own$f.call(value, "start") || $560639d49e3c9a19$var$own$f.call(value, "end"))
    return $560639d49e3c9a19$var$position$1(value);
  if ($560639d49e3c9a19$var$own$f.call(value, "line") || $560639d49e3c9a19$var$own$f.call(value, "column"))
    return $560639d49e3c9a19$var$point(value);
  return "";
}
function $560639d49e3c9a19$var$point(point) {
  if (!point || typeof point !== "object")
    point = {};
  return $560639d49e3c9a19$var$index$6(point.line) + ":" + $560639d49e3c9a19$var$index$6(point.column);
}
function $560639d49e3c9a19$var$position$1(pos) {
  if (!pos || typeof pos !== "object")
    pos = {};
  return $560639d49e3c9a19$var$point(pos.start) + "-" + $560639d49e3c9a19$var$point(pos.end);
}
function $560639d49e3c9a19$var$index$6(value) {
  return value && typeof value === "number" ? value : 1;
}
var $560639d49e3c9a19$var$vfileMessage = $560639d49e3c9a19$var$VMessage;
function $560639d49e3c9a19$var$VMessagePrototype() {
}
$560639d49e3c9a19$var$VMessagePrototype.prototype = Error.prototype;
$560639d49e3c9a19$var$VMessage.prototype = new $560639d49e3c9a19$var$VMessagePrototype();
var $560639d49e3c9a19$var$proto$6 = $560639d49e3c9a19$var$VMessage.prototype;
$560639d49e3c9a19$var$proto$6.file = "";
$560639d49e3c9a19$var$proto$6.name = "";
$560639d49e3c9a19$var$proto$6.reason = "";
$560639d49e3c9a19$var$proto$6.message = "";
$560639d49e3c9a19$var$proto$6.stack = "";
$560639d49e3c9a19$var$proto$6.fatal = null;
$560639d49e3c9a19$var$proto$6.column = null;
$560639d49e3c9a19$var$proto$6.line = null;
function $560639d49e3c9a19$var$VMessage(reason, position, origin) {
  var parts;
  var range;
  var location;
  if (typeof position === "string") {
    origin = position;
    position = null;
  }
  parts = $560639d49e3c9a19$var$parseOrigin(origin);
  range = $560639d49e3c9a19$var$unistUtilStringifyPosition(position) || "1:1";
  location = {
    start: {
      line: null,
      column: null
    },
    end: {
      line: null,
      column: null
    }
  };
  if (position && position.position)
    position = position.position;
  if (position) {
    if (position.start) {
      location = position;
      position = position.start;
    } else
      location.start = position;
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range;
  this.reason = reason;
  this.line = position ? position.line : null;
  this.column = position ? position.column : null;
  this.location = location;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function $560639d49e3c9a19$var$parseOrigin(origin) {
  var result = [
    null,
    null
  ];
  var index;
  if (typeof origin === "string") {
    index = origin.indexOf(":");
    if (index === -1)
      result[1] = origin;
    else {
      result[0] = origin.slice(0, index);
      result[1] = origin.slice(index + 1);
    }
  }
  return result;
}
function $560639d49e3c9a19$var$replaceExt(npath, ext) {
  if (typeof npath !== "string")
    return npath;
  if (npath.length === 0)
    return npath;
  var nFileName = $4S4dR$path1__default.basename(npath, $4S4dR$path1__default.extname(npath)) + ext;
  return $4S4dR$path1__default.join($4S4dR$path1__default.dirname(npath), nFileName);
}
var $560639d49e3c9a19$var$replaceExt_1 = $560639d49e3c9a19$var$replaceExt;
var $560639d49e3c9a19$var$core$1 = $560639d49e3c9a19$var$VFile;
var $560639d49e3c9a19$var$own$e = {}.hasOwnProperty;
var $560639d49e3c9a19$var$proto$5 = $560639d49e3c9a19$var$VFile.prototype;
var $560639d49e3c9a19$var$order$1 = [
  "history",
  "path",
  "basename",
  "stem",
  "extname",
  "dirname"
];
$560639d49e3c9a19$var$proto$5.toString = $560639d49e3c9a19$var$toString;
Object.defineProperty($560639d49e3c9a19$var$proto$5, "path", {
  get: $560639d49e3c9a19$var$getPath,
  set: $560639d49e3c9a19$var$setPath
});
Object.defineProperty($560639d49e3c9a19$var$proto$5, "dirname", {
  get: $560639d49e3c9a19$var$getDirname,
  set: $560639d49e3c9a19$var$setDirname
});
Object.defineProperty($560639d49e3c9a19$var$proto$5, "basename", {
  get: $560639d49e3c9a19$var$getBasename,
  set: $560639d49e3c9a19$var$setBasename
});
Object.defineProperty($560639d49e3c9a19$var$proto$5, "extname", {
  get: $560639d49e3c9a19$var$getExtname,
  set: $560639d49e3c9a19$var$setExtname
});
Object.defineProperty($560639d49e3c9a19$var$proto$5, "stem", {
  get: $560639d49e3c9a19$var$getStem,
  set: $560639d49e3c9a19$var$setStem
});
function $560639d49e3c9a19$var$VFile(options) {
  var prop;
  var index;
  var length;
  if (!options)
    options = {};
  else if (typeof options === "string" || $560639d49e3c9a19$var$isBuffer(options))
    options = {
      contents: options
    };
  else if ("message" in options && "messages" in options)
    return options;
  if (!(this instanceof $560639d49e3c9a19$var$VFile))
    return new $560639d49e3c9a19$var$VFile(options);
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = process.cwd();
  index = -1;
  length = $560639d49e3c9a19$var$order$1.length;
  while (++index < length) {
    prop = $560639d49e3c9a19$var$order$1[index];
    if ($560639d49e3c9a19$var$own$e.call(options, prop))
      this[prop] = options[prop];
  }
  for (prop in options)
    if ($560639d49e3c9a19$var$order$1.indexOf(prop) === -1)
      this[prop] = options[prop];
}
function $560639d49e3c9a19$var$getPath() {
  return this.history[this.history.length - 1];
}
function $560639d49e3c9a19$var$setPath(path) {
  $560639d49e3c9a19$var$assertNonEmpty(path, "path");
  if (path !== this.path)
    this.history.push(path);
}
function $560639d49e3c9a19$var$getDirname() {
  return typeof this.path === "string" ? $4S4dR$path1__default.dirname(this.path) : void 0;
}
function $560639d49e3c9a19$var$setDirname(dirname) {
  $560639d49e3c9a19$var$assertPath(this.path, "dirname");
  this.path = $4S4dR$path1__default.join(dirname || "", this.basename);
}
function $560639d49e3c9a19$var$getBasename() {
  return typeof this.path === "string" ? $4S4dR$path1__default.basename(this.path) : void 0;
}
function $560639d49e3c9a19$var$setBasename(basename) {
  $560639d49e3c9a19$var$assertNonEmpty(basename, "basename");
  $560639d49e3c9a19$var$assertPart(basename, "basename");
  this.path = $4S4dR$path1__default.join(this.dirname || "", basename);
}
function $560639d49e3c9a19$var$getExtname() {
  return typeof this.path === "string" ? $4S4dR$path1__default.extname(this.path) : void 0;
}
function $560639d49e3c9a19$var$setExtname(extname) {
  var ext = extname || "";
  $560639d49e3c9a19$var$assertPart(ext, "extname");
  $560639d49e3c9a19$var$assertPath(this.path, "extname");
  if (ext) {
    if (ext.charAt(0) !== ".")
      throw new Error("`extname` must start with `.`");
    if (ext.indexOf(".", 1) !== -1)
      throw new Error("`extname` cannot contain multiple dots");
  }
  this.path = $560639d49e3c9a19$var$replaceExt_1(this.path, ext);
}
function $560639d49e3c9a19$var$getStem() {
  return typeof this.path === "string" ? $4S4dR$path1__default.basename(this.path, this.extname) : void 0;
}
function $560639d49e3c9a19$var$setStem(stem) {
  $560639d49e3c9a19$var$assertNonEmpty(stem, "stem");
  $560639d49e3c9a19$var$assertPart(stem, "stem");
  this.path = $4S4dR$path1__default.join(this.dirname || "", stem + (this.extname || ""));
}
function $560639d49e3c9a19$var$toString(encoding) {
  var value = this.contents || "";
  return $560639d49e3c9a19$var$isBuffer(value) ? value.toString(encoding) : String(value);
}
function $560639d49e3c9a19$var$assertPart(part, name) {
  if (part.indexOf($4S4dR$path1__default.sep) !== -1)
    throw new Error("`" + name + "` cannot be a path: did not expect `" + $4S4dR$path1__default.sep + "`");
}
function $560639d49e3c9a19$var$assertNonEmpty(part, name) {
  if (!part)
    throw new Error("`" + name + "` cannot be empty");
}
function $560639d49e3c9a19$var$assertPath(path, name) {
  if (!path)
    throw new Error("Setting `" + name + "` requires `path` to be set too");
}
var $560639d49e3c9a19$var$vfile = $560639d49e3c9a19$var$core$1;
var $560639d49e3c9a19$var$proto$4 = $560639d49e3c9a19$var$core$1.prototype;
$560639d49e3c9a19$var$proto$4.message = $560639d49e3c9a19$var$message;
$560639d49e3c9a19$var$proto$4.info = $560639d49e3c9a19$var$info$1;
$560639d49e3c9a19$var$proto$4.fail = $560639d49e3c9a19$var$fail;
function $560639d49e3c9a19$var$message(reason, position, origin) {
  var filePath = this.path;
  var message = new $560639d49e3c9a19$var$vfileMessage(reason, position, origin);
  if (filePath) {
    message.name = filePath + ":" + message.name;
    message.file = filePath;
  }
  message.fatal = false;
  this.messages.push(message);
  return message;
}
function $560639d49e3c9a19$var$fail() {
  var message = this.message.apply(this, arguments);
  message.fatal = true;
  throw message;
}
function $560639d49e3c9a19$var$info$1() {
  var message = this.message.apply(this, arguments);
  message.fatal = null;
  return message;
}
var $560639d49e3c9a19$var$unified_1$1 = $560639d49e3c9a19$var$unified$1().freeze();
var $560639d49e3c9a19$var$slice$1 = [].slice;
var $560639d49e3c9a19$var$own$d = {}.hasOwnProperty;
var $560639d49e3c9a19$var$pipeline$1 = $560639d49e3c9a19$var$trough_1().use($560639d49e3c9a19$var$pipelineParse$1).use($560639d49e3c9a19$var$pipelineRun$1).use($560639d49e3c9a19$var$pipelineStringify$1);
function $560639d49e3c9a19$var$pipelineParse$1(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}
function $560639d49e3c9a19$var$pipelineRun$1(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err)
      next(err);
    else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function $560639d49e3c9a19$var$pipelineStringify$1(p, ctx) {
  var result = p.stringify(ctx.tree, ctx.file);
  var file = ctx.file;
  if (result === void 0 || result === null)
    ;
  else if (typeof result === "string" || $560639d49e3c9a19$var$isBuffer(result))
    file.contents = result;
  else
    file.result = result;
}
function $560639d49e3c9a19$var$unified$1() {
  var attachers = [];
  var transformers = $560639d49e3c9a19$var$trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process1;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = $560639d49e3c9a19$var$unified$1();
    var length = attachers.length;
    var index = -1;
    while (++index < length)
      destination.use.apply(null, attachers[index]);
    destination.data($560639d49e3c9a19$var$extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;
    if (frozen)
      return processor;
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;
      if (options === false)
        continue;
      if (options === true)
        values[1] = void 0;
      transformer = plugin.apply(processor, values.slice(1));
      if (typeof transformer === "function")
        transformers.use(transformer);
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        $560639d49e3c9a19$var$assertUnfrozen$1("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return $560639d49e3c9a19$var$own$d.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      $560639d49e3c9a19$var$assertUnfrozen$1("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    $560639d49e3c9a19$var$assertUnfrozen$1("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function")
      addPlugin.apply(null, arguments);
    else if (typeof value === "object") {
      if ("length" in value)
        addList(value);
      else
        addPreset(value);
    } else
      throw new Error("Expected usable value, not `" + value + "`");
    if (settings)
      namespace.settings = $560639d49e3c9a19$var$extend$2(namespace.settings || {}, settings);
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings)
        settings = $560639d49e3c9a19$var$extend$2(settings || {}, result.settings);
    }
    function add(value2) {
      if (typeof value2 === "function")
        addPlugin(value2);
      else if (typeof value2 === "object") {
        if ("length" in value2)
          addPlugin.apply(null, value2);
        else
          addPreset(value2);
      } else
        throw new Error("Expected usable value, not `" + value2 + "`");
    }
    function addList(plugins) {
      var length;
      var index;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index = -1;
        while (++index < length)
          add(plugins[index]);
      } else
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
    }
    function addPlugin(plugin, value2) {
      var entry = find(plugin);
      if (entry) {
        if ($560639d49e3c9a19$var$isPlainObj(entry[1]) && $560639d49e3c9a19$var$isPlainObj(value2))
          value2 = $560639d49e3c9a19$var$extend$2(entry[1], value2);
        entry[1] = value2;
      } else
        attachers.push($560639d49e3c9a19$var$slice$1.call(arguments));
    }
  }
  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;
    while (++index < length) {
      entry = attachers[index];
      if (entry[0] === plugin)
        return entry;
    }
  }
  function parse(doc) {
    var file = $560639d49e3c9a19$var$vfile(doc);
    var Parser;
    freeze();
    Parser = processor.Parser;
    $560639d49e3c9a19$var$assertParser$1("parse", Parser);
    if ($560639d49e3c9a19$var$newable$1(Parser, "parse"))
      return new Parser(String(file), file).parse();
    return Parser(String(file), file);
  }
  function run(node, file, cb) {
    $560639d49e3c9a19$var$assertNode$1(node);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node, $560639d49e3c9a19$var$vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node;
        if (err)
          reject(err);
        else if (resolve)
          resolve(tree);
        else
          cb(null, tree, file2);
      }
    }
  }
  function runSync(node, file) {
    var complete = false;
    var result;
    run(node, file, done);
    $560639d49e3c9a19$var$assertDone$1("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      $560639d49e3c9a19$var$bail_1(err);
      result = tree;
    }
  }
  function stringify(node, doc) {
    var file = $560639d49e3c9a19$var$vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    $560639d49e3c9a19$var$assertCompiler$1("stringify", Compiler);
    $560639d49e3c9a19$var$assertNode$1(node);
    if ($560639d49e3c9a19$var$newable$1(Compiler, "compile"))
      return new Compiler(node, file).compile();
    return Compiler(node, file);
  }
  function process1(doc, cb) {
    freeze();
    $560639d49e3c9a19$var$assertParser$1("process", processor.Parser);
    $560639d49e3c9a19$var$assertCompiler$1("process", processor.Compiler);
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      var file = $560639d49e3c9a19$var$vfile(doc);
      $560639d49e3c9a19$var$pipeline$1.run(processor, {
        file
      }, done);
      function done(err) {
        if (err)
          reject(err);
        else if (resolve)
          resolve(file);
        else
          cb(null, file);
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    $560639d49e3c9a19$var$assertParser$1("processSync", processor.Parser);
    $560639d49e3c9a19$var$assertCompiler$1("processSync", processor.Compiler);
    file = $560639d49e3c9a19$var$vfile(doc);
    process1(file, done);
    $560639d49e3c9a19$var$assertDone$1("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      $560639d49e3c9a19$var$bail_1(err);
    }
  }
}
function $560639d49e3c9a19$var$newable$1(value, name) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  ($560639d49e3c9a19$var$keys$2(value.prototype) || name in value.prototype);
}
function $560639d49e3c9a19$var$keys$2(value) {
  var key;
  for (key in value)
    return true;
  return false;
}
function $560639d49e3c9a19$var$assertParser$1(name, Parser) {
  if (typeof Parser !== "function")
    throw new Error("Cannot `" + name + "` without `Parser`");
}
function $560639d49e3c9a19$var$assertCompiler$1(name, Compiler) {
  if (typeof Compiler !== "function")
    throw new Error("Cannot `" + name + "` without `Compiler`");
}
function $560639d49e3c9a19$var$assertUnfrozen$1(name, frozen) {
  if (frozen)
    throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
function $560639d49e3c9a19$var$assertNode$1(node) {
  if (!node || typeof node.type !== "string")
    throw new Error("Expected node, got `" + node + "`");
}
function $560639d49e3c9a19$var$assertDone$1(name, asyncName, complete) {
  if (!complete)
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $560639d49e3c9a19$var$immutable = $560639d49e3c9a19$var$extend$1;
var $560639d49e3c9a19$var$hasOwnProperty = Object.prototype.hasOwnProperty;
function $560639d49e3c9a19$var$extend$1() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source)
      if ($560639d49e3c9a19$var$hasOwnProperty.call(source, key))
        target[key] = source[key];
  }
  return target;
}
function $560639d49e3c9a19$var$commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
}
function $560639d49e3c9a19$var$createCommonjsModule(fn, module) {
  return module = {
    exports: {}
  }, fn(module, module.exports), module.exports;
}
function $560639d49e3c9a19$var$getCjsExportFromNamespace(n) {
  return n && n["default"] || n;
}
var $560639d49e3c9a19$var$inherits_browser = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
  if (typeof Object.create === "function")
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  else
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
});
var $560639d49e3c9a19$var$inherits = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
  try {
    var util$1 = (0, $4S4dR$util);
    if (typeof util$1.inherits !== "function")
      throw "";
    module.exports = util$1.inherits;
  } catch (e) {
    module.exports = $560639d49e3c9a19$var$inherits_browser;
  }
});
var $560639d49e3c9a19$var$unherit_1 = $560639d49e3c9a19$var$unherit;
function $560639d49e3c9a19$var$unherit(Super) {
  var result;
  var key;
  var value;
  $560639d49e3c9a19$var$inherits(Of, Super);
  $560639d49e3c9a19$var$inherits(From, Of);
  result = Of.prototype;
  for (key in result) {
    value = result[key];
    if (value && typeof value === "object")
      result[key] = "concat" in value ? value.concat() : $560639d49e3c9a19$var$immutable(value);
  }
  return Of;
  function From(parameters) {
    return Super.apply(this, parameters);
  }
  function Of() {
    if (!(this instanceof Of))
      return new From(arguments);
    return Super.apply(this, arguments);
  }
}
var $560639d49e3c9a19$var$stateToggle = $560639d49e3c9a19$var$factory$6;
function $560639d49e3c9a19$var$factory$6(key, state, ctx) {
  return enter;
  function enter() {
    var context = ctx || this;
    var current = context[key];
    context[key] = !state;
    return exit;
    function exit() {
      context[key] = current;
    }
  }
}
var $560639d49e3c9a19$var$vfileLocation = $560639d49e3c9a19$var$factory$5;
function $560639d49e3c9a19$var$factory$5(file) {
  var contents = $560639d49e3c9a19$var$indices(String(file));
  return {
    toPosition: $560639d49e3c9a19$var$offsetToPositionFactory(contents),
    toOffset: $560639d49e3c9a19$var$positionToOffsetFactory(contents)
  };
}
function $560639d49e3c9a19$var$offsetToPositionFactory(indices) {
  return offsetToPosition;
  function offsetToPosition(offset) {
    var index = -1;
    var length = indices.length;
    if (offset < 0)
      return {};
    while (++index < length) {
      if (indices[index] > offset)
        return {
          line: index + 1,
          column: offset - (indices[index - 1] || 0) + 1,
          offset
        };
    }
    return {};
  }
}
function $560639d49e3c9a19$var$positionToOffsetFactory(indices) {
  return positionToOffset;
  function positionToOffset(position) {
    var line = position && position.line;
    var column = position && position.column;
    if (!isNaN(line) && !isNaN(column) && line - 1 in indices)
      return (indices[line - 2] || 0) + column - 1 || 0;
    return -1;
  }
}
function $560639d49e3c9a19$var$indices(value) {
  var result = [];
  var index = value.indexOf("\n");
  while (index !== -1) {
    result.push(index + 1);
    index = value.indexOf("\n", index + 1);
  }
  result.push(value.length + 1);
  return result;
}
var $560639d49e3c9a19$var$_unescape = $560639d49e3c9a19$var$factory$4;
var $560639d49e3c9a19$var$backslash$7 = "\\";
function $560639d49e3c9a19$var$factory$4(ctx, key) {
  return unescape2;
  function unescape2(value) {
    var previous = 0;
    var index = value.indexOf($560639d49e3c9a19$var$backslash$7);
    var escape = ctx[key];
    var queue = [];
    var character;
    while (index !== -1) {
      queue.push(value.slice(previous, index));
      previous = index + 1;
      character = value.charAt(previous);
      if (!character || escape.indexOf(character) === -1)
        queue.push($560639d49e3c9a19$var$backslash$7);
      index = value.indexOf($560639d49e3c9a19$var$backslash$7, previous + 1);
    }
    queue.push(value.slice(previous));
    return queue.join("");
  }
}
var $560639d49e3c9a19$var$AElig$2 = "Æ";
var $560639d49e3c9a19$var$AMP$2 = "&";
var $560639d49e3c9a19$var$Aacute$2 = "Á";
var $560639d49e3c9a19$var$Acirc$2 = "Â";
var $560639d49e3c9a19$var$Agrave$2 = "À";
var $560639d49e3c9a19$var$Aring$2 = "Å";
var $560639d49e3c9a19$var$Atilde$2 = "Ã";
var $560639d49e3c9a19$var$Auml$2 = "Ä";
var $560639d49e3c9a19$var$COPY$1 = "©";
var $560639d49e3c9a19$var$Ccedil$2 = "Ç";
var $560639d49e3c9a19$var$ETH$2 = "Ð";
var $560639d49e3c9a19$var$Eacute$2 = "É";
var $560639d49e3c9a19$var$Ecirc$2 = "Ê";
var $560639d49e3c9a19$var$Egrave$2 = "È";
var $560639d49e3c9a19$var$Euml$2 = "Ë";
var $560639d49e3c9a19$var$GT$2 = ">";
var $560639d49e3c9a19$var$Iacute$2 = "Í";
var $560639d49e3c9a19$var$Icirc$2 = "Î";
var $560639d49e3c9a19$var$Igrave$2 = "Ì";
var $560639d49e3c9a19$var$Iuml$2 = "Ï";
var $560639d49e3c9a19$var$LT$2 = "<";
var $560639d49e3c9a19$var$Ntilde$2 = "Ñ";
var $560639d49e3c9a19$var$Oacute$2 = "Ó";
var $560639d49e3c9a19$var$Ocirc$2 = "Ô";
var $560639d49e3c9a19$var$Ograve$2 = "Ò";
var $560639d49e3c9a19$var$Oslash$2 = "Ø";
var $560639d49e3c9a19$var$Otilde$2 = "Õ";
var $560639d49e3c9a19$var$Ouml$2 = "Ö";
var $560639d49e3c9a19$var$QUOT$1 = '"';
var $560639d49e3c9a19$var$REG$1 = "®";
var $560639d49e3c9a19$var$THORN$2 = "Þ";
var $560639d49e3c9a19$var$Uacute$2 = "Ú";
var $560639d49e3c9a19$var$Ucirc$2 = "Û";
var $560639d49e3c9a19$var$Ugrave$2 = "Ù";
var $560639d49e3c9a19$var$Uuml$2 = "Ü";
var $560639d49e3c9a19$var$Yacute$2 = "Ý";
var $560639d49e3c9a19$var$aacute$2 = "á";
var $560639d49e3c9a19$var$acirc$2 = "â";
var $560639d49e3c9a19$var$acute$2 = "´";
var $560639d49e3c9a19$var$aelig$2 = "æ";
var $560639d49e3c9a19$var$agrave$2 = "à";
var $560639d49e3c9a19$var$amp$2 = "&";
var $560639d49e3c9a19$var$aring$2 = "å";
var $560639d49e3c9a19$var$atilde$2 = "ã";
var $560639d49e3c9a19$var$auml$2 = "ä";
var $560639d49e3c9a19$var$brvbar$2 = "¦";
var $560639d49e3c9a19$var$ccedil$2 = "ç";
var $560639d49e3c9a19$var$cedil$2 = "¸";
var $560639d49e3c9a19$var$cent$2 = "¢";
var $560639d49e3c9a19$var$copy$2 = "©";
var $560639d49e3c9a19$var$curren$2 = "¤";
var $560639d49e3c9a19$var$deg$2 = "°";
var $560639d49e3c9a19$var$divide$2 = "÷";
var $560639d49e3c9a19$var$eacute$2 = "é";
var $560639d49e3c9a19$var$ecirc$2 = "ê";
var $560639d49e3c9a19$var$egrave$2 = "è";
var $560639d49e3c9a19$var$eth$2 = "ð";
var $560639d49e3c9a19$var$euml$2 = "ë";
var $560639d49e3c9a19$var$frac12$2 = "½";
var $560639d49e3c9a19$var$frac14$2 = "¼";
var $560639d49e3c9a19$var$frac34$2 = "¾";
var $560639d49e3c9a19$var$gt$2 = ">";
var $560639d49e3c9a19$var$iacute$2 = "í";
var $560639d49e3c9a19$var$icirc$2 = "î";
var $560639d49e3c9a19$var$iexcl$2 = "¡";
var $560639d49e3c9a19$var$igrave$2 = "ì";
var $560639d49e3c9a19$var$iquest$2 = "¿";
var $560639d49e3c9a19$var$iuml$2 = "ï";
var $560639d49e3c9a19$var$laquo$2 = "«";
var $560639d49e3c9a19$var$lt$2 = "<";
var $560639d49e3c9a19$var$macr$2 = "¯";
var $560639d49e3c9a19$var$micro$2 = "µ";
var $560639d49e3c9a19$var$middot$2 = "·";
var $560639d49e3c9a19$var$nbsp$2 = " ";
var $560639d49e3c9a19$var$not$2 = "¬";
var $560639d49e3c9a19$var$ntilde$2 = "ñ";
var $560639d49e3c9a19$var$oacute$2 = "ó";
var $560639d49e3c9a19$var$ocirc$2 = "ô";
var $560639d49e3c9a19$var$ograve$2 = "ò";
var $560639d49e3c9a19$var$ordf$2 = "ª";
var $560639d49e3c9a19$var$ordm$2 = "º";
var $560639d49e3c9a19$var$oslash$2 = "ø";
var $560639d49e3c9a19$var$otilde$2 = "õ";
var $560639d49e3c9a19$var$ouml$2 = "ö";
var $560639d49e3c9a19$var$para$2 = "¶";
var $560639d49e3c9a19$var$plusmn$2 = "±";
var $560639d49e3c9a19$var$pound$2 = "£";
var $560639d49e3c9a19$var$quot$2 = '"';
var $560639d49e3c9a19$var$raquo$2 = "»";
var $560639d49e3c9a19$var$reg$2 = "®";
var $560639d49e3c9a19$var$sect$2 = "§";
var $560639d49e3c9a19$var$shy$2 = "­";
var $560639d49e3c9a19$var$sup1$2 = "¹";
var $560639d49e3c9a19$var$sup2$2 = "²";
var $560639d49e3c9a19$var$sup3$2 = "³";
var $560639d49e3c9a19$var$szlig$2 = "ß";
var $560639d49e3c9a19$var$thorn$2 = "þ";
var $560639d49e3c9a19$var$times$2 = "×";
var $560639d49e3c9a19$var$uacute$2 = "ú";
var $560639d49e3c9a19$var$ucirc$2 = "û";
var $560639d49e3c9a19$var$ugrave$2 = "ù";
var $560639d49e3c9a19$var$uml$2 = "¨";
var $560639d49e3c9a19$var$uuml$2 = "ü";
var $560639d49e3c9a19$var$yacute$2 = "ý";
var $560639d49e3c9a19$var$yen$2 = "¥";
var $560639d49e3c9a19$var$yuml$2 = "ÿ";
var $560639d49e3c9a19$var$index$5 = {
  AElig: $560639d49e3c9a19$var$AElig$2,
  AMP: $560639d49e3c9a19$var$AMP$2,
  Aacute: $560639d49e3c9a19$var$Aacute$2,
  Acirc: $560639d49e3c9a19$var$Acirc$2,
  Agrave: $560639d49e3c9a19$var$Agrave$2,
  Aring: $560639d49e3c9a19$var$Aring$2,
  Atilde: $560639d49e3c9a19$var$Atilde$2,
  Auml: $560639d49e3c9a19$var$Auml$2,
  COPY: $560639d49e3c9a19$var$COPY$1,
  Ccedil: $560639d49e3c9a19$var$Ccedil$2,
  ETH: $560639d49e3c9a19$var$ETH$2,
  Eacute: $560639d49e3c9a19$var$Eacute$2,
  Ecirc: $560639d49e3c9a19$var$Ecirc$2,
  Egrave: $560639d49e3c9a19$var$Egrave$2,
  Euml: $560639d49e3c9a19$var$Euml$2,
  GT: $560639d49e3c9a19$var$GT$2,
  Iacute: $560639d49e3c9a19$var$Iacute$2,
  Icirc: $560639d49e3c9a19$var$Icirc$2,
  Igrave: $560639d49e3c9a19$var$Igrave$2,
  Iuml: $560639d49e3c9a19$var$Iuml$2,
  LT: $560639d49e3c9a19$var$LT$2,
  Ntilde: $560639d49e3c9a19$var$Ntilde$2,
  Oacute: $560639d49e3c9a19$var$Oacute$2,
  Ocirc: $560639d49e3c9a19$var$Ocirc$2,
  Ograve: $560639d49e3c9a19$var$Ograve$2,
  Oslash: $560639d49e3c9a19$var$Oslash$2,
  Otilde: $560639d49e3c9a19$var$Otilde$2,
  Ouml: $560639d49e3c9a19$var$Ouml$2,
  QUOT: $560639d49e3c9a19$var$QUOT$1,
  REG: $560639d49e3c9a19$var$REG$1,
  THORN: $560639d49e3c9a19$var$THORN$2,
  Uacute: $560639d49e3c9a19$var$Uacute$2,
  Ucirc: $560639d49e3c9a19$var$Ucirc$2,
  Ugrave: $560639d49e3c9a19$var$Ugrave$2,
  Uuml: $560639d49e3c9a19$var$Uuml$2,
  Yacute: $560639d49e3c9a19$var$Yacute$2,
  aacute: $560639d49e3c9a19$var$aacute$2,
  acirc: $560639d49e3c9a19$var$acirc$2,
  acute: $560639d49e3c9a19$var$acute$2,
  aelig: $560639d49e3c9a19$var$aelig$2,
  agrave: $560639d49e3c9a19$var$agrave$2,
  amp: $560639d49e3c9a19$var$amp$2,
  aring: $560639d49e3c9a19$var$aring$2,
  atilde: $560639d49e3c9a19$var$atilde$2,
  auml: $560639d49e3c9a19$var$auml$2,
  brvbar: $560639d49e3c9a19$var$brvbar$2,
  ccedil: $560639d49e3c9a19$var$ccedil$2,
  cedil: $560639d49e3c9a19$var$cedil$2,
  cent: $560639d49e3c9a19$var$cent$2,
  copy: $560639d49e3c9a19$var$copy$2,
  curren: $560639d49e3c9a19$var$curren$2,
  deg: $560639d49e3c9a19$var$deg$2,
  divide: $560639d49e3c9a19$var$divide$2,
  eacute: $560639d49e3c9a19$var$eacute$2,
  ecirc: $560639d49e3c9a19$var$ecirc$2,
  egrave: $560639d49e3c9a19$var$egrave$2,
  eth: $560639d49e3c9a19$var$eth$2,
  euml: $560639d49e3c9a19$var$euml$2,
  frac12: $560639d49e3c9a19$var$frac12$2,
  frac14: $560639d49e3c9a19$var$frac14$2,
  frac34: $560639d49e3c9a19$var$frac34$2,
  gt: $560639d49e3c9a19$var$gt$2,
  iacute: $560639d49e3c9a19$var$iacute$2,
  icirc: $560639d49e3c9a19$var$icirc$2,
  iexcl: $560639d49e3c9a19$var$iexcl$2,
  igrave: $560639d49e3c9a19$var$igrave$2,
  iquest: $560639d49e3c9a19$var$iquest$2,
  iuml: $560639d49e3c9a19$var$iuml$2,
  laquo: $560639d49e3c9a19$var$laquo$2,
  lt: $560639d49e3c9a19$var$lt$2,
  macr: $560639d49e3c9a19$var$macr$2,
  micro: $560639d49e3c9a19$var$micro$2,
  middot: $560639d49e3c9a19$var$middot$2,
  nbsp: $560639d49e3c9a19$var$nbsp$2,
  not: $560639d49e3c9a19$var$not$2,
  ntilde: $560639d49e3c9a19$var$ntilde$2,
  oacute: $560639d49e3c9a19$var$oacute$2,
  ocirc: $560639d49e3c9a19$var$ocirc$2,
  ograve: $560639d49e3c9a19$var$ograve$2,
  ordf: $560639d49e3c9a19$var$ordf$2,
  ordm: $560639d49e3c9a19$var$ordm$2,
  oslash: $560639d49e3c9a19$var$oslash$2,
  otilde: $560639d49e3c9a19$var$otilde$2,
  ouml: $560639d49e3c9a19$var$ouml$2,
  para: $560639d49e3c9a19$var$para$2,
  plusmn: $560639d49e3c9a19$var$plusmn$2,
  pound: $560639d49e3c9a19$var$pound$2,
  quot: $560639d49e3c9a19$var$quot$2,
  raquo: $560639d49e3c9a19$var$raquo$2,
  reg: $560639d49e3c9a19$var$reg$2,
  sect: $560639d49e3c9a19$var$sect$2,
  shy: $560639d49e3c9a19$var$shy$2,
  sup1: $560639d49e3c9a19$var$sup1$2,
  sup2: $560639d49e3c9a19$var$sup2$2,
  sup3: $560639d49e3c9a19$var$sup3$2,
  szlig: $560639d49e3c9a19$var$szlig$2,
  thorn: $560639d49e3c9a19$var$thorn$2,
  times: $560639d49e3c9a19$var$times$2,
  uacute: $560639d49e3c9a19$var$uacute$2,
  ucirc: $560639d49e3c9a19$var$ucirc$2,
  ugrave: $560639d49e3c9a19$var$ugrave$2,
  uml: $560639d49e3c9a19$var$uml$2,
  uuml: $560639d49e3c9a19$var$uuml$2,
  yacute: $560639d49e3c9a19$var$yacute$2,
  yen: $560639d49e3c9a19$var$yen$2,
  yuml: $560639d49e3c9a19$var$yuml$2
};
var $560639d49e3c9a19$var$characterEntitiesLegacy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AElig: $560639d49e3c9a19$var$AElig$2,
  AMP: $560639d49e3c9a19$var$AMP$2,
  Aacute: $560639d49e3c9a19$var$Aacute$2,
  Acirc: $560639d49e3c9a19$var$Acirc$2,
  Agrave: $560639d49e3c9a19$var$Agrave$2,
  Aring: $560639d49e3c9a19$var$Aring$2,
  Atilde: $560639d49e3c9a19$var$Atilde$2,
  Auml: $560639d49e3c9a19$var$Auml$2,
  COPY: $560639d49e3c9a19$var$COPY$1,
  Ccedil: $560639d49e3c9a19$var$Ccedil$2,
  ETH: $560639d49e3c9a19$var$ETH$2,
  Eacute: $560639d49e3c9a19$var$Eacute$2,
  Ecirc: $560639d49e3c9a19$var$Ecirc$2,
  Egrave: $560639d49e3c9a19$var$Egrave$2,
  Euml: $560639d49e3c9a19$var$Euml$2,
  GT: $560639d49e3c9a19$var$GT$2,
  Iacute: $560639d49e3c9a19$var$Iacute$2,
  Icirc: $560639d49e3c9a19$var$Icirc$2,
  Igrave: $560639d49e3c9a19$var$Igrave$2,
  Iuml: $560639d49e3c9a19$var$Iuml$2,
  LT: $560639d49e3c9a19$var$LT$2,
  Ntilde: $560639d49e3c9a19$var$Ntilde$2,
  Oacute: $560639d49e3c9a19$var$Oacute$2,
  Ocirc: $560639d49e3c9a19$var$Ocirc$2,
  Ograve: $560639d49e3c9a19$var$Ograve$2,
  Oslash: $560639d49e3c9a19$var$Oslash$2,
  Otilde: $560639d49e3c9a19$var$Otilde$2,
  Ouml: $560639d49e3c9a19$var$Ouml$2,
  QUOT: $560639d49e3c9a19$var$QUOT$1,
  REG: $560639d49e3c9a19$var$REG$1,
  THORN: $560639d49e3c9a19$var$THORN$2,
  Uacute: $560639d49e3c9a19$var$Uacute$2,
  Ucirc: $560639d49e3c9a19$var$Ucirc$2,
  Ugrave: $560639d49e3c9a19$var$Ugrave$2,
  Uuml: $560639d49e3c9a19$var$Uuml$2,
  Yacute: $560639d49e3c9a19$var$Yacute$2,
  aacute: $560639d49e3c9a19$var$aacute$2,
  acirc: $560639d49e3c9a19$var$acirc$2,
  acute: $560639d49e3c9a19$var$acute$2,
  aelig: $560639d49e3c9a19$var$aelig$2,
  agrave: $560639d49e3c9a19$var$agrave$2,
  amp: $560639d49e3c9a19$var$amp$2,
  aring: $560639d49e3c9a19$var$aring$2,
  atilde: $560639d49e3c9a19$var$atilde$2,
  auml: $560639d49e3c9a19$var$auml$2,
  brvbar: $560639d49e3c9a19$var$brvbar$2,
  ccedil: $560639d49e3c9a19$var$ccedil$2,
  cedil: $560639d49e3c9a19$var$cedil$2,
  cent: $560639d49e3c9a19$var$cent$2,
  copy: $560639d49e3c9a19$var$copy$2,
  curren: $560639d49e3c9a19$var$curren$2,
  deg: $560639d49e3c9a19$var$deg$2,
  divide: $560639d49e3c9a19$var$divide$2,
  eacute: $560639d49e3c9a19$var$eacute$2,
  ecirc: $560639d49e3c9a19$var$ecirc$2,
  egrave: $560639d49e3c9a19$var$egrave$2,
  eth: $560639d49e3c9a19$var$eth$2,
  euml: $560639d49e3c9a19$var$euml$2,
  frac12: $560639d49e3c9a19$var$frac12$2,
  frac14: $560639d49e3c9a19$var$frac14$2,
  frac34: $560639d49e3c9a19$var$frac34$2,
  gt: $560639d49e3c9a19$var$gt$2,
  iacute: $560639d49e3c9a19$var$iacute$2,
  icirc: $560639d49e3c9a19$var$icirc$2,
  iexcl: $560639d49e3c9a19$var$iexcl$2,
  igrave: $560639d49e3c9a19$var$igrave$2,
  iquest: $560639d49e3c9a19$var$iquest$2,
  iuml: $560639d49e3c9a19$var$iuml$2,
  laquo: $560639d49e3c9a19$var$laquo$2,
  lt: $560639d49e3c9a19$var$lt$2,
  macr: $560639d49e3c9a19$var$macr$2,
  micro: $560639d49e3c9a19$var$micro$2,
  middot: $560639d49e3c9a19$var$middot$2,
  nbsp: $560639d49e3c9a19$var$nbsp$2,
  not: $560639d49e3c9a19$var$not$2,
  ntilde: $560639d49e3c9a19$var$ntilde$2,
  oacute: $560639d49e3c9a19$var$oacute$2,
  ocirc: $560639d49e3c9a19$var$ocirc$2,
  ograve: $560639d49e3c9a19$var$ograve$2,
  ordf: $560639d49e3c9a19$var$ordf$2,
  ordm: $560639d49e3c9a19$var$ordm$2,
  oslash: $560639d49e3c9a19$var$oslash$2,
  otilde: $560639d49e3c9a19$var$otilde$2,
  ouml: $560639d49e3c9a19$var$ouml$2,
  para: $560639d49e3c9a19$var$para$2,
  plusmn: $560639d49e3c9a19$var$plusmn$2,
  pound: $560639d49e3c9a19$var$pound$2,
  quot: $560639d49e3c9a19$var$quot$2,
  raquo: $560639d49e3c9a19$var$raquo$2,
  reg: $560639d49e3c9a19$var$reg$2,
  sect: $560639d49e3c9a19$var$sect$2,
  shy: $560639d49e3c9a19$var$shy$2,
  sup1: $560639d49e3c9a19$var$sup1$2,
  sup2: $560639d49e3c9a19$var$sup2$2,
  sup3: $560639d49e3c9a19$var$sup3$2,
  szlig: $560639d49e3c9a19$var$szlig$2,
  thorn: $560639d49e3c9a19$var$thorn$2,
  times: $560639d49e3c9a19$var$times$2,
  uacute: $560639d49e3c9a19$var$uacute$2,
  ucirc: $560639d49e3c9a19$var$ucirc$2,
  ugrave: $560639d49e3c9a19$var$ugrave$2,
  uml: $560639d49e3c9a19$var$uml$2,
  uuml: $560639d49e3c9a19$var$uuml$2,
  yacute: $560639d49e3c9a19$var$yacute$2,
  yen: $560639d49e3c9a19$var$yen$2,
  yuml: $560639d49e3c9a19$var$yuml$2,
  "default": $560639d49e3c9a19$var$index$5
});
var $560639d49e3c9a19$var$index$4 = {
  "0": "�",
  "128": "€",
  "130": "‚",
  "131": "ƒ",
  "132": "„",
  "133": "…",
  "134": "†",
  "135": "‡",
  "136": "ˆ",
  "137": "‰",
  "138": "Š",
  "139": "‹",
  "140": "Œ",
  "142": "Ž",
  "145": "‘",
  "146": "’",
  "147": "“",
  "148": "”",
  "149": "•",
  "150": "–",
  "151": "—",
  "152": "˜",
  "153": "™",
  "154": "š",
  "155": "›",
  "156": "œ",
  "158": "ž",
  "159": "Ÿ"
};
var $560639d49e3c9a19$var$characterReferenceInvalid = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": $560639d49e3c9a19$var$index$4
});
var $560639d49e3c9a19$var$isDecimal = $560639d49e3c9a19$var$decimal$1;
function $560639d49e3c9a19$var$decimal$1(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 48 && code <= 57;
}
var $560639d49e3c9a19$var$isHexadecimal = $560639d49e3c9a19$var$hexadecimal;
function $560639d49e3c9a19$var$hexadecimal(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
}
var $560639d49e3c9a19$var$isAlphabetical = $560639d49e3c9a19$var$alphabetical;
function $560639d49e3c9a19$var$alphabetical(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
var $560639d49e3c9a19$var$isAlphanumerical = $560639d49e3c9a19$var$alphanumerical;
function $560639d49e3c9a19$var$alphanumerical(character) {
  return $560639d49e3c9a19$var$isAlphabetical(character) || $560639d49e3c9a19$var$isDecimal(character);
}
var $560639d49e3c9a19$var$AEli = "Æ";
var $560639d49e3c9a19$var$AElig$1 = "Æ";
var $560639d49e3c9a19$var$AM = "&";
var $560639d49e3c9a19$var$AMP$1 = "&";
var $560639d49e3c9a19$var$Aacut = "Á";
var $560639d49e3c9a19$var$Aacute$1 = "Á";
var $560639d49e3c9a19$var$Abreve = "Ă";
var $560639d49e3c9a19$var$Acir = "Â";
var $560639d49e3c9a19$var$Acirc$1 = "Â";
var $560639d49e3c9a19$var$Acy = "А";
var $560639d49e3c9a19$var$Afr = "𝔄";
var $560639d49e3c9a19$var$Agrav = "À";
var $560639d49e3c9a19$var$Agrave$1 = "À";
var $560639d49e3c9a19$var$Alpha$1 = "Α";
var $560639d49e3c9a19$var$Amacr = "Ā";
var $560639d49e3c9a19$var$And = "⩓";
var $560639d49e3c9a19$var$Aogon = "Ą";
var $560639d49e3c9a19$var$Aopf = "𝔸";
var $560639d49e3c9a19$var$ApplyFunction = "⁡";
var $560639d49e3c9a19$var$Arin = "Å";
var $560639d49e3c9a19$var$Aring$1 = "Å";
var $560639d49e3c9a19$var$Ascr = "𝒜";
var $560639d49e3c9a19$var$Assign = "≔";
var $560639d49e3c9a19$var$Atild = "Ã";
var $560639d49e3c9a19$var$Atilde$1 = "Ã";
var $560639d49e3c9a19$var$Aum = "Ä";
var $560639d49e3c9a19$var$Auml$1 = "Ä";
var $560639d49e3c9a19$var$Backslash = "∖";
var $560639d49e3c9a19$var$Barv = "⫧";
var $560639d49e3c9a19$var$Barwed = "⌆";
var $560639d49e3c9a19$var$Bcy = "Б";
var $560639d49e3c9a19$var$Because = "∵";
var $560639d49e3c9a19$var$Bernoullis = "ℬ";
var $560639d49e3c9a19$var$Beta$1 = "Β";
var $560639d49e3c9a19$var$Bfr = "𝔅";
var $560639d49e3c9a19$var$Bopf = "𝔹";
var $560639d49e3c9a19$var$Breve = "˘";
var $560639d49e3c9a19$var$Bscr = "ℬ";
var $560639d49e3c9a19$var$Bumpeq = "≎";
var $560639d49e3c9a19$var$CHcy = "Ч";
var $560639d49e3c9a19$var$COP = "©";
var $560639d49e3c9a19$var$COPY = "©";
var $560639d49e3c9a19$var$Cacute = "Ć";
var $560639d49e3c9a19$var$Cap = "⋒";
var $560639d49e3c9a19$var$CapitalDifferentialD = "ⅅ";
var $560639d49e3c9a19$var$Cayleys = "ℭ";
var $560639d49e3c9a19$var$Ccaron = "Č";
var $560639d49e3c9a19$var$Ccedi = "Ç";
var $560639d49e3c9a19$var$Ccedil$1 = "Ç";
var $560639d49e3c9a19$var$Ccirc = "Ĉ";
var $560639d49e3c9a19$var$Cconint = "∰";
var $560639d49e3c9a19$var$Cdot = "Ċ";
var $560639d49e3c9a19$var$Cedilla = "¸";
var $560639d49e3c9a19$var$CenterDot = "·";
var $560639d49e3c9a19$var$Cfr = "ℭ";
var $560639d49e3c9a19$var$Chi$1 = "Χ";
var $560639d49e3c9a19$var$CircleDot = "⊙";
var $560639d49e3c9a19$var$CircleMinus = "⊖";
var $560639d49e3c9a19$var$CirclePlus = "⊕";
var $560639d49e3c9a19$var$CircleTimes = "⊗";
var $560639d49e3c9a19$var$ClockwiseContourIntegral = "∲";
var $560639d49e3c9a19$var$CloseCurlyDoubleQuote = "”";
var $560639d49e3c9a19$var$CloseCurlyQuote = "’";
var $560639d49e3c9a19$var$Colon = "∷";
var $560639d49e3c9a19$var$Colone = "⩴";
var $560639d49e3c9a19$var$Congruent = "≡";
var $560639d49e3c9a19$var$Conint = "∯";
var $560639d49e3c9a19$var$ContourIntegral = "∮";
var $560639d49e3c9a19$var$Copf = "ℂ";
var $560639d49e3c9a19$var$Coproduct = "∐";
var $560639d49e3c9a19$var$CounterClockwiseContourIntegral = "∳";
var $560639d49e3c9a19$var$Cross = "⨯";
var $560639d49e3c9a19$var$Cscr = "𝒞";
var $560639d49e3c9a19$var$Cup = "⋓";
var $560639d49e3c9a19$var$CupCap = "≍";
var $560639d49e3c9a19$var$DD = "ⅅ";
var $560639d49e3c9a19$var$DDotrahd = "⤑";
var $560639d49e3c9a19$var$DJcy = "Ђ";
var $560639d49e3c9a19$var$DScy = "Ѕ";
var $560639d49e3c9a19$var$DZcy = "Џ";
var $560639d49e3c9a19$var$Dagger$1 = "‡";
var $560639d49e3c9a19$var$Darr = "↡";
var $560639d49e3c9a19$var$Dashv = "⫤";
var $560639d49e3c9a19$var$Dcaron = "Ď";
var $560639d49e3c9a19$var$Dcy = "Д";
var $560639d49e3c9a19$var$Del = "∇";
var $560639d49e3c9a19$var$Delta$1 = "Δ";
var $560639d49e3c9a19$var$Dfr = "𝔇";
var $560639d49e3c9a19$var$DiacriticalAcute = "´";
var $560639d49e3c9a19$var$DiacriticalDot = "˙";
var $560639d49e3c9a19$var$DiacriticalDoubleAcute = "˝";
var $560639d49e3c9a19$var$DiacriticalGrave = "`";
var $560639d49e3c9a19$var$DiacriticalTilde = "˜";
var $560639d49e3c9a19$var$Diamond = "⋄";
var $560639d49e3c9a19$var$DifferentialD = "ⅆ";
var $560639d49e3c9a19$var$Dopf = "𝔻";
var $560639d49e3c9a19$var$Dot = "¨";
var $560639d49e3c9a19$var$DotDot = "⃜";
var $560639d49e3c9a19$var$DotEqual = "≐";
var $560639d49e3c9a19$var$DoubleContourIntegral = "∯";
var $560639d49e3c9a19$var$DoubleDot = "¨";
var $560639d49e3c9a19$var$DoubleDownArrow = "⇓";
var $560639d49e3c9a19$var$DoubleLeftArrow = "⇐";
var $560639d49e3c9a19$var$DoubleLeftRightArrow = "⇔";
var $560639d49e3c9a19$var$DoubleLeftTee = "⫤";
var $560639d49e3c9a19$var$DoubleLongLeftArrow = "⟸";
var $560639d49e3c9a19$var$DoubleLongLeftRightArrow = "⟺";
var $560639d49e3c9a19$var$DoubleLongRightArrow = "⟹";
var $560639d49e3c9a19$var$DoubleRightArrow = "⇒";
var $560639d49e3c9a19$var$DoubleRightTee = "⊨";
var $560639d49e3c9a19$var$DoubleUpArrow = "⇑";
var $560639d49e3c9a19$var$DoubleUpDownArrow = "⇕";
var $560639d49e3c9a19$var$DoubleVerticalBar = "∥";
var $560639d49e3c9a19$var$DownArrow = "↓";
var $560639d49e3c9a19$var$DownArrowBar = "⤓";
var $560639d49e3c9a19$var$DownArrowUpArrow = "⇵";
var $560639d49e3c9a19$var$DownBreve = "̑";
var $560639d49e3c9a19$var$DownLeftRightVector = "⥐";
var $560639d49e3c9a19$var$DownLeftTeeVector = "⥞";
var $560639d49e3c9a19$var$DownLeftVector = "↽";
var $560639d49e3c9a19$var$DownLeftVectorBar = "⥖";
var $560639d49e3c9a19$var$DownRightTeeVector = "⥟";
var $560639d49e3c9a19$var$DownRightVector = "⇁";
var $560639d49e3c9a19$var$DownRightVectorBar = "⥗";
var $560639d49e3c9a19$var$DownTee = "⊤";
var $560639d49e3c9a19$var$DownTeeArrow = "↧";
var $560639d49e3c9a19$var$Downarrow = "⇓";
var $560639d49e3c9a19$var$Dscr = "𝒟";
var $560639d49e3c9a19$var$Dstrok = "Đ";
var $560639d49e3c9a19$var$ENG = "Ŋ";
var $560639d49e3c9a19$var$ET = "Ð";
var $560639d49e3c9a19$var$ETH$1 = "Ð";
var $560639d49e3c9a19$var$Eacut = "É";
var $560639d49e3c9a19$var$Eacute$1 = "É";
var $560639d49e3c9a19$var$Ecaron = "Ě";
var $560639d49e3c9a19$var$Ecir = "Ê";
var $560639d49e3c9a19$var$Ecirc$1 = "Ê";
var $560639d49e3c9a19$var$Ecy = "Э";
var $560639d49e3c9a19$var$Edot = "Ė";
var $560639d49e3c9a19$var$Efr = "𝔈";
var $560639d49e3c9a19$var$Egrav = "È";
var $560639d49e3c9a19$var$Egrave$1 = "È";
var $560639d49e3c9a19$var$Element = "∈";
var $560639d49e3c9a19$var$Emacr = "Ē";
var $560639d49e3c9a19$var$EmptySmallSquare = "◻";
var $560639d49e3c9a19$var$EmptyVerySmallSquare = "▫";
var $560639d49e3c9a19$var$Eogon = "Ę";
var $560639d49e3c9a19$var$Eopf = "𝔼";
var $560639d49e3c9a19$var$Epsilon$1 = "Ε";
var $560639d49e3c9a19$var$Equal = "⩵";
var $560639d49e3c9a19$var$EqualTilde = "≂";
var $560639d49e3c9a19$var$Equilibrium = "⇌";
var $560639d49e3c9a19$var$Escr = "ℰ";
var $560639d49e3c9a19$var$Esim = "⩳";
var $560639d49e3c9a19$var$Eta$1 = "Η";
var $560639d49e3c9a19$var$Eum = "Ë";
var $560639d49e3c9a19$var$Euml$1 = "Ë";
var $560639d49e3c9a19$var$Exists = "∃";
var $560639d49e3c9a19$var$ExponentialE = "ⅇ";
var $560639d49e3c9a19$var$Fcy = "Ф";
var $560639d49e3c9a19$var$Ffr = "𝔉";
var $560639d49e3c9a19$var$FilledSmallSquare = "◼";
var $560639d49e3c9a19$var$FilledVerySmallSquare = "▪";
var $560639d49e3c9a19$var$Fopf = "𝔽";
var $560639d49e3c9a19$var$ForAll = "∀";
var $560639d49e3c9a19$var$Fouriertrf = "ℱ";
var $560639d49e3c9a19$var$Fscr = "ℱ";
var $560639d49e3c9a19$var$GJcy = "Ѓ";
var $560639d49e3c9a19$var$G = ">";
var $560639d49e3c9a19$var$GT$1 = ">";
var $560639d49e3c9a19$var$Gamma$1 = "Γ";
var $560639d49e3c9a19$var$Gammad = "Ϝ";
var $560639d49e3c9a19$var$Gbreve = "Ğ";
var $560639d49e3c9a19$var$Gcedil = "Ģ";
var $560639d49e3c9a19$var$Gcirc = "Ĝ";
var $560639d49e3c9a19$var$Gcy = "Г";
var $560639d49e3c9a19$var$Gdot = "Ġ";
var $560639d49e3c9a19$var$Gfr = "𝔊";
var $560639d49e3c9a19$var$Gg = "⋙";
var $560639d49e3c9a19$var$Gopf = "𝔾";
var $560639d49e3c9a19$var$GreaterEqual = "≥";
var $560639d49e3c9a19$var$GreaterEqualLess = "⋛";
var $560639d49e3c9a19$var$GreaterFullEqual = "≧";
var $560639d49e3c9a19$var$GreaterGreater = "⪢";
var $560639d49e3c9a19$var$GreaterLess = "≷";
var $560639d49e3c9a19$var$GreaterSlantEqual = "⩾";
var $560639d49e3c9a19$var$GreaterTilde = "≳";
var $560639d49e3c9a19$var$Gscr = "𝒢";
var $560639d49e3c9a19$var$Gt = "≫";
var $560639d49e3c9a19$var$HARDcy = "Ъ";
var $560639d49e3c9a19$var$Hacek = "ˇ";
var $560639d49e3c9a19$var$Hat = "^";
var $560639d49e3c9a19$var$Hcirc = "Ĥ";
var $560639d49e3c9a19$var$Hfr = "ℌ";
var $560639d49e3c9a19$var$HilbertSpace = "ℋ";
var $560639d49e3c9a19$var$Hopf = "ℍ";
var $560639d49e3c9a19$var$HorizontalLine = "─";
var $560639d49e3c9a19$var$Hscr = "ℋ";
var $560639d49e3c9a19$var$Hstrok = "Ħ";
var $560639d49e3c9a19$var$HumpDownHump = "≎";
var $560639d49e3c9a19$var$HumpEqual = "≏";
var $560639d49e3c9a19$var$IEcy = "Е";
var $560639d49e3c9a19$var$IJlig = "Ĳ";
var $560639d49e3c9a19$var$IOcy = "Ё";
var $560639d49e3c9a19$var$Iacut = "Í";
var $560639d49e3c9a19$var$Iacute$1 = "Í";
var $560639d49e3c9a19$var$Icir = "Î";
var $560639d49e3c9a19$var$Icirc$1 = "Î";
var $560639d49e3c9a19$var$Icy = "И";
var $560639d49e3c9a19$var$Idot = "İ";
var $560639d49e3c9a19$var$Ifr = "ℑ";
var $560639d49e3c9a19$var$Igrav = "Ì";
var $560639d49e3c9a19$var$Igrave$1 = "Ì";
var $560639d49e3c9a19$var$Im = "ℑ";
var $560639d49e3c9a19$var$Imacr = "Ī";
var $560639d49e3c9a19$var$ImaginaryI = "ⅈ";
var $560639d49e3c9a19$var$Implies = "⇒";
var $560639d49e3c9a19$var$Int = "∬";
var $560639d49e3c9a19$var$Integral = "∫";
var $560639d49e3c9a19$var$Intersection = "⋂";
var $560639d49e3c9a19$var$InvisibleComma = "⁣";
var $560639d49e3c9a19$var$InvisibleTimes = "⁢";
var $560639d49e3c9a19$var$Iogon = "Į";
var $560639d49e3c9a19$var$Iopf = "𝕀";
var $560639d49e3c9a19$var$Iota$1 = "Ι";
var $560639d49e3c9a19$var$Iscr = "ℐ";
var $560639d49e3c9a19$var$Itilde = "Ĩ";
var $560639d49e3c9a19$var$Iukcy = "І";
var $560639d49e3c9a19$var$Ium = "Ï";
var $560639d49e3c9a19$var$Iuml$1 = "Ï";
var $560639d49e3c9a19$var$Jcirc = "Ĵ";
var $560639d49e3c9a19$var$Jcy = "Й";
var $560639d49e3c9a19$var$Jfr = "𝔍";
var $560639d49e3c9a19$var$Jopf = "𝕁";
var $560639d49e3c9a19$var$Jscr = "𝒥";
var $560639d49e3c9a19$var$Jsercy = "Ј";
var $560639d49e3c9a19$var$Jukcy = "Є";
var $560639d49e3c9a19$var$KHcy = "Х";
var $560639d49e3c9a19$var$KJcy = "Ќ";
var $560639d49e3c9a19$var$Kappa$1 = "Κ";
var $560639d49e3c9a19$var$Kcedil = "Ķ";
var $560639d49e3c9a19$var$Kcy = "К";
var $560639d49e3c9a19$var$Kfr = "𝔎";
var $560639d49e3c9a19$var$Kopf = "𝕂";
var $560639d49e3c9a19$var$Kscr = "𝒦";
var $560639d49e3c9a19$var$LJcy = "Љ";
var $560639d49e3c9a19$var$L = "<";
var $560639d49e3c9a19$var$LT$1 = "<";
var $560639d49e3c9a19$var$Lacute = "Ĺ";
var $560639d49e3c9a19$var$Lambda$1 = "Λ";
var $560639d49e3c9a19$var$Lang = "⟪";
var $560639d49e3c9a19$var$Laplacetrf = "ℒ";
var $560639d49e3c9a19$var$Larr = "↞";
var $560639d49e3c9a19$var$Lcaron = "Ľ";
var $560639d49e3c9a19$var$Lcedil = "Ļ";
var $560639d49e3c9a19$var$Lcy = "Л";
var $560639d49e3c9a19$var$LeftAngleBracket = "⟨";
var $560639d49e3c9a19$var$LeftArrow = "←";
var $560639d49e3c9a19$var$LeftArrowBar = "⇤";
var $560639d49e3c9a19$var$LeftArrowRightArrow = "⇆";
var $560639d49e3c9a19$var$LeftCeiling = "⌈";
var $560639d49e3c9a19$var$LeftDoubleBracket = "⟦";
var $560639d49e3c9a19$var$LeftDownTeeVector = "⥡";
var $560639d49e3c9a19$var$LeftDownVector = "⇃";
var $560639d49e3c9a19$var$LeftDownVectorBar = "⥙";
var $560639d49e3c9a19$var$LeftFloor = "⌊";
var $560639d49e3c9a19$var$LeftRightArrow = "↔";
var $560639d49e3c9a19$var$LeftRightVector = "⥎";
var $560639d49e3c9a19$var$LeftTee = "⊣";
var $560639d49e3c9a19$var$LeftTeeArrow = "↤";
var $560639d49e3c9a19$var$LeftTeeVector = "⥚";
var $560639d49e3c9a19$var$LeftTriangle = "⊲";
var $560639d49e3c9a19$var$LeftTriangleBar = "⧏";
var $560639d49e3c9a19$var$LeftTriangleEqual = "⊴";
var $560639d49e3c9a19$var$LeftUpDownVector = "⥑";
var $560639d49e3c9a19$var$LeftUpTeeVector = "⥠";
var $560639d49e3c9a19$var$LeftUpVector = "↿";
var $560639d49e3c9a19$var$LeftUpVectorBar = "⥘";
var $560639d49e3c9a19$var$LeftVector = "↼";
var $560639d49e3c9a19$var$LeftVectorBar = "⥒";
var $560639d49e3c9a19$var$Leftarrow = "⇐";
var $560639d49e3c9a19$var$Leftrightarrow = "⇔";
var $560639d49e3c9a19$var$LessEqualGreater = "⋚";
var $560639d49e3c9a19$var$LessFullEqual = "≦";
var $560639d49e3c9a19$var$LessGreater = "≶";
var $560639d49e3c9a19$var$LessLess = "⪡";
var $560639d49e3c9a19$var$LessSlantEqual = "⩽";
var $560639d49e3c9a19$var$LessTilde = "≲";
var $560639d49e3c9a19$var$Lfr = "𝔏";
var $560639d49e3c9a19$var$Ll = "⋘";
var $560639d49e3c9a19$var$Lleftarrow = "⇚";
var $560639d49e3c9a19$var$Lmidot = "Ŀ";
var $560639d49e3c9a19$var$LongLeftArrow = "⟵";
var $560639d49e3c9a19$var$LongLeftRightArrow = "⟷";
var $560639d49e3c9a19$var$LongRightArrow = "⟶";
var $560639d49e3c9a19$var$Longleftarrow = "⟸";
var $560639d49e3c9a19$var$Longleftrightarrow = "⟺";
var $560639d49e3c9a19$var$Longrightarrow = "⟹";
var $560639d49e3c9a19$var$Lopf = "𝕃";
var $560639d49e3c9a19$var$LowerLeftArrow = "↙";
var $560639d49e3c9a19$var$LowerRightArrow = "↘";
var $560639d49e3c9a19$var$Lscr = "ℒ";
var $560639d49e3c9a19$var$Lsh = "↰";
var $560639d49e3c9a19$var$Lstrok = "Ł";
var $560639d49e3c9a19$var$Lt = "≪";
var $560639d49e3c9a19$var$Mcy = "М";
var $560639d49e3c9a19$var$MediumSpace = " ";
var $560639d49e3c9a19$var$Mellintrf = "ℳ";
var $560639d49e3c9a19$var$Mfr = "𝔐";
var $560639d49e3c9a19$var$MinusPlus = "∓";
var $560639d49e3c9a19$var$Mopf = "𝕄";
var $560639d49e3c9a19$var$Mscr = "ℳ";
var $560639d49e3c9a19$var$Mu$1 = "Μ";
var $560639d49e3c9a19$var$NJcy = "Њ";
var $560639d49e3c9a19$var$Nacute = "Ń";
var $560639d49e3c9a19$var$Ncaron = "Ň";
var $560639d49e3c9a19$var$Ncedil = "Ņ";
var $560639d49e3c9a19$var$Ncy = "Н";
var $560639d49e3c9a19$var$NegativeMediumSpace = "​";
var $560639d49e3c9a19$var$NegativeThickSpace = "​";
var $560639d49e3c9a19$var$NegativeThinSpace = "​";
var $560639d49e3c9a19$var$NegativeVeryThinSpace = "​";
var $560639d49e3c9a19$var$NestedGreaterGreater = "≫";
var $560639d49e3c9a19$var$NestedLessLess = "≪";
var $560639d49e3c9a19$var$NewLine = "\n";
var $560639d49e3c9a19$var$Nfr = "𝔑";
var $560639d49e3c9a19$var$NoBreak = "⁠";
var $560639d49e3c9a19$var$NonBreakingSpace = " ";
var $560639d49e3c9a19$var$Nopf = "ℕ";
var $560639d49e3c9a19$var$Not = "⫬";
var $560639d49e3c9a19$var$NotCongruent = "≢";
var $560639d49e3c9a19$var$NotCupCap = "≭";
var $560639d49e3c9a19$var$NotDoubleVerticalBar = "∦";
var $560639d49e3c9a19$var$NotElement = "∉";
var $560639d49e3c9a19$var$NotEqual = "≠";
var $560639d49e3c9a19$var$NotEqualTilde = "≂̸";
var $560639d49e3c9a19$var$NotExists = "∄";
var $560639d49e3c9a19$var$NotGreater = "≯";
var $560639d49e3c9a19$var$NotGreaterEqual = "≱";
var $560639d49e3c9a19$var$NotGreaterFullEqual = "≧̸";
var $560639d49e3c9a19$var$NotGreaterGreater = "≫̸";
var $560639d49e3c9a19$var$NotGreaterLess = "≹";
var $560639d49e3c9a19$var$NotGreaterSlantEqual = "⩾̸";
var $560639d49e3c9a19$var$NotGreaterTilde = "≵";
var $560639d49e3c9a19$var$NotHumpDownHump = "≎̸";
var $560639d49e3c9a19$var$NotHumpEqual = "≏̸";
var $560639d49e3c9a19$var$NotLeftTriangle = "⋪";
var $560639d49e3c9a19$var$NotLeftTriangleBar = "⧏̸";
var $560639d49e3c9a19$var$NotLeftTriangleEqual = "⋬";
var $560639d49e3c9a19$var$NotLess = "≮";
var $560639d49e3c9a19$var$NotLessEqual = "≰";
var $560639d49e3c9a19$var$NotLessGreater = "≸";
var $560639d49e3c9a19$var$NotLessLess = "≪̸";
var $560639d49e3c9a19$var$NotLessSlantEqual = "⩽̸";
var $560639d49e3c9a19$var$NotLessTilde = "≴";
var $560639d49e3c9a19$var$NotNestedGreaterGreater = "⪢̸";
var $560639d49e3c9a19$var$NotNestedLessLess = "⪡̸";
var $560639d49e3c9a19$var$NotPrecedes = "⊀";
var $560639d49e3c9a19$var$NotPrecedesEqual = "⪯̸";
var $560639d49e3c9a19$var$NotPrecedesSlantEqual = "⋠";
var $560639d49e3c9a19$var$NotReverseElement = "∌";
var $560639d49e3c9a19$var$NotRightTriangle = "⋫";
var $560639d49e3c9a19$var$NotRightTriangleBar = "⧐̸";
var $560639d49e3c9a19$var$NotRightTriangleEqual = "⋭";
var $560639d49e3c9a19$var$NotSquareSubset = "⊏̸";
var $560639d49e3c9a19$var$NotSquareSubsetEqual = "⋢";
var $560639d49e3c9a19$var$NotSquareSuperset = "⊐̸";
var $560639d49e3c9a19$var$NotSquareSupersetEqual = "⋣";
var $560639d49e3c9a19$var$NotSubset = "⊂⃒";
var $560639d49e3c9a19$var$NotSubsetEqual = "⊈";
var $560639d49e3c9a19$var$NotSucceeds = "⊁";
var $560639d49e3c9a19$var$NotSucceedsEqual = "⪰̸";
var $560639d49e3c9a19$var$NotSucceedsSlantEqual = "⋡";
var $560639d49e3c9a19$var$NotSucceedsTilde = "≿̸";
var $560639d49e3c9a19$var$NotSuperset = "⊃⃒";
var $560639d49e3c9a19$var$NotSupersetEqual = "⊉";
var $560639d49e3c9a19$var$NotTilde = "≁";
var $560639d49e3c9a19$var$NotTildeEqual = "≄";
var $560639d49e3c9a19$var$NotTildeFullEqual = "≇";
var $560639d49e3c9a19$var$NotTildeTilde = "≉";
var $560639d49e3c9a19$var$NotVerticalBar = "∤";
var $560639d49e3c9a19$var$Nscr = "𝒩";
var $560639d49e3c9a19$var$Ntild = "Ñ";
var $560639d49e3c9a19$var$Ntilde$1 = "Ñ";
var $560639d49e3c9a19$var$Nu$1 = "Ν";
var $560639d49e3c9a19$var$OElig$1 = "Œ";
var $560639d49e3c9a19$var$Oacut = "Ó";
var $560639d49e3c9a19$var$Oacute$1 = "Ó";
var $560639d49e3c9a19$var$Ocir = "Ô";
var $560639d49e3c9a19$var$Ocirc$1 = "Ô";
var $560639d49e3c9a19$var$Ocy = "О";
var $560639d49e3c9a19$var$Odblac = "Ő";
var $560639d49e3c9a19$var$Ofr = "𝔒";
var $560639d49e3c9a19$var$Ograv = "Ò";
var $560639d49e3c9a19$var$Ograve$1 = "Ò";
var $560639d49e3c9a19$var$Omacr = "Ō";
var $560639d49e3c9a19$var$Omega$1 = "Ω";
var $560639d49e3c9a19$var$Omicron$1 = "Ο";
var $560639d49e3c9a19$var$Oopf = "𝕆";
var $560639d49e3c9a19$var$OpenCurlyDoubleQuote = "“";
var $560639d49e3c9a19$var$OpenCurlyQuote = "‘";
var $560639d49e3c9a19$var$Or = "⩔";
var $560639d49e3c9a19$var$Oscr = "𝒪";
var $560639d49e3c9a19$var$Oslas = "Ø";
var $560639d49e3c9a19$var$Oslash$1 = "Ø";
var $560639d49e3c9a19$var$Otild = "Õ";
var $560639d49e3c9a19$var$Otilde$1 = "Õ";
var $560639d49e3c9a19$var$Otimes = "⨷";
var $560639d49e3c9a19$var$Oum = "Ö";
var $560639d49e3c9a19$var$Ouml$1 = "Ö";
var $560639d49e3c9a19$var$OverBar = "‾";
var $560639d49e3c9a19$var$OverBrace = "⏞";
var $560639d49e3c9a19$var$OverBracket = "⎴";
var $560639d49e3c9a19$var$OverParenthesis = "⏜";
var $560639d49e3c9a19$var$PartialD = "∂";
var $560639d49e3c9a19$var$Pcy = "П";
var $560639d49e3c9a19$var$Pfr = "𝔓";
var $560639d49e3c9a19$var$Phi$1 = "Φ";
var $560639d49e3c9a19$var$Pi$1 = "Π";
var $560639d49e3c9a19$var$PlusMinus = "±";
var $560639d49e3c9a19$var$Poincareplane = "ℌ";
var $560639d49e3c9a19$var$Popf = "ℙ";
var $560639d49e3c9a19$var$Pr = "⪻";
var $560639d49e3c9a19$var$Precedes = "≺";
var $560639d49e3c9a19$var$PrecedesEqual = "⪯";
var $560639d49e3c9a19$var$PrecedesSlantEqual = "≼";
var $560639d49e3c9a19$var$PrecedesTilde = "≾";
var $560639d49e3c9a19$var$Prime$1 = "″";
var $560639d49e3c9a19$var$Product = "∏";
var $560639d49e3c9a19$var$Proportion = "∷";
var $560639d49e3c9a19$var$Proportional = "∝";
var $560639d49e3c9a19$var$Pscr = "𝒫";
var $560639d49e3c9a19$var$Psi$1 = "Ψ";
var $560639d49e3c9a19$var$QUO = '"';
var $560639d49e3c9a19$var$QUOT = '"';
var $560639d49e3c9a19$var$Qfr = "𝔔";
var $560639d49e3c9a19$var$Qopf = "ℚ";
var $560639d49e3c9a19$var$Qscr = "𝒬";
var $560639d49e3c9a19$var$RBarr = "⤐";
var $560639d49e3c9a19$var$RE = "®";
var $560639d49e3c9a19$var$REG = "®";
var $560639d49e3c9a19$var$Racute = "Ŕ";
var $560639d49e3c9a19$var$Rang = "⟫";
var $560639d49e3c9a19$var$Rarr = "↠";
var $560639d49e3c9a19$var$Rarrtl = "⤖";
var $560639d49e3c9a19$var$Rcaron = "Ř";
var $560639d49e3c9a19$var$Rcedil = "Ŗ";
var $560639d49e3c9a19$var$Rcy = "Р";
var $560639d49e3c9a19$var$Re = "ℜ";
var $560639d49e3c9a19$var$ReverseElement = "∋";
var $560639d49e3c9a19$var$ReverseEquilibrium = "⇋";
var $560639d49e3c9a19$var$ReverseUpEquilibrium = "⥯";
var $560639d49e3c9a19$var$Rfr = "ℜ";
var $560639d49e3c9a19$var$Rho$1 = "Ρ";
var $560639d49e3c9a19$var$RightAngleBracket = "⟩";
var $560639d49e3c9a19$var$RightArrow = "→";
var $560639d49e3c9a19$var$RightArrowBar = "⇥";
var $560639d49e3c9a19$var$RightArrowLeftArrow = "⇄";
var $560639d49e3c9a19$var$RightCeiling = "⌉";
var $560639d49e3c9a19$var$RightDoubleBracket = "⟧";
var $560639d49e3c9a19$var$RightDownTeeVector = "⥝";
var $560639d49e3c9a19$var$RightDownVector = "⇂";
var $560639d49e3c9a19$var$RightDownVectorBar = "⥕";
var $560639d49e3c9a19$var$RightFloor = "⌋";
var $560639d49e3c9a19$var$RightTee = "⊢";
var $560639d49e3c9a19$var$RightTeeArrow = "↦";
var $560639d49e3c9a19$var$RightTeeVector = "⥛";
var $560639d49e3c9a19$var$RightTriangle = "⊳";
var $560639d49e3c9a19$var$RightTriangleBar = "⧐";
var $560639d49e3c9a19$var$RightTriangleEqual = "⊵";
var $560639d49e3c9a19$var$RightUpDownVector = "⥏";
var $560639d49e3c9a19$var$RightUpTeeVector = "⥜";
var $560639d49e3c9a19$var$RightUpVector = "↾";
var $560639d49e3c9a19$var$RightUpVectorBar = "⥔";
var $560639d49e3c9a19$var$RightVector = "⇀";
var $560639d49e3c9a19$var$RightVectorBar = "⥓";
var $560639d49e3c9a19$var$Rightarrow = "⇒";
var $560639d49e3c9a19$var$Ropf = "ℝ";
var $560639d49e3c9a19$var$RoundImplies = "⥰";
var $560639d49e3c9a19$var$Rrightarrow = "⇛";
var $560639d49e3c9a19$var$Rscr = "ℛ";
var $560639d49e3c9a19$var$Rsh = "↱";
var $560639d49e3c9a19$var$RuleDelayed = "⧴";
var $560639d49e3c9a19$var$SHCHcy = "Щ";
var $560639d49e3c9a19$var$SHcy = "Ш";
var $560639d49e3c9a19$var$SOFTcy = "Ь";
var $560639d49e3c9a19$var$Sacute = "Ś";
var $560639d49e3c9a19$var$Sc = "⪼";
var $560639d49e3c9a19$var$Scaron$1 = "Š";
var $560639d49e3c9a19$var$Scedil = "Ş";
var $560639d49e3c9a19$var$Scirc = "Ŝ";
var $560639d49e3c9a19$var$Scy = "С";
var $560639d49e3c9a19$var$Sfr = "𝔖";
var $560639d49e3c9a19$var$ShortDownArrow = "↓";
var $560639d49e3c9a19$var$ShortLeftArrow = "←";
var $560639d49e3c9a19$var$ShortRightArrow = "→";
var $560639d49e3c9a19$var$ShortUpArrow = "↑";
var $560639d49e3c9a19$var$Sigma$1 = "Σ";
var $560639d49e3c9a19$var$SmallCircle = "∘";
var $560639d49e3c9a19$var$Sopf = "𝕊";
var $560639d49e3c9a19$var$Sqrt = "√";
var $560639d49e3c9a19$var$Square = "□";
var $560639d49e3c9a19$var$SquareIntersection = "⊓";
var $560639d49e3c9a19$var$SquareSubset = "⊏";
var $560639d49e3c9a19$var$SquareSubsetEqual = "⊑";
var $560639d49e3c9a19$var$SquareSuperset = "⊐";
var $560639d49e3c9a19$var$SquareSupersetEqual = "⊒";
var $560639d49e3c9a19$var$SquareUnion = "⊔";
var $560639d49e3c9a19$var$Sscr = "𝒮";
var $560639d49e3c9a19$var$Star = "⋆";
var $560639d49e3c9a19$var$Sub = "⋐";
var $560639d49e3c9a19$var$Subset = "⋐";
var $560639d49e3c9a19$var$SubsetEqual = "⊆";
var $560639d49e3c9a19$var$Succeeds = "≻";
var $560639d49e3c9a19$var$SucceedsEqual = "⪰";
var $560639d49e3c9a19$var$SucceedsSlantEqual = "≽";
var $560639d49e3c9a19$var$SucceedsTilde = "≿";
var $560639d49e3c9a19$var$SuchThat = "∋";
var $560639d49e3c9a19$var$Sum = "∑";
var $560639d49e3c9a19$var$Sup = "⋑";
var $560639d49e3c9a19$var$Superset = "⊃";
var $560639d49e3c9a19$var$SupersetEqual = "⊇";
var $560639d49e3c9a19$var$Supset = "⋑";
var $560639d49e3c9a19$var$THOR = "Þ";
var $560639d49e3c9a19$var$THORN$1 = "Þ";
var $560639d49e3c9a19$var$TRADE = "™";
var $560639d49e3c9a19$var$TSHcy = "Ћ";
var $560639d49e3c9a19$var$TScy = "Ц";
var $560639d49e3c9a19$var$Tab = "	";
var $560639d49e3c9a19$var$Tau$1 = "Τ";
var $560639d49e3c9a19$var$Tcaron = "Ť";
var $560639d49e3c9a19$var$Tcedil = "Ţ";
var $560639d49e3c9a19$var$Tcy = "Т";
var $560639d49e3c9a19$var$Tfr = "𝔗";
var $560639d49e3c9a19$var$Therefore = "∴";
var $560639d49e3c9a19$var$Theta$1 = "Θ";
var $560639d49e3c9a19$var$ThickSpace = "  ";
var $560639d49e3c9a19$var$ThinSpace = " ";
var $560639d49e3c9a19$var$Tilde = "∼";
var $560639d49e3c9a19$var$TildeEqual = "≃";
var $560639d49e3c9a19$var$TildeFullEqual = "≅";
var $560639d49e3c9a19$var$TildeTilde = "≈";
var $560639d49e3c9a19$var$Topf = "𝕋";
var $560639d49e3c9a19$var$TripleDot = "⃛";
var $560639d49e3c9a19$var$Tscr = "𝒯";
var $560639d49e3c9a19$var$Tstrok = "Ŧ";
var $560639d49e3c9a19$var$Uacut = "Ú";
var $560639d49e3c9a19$var$Uacute$1 = "Ú";
var $560639d49e3c9a19$var$Uarr = "↟";
var $560639d49e3c9a19$var$Uarrocir = "⥉";
var $560639d49e3c9a19$var$Ubrcy = "Ў";
var $560639d49e3c9a19$var$Ubreve = "Ŭ";
var $560639d49e3c9a19$var$Ucir = "Û";
var $560639d49e3c9a19$var$Ucirc$1 = "Û";
var $560639d49e3c9a19$var$Ucy = "У";
var $560639d49e3c9a19$var$Udblac = "Ű";
var $560639d49e3c9a19$var$Ufr = "𝔘";
var $560639d49e3c9a19$var$Ugrav = "Ù";
var $560639d49e3c9a19$var$Ugrave$1 = "Ù";
var $560639d49e3c9a19$var$Umacr = "Ū";
var $560639d49e3c9a19$var$UnderBar = "_";
var $560639d49e3c9a19$var$UnderBrace = "⏟";
var $560639d49e3c9a19$var$UnderBracket = "⎵";
var $560639d49e3c9a19$var$UnderParenthesis = "⏝";
var $560639d49e3c9a19$var$Union = "⋃";
var $560639d49e3c9a19$var$UnionPlus = "⊎";
var $560639d49e3c9a19$var$Uogon = "Ų";
var $560639d49e3c9a19$var$Uopf = "𝕌";
var $560639d49e3c9a19$var$UpArrow = "↑";
var $560639d49e3c9a19$var$UpArrowBar = "⤒";
var $560639d49e3c9a19$var$UpArrowDownArrow = "⇅";
var $560639d49e3c9a19$var$UpDownArrow = "↕";
var $560639d49e3c9a19$var$UpEquilibrium = "⥮";
var $560639d49e3c9a19$var$UpTee = "⊥";
var $560639d49e3c9a19$var$UpTeeArrow = "↥";
var $560639d49e3c9a19$var$Uparrow = "⇑";
var $560639d49e3c9a19$var$Updownarrow = "⇕";
var $560639d49e3c9a19$var$UpperLeftArrow = "↖";
var $560639d49e3c9a19$var$UpperRightArrow = "↗";
var $560639d49e3c9a19$var$Upsi = "ϒ";
var $560639d49e3c9a19$var$Upsilon$1 = "Υ";
var $560639d49e3c9a19$var$Uring = "Ů";
var $560639d49e3c9a19$var$Uscr = "𝒰";
var $560639d49e3c9a19$var$Utilde = "Ũ";
var $560639d49e3c9a19$var$Uum = "Ü";
var $560639d49e3c9a19$var$Uuml$1 = "Ü";
var $560639d49e3c9a19$var$VDash = "⊫";
var $560639d49e3c9a19$var$Vbar = "⫫";
var $560639d49e3c9a19$var$Vcy = "В";
var $560639d49e3c9a19$var$Vdash = "⊩";
var $560639d49e3c9a19$var$Vdashl = "⫦";
var $560639d49e3c9a19$var$Vee = "⋁";
var $560639d49e3c9a19$var$Verbar = "‖";
var $560639d49e3c9a19$var$Vert = "‖";
var $560639d49e3c9a19$var$VerticalBar = "∣";
var $560639d49e3c9a19$var$VerticalLine = "|";
var $560639d49e3c9a19$var$VerticalSeparator = "❘";
var $560639d49e3c9a19$var$VerticalTilde = "≀";
var $560639d49e3c9a19$var$VeryThinSpace = " ";
var $560639d49e3c9a19$var$Vfr = "𝔙";
var $560639d49e3c9a19$var$Vopf = "𝕍";
var $560639d49e3c9a19$var$Vscr = "𝒱";
var $560639d49e3c9a19$var$Vvdash = "⊪";
var $560639d49e3c9a19$var$Wcirc = "Ŵ";
var $560639d49e3c9a19$var$Wedge = "⋀";
var $560639d49e3c9a19$var$Wfr = "𝔚";
var $560639d49e3c9a19$var$Wopf = "𝕎";
var $560639d49e3c9a19$var$Wscr = "𝒲";
var $560639d49e3c9a19$var$Xfr = "𝔛";
var $560639d49e3c9a19$var$Xi$1 = "Ξ";
var $560639d49e3c9a19$var$Xopf = "𝕏";
var $560639d49e3c9a19$var$Xscr = "𝒳";
var $560639d49e3c9a19$var$YAcy = "Я";
var $560639d49e3c9a19$var$YIcy = "Ї";
var $560639d49e3c9a19$var$YUcy = "Ю";
var $560639d49e3c9a19$var$Yacut = "Ý";
var $560639d49e3c9a19$var$Yacute$1 = "Ý";
var $560639d49e3c9a19$var$Ycirc = "Ŷ";
var $560639d49e3c9a19$var$Ycy = "Ы";
var $560639d49e3c9a19$var$Yfr = "𝔜";
var $560639d49e3c9a19$var$Yopf = "𝕐";
var $560639d49e3c9a19$var$Yscr = "𝒴";
var $560639d49e3c9a19$var$Yuml$1 = "Ÿ";
var $560639d49e3c9a19$var$ZHcy = "Ж";
var $560639d49e3c9a19$var$Zacute = "Ź";
var $560639d49e3c9a19$var$Zcaron = "Ž";
var $560639d49e3c9a19$var$Zcy = "З";
var $560639d49e3c9a19$var$Zdot = "Ż";
var $560639d49e3c9a19$var$ZeroWidthSpace = "​";
var $560639d49e3c9a19$var$Zeta$1 = "Ζ";
var $560639d49e3c9a19$var$Zfr = "ℨ";
var $560639d49e3c9a19$var$Zopf = "ℤ";
var $560639d49e3c9a19$var$Zscr = "𝒵";
var $560639d49e3c9a19$var$aacut = "á";
var $560639d49e3c9a19$var$aacute$1 = "á";
var $560639d49e3c9a19$var$abreve = "ă";
var $560639d49e3c9a19$var$ac = "∾";
var $560639d49e3c9a19$var$acE = "∾̳";
var $560639d49e3c9a19$var$acd = "∿";
var $560639d49e3c9a19$var$acir = "â";
var $560639d49e3c9a19$var$acirc$1 = "â";
var $560639d49e3c9a19$var$acut = "´";
var $560639d49e3c9a19$var$acute$1 = "´";
var $560639d49e3c9a19$var$acy = "а";
var $560639d49e3c9a19$var$aeli = "æ";
var $560639d49e3c9a19$var$aelig$1 = "æ";
var $560639d49e3c9a19$var$af = "⁡";
var $560639d49e3c9a19$var$afr = "𝔞";
var $560639d49e3c9a19$var$agrav = "à";
var $560639d49e3c9a19$var$agrave$1 = "à";
var $560639d49e3c9a19$var$alefsym$1 = "ℵ";
var $560639d49e3c9a19$var$aleph = "ℵ";
var $560639d49e3c9a19$var$alpha$1 = "α";
var $560639d49e3c9a19$var$amacr = "ā";
var $560639d49e3c9a19$var$amalg = "⨿";
var $560639d49e3c9a19$var$am = "&";
var $560639d49e3c9a19$var$amp$1 = "&";
var $560639d49e3c9a19$var$and$1 = "∧";
var $560639d49e3c9a19$var$andand = "⩕";
var $560639d49e3c9a19$var$andd = "⩜";
var $560639d49e3c9a19$var$andslope = "⩘";
var $560639d49e3c9a19$var$andv = "⩚";
var $560639d49e3c9a19$var$ang$1 = "∠";
var $560639d49e3c9a19$var$ange = "⦤";
var $560639d49e3c9a19$var$angle = "∠";
var $560639d49e3c9a19$var$angmsd = "∡";
var $560639d49e3c9a19$var$angmsdaa = "⦨";
var $560639d49e3c9a19$var$angmsdab = "⦩";
var $560639d49e3c9a19$var$angmsdac = "⦪";
var $560639d49e3c9a19$var$angmsdad = "⦫";
var $560639d49e3c9a19$var$angmsdae = "⦬";
var $560639d49e3c9a19$var$angmsdaf = "⦭";
var $560639d49e3c9a19$var$angmsdag = "⦮";
var $560639d49e3c9a19$var$angmsdah = "⦯";
var $560639d49e3c9a19$var$angrt = "∟";
var $560639d49e3c9a19$var$angrtvb = "⊾";
var $560639d49e3c9a19$var$angrtvbd = "⦝";
var $560639d49e3c9a19$var$angsph = "∢";
var $560639d49e3c9a19$var$angst = "Å";
var $560639d49e3c9a19$var$angzarr = "⍼";
var $560639d49e3c9a19$var$aogon = "ą";
var $560639d49e3c9a19$var$aopf = "𝕒";
var $560639d49e3c9a19$var$ap = "≈";
var $560639d49e3c9a19$var$apE = "⩰";
var $560639d49e3c9a19$var$apacir = "⩯";
var $560639d49e3c9a19$var$ape = "≊";
var $560639d49e3c9a19$var$apid = "≋";
var $560639d49e3c9a19$var$apos = "'";
var $560639d49e3c9a19$var$approx = "≈";
var $560639d49e3c9a19$var$approxeq = "≊";
var $560639d49e3c9a19$var$arin = "å";
var $560639d49e3c9a19$var$aring$1 = "å";
var $560639d49e3c9a19$var$ascr = "𝒶";
var $560639d49e3c9a19$var$ast = "*";
var $560639d49e3c9a19$var$asymp$1 = "≈";
var $560639d49e3c9a19$var$asympeq = "≍";
var $560639d49e3c9a19$var$atild = "ã";
var $560639d49e3c9a19$var$atilde$1 = "ã";
var $560639d49e3c9a19$var$aum = "ä";
var $560639d49e3c9a19$var$auml$1 = "ä";
var $560639d49e3c9a19$var$awconint = "∳";
var $560639d49e3c9a19$var$awint = "⨑";
var $560639d49e3c9a19$var$bNot = "⫭";
var $560639d49e3c9a19$var$backcong = "≌";
var $560639d49e3c9a19$var$backepsilon = "϶";
var $560639d49e3c9a19$var$backprime = "‵";
var $560639d49e3c9a19$var$backsim = "∽";
var $560639d49e3c9a19$var$backsimeq = "⋍";
var $560639d49e3c9a19$var$barvee = "⊽";
var $560639d49e3c9a19$var$barwed = "⌅";
var $560639d49e3c9a19$var$barwedge = "⌅";
var $560639d49e3c9a19$var$bbrk = "⎵";
var $560639d49e3c9a19$var$bbrktbrk = "⎶";
var $560639d49e3c9a19$var$bcong = "≌";
var $560639d49e3c9a19$var$bcy = "б";
var $560639d49e3c9a19$var$bdquo$1 = "„";
var $560639d49e3c9a19$var$becaus = "∵";
var $560639d49e3c9a19$var$because = "∵";
var $560639d49e3c9a19$var$bemptyv = "⦰";
var $560639d49e3c9a19$var$bepsi = "϶";
var $560639d49e3c9a19$var$bernou = "ℬ";
var $560639d49e3c9a19$var$beta$1 = "β";
var $560639d49e3c9a19$var$beth = "ℶ";
var $560639d49e3c9a19$var$between = "≬";
var $560639d49e3c9a19$var$bfr = "𝔟";
var $560639d49e3c9a19$var$bigcap = "⋂";
var $560639d49e3c9a19$var$bigcirc = "◯";
var $560639d49e3c9a19$var$bigcup = "⋃";
var $560639d49e3c9a19$var$bigodot = "⨀";
var $560639d49e3c9a19$var$bigoplus = "⨁";
var $560639d49e3c9a19$var$bigotimes = "⨂";
var $560639d49e3c9a19$var$bigsqcup = "⨆";
var $560639d49e3c9a19$var$bigstar = "★";
var $560639d49e3c9a19$var$bigtriangledown = "▽";
var $560639d49e3c9a19$var$bigtriangleup = "△";
var $560639d49e3c9a19$var$biguplus = "⨄";
var $560639d49e3c9a19$var$bigvee = "⋁";
var $560639d49e3c9a19$var$bigwedge = "⋀";
var $560639d49e3c9a19$var$bkarow = "⤍";
var $560639d49e3c9a19$var$blacklozenge = "⧫";
var $560639d49e3c9a19$var$blacksquare = "▪";
var $560639d49e3c9a19$var$blacktriangle = "▴";
var $560639d49e3c9a19$var$blacktriangledown = "▾";
var $560639d49e3c9a19$var$blacktriangleleft = "◂";
var $560639d49e3c9a19$var$blacktriangleright = "▸";
var $560639d49e3c9a19$var$blank = "␣";
var $560639d49e3c9a19$var$blk12 = "▒";
var $560639d49e3c9a19$var$blk14 = "░";
var $560639d49e3c9a19$var$blk34 = "▓";
var $560639d49e3c9a19$var$block = "█";
var $560639d49e3c9a19$var$bne = "=⃥";
var $560639d49e3c9a19$var$bnequiv = "≡⃥";
var $560639d49e3c9a19$var$bnot = "⌐";
var $560639d49e3c9a19$var$bopf = "𝕓";
var $560639d49e3c9a19$var$bot = "⊥";
var $560639d49e3c9a19$var$bottom = "⊥";
var $560639d49e3c9a19$var$bowtie = "⋈";
var $560639d49e3c9a19$var$boxDL = "╗";
var $560639d49e3c9a19$var$boxDR = "╔";
var $560639d49e3c9a19$var$boxDl = "╖";
var $560639d49e3c9a19$var$boxDr = "╓";
var $560639d49e3c9a19$var$boxH = "═";
var $560639d49e3c9a19$var$boxHD = "╦";
var $560639d49e3c9a19$var$boxHU = "╩";
var $560639d49e3c9a19$var$boxHd = "╤";
var $560639d49e3c9a19$var$boxHu = "╧";
var $560639d49e3c9a19$var$boxUL = "╝";
var $560639d49e3c9a19$var$boxUR = "╚";
var $560639d49e3c9a19$var$boxUl = "╜";
var $560639d49e3c9a19$var$boxUr = "╙";
var $560639d49e3c9a19$var$boxV = "║";
var $560639d49e3c9a19$var$boxVH = "╬";
var $560639d49e3c9a19$var$boxVL = "╣";
var $560639d49e3c9a19$var$boxVR = "╠";
var $560639d49e3c9a19$var$boxVh = "╫";
var $560639d49e3c9a19$var$boxVl = "╢";
var $560639d49e3c9a19$var$boxVr = "╟";
var $560639d49e3c9a19$var$boxbox = "⧉";
var $560639d49e3c9a19$var$boxdL = "╕";
var $560639d49e3c9a19$var$boxdR = "╒";
var $560639d49e3c9a19$var$boxdl = "┐";
var $560639d49e3c9a19$var$boxdr = "┌";
var $560639d49e3c9a19$var$boxh = "─";
var $560639d49e3c9a19$var$boxhD = "╥";
var $560639d49e3c9a19$var$boxhU = "╨";
var $560639d49e3c9a19$var$boxhd = "┬";
var $560639d49e3c9a19$var$boxhu = "┴";
var $560639d49e3c9a19$var$boxminus = "⊟";
var $560639d49e3c9a19$var$boxplus = "⊞";
var $560639d49e3c9a19$var$boxtimes = "⊠";
var $560639d49e3c9a19$var$boxuL = "╛";
var $560639d49e3c9a19$var$boxuR = "╘";
var $560639d49e3c9a19$var$boxul = "┘";
var $560639d49e3c9a19$var$boxur = "└";
var $560639d49e3c9a19$var$boxv = "│";
var $560639d49e3c9a19$var$boxvH = "╪";
var $560639d49e3c9a19$var$boxvL = "╡";
var $560639d49e3c9a19$var$boxvR = "╞";
var $560639d49e3c9a19$var$boxvh = "┼";
var $560639d49e3c9a19$var$boxvl = "┤";
var $560639d49e3c9a19$var$boxvr = "├";
var $560639d49e3c9a19$var$bprime = "‵";
var $560639d49e3c9a19$var$breve = "˘";
var $560639d49e3c9a19$var$brvba = "¦";
var $560639d49e3c9a19$var$brvbar$1 = "¦";
var $560639d49e3c9a19$var$bscr = "𝒷";
var $560639d49e3c9a19$var$bsemi = "⁏";
var $560639d49e3c9a19$var$bsim = "∽";
var $560639d49e3c9a19$var$bsime = "⋍";
var $560639d49e3c9a19$var$bsol = "\\";
var $560639d49e3c9a19$var$bsolb = "⧅";
var $560639d49e3c9a19$var$bsolhsub = "⟈";
var $560639d49e3c9a19$var$bull$1 = "•";
var $560639d49e3c9a19$var$bullet = "•";
var $560639d49e3c9a19$var$bump = "≎";
var $560639d49e3c9a19$var$bumpE = "⪮";
var $560639d49e3c9a19$var$bumpe = "≏";
var $560639d49e3c9a19$var$bumpeq = "≏";
var $560639d49e3c9a19$var$cacute = "ć";
var $560639d49e3c9a19$var$cap$2 = "∩";
var $560639d49e3c9a19$var$capand = "⩄";
var $560639d49e3c9a19$var$capbrcup = "⩉";
var $560639d49e3c9a19$var$capcap = "⩋";
var $560639d49e3c9a19$var$capcup = "⩇";
var $560639d49e3c9a19$var$capdot = "⩀";
var $560639d49e3c9a19$var$caps = "∩︀";
var $560639d49e3c9a19$var$caret = "⁁";
var $560639d49e3c9a19$var$caron = "ˇ";
var $560639d49e3c9a19$var$ccaps = "⩍";
var $560639d49e3c9a19$var$ccaron = "č";
var $560639d49e3c9a19$var$ccedi = "ç";
var $560639d49e3c9a19$var$ccedil$1 = "ç";
var $560639d49e3c9a19$var$ccirc = "ĉ";
var $560639d49e3c9a19$var$ccups = "⩌";
var $560639d49e3c9a19$var$ccupssm = "⩐";
var $560639d49e3c9a19$var$cdot = "ċ";
var $560639d49e3c9a19$var$cedi = "¸";
var $560639d49e3c9a19$var$cedil$1 = "¸";
var $560639d49e3c9a19$var$cemptyv = "⦲";
var $560639d49e3c9a19$var$cen = "¢";
var $560639d49e3c9a19$var$cent$1 = "¢";
var $560639d49e3c9a19$var$centerdot = "·";
var $560639d49e3c9a19$var$cfr = "𝔠";
var $560639d49e3c9a19$var$chcy = "ч";
var $560639d49e3c9a19$var$check = "✓";
var $560639d49e3c9a19$var$checkmark = "✓";
var $560639d49e3c9a19$var$chi$1 = "χ";
var $560639d49e3c9a19$var$cir = "○";
var $560639d49e3c9a19$var$cirE = "⧃";
var $560639d49e3c9a19$var$circ$1 = "ˆ";
var $560639d49e3c9a19$var$circeq = "≗";
var $560639d49e3c9a19$var$circlearrowleft = "↺";
var $560639d49e3c9a19$var$circlearrowright = "↻";
var $560639d49e3c9a19$var$circledR = "®";
var $560639d49e3c9a19$var$circledS = "Ⓢ";
var $560639d49e3c9a19$var$circledast = "⊛";
var $560639d49e3c9a19$var$circledcirc = "⊚";
var $560639d49e3c9a19$var$circleddash = "⊝";
var $560639d49e3c9a19$var$cire = "≗";
var $560639d49e3c9a19$var$cirfnint = "⨐";
var $560639d49e3c9a19$var$cirmid = "⫯";
var $560639d49e3c9a19$var$cirscir = "⧂";
var $560639d49e3c9a19$var$clubs$1 = "♣";
var $560639d49e3c9a19$var$clubsuit = "♣";
var $560639d49e3c9a19$var$colon$3 = ":";
var $560639d49e3c9a19$var$colone = "≔";
var $560639d49e3c9a19$var$coloneq = "≔";
var $560639d49e3c9a19$var$comma$2 = ",";
var $560639d49e3c9a19$var$commat = "@";
var $560639d49e3c9a19$var$comp = "∁";
var $560639d49e3c9a19$var$compfn = "∘";
var $560639d49e3c9a19$var$complement = "∁";
var $560639d49e3c9a19$var$complexes = "ℂ";
var $560639d49e3c9a19$var$cong$1 = "≅";
var $560639d49e3c9a19$var$congdot = "⩭";
var $560639d49e3c9a19$var$conint = "∮";
var $560639d49e3c9a19$var$copf = "𝕔";
var $560639d49e3c9a19$var$coprod = "∐";
var $560639d49e3c9a19$var$cop = "©";
var $560639d49e3c9a19$var$copy$1 = "©";
var $560639d49e3c9a19$var$copysr = "℗";
var $560639d49e3c9a19$var$crarr$1 = "↵";
var $560639d49e3c9a19$var$cross = "✗";
var $560639d49e3c9a19$var$cscr = "𝒸";
var $560639d49e3c9a19$var$csub = "⫏";
var $560639d49e3c9a19$var$csube = "⫑";
var $560639d49e3c9a19$var$csup = "⫐";
var $560639d49e3c9a19$var$csupe = "⫒";
var $560639d49e3c9a19$var$ctdot = "⋯";
var $560639d49e3c9a19$var$cudarrl = "⤸";
var $560639d49e3c9a19$var$cudarrr = "⤵";
var $560639d49e3c9a19$var$cuepr = "⋞";
var $560639d49e3c9a19$var$cuesc = "⋟";
var $560639d49e3c9a19$var$cularr = "↶";
var $560639d49e3c9a19$var$cularrp = "⤽";
var $560639d49e3c9a19$var$cup$1 = "∪";
var $560639d49e3c9a19$var$cupbrcap = "⩈";
var $560639d49e3c9a19$var$cupcap = "⩆";
var $560639d49e3c9a19$var$cupcup = "⩊";
var $560639d49e3c9a19$var$cupdot = "⊍";
var $560639d49e3c9a19$var$cupor = "⩅";
var $560639d49e3c9a19$var$cups = "∪︀";
var $560639d49e3c9a19$var$curarr = "↷";
var $560639d49e3c9a19$var$curarrm = "⤼";
var $560639d49e3c9a19$var$curlyeqprec = "⋞";
var $560639d49e3c9a19$var$curlyeqsucc = "⋟";
var $560639d49e3c9a19$var$curlyvee = "⋎";
var $560639d49e3c9a19$var$curlywedge = "⋏";
var $560639d49e3c9a19$var$curre = "¤";
var $560639d49e3c9a19$var$curren$1 = "¤";
var $560639d49e3c9a19$var$curvearrowleft = "↶";
var $560639d49e3c9a19$var$curvearrowright = "↷";
var $560639d49e3c9a19$var$cuvee = "⋎";
var $560639d49e3c9a19$var$cuwed = "⋏";
var $560639d49e3c9a19$var$cwconint = "∲";
var $560639d49e3c9a19$var$cwint = "∱";
var $560639d49e3c9a19$var$cylcty = "⌭";
var $560639d49e3c9a19$var$dArr$1 = "⇓";
var $560639d49e3c9a19$var$dHar = "⥥";
var $560639d49e3c9a19$var$dagger$1 = "†";
var $560639d49e3c9a19$var$daleth = "ℸ";
var $560639d49e3c9a19$var$darr$1 = "↓";
var $560639d49e3c9a19$var$dash$8 = "‐";
var $560639d49e3c9a19$var$dashv = "⊣";
var $560639d49e3c9a19$var$dbkarow = "⤏";
var $560639d49e3c9a19$var$dblac = "˝";
var $560639d49e3c9a19$var$dcaron = "ď";
var $560639d49e3c9a19$var$dcy = "д";
var $560639d49e3c9a19$var$dd$1 = "ⅆ";
var $560639d49e3c9a19$var$ddagger = "‡";
var $560639d49e3c9a19$var$ddarr = "⇊";
var $560639d49e3c9a19$var$ddotseq = "⩷";
var $560639d49e3c9a19$var$de = "°";
var $560639d49e3c9a19$var$deg$1 = "°";
var $560639d49e3c9a19$var$delta$1 = "δ";
var $560639d49e3c9a19$var$demptyv = "⦱";
var $560639d49e3c9a19$var$dfisht = "⥿";
var $560639d49e3c9a19$var$dfr = "𝔡";
var $560639d49e3c9a19$var$dharl = "⇃";
var $560639d49e3c9a19$var$dharr = "⇂";
var $560639d49e3c9a19$var$diam = "⋄";
var $560639d49e3c9a19$var$diamond = "⋄";
var $560639d49e3c9a19$var$diamondsuit = "♦";
var $560639d49e3c9a19$var$diams$1 = "♦";
var $560639d49e3c9a19$var$die = "¨";
var $560639d49e3c9a19$var$digamma = "ϝ";
var $560639d49e3c9a19$var$disin = "⋲";
var $560639d49e3c9a19$var$div = "÷";
var $560639d49e3c9a19$var$divid = "÷";
var $560639d49e3c9a19$var$divide$1 = "÷";
var $560639d49e3c9a19$var$divideontimes = "⋇";
var $560639d49e3c9a19$var$divonx = "⋇";
var $560639d49e3c9a19$var$djcy = "ђ";
var $560639d49e3c9a19$var$dlcorn = "⌞";
var $560639d49e3c9a19$var$dlcrop = "⌍";
var $560639d49e3c9a19$var$dollar = "$";
var $560639d49e3c9a19$var$dopf = "𝕕";
var $560639d49e3c9a19$var$dot$4 = "˙";
var $560639d49e3c9a19$var$doteq = "≐";
var $560639d49e3c9a19$var$doteqdot = "≑";
var $560639d49e3c9a19$var$dotminus = "∸";
var $560639d49e3c9a19$var$dotplus = "∔";
var $560639d49e3c9a19$var$dotsquare = "⊡";
var $560639d49e3c9a19$var$doublebarwedge = "⌆";
var $560639d49e3c9a19$var$downarrow = "↓";
var $560639d49e3c9a19$var$downdownarrows = "⇊";
var $560639d49e3c9a19$var$downharpoonleft = "⇃";
var $560639d49e3c9a19$var$downharpoonright = "⇂";
var $560639d49e3c9a19$var$drbkarow = "⤐";
var $560639d49e3c9a19$var$drcorn = "⌟";
var $560639d49e3c9a19$var$drcrop = "⌌";
var $560639d49e3c9a19$var$dscr = "𝒹";
var $560639d49e3c9a19$var$dscy = "ѕ";
var $560639d49e3c9a19$var$dsol = "⧶";
var $560639d49e3c9a19$var$dstrok = "đ";
var $560639d49e3c9a19$var$dtdot = "⋱";
var $560639d49e3c9a19$var$dtri = "▿";
var $560639d49e3c9a19$var$dtrif = "▾";
var $560639d49e3c9a19$var$duarr = "⇵";
var $560639d49e3c9a19$var$duhar = "⥯";
var $560639d49e3c9a19$var$dwangle = "⦦";
var $560639d49e3c9a19$var$dzcy = "џ";
var $560639d49e3c9a19$var$dzigrarr = "⟿";
var $560639d49e3c9a19$var$eDDot = "⩷";
var $560639d49e3c9a19$var$eDot = "≑";
var $560639d49e3c9a19$var$eacut = "é";
var $560639d49e3c9a19$var$eacute$1 = "é";
var $560639d49e3c9a19$var$easter = "⩮";
var $560639d49e3c9a19$var$ecaron = "ě";
var $560639d49e3c9a19$var$ecir = "ê";
var $560639d49e3c9a19$var$ecirc$1 = "ê";
var $560639d49e3c9a19$var$ecolon = "≕";
var $560639d49e3c9a19$var$ecy = "э";
var $560639d49e3c9a19$var$edot = "ė";
var $560639d49e3c9a19$var$ee = "ⅇ";
var $560639d49e3c9a19$var$efDot = "≒";
var $560639d49e3c9a19$var$efr = "𝔢";
var $560639d49e3c9a19$var$eg = "⪚";
var $560639d49e3c9a19$var$egrav = "è";
var $560639d49e3c9a19$var$egrave$1 = "è";
var $560639d49e3c9a19$var$egs = "⪖";
var $560639d49e3c9a19$var$egsdot = "⪘";
var $560639d49e3c9a19$var$el = "⪙";
var $560639d49e3c9a19$var$elinters = "⏧";
var $560639d49e3c9a19$var$ell = "ℓ";
var $560639d49e3c9a19$var$els = "⪕";
var $560639d49e3c9a19$var$elsdot = "⪗";
var $560639d49e3c9a19$var$emacr = "ē";
var $560639d49e3c9a19$var$empty$3 = "∅";
var $560639d49e3c9a19$var$emptyset = "∅";
var $560639d49e3c9a19$var$emptyv = "∅";
var $560639d49e3c9a19$var$emsp13 = " ";
var $560639d49e3c9a19$var$emsp14 = " ";
var $560639d49e3c9a19$var$emsp$1 = " ";
var $560639d49e3c9a19$var$eng = "ŋ";
var $560639d49e3c9a19$var$ensp$1 = " ";
var $560639d49e3c9a19$var$eogon = "ę";
var $560639d49e3c9a19$var$eopf = "𝕖";
var $560639d49e3c9a19$var$epar = "⋕";
var $560639d49e3c9a19$var$eparsl = "⧣";
var $560639d49e3c9a19$var$eplus = "⩱";
var $560639d49e3c9a19$var$epsi = "ε";
var $560639d49e3c9a19$var$epsilon$1 = "ε";
var $560639d49e3c9a19$var$epsiv = "ϵ";
var $560639d49e3c9a19$var$eqcirc = "≖";
var $560639d49e3c9a19$var$eqcolon = "≕";
var $560639d49e3c9a19$var$eqsim = "≂";
var $560639d49e3c9a19$var$eqslantgtr = "⪖";
var $560639d49e3c9a19$var$eqslantless = "⪕";
var $560639d49e3c9a19$var$equals = "=";
var $560639d49e3c9a19$var$equest = "≟";
var $560639d49e3c9a19$var$equiv$1 = "≡";
var $560639d49e3c9a19$var$equivDD = "⩸";
var $560639d49e3c9a19$var$eqvparsl = "⧥";
var $560639d49e3c9a19$var$erDot = "≓";
var $560639d49e3c9a19$var$erarr = "⥱";
var $560639d49e3c9a19$var$escr = "ℯ";
var $560639d49e3c9a19$var$esdot = "≐";
var $560639d49e3c9a19$var$esim = "≂";
var $560639d49e3c9a19$var$eta$1 = "η";
var $560639d49e3c9a19$var$et = "ð";
var $560639d49e3c9a19$var$eth$1 = "ð";
var $560639d49e3c9a19$var$eum = "ë";
var $560639d49e3c9a19$var$euml$1 = "ë";
var $560639d49e3c9a19$var$euro$1 = "€";
var $560639d49e3c9a19$var$excl = "!";
var $560639d49e3c9a19$var$exist$1 = "∃";
var $560639d49e3c9a19$var$expectation = "ℰ";
var $560639d49e3c9a19$var$exponentiale = "ⅇ";
var $560639d49e3c9a19$var$fallingdotseq = "≒";
var $560639d49e3c9a19$var$fcy = "ф";
var $560639d49e3c9a19$var$female = "♀";
var $560639d49e3c9a19$var$ffilig = "ﬃ";
var $560639d49e3c9a19$var$fflig = "ﬀ";
var $560639d49e3c9a19$var$ffllig = "ﬄ";
var $560639d49e3c9a19$var$ffr = "𝔣";
var $560639d49e3c9a19$var$filig = "ﬁ";
var $560639d49e3c9a19$var$fjlig = "fj";
var $560639d49e3c9a19$var$flat = "♭";
var $560639d49e3c9a19$var$fllig = "ﬂ";
var $560639d49e3c9a19$var$fltns = "▱";
var $560639d49e3c9a19$var$fnof$1 = "ƒ";
var $560639d49e3c9a19$var$fopf = "𝕗";
var $560639d49e3c9a19$var$forall$1 = "∀";
var $560639d49e3c9a19$var$fork = "⋔";
var $560639d49e3c9a19$var$forkv = "⫙";
var $560639d49e3c9a19$var$fpartint = "⨍";
var $560639d49e3c9a19$var$frac1 = "¼";
var $560639d49e3c9a19$var$frac12$1 = "½";
var $560639d49e3c9a19$var$frac13 = "⅓";
var $560639d49e3c9a19$var$frac14$1 = "¼";
var $560639d49e3c9a19$var$frac15 = "⅕";
var $560639d49e3c9a19$var$frac16 = "⅙";
var $560639d49e3c9a19$var$frac18 = "⅛";
var $560639d49e3c9a19$var$frac23 = "⅔";
var $560639d49e3c9a19$var$frac25 = "⅖";
var $560639d49e3c9a19$var$frac3 = "¾";
var $560639d49e3c9a19$var$frac34$1 = "¾";
var $560639d49e3c9a19$var$frac35 = "⅗";
var $560639d49e3c9a19$var$frac38 = "⅜";
var $560639d49e3c9a19$var$frac45 = "⅘";
var $560639d49e3c9a19$var$frac56 = "⅚";
var $560639d49e3c9a19$var$frac58 = "⅝";
var $560639d49e3c9a19$var$frac78 = "⅞";
var $560639d49e3c9a19$var$frasl$1 = "⁄";
var $560639d49e3c9a19$var$frown = "⌢";
var $560639d49e3c9a19$var$fscr = "𝒻";
var $560639d49e3c9a19$var$gE = "≧";
var $560639d49e3c9a19$var$gEl = "⪌";
var $560639d49e3c9a19$var$gacute = "ǵ";
var $560639d49e3c9a19$var$gamma$1 = "γ";
var $560639d49e3c9a19$var$gammad = "ϝ";
var $560639d49e3c9a19$var$gap = "⪆";
var $560639d49e3c9a19$var$gbreve = "ğ";
var $560639d49e3c9a19$var$gcirc = "ĝ";
var $560639d49e3c9a19$var$gcy = "г";
var $560639d49e3c9a19$var$gdot = "ġ";
var $560639d49e3c9a19$var$ge$1 = "≥";
var $560639d49e3c9a19$var$gel = "⋛";
var $560639d49e3c9a19$var$geq = "≥";
var $560639d49e3c9a19$var$geqq = "≧";
var $560639d49e3c9a19$var$geqslant = "⩾";
var $560639d49e3c9a19$var$ges = "⩾";
var $560639d49e3c9a19$var$gescc = "⪩";
var $560639d49e3c9a19$var$gesdot = "⪀";
var $560639d49e3c9a19$var$gesdoto = "⪂";
var $560639d49e3c9a19$var$gesdotol = "⪄";
var $560639d49e3c9a19$var$gesl = "⋛︀";
var $560639d49e3c9a19$var$gesles = "⪔";
var $560639d49e3c9a19$var$gfr = "𝔤";
var $560639d49e3c9a19$var$gg = "≫";
var $560639d49e3c9a19$var$ggg = "⋙";
var $560639d49e3c9a19$var$gimel = "ℷ";
var $560639d49e3c9a19$var$gjcy = "ѓ";
var $560639d49e3c9a19$var$gl = "≷";
var $560639d49e3c9a19$var$glE = "⪒";
var $560639d49e3c9a19$var$gla = "⪥";
var $560639d49e3c9a19$var$glj = "⪤";
var $560639d49e3c9a19$var$gnE = "≩";
var $560639d49e3c9a19$var$gnap = "⪊";
var $560639d49e3c9a19$var$gnapprox = "⪊";
var $560639d49e3c9a19$var$gne = "⪈";
var $560639d49e3c9a19$var$gneq = "⪈";
var $560639d49e3c9a19$var$gneqq = "≩";
var $560639d49e3c9a19$var$gnsim = "⋧";
var $560639d49e3c9a19$var$gopf = "𝕘";
var $560639d49e3c9a19$var$grave = "`";
var $560639d49e3c9a19$var$gscr = "ℊ";
var $560639d49e3c9a19$var$gsim = "≳";
var $560639d49e3c9a19$var$gsime = "⪎";
var $560639d49e3c9a19$var$gsiml = "⪐";
var $560639d49e3c9a19$var$g = ">";
var $560639d49e3c9a19$var$gt$1 = ">";
var $560639d49e3c9a19$var$gtcc = "⪧";
var $560639d49e3c9a19$var$gtcir = "⩺";
var $560639d49e3c9a19$var$gtdot = "⋗";
var $560639d49e3c9a19$var$gtlPar = "⦕";
var $560639d49e3c9a19$var$gtquest = "⩼";
var $560639d49e3c9a19$var$gtrapprox = "⪆";
var $560639d49e3c9a19$var$gtrarr = "⥸";
var $560639d49e3c9a19$var$gtrdot = "⋗";
var $560639d49e3c9a19$var$gtreqless = "⋛";
var $560639d49e3c9a19$var$gtreqqless = "⪌";
var $560639d49e3c9a19$var$gtrless = "≷";
var $560639d49e3c9a19$var$gtrsim = "≳";
var $560639d49e3c9a19$var$gvertneqq = "≩︀";
var $560639d49e3c9a19$var$gvnE = "≩︀";
var $560639d49e3c9a19$var$hArr$1 = "⇔";
var $560639d49e3c9a19$var$hairsp = " ";
var $560639d49e3c9a19$var$half = "½";
var $560639d49e3c9a19$var$hamilt = "ℋ";
var $560639d49e3c9a19$var$hardcy = "ъ";
var $560639d49e3c9a19$var$harr$1 = "↔";
var $560639d49e3c9a19$var$harrcir = "⥈";
var $560639d49e3c9a19$var$harrw = "↭";
var $560639d49e3c9a19$var$hbar = "ℏ";
var $560639d49e3c9a19$var$hcirc = "ĥ";
var $560639d49e3c9a19$var$hearts$1 = "♥";
var $560639d49e3c9a19$var$heartsuit = "♥";
var $560639d49e3c9a19$var$hellip$1 = "…";
var $560639d49e3c9a19$var$hercon = "⊹";
var $560639d49e3c9a19$var$hfr = "𝔥";
var $560639d49e3c9a19$var$hksearow = "⤥";
var $560639d49e3c9a19$var$hkswarow = "⤦";
var $560639d49e3c9a19$var$hoarr = "⇿";
var $560639d49e3c9a19$var$homtht = "∻";
var $560639d49e3c9a19$var$hookleftarrow = "↩";
var $560639d49e3c9a19$var$hookrightarrow = "↪";
var $560639d49e3c9a19$var$hopf = "𝕙";
var $560639d49e3c9a19$var$horbar = "―";
var $560639d49e3c9a19$var$hscr = "𝒽";
var $560639d49e3c9a19$var$hslash = "ℏ";
var $560639d49e3c9a19$var$hstrok = "ħ";
var $560639d49e3c9a19$var$hybull = "⁃";
var $560639d49e3c9a19$var$hyphen = "‐";
var $560639d49e3c9a19$var$iacut = "í";
var $560639d49e3c9a19$var$iacute$1 = "í";
var $560639d49e3c9a19$var$ic = "⁣";
var $560639d49e3c9a19$var$icir = "î";
var $560639d49e3c9a19$var$icirc$1 = "î";
var $560639d49e3c9a19$var$icy = "и";
var $560639d49e3c9a19$var$iecy = "е";
var $560639d49e3c9a19$var$iexc = "¡";
var $560639d49e3c9a19$var$iexcl$1 = "¡";
var $560639d49e3c9a19$var$iff = "⇔";
var $560639d49e3c9a19$var$ifr = "𝔦";
var $560639d49e3c9a19$var$igrav = "ì";
var $560639d49e3c9a19$var$igrave$1 = "ì";
var $560639d49e3c9a19$var$ii = "ⅈ";
var $560639d49e3c9a19$var$iiiint = "⨌";
var $560639d49e3c9a19$var$iiint = "∭";
var $560639d49e3c9a19$var$iinfin = "⧜";
var $560639d49e3c9a19$var$iiota = "℩";
var $560639d49e3c9a19$var$ijlig = "ĳ";
var $560639d49e3c9a19$var$imacr = "ī";
var $560639d49e3c9a19$var$image$3 = "ℑ";
var $560639d49e3c9a19$var$imagline = "ℐ";
var $560639d49e3c9a19$var$imagpart = "ℑ";
var $560639d49e3c9a19$var$imath = "ı";
var $560639d49e3c9a19$var$imof = "⊷";
var $560639d49e3c9a19$var$imped = "Ƶ";
var $560639d49e3c9a19$var$incare = "℅";
var $560639d49e3c9a19$var$infin$1 = "∞";
var $560639d49e3c9a19$var$infintie = "⧝";
var $560639d49e3c9a19$var$inodot = "ı";
var $560639d49e3c9a19$var$int$1 = "∫";
var $560639d49e3c9a19$var$intcal = "⊺";
var $560639d49e3c9a19$var$integers = "ℤ";
var $560639d49e3c9a19$var$intercal = "⊺";
var $560639d49e3c9a19$var$intlarhk = "⨗";
var $560639d49e3c9a19$var$intprod = "⨼";
var $560639d49e3c9a19$var$iocy = "ё";
var $560639d49e3c9a19$var$iogon = "į";
var $560639d49e3c9a19$var$iopf = "𝕚";
var $560639d49e3c9a19$var$iota$1 = "ι";
var $560639d49e3c9a19$var$iprod = "⨼";
var $560639d49e3c9a19$var$iques = "¿";
var $560639d49e3c9a19$var$iquest$1 = "¿";
var $560639d49e3c9a19$var$iscr = "𝒾";
var $560639d49e3c9a19$var$isin$1 = "∈";
var $560639d49e3c9a19$var$isinE = "⋹";
var $560639d49e3c9a19$var$isindot = "⋵";
var $560639d49e3c9a19$var$isins = "⋴";
var $560639d49e3c9a19$var$isinsv = "⋳";
var $560639d49e3c9a19$var$isinv = "∈";
var $560639d49e3c9a19$var$it = "⁢";
var $560639d49e3c9a19$var$itilde = "ĩ";
var $560639d49e3c9a19$var$iukcy = "і";
var $560639d49e3c9a19$var$ium = "ï";
var $560639d49e3c9a19$var$iuml$1 = "ï";
var $560639d49e3c9a19$var$jcirc = "ĵ";
var $560639d49e3c9a19$var$jcy = "й";
var $560639d49e3c9a19$var$jfr = "𝔧";
var $560639d49e3c9a19$var$jmath = "ȷ";
var $560639d49e3c9a19$var$jopf = "𝕛";
var $560639d49e3c9a19$var$jscr = "𝒿";
var $560639d49e3c9a19$var$jsercy = "ј";
var $560639d49e3c9a19$var$jukcy = "є";
var $560639d49e3c9a19$var$kappa$1 = "κ";
var $560639d49e3c9a19$var$kappav = "ϰ";
var $560639d49e3c9a19$var$kcedil = "ķ";
var $560639d49e3c9a19$var$kcy = "к";
var $560639d49e3c9a19$var$kfr = "𝔨";
var $560639d49e3c9a19$var$kgreen = "ĸ";
var $560639d49e3c9a19$var$khcy = "х";
var $560639d49e3c9a19$var$kjcy = "ќ";
var $560639d49e3c9a19$var$kopf = "𝕜";
var $560639d49e3c9a19$var$kscr = "𝓀";
var $560639d49e3c9a19$var$lAarr = "⇚";
var $560639d49e3c9a19$var$lArr$1 = "⇐";
var $560639d49e3c9a19$var$lAtail = "⤛";
var $560639d49e3c9a19$var$lBarr = "⤎";
var $560639d49e3c9a19$var$lE = "≦";
var $560639d49e3c9a19$var$lEg = "⪋";
var $560639d49e3c9a19$var$lHar = "⥢";
var $560639d49e3c9a19$var$lacute = "ĺ";
var $560639d49e3c9a19$var$laemptyv = "⦴";
var $560639d49e3c9a19$var$lagran = "ℒ";
var $560639d49e3c9a19$var$lambda$1 = "λ";
var $560639d49e3c9a19$var$lang$1 = "⟨";
var $560639d49e3c9a19$var$langd = "⦑";
var $560639d49e3c9a19$var$langle = "⟨";
var $560639d49e3c9a19$var$lap = "⪅";
var $560639d49e3c9a19$var$laqu = "«";
var $560639d49e3c9a19$var$laquo$1 = "«";
var $560639d49e3c9a19$var$larr$1 = "←";
var $560639d49e3c9a19$var$larrb = "⇤";
var $560639d49e3c9a19$var$larrbfs = "⤟";
var $560639d49e3c9a19$var$larrfs = "⤝";
var $560639d49e3c9a19$var$larrhk = "↩";
var $560639d49e3c9a19$var$larrlp = "↫";
var $560639d49e3c9a19$var$larrpl = "⤹";
var $560639d49e3c9a19$var$larrsim = "⥳";
var $560639d49e3c9a19$var$larrtl = "↢";
var $560639d49e3c9a19$var$lat = "⪫";
var $560639d49e3c9a19$var$latail = "⤙";
var $560639d49e3c9a19$var$late = "⪭";
var $560639d49e3c9a19$var$lates = "⪭︀";
var $560639d49e3c9a19$var$lbarr = "⤌";
var $560639d49e3c9a19$var$lbbrk = "❲";
var $560639d49e3c9a19$var$lbrace = "{";
var $560639d49e3c9a19$var$lbrack = "[";
var $560639d49e3c9a19$var$lbrke = "⦋";
var $560639d49e3c9a19$var$lbrksld = "⦏";
var $560639d49e3c9a19$var$lbrkslu = "⦍";
var $560639d49e3c9a19$var$lcaron = "ľ";
var $560639d49e3c9a19$var$lcedil = "ļ";
var $560639d49e3c9a19$var$lceil$1 = "⌈";
var $560639d49e3c9a19$var$lcub = "{";
var $560639d49e3c9a19$var$lcy = "л";
var $560639d49e3c9a19$var$ldca = "⤶";
var $560639d49e3c9a19$var$ldquo$1 = "“";
var $560639d49e3c9a19$var$ldquor = "„";
var $560639d49e3c9a19$var$ldrdhar = "⥧";
var $560639d49e3c9a19$var$ldrushar = "⥋";
var $560639d49e3c9a19$var$ldsh = "↲";
var $560639d49e3c9a19$var$le$1 = "≤";
var $560639d49e3c9a19$var$leftarrow = "←";
var $560639d49e3c9a19$var$leftarrowtail = "↢";
var $560639d49e3c9a19$var$leftharpoondown = "↽";
var $560639d49e3c9a19$var$leftharpoonup = "↼";
var $560639d49e3c9a19$var$leftleftarrows = "⇇";
var $560639d49e3c9a19$var$leftrightarrow = "↔";
var $560639d49e3c9a19$var$leftrightarrows = "⇆";
var $560639d49e3c9a19$var$leftrightharpoons = "⇋";
var $560639d49e3c9a19$var$leftrightsquigarrow = "↭";
var $560639d49e3c9a19$var$leftthreetimes = "⋋";
var $560639d49e3c9a19$var$leg = "⋚";
var $560639d49e3c9a19$var$leq = "≤";
var $560639d49e3c9a19$var$leqq = "≦";
var $560639d49e3c9a19$var$leqslant = "⩽";
var $560639d49e3c9a19$var$les = "⩽";
var $560639d49e3c9a19$var$lescc = "⪨";
var $560639d49e3c9a19$var$lesdot = "⩿";
var $560639d49e3c9a19$var$lesdoto = "⪁";
var $560639d49e3c9a19$var$lesdotor = "⪃";
var $560639d49e3c9a19$var$lesg = "⋚︀";
var $560639d49e3c9a19$var$lesges = "⪓";
var $560639d49e3c9a19$var$lessapprox = "⪅";
var $560639d49e3c9a19$var$lessdot = "⋖";
var $560639d49e3c9a19$var$lesseqgtr = "⋚";
var $560639d49e3c9a19$var$lesseqqgtr = "⪋";
var $560639d49e3c9a19$var$lessgtr = "≶";
var $560639d49e3c9a19$var$lesssim = "≲";
var $560639d49e3c9a19$var$lfisht = "⥼";
var $560639d49e3c9a19$var$lfloor$1 = "⌊";
var $560639d49e3c9a19$var$lfr = "𝔩";
var $560639d49e3c9a19$var$lg = "≶";
var $560639d49e3c9a19$var$lgE = "⪑";
var $560639d49e3c9a19$var$lhard = "↽";
var $560639d49e3c9a19$var$lharu = "↼";
var $560639d49e3c9a19$var$lharul = "⥪";
var $560639d49e3c9a19$var$lhblk = "▄";
var $560639d49e3c9a19$var$ljcy = "љ";
var $560639d49e3c9a19$var$ll = "≪";
var $560639d49e3c9a19$var$llarr = "⇇";
var $560639d49e3c9a19$var$llcorner = "⌞";
var $560639d49e3c9a19$var$llhard = "⥫";
var $560639d49e3c9a19$var$lltri = "◺";
var $560639d49e3c9a19$var$lmidot = "ŀ";
var $560639d49e3c9a19$var$lmoust = "⎰";
var $560639d49e3c9a19$var$lmoustache = "⎰";
var $560639d49e3c9a19$var$lnE = "≨";
var $560639d49e3c9a19$var$lnap = "⪉";
var $560639d49e3c9a19$var$lnapprox = "⪉";
var $560639d49e3c9a19$var$lne = "⪇";
var $560639d49e3c9a19$var$lneq = "⪇";
var $560639d49e3c9a19$var$lneqq = "≨";
var $560639d49e3c9a19$var$lnsim = "⋦";
var $560639d49e3c9a19$var$loang = "⟬";
var $560639d49e3c9a19$var$loarr = "⇽";
var $560639d49e3c9a19$var$lobrk = "⟦";
var $560639d49e3c9a19$var$longleftarrow = "⟵";
var $560639d49e3c9a19$var$longleftrightarrow = "⟷";
var $560639d49e3c9a19$var$longmapsto = "⟼";
var $560639d49e3c9a19$var$longrightarrow = "⟶";
var $560639d49e3c9a19$var$looparrowleft = "↫";
var $560639d49e3c9a19$var$looparrowright = "↬";
var $560639d49e3c9a19$var$lopar = "⦅";
var $560639d49e3c9a19$var$lopf = "𝕝";
var $560639d49e3c9a19$var$loplus = "⨭";
var $560639d49e3c9a19$var$lotimes = "⨴";
var $560639d49e3c9a19$var$lowast$1 = "∗";
var $560639d49e3c9a19$var$lowbar = "_";
var $560639d49e3c9a19$var$loz$1 = "◊";
var $560639d49e3c9a19$var$lozenge = "◊";
var $560639d49e3c9a19$var$lozf = "⧫";
var $560639d49e3c9a19$var$lpar = "(";
var $560639d49e3c9a19$var$lparlt = "⦓";
var $560639d49e3c9a19$var$lrarr = "⇆";
var $560639d49e3c9a19$var$lrcorner = "⌟";
var $560639d49e3c9a19$var$lrhar = "⇋";
var $560639d49e3c9a19$var$lrhard = "⥭";
var $560639d49e3c9a19$var$lrm$1 = "‎";
var $560639d49e3c9a19$var$lrtri = "⊿";
var $560639d49e3c9a19$var$lsaquo$1 = "‹";
var $560639d49e3c9a19$var$lscr = "𝓁";
var $560639d49e3c9a19$var$lsh = "↰";
var $560639d49e3c9a19$var$lsim = "≲";
var $560639d49e3c9a19$var$lsime = "⪍";
var $560639d49e3c9a19$var$lsimg = "⪏";
var $560639d49e3c9a19$var$lsqb = "[";
var $560639d49e3c9a19$var$lsquo$1 = "‘";
var $560639d49e3c9a19$var$lsquor = "‚";
var $560639d49e3c9a19$var$lstrok = "ł";
var $560639d49e3c9a19$var$l = "<";
var $560639d49e3c9a19$var$lt$1 = "<";
var $560639d49e3c9a19$var$ltcc = "⪦";
var $560639d49e3c9a19$var$ltcir = "⩹";
var $560639d49e3c9a19$var$ltdot = "⋖";
var $560639d49e3c9a19$var$lthree = "⋋";
var $560639d49e3c9a19$var$ltimes = "⋉";
var $560639d49e3c9a19$var$ltlarr = "⥶";
var $560639d49e3c9a19$var$ltquest = "⩻";
var $560639d49e3c9a19$var$ltrPar = "⦖";
var $560639d49e3c9a19$var$ltri = "◃";
var $560639d49e3c9a19$var$ltrie = "⊴";
var $560639d49e3c9a19$var$ltrif = "◂";
var $560639d49e3c9a19$var$lurdshar = "⥊";
var $560639d49e3c9a19$var$luruhar = "⥦";
var $560639d49e3c9a19$var$lvertneqq = "≨︀";
var $560639d49e3c9a19$var$lvnE = "≨︀";
var $560639d49e3c9a19$var$mDDot = "∺";
var $560639d49e3c9a19$var$mac = "¯";
var $560639d49e3c9a19$var$macr$1 = "¯";
var $560639d49e3c9a19$var$male = "♂";
var $560639d49e3c9a19$var$malt = "✠";
var $560639d49e3c9a19$var$maltese = "✠";
var $560639d49e3c9a19$var$map$1 = "↦";
var $560639d49e3c9a19$var$mapsto = "↦";
var $560639d49e3c9a19$var$mapstodown = "↧";
var $560639d49e3c9a19$var$mapstoleft = "↤";
var $560639d49e3c9a19$var$mapstoup = "↥";
var $560639d49e3c9a19$var$marker = "▮";
var $560639d49e3c9a19$var$mcomma = "⨩";
var $560639d49e3c9a19$var$mcy = "м";
var $560639d49e3c9a19$var$mdash$1 = "—";
var $560639d49e3c9a19$var$measuredangle = "∡";
var $560639d49e3c9a19$var$mfr = "𝔪";
var $560639d49e3c9a19$var$mho = "℧";
var $560639d49e3c9a19$var$micr = "µ";
var $560639d49e3c9a19$var$micro$1 = "µ";
var $560639d49e3c9a19$var$mid = "∣";
var $560639d49e3c9a19$var$midast = "*";
var $560639d49e3c9a19$var$midcir = "⫰";
var $560639d49e3c9a19$var$middo = "·";
var $560639d49e3c9a19$var$middot$1 = "·";
var $560639d49e3c9a19$var$minus$1 = "−";
var $560639d49e3c9a19$var$minusb = "⊟";
var $560639d49e3c9a19$var$minusd = "∸";
var $560639d49e3c9a19$var$minusdu = "⨪";
var $560639d49e3c9a19$var$mlcp = "⫛";
var $560639d49e3c9a19$var$mldr = "…";
var $560639d49e3c9a19$var$mnplus = "∓";
var $560639d49e3c9a19$var$models = "⊧";
var $560639d49e3c9a19$var$mopf = "𝕞";
var $560639d49e3c9a19$var$mp = "∓";
var $560639d49e3c9a19$var$mscr = "𝓂";
var $560639d49e3c9a19$var$mstpos = "∾";
var $560639d49e3c9a19$var$mu$1 = "μ";
var $560639d49e3c9a19$var$multimap = "⊸";
var $560639d49e3c9a19$var$mumap = "⊸";
var $560639d49e3c9a19$var$nGg = "⋙̸";
var $560639d49e3c9a19$var$nGt = "≫⃒";
var $560639d49e3c9a19$var$nGtv = "≫̸";
var $560639d49e3c9a19$var$nLeftarrow = "⇍";
var $560639d49e3c9a19$var$nLeftrightarrow = "⇎";
var $560639d49e3c9a19$var$nLl = "⋘̸";
var $560639d49e3c9a19$var$nLt = "≪⃒";
var $560639d49e3c9a19$var$nLtv = "≪̸";
var $560639d49e3c9a19$var$nRightarrow = "⇏";
var $560639d49e3c9a19$var$nVDash = "⊯";
var $560639d49e3c9a19$var$nVdash = "⊮";
var $560639d49e3c9a19$var$nabla$1 = "∇";
var $560639d49e3c9a19$var$nacute = "ń";
var $560639d49e3c9a19$var$nang = "∠⃒";
var $560639d49e3c9a19$var$nap = "≉";
var $560639d49e3c9a19$var$napE = "⩰̸";
var $560639d49e3c9a19$var$napid = "≋̸";
var $560639d49e3c9a19$var$napos = "ŉ";
var $560639d49e3c9a19$var$napprox = "≉";
var $560639d49e3c9a19$var$natur = "♮";
var $560639d49e3c9a19$var$natural = "♮";
var $560639d49e3c9a19$var$naturals = "ℕ";
var $560639d49e3c9a19$var$nbs = " ";
var $560639d49e3c9a19$var$nbsp$1 = " ";
var $560639d49e3c9a19$var$nbump = "≎̸";
var $560639d49e3c9a19$var$nbumpe = "≏̸";
var $560639d49e3c9a19$var$ncap = "⩃";
var $560639d49e3c9a19$var$ncaron = "ň";
var $560639d49e3c9a19$var$ncedil = "ņ";
var $560639d49e3c9a19$var$ncong = "≇";
var $560639d49e3c9a19$var$ncongdot = "⩭̸";
var $560639d49e3c9a19$var$ncup = "⩂";
var $560639d49e3c9a19$var$ncy = "н";
var $560639d49e3c9a19$var$ndash$1 = "–";
var $560639d49e3c9a19$var$ne$1 = "≠";
var $560639d49e3c9a19$var$neArr = "⇗";
var $560639d49e3c9a19$var$nearhk = "⤤";
var $560639d49e3c9a19$var$nearr = "↗";
var $560639d49e3c9a19$var$nearrow = "↗";
var $560639d49e3c9a19$var$nedot = "≐̸";
var $560639d49e3c9a19$var$nequiv = "≢";
var $560639d49e3c9a19$var$nesear = "⤨";
var $560639d49e3c9a19$var$nesim = "≂̸";
var $560639d49e3c9a19$var$nexist = "∄";
var $560639d49e3c9a19$var$nexists = "∄";
var $560639d49e3c9a19$var$nfr = "𝔫";
var $560639d49e3c9a19$var$ngE = "≧̸";
var $560639d49e3c9a19$var$nge = "≱";
var $560639d49e3c9a19$var$ngeq = "≱";
var $560639d49e3c9a19$var$ngeqq = "≧̸";
var $560639d49e3c9a19$var$ngeqslant = "⩾̸";
var $560639d49e3c9a19$var$nges = "⩾̸";
var $560639d49e3c9a19$var$ngsim = "≵";
var $560639d49e3c9a19$var$ngt = "≯";
var $560639d49e3c9a19$var$ngtr = "≯";
var $560639d49e3c9a19$var$nhArr = "⇎";
var $560639d49e3c9a19$var$nharr = "↮";
var $560639d49e3c9a19$var$nhpar = "⫲";
var $560639d49e3c9a19$var$ni$1 = "∋";
var $560639d49e3c9a19$var$nis = "⋼";
var $560639d49e3c9a19$var$nisd = "⋺";
var $560639d49e3c9a19$var$niv = "∋";
var $560639d49e3c9a19$var$njcy = "њ";
var $560639d49e3c9a19$var$nlArr = "⇍";
var $560639d49e3c9a19$var$nlE = "≦̸";
var $560639d49e3c9a19$var$nlarr = "↚";
var $560639d49e3c9a19$var$nldr = "‥";
var $560639d49e3c9a19$var$nle = "≰";
var $560639d49e3c9a19$var$nleftarrow = "↚";
var $560639d49e3c9a19$var$nleftrightarrow = "↮";
var $560639d49e3c9a19$var$nleq = "≰";
var $560639d49e3c9a19$var$nleqq = "≦̸";
var $560639d49e3c9a19$var$nleqslant = "⩽̸";
var $560639d49e3c9a19$var$nles = "⩽̸";
var $560639d49e3c9a19$var$nless = "≮";
var $560639d49e3c9a19$var$nlsim = "≴";
var $560639d49e3c9a19$var$nlt = "≮";
var $560639d49e3c9a19$var$nltri = "⋪";
var $560639d49e3c9a19$var$nltrie = "⋬";
var $560639d49e3c9a19$var$nmid = "∤";
var $560639d49e3c9a19$var$nopf = "𝕟";
var $560639d49e3c9a19$var$no = "¬";
var $560639d49e3c9a19$var$not$1 = "¬";
var $560639d49e3c9a19$var$notin$1 = "∉";
var $560639d49e3c9a19$var$notinE = "⋹̸";
var $560639d49e3c9a19$var$notindot = "⋵̸";
var $560639d49e3c9a19$var$notinva = "∉";
var $560639d49e3c9a19$var$notinvb = "⋷";
var $560639d49e3c9a19$var$notinvc = "⋶";
var $560639d49e3c9a19$var$notni = "∌";
var $560639d49e3c9a19$var$notniva = "∌";
var $560639d49e3c9a19$var$notnivb = "⋾";
var $560639d49e3c9a19$var$notnivc = "⋽";
var $560639d49e3c9a19$var$npar = "∦";
var $560639d49e3c9a19$var$nparallel = "∦";
var $560639d49e3c9a19$var$nparsl = "⫽⃥";
var $560639d49e3c9a19$var$npart = "∂̸";
var $560639d49e3c9a19$var$npolint = "⨔";
var $560639d49e3c9a19$var$npr = "⊀";
var $560639d49e3c9a19$var$nprcue = "⋠";
var $560639d49e3c9a19$var$npre = "⪯̸";
var $560639d49e3c9a19$var$nprec = "⊀";
var $560639d49e3c9a19$var$npreceq = "⪯̸";
var $560639d49e3c9a19$var$nrArr = "⇏";
var $560639d49e3c9a19$var$nrarr = "↛";
var $560639d49e3c9a19$var$nrarrc = "⤳̸";
var $560639d49e3c9a19$var$nrarrw = "↝̸";
var $560639d49e3c9a19$var$nrightarrow = "↛";
var $560639d49e3c9a19$var$nrtri = "⋫";
var $560639d49e3c9a19$var$nrtrie = "⋭";
var $560639d49e3c9a19$var$nsc = "⊁";
var $560639d49e3c9a19$var$nsccue = "⋡";
var $560639d49e3c9a19$var$nsce = "⪰̸";
var $560639d49e3c9a19$var$nscr = "𝓃";
var $560639d49e3c9a19$var$nshortmid = "∤";
var $560639d49e3c9a19$var$nshortparallel = "∦";
var $560639d49e3c9a19$var$nsim = "≁";
var $560639d49e3c9a19$var$nsime = "≄";
var $560639d49e3c9a19$var$nsimeq = "≄";
var $560639d49e3c9a19$var$nsmid = "∤";
var $560639d49e3c9a19$var$nspar = "∦";
var $560639d49e3c9a19$var$nsqsube = "⋢";
var $560639d49e3c9a19$var$nsqsupe = "⋣";
var $560639d49e3c9a19$var$nsub$1 = "⊄";
var $560639d49e3c9a19$var$nsubE = "⫅̸";
var $560639d49e3c9a19$var$nsube = "⊈";
var $560639d49e3c9a19$var$nsubset = "⊂⃒";
var $560639d49e3c9a19$var$nsubseteq = "⊈";
var $560639d49e3c9a19$var$nsubseteqq = "⫅̸";
var $560639d49e3c9a19$var$nsucc = "⊁";
var $560639d49e3c9a19$var$nsucceq = "⪰̸";
var $560639d49e3c9a19$var$nsup = "⊅";
var $560639d49e3c9a19$var$nsupE = "⫆̸";
var $560639d49e3c9a19$var$nsupe = "⊉";
var $560639d49e3c9a19$var$nsupset = "⊃⃒";
var $560639d49e3c9a19$var$nsupseteq = "⊉";
var $560639d49e3c9a19$var$nsupseteqq = "⫆̸";
var $560639d49e3c9a19$var$ntgl = "≹";
var $560639d49e3c9a19$var$ntild = "ñ";
var $560639d49e3c9a19$var$ntilde$1 = "ñ";
var $560639d49e3c9a19$var$ntlg = "≸";
var $560639d49e3c9a19$var$ntriangleleft = "⋪";
var $560639d49e3c9a19$var$ntrianglelefteq = "⋬";
var $560639d49e3c9a19$var$ntriangleright = "⋫";
var $560639d49e3c9a19$var$ntrianglerighteq = "⋭";
var $560639d49e3c9a19$var$nu$1 = "ν";
var $560639d49e3c9a19$var$num = "#";
var $560639d49e3c9a19$var$numero = "№";
var $560639d49e3c9a19$var$numsp = " ";
var $560639d49e3c9a19$var$nvDash = "⊭";
var $560639d49e3c9a19$var$nvHarr = "⤄";
var $560639d49e3c9a19$var$nvap = "≍⃒";
var $560639d49e3c9a19$var$nvdash = "⊬";
var $560639d49e3c9a19$var$nvge = "≥⃒";
var $560639d49e3c9a19$var$nvgt = ">⃒";
var $560639d49e3c9a19$var$nvinfin = "⧞";
var $560639d49e3c9a19$var$nvlArr = "⤂";
var $560639d49e3c9a19$var$nvle = "≤⃒";
var $560639d49e3c9a19$var$nvlt = "<⃒";
var $560639d49e3c9a19$var$nvltrie = "⊴⃒";
var $560639d49e3c9a19$var$nvrArr = "⤃";
var $560639d49e3c9a19$var$nvrtrie = "⊵⃒";
var $560639d49e3c9a19$var$nvsim = "∼⃒";
var $560639d49e3c9a19$var$nwArr = "⇖";
var $560639d49e3c9a19$var$nwarhk = "⤣";
var $560639d49e3c9a19$var$nwarr = "↖";
var $560639d49e3c9a19$var$nwarrow = "↖";
var $560639d49e3c9a19$var$nwnear = "⤧";
var $560639d49e3c9a19$var$oS = "Ⓢ";
var $560639d49e3c9a19$var$oacut = "ó";
var $560639d49e3c9a19$var$oacute$1 = "ó";
var $560639d49e3c9a19$var$oast = "⊛";
var $560639d49e3c9a19$var$ocir = "ô";
var $560639d49e3c9a19$var$ocirc$1 = "ô";
var $560639d49e3c9a19$var$ocy = "о";
var $560639d49e3c9a19$var$odash = "⊝";
var $560639d49e3c9a19$var$odblac = "ő";
var $560639d49e3c9a19$var$odiv = "⨸";
var $560639d49e3c9a19$var$odot = "⊙";
var $560639d49e3c9a19$var$odsold = "⦼";
var $560639d49e3c9a19$var$oelig$1 = "œ";
var $560639d49e3c9a19$var$ofcir = "⦿";
var $560639d49e3c9a19$var$ofr = "𝔬";
var $560639d49e3c9a19$var$ogon = "˛";
var $560639d49e3c9a19$var$ograv = "ò";
var $560639d49e3c9a19$var$ograve$1 = "ò";
var $560639d49e3c9a19$var$ogt = "⧁";
var $560639d49e3c9a19$var$ohbar = "⦵";
var $560639d49e3c9a19$var$ohm = "Ω";
var $560639d49e3c9a19$var$oint = "∮";
var $560639d49e3c9a19$var$olarr = "↺";
var $560639d49e3c9a19$var$olcir = "⦾";
var $560639d49e3c9a19$var$olcross = "⦻";
var $560639d49e3c9a19$var$oline$1 = "‾";
var $560639d49e3c9a19$var$olt = "⧀";
var $560639d49e3c9a19$var$omacr = "ō";
var $560639d49e3c9a19$var$omega$1 = "ω";
var $560639d49e3c9a19$var$omicron$1 = "ο";
var $560639d49e3c9a19$var$omid = "⦶";
var $560639d49e3c9a19$var$ominus = "⊖";
var $560639d49e3c9a19$var$oopf = "𝕠";
var $560639d49e3c9a19$var$opar = "⦷";
var $560639d49e3c9a19$var$operp = "⦹";
var $560639d49e3c9a19$var$oplus$1 = "⊕";
var $560639d49e3c9a19$var$or$1 = "∨";
var $560639d49e3c9a19$var$orarr = "↻";
var $560639d49e3c9a19$var$ord = "º";
var $560639d49e3c9a19$var$order = "ℴ";
var $560639d49e3c9a19$var$orderof = "ℴ";
var $560639d49e3c9a19$var$ordf$1 = "ª";
var $560639d49e3c9a19$var$ordm$1 = "º";
var $560639d49e3c9a19$var$origof = "⊶";
var $560639d49e3c9a19$var$oror = "⩖";
var $560639d49e3c9a19$var$orslope = "⩗";
var $560639d49e3c9a19$var$orv = "⩛";
var $560639d49e3c9a19$var$oscr = "ℴ";
var $560639d49e3c9a19$var$oslas = "ø";
var $560639d49e3c9a19$var$oslash$1 = "ø";
var $560639d49e3c9a19$var$osol = "⊘";
var $560639d49e3c9a19$var$otild = "õ";
var $560639d49e3c9a19$var$otilde$1 = "õ";
var $560639d49e3c9a19$var$otimes$1 = "⊗";
var $560639d49e3c9a19$var$otimesas = "⨶";
var $560639d49e3c9a19$var$oum = "ö";
var $560639d49e3c9a19$var$ouml$1 = "ö";
var $560639d49e3c9a19$var$ovbar = "⌽";
var $560639d49e3c9a19$var$par = "¶";
var $560639d49e3c9a19$var$para$1 = "¶";
var $560639d49e3c9a19$var$parallel = "∥";
var $560639d49e3c9a19$var$parsim = "⫳";
var $560639d49e3c9a19$var$parsl = "⫽";
var $560639d49e3c9a19$var$part$1 = "∂";
var $560639d49e3c9a19$var$pcy = "п";
var $560639d49e3c9a19$var$percnt = "%";
var $560639d49e3c9a19$var$period = ".";
var $560639d49e3c9a19$var$permil$1 = "‰";
var $560639d49e3c9a19$var$perp$1 = "⊥";
var $560639d49e3c9a19$var$pertenk = "‱";
var $560639d49e3c9a19$var$pfr = "𝔭";
var $560639d49e3c9a19$var$phi$1 = "φ";
var $560639d49e3c9a19$var$phiv = "ϕ";
var $560639d49e3c9a19$var$phmmat = "ℳ";
var $560639d49e3c9a19$var$phone = "☎";
var $560639d49e3c9a19$var$pi$1 = "π";
var $560639d49e3c9a19$var$pitchfork = "⋔";
var $560639d49e3c9a19$var$piv$1 = "ϖ";
var $560639d49e3c9a19$var$planck = "ℏ";
var $560639d49e3c9a19$var$planckh = "ℎ";
var $560639d49e3c9a19$var$plankv = "ℏ";
var $560639d49e3c9a19$var$plus = "+";
var $560639d49e3c9a19$var$plusacir = "⨣";
var $560639d49e3c9a19$var$plusb = "⊞";
var $560639d49e3c9a19$var$pluscir = "⨢";
var $560639d49e3c9a19$var$plusdo = "∔";
var $560639d49e3c9a19$var$plusdu = "⨥";
var $560639d49e3c9a19$var$pluse = "⩲";
var $560639d49e3c9a19$var$plusm = "±";
var $560639d49e3c9a19$var$plusmn$1 = "±";
var $560639d49e3c9a19$var$plussim = "⨦";
var $560639d49e3c9a19$var$plustwo = "⨧";
var $560639d49e3c9a19$var$pm = "±";
var $560639d49e3c9a19$var$pointint = "⨕";
var $560639d49e3c9a19$var$popf = "𝕡";
var $560639d49e3c9a19$var$poun = "£";
var $560639d49e3c9a19$var$pound$1 = "£";
var $560639d49e3c9a19$var$pr = "≺";
var $560639d49e3c9a19$var$prE = "⪳";
var $560639d49e3c9a19$var$prap = "⪷";
var $560639d49e3c9a19$var$prcue = "≼";
var $560639d49e3c9a19$var$pre = "⪯";
var $560639d49e3c9a19$var$prec = "≺";
var $560639d49e3c9a19$var$precapprox = "⪷";
var $560639d49e3c9a19$var$preccurlyeq = "≼";
var $560639d49e3c9a19$var$preceq = "⪯";
var $560639d49e3c9a19$var$precnapprox = "⪹";
var $560639d49e3c9a19$var$precneqq = "⪵";
var $560639d49e3c9a19$var$precnsim = "⋨";
var $560639d49e3c9a19$var$precsim = "≾";
var $560639d49e3c9a19$var$prime$1 = "′";
var $560639d49e3c9a19$var$primes = "ℙ";
var $560639d49e3c9a19$var$prnE = "⪵";
var $560639d49e3c9a19$var$prnap = "⪹";
var $560639d49e3c9a19$var$prnsim = "⋨";
var $560639d49e3c9a19$var$prod$1 = "∏";
var $560639d49e3c9a19$var$profalar = "⌮";
var $560639d49e3c9a19$var$profline = "⌒";
var $560639d49e3c9a19$var$profsurf = "⌓";
var $560639d49e3c9a19$var$prop$1 = "∝";
var $560639d49e3c9a19$var$propto = "∝";
var $560639d49e3c9a19$var$prsim = "≾";
var $560639d49e3c9a19$var$prurel = "⊰";
var $560639d49e3c9a19$var$pscr = "𝓅";
var $560639d49e3c9a19$var$psi$1 = "ψ";
var $560639d49e3c9a19$var$puncsp = " ";
var $560639d49e3c9a19$var$qfr = "𝔮";
var $560639d49e3c9a19$var$qint = "⨌";
var $560639d49e3c9a19$var$qopf = "𝕢";
var $560639d49e3c9a19$var$qprime = "⁗";
var $560639d49e3c9a19$var$qscr = "𝓆";
var $560639d49e3c9a19$var$quaternions = "ℍ";
var $560639d49e3c9a19$var$quatint = "⨖";
var $560639d49e3c9a19$var$quest = "?";
var $560639d49e3c9a19$var$questeq = "≟";
var $560639d49e3c9a19$var$quo = '"';
var $560639d49e3c9a19$var$quot$1 = '"';
var $560639d49e3c9a19$var$rAarr = "⇛";
var $560639d49e3c9a19$var$rArr$1 = "⇒";
var $560639d49e3c9a19$var$rAtail = "⤜";
var $560639d49e3c9a19$var$rBarr = "⤏";
var $560639d49e3c9a19$var$rHar = "⥤";
var $560639d49e3c9a19$var$race = "∽̱";
var $560639d49e3c9a19$var$racute = "ŕ";
var $560639d49e3c9a19$var$radic$1 = "√";
var $560639d49e3c9a19$var$raemptyv = "⦳";
var $560639d49e3c9a19$var$rang$1 = "⟩";
var $560639d49e3c9a19$var$rangd = "⦒";
var $560639d49e3c9a19$var$range = "⦥";
var $560639d49e3c9a19$var$rangle = "⟩";
var $560639d49e3c9a19$var$raqu = "»";
var $560639d49e3c9a19$var$raquo$1 = "»";
var $560639d49e3c9a19$var$rarr$1 = "→";
var $560639d49e3c9a19$var$rarrap = "⥵";
var $560639d49e3c9a19$var$rarrb = "⇥";
var $560639d49e3c9a19$var$rarrbfs = "⤠";
var $560639d49e3c9a19$var$rarrc = "⤳";
var $560639d49e3c9a19$var$rarrfs = "⤞";
var $560639d49e3c9a19$var$rarrhk = "↪";
var $560639d49e3c9a19$var$rarrlp = "↬";
var $560639d49e3c9a19$var$rarrpl = "⥅";
var $560639d49e3c9a19$var$rarrsim = "⥴";
var $560639d49e3c9a19$var$rarrtl = "↣";
var $560639d49e3c9a19$var$rarrw = "↝";
var $560639d49e3c9a19$var$ratail = "⤚";
var $560639d49e3c9a19$var$ratio = "∶";
var $560639d49e3c9a19$var$rationals = "ℚ";
var $560639d49e3c9a19$var$rbarr = "⤍";
var $560639d49e3c9a19$var$rbbrk = "❳";
var $560639d49e3c9a19$var$rbrace = "}";
var $560639d49e3c9a19$var$rbrack = "]";
var $560639d49e3c9a19$var$rbrke = "⦌";
var $560639d49e3c9a19$var$rbrksld = "⦎";
var $560639d49e3c9a19$var$rbrkslu = "⦐";
var $560639d49e3c9a19$var$rcaron = "ř";
var $560639d49e3c9a19$var$rcedil = "ŗ";
var $560639d49e3c9a19$var$rceil$1 = "⌉";
var $560639d49e3c9a19$var$rcub = "}";
var $560639d49e3c9a19$var$rcy = "р";
var $560639d49e3c9a19$var$rdca = "⤷";
var $560639d49e3c9a19$var$rdldhar = "⥩";
var $560639d49e3c9a19$var$rdquo$1 = "”";
var $560639d49e3c9a19$var$rdquor = "”";
var $560639d49e3c9a19$var$rdsh = "↳";
var $560639d49e3c9a19$var$real$1 = "ℜ";
var $560639d49e3c9a19$var$realine = "ℛ";
var $560639d49e3c9a19$var$realpart = "ℜ";
var $560639d49e3c9a19$var$reals = "ℝ";
var $560639d49e3c9a19$var$rect = "▭";
var $560639d49e3c9a19$var$re$3 = "®";
var $560639d49e3c9a19$var$reg$1 = "®";
var $560639d49e3c9a19$var$rfisht = "⥽";
var $560639d49e3c9a19$var$rfloor$1 = "⌋";
var $560639d49e3c9a19$var$rfr = "𝔯";
var $560639d49e3c9a19$var$rhard = "⇁";
var $560639d49e3c9a19$var$rharu = "⇀";
var $560639d49e3c9a19$var$rharul = "⥬";
var $560639d49e3c9a19$var$rho$1 = "ρ";
var $560639d49e3c9a19$var$rhov = "ϱ";
var $560639d49e3c9a19$var$rightarrow = "→";
var $560639d49e3c9a19$var$rightarrowtail = "↣";
var $560639d49e3c9a19$var$rightharpoondown = "⇁";
var $560639d49e3c9a19$var$rightharpoonup = "⇀";
var $560639d49e3c9a19$var$rightleftarrows = "⇄";
var $560639d49e3c9a19$var$rightleftharpoons = "⇌";
var $560639d49e3c9a19$var$rightrightarrows = "⇉";
var $560639d49e3c9a19$var$rightsquigarrow = "↝";
var $560639d49e3c9a19$var$rightthreetimes = "⋌";
var $560639d49e3c9a19$var$ring = "˚";
var $560639d49e3c9a19$var$risingdotseq = "≓";
var $560639d49e3c9a19$var$rlarr = "⇄";
var $560639d49e3c9a19$var$rlhar = "⇌";
var $560639d49e3c9a19$var$rlm$1 = "‏";
var $560639d49e3c9a19$var$rmoust = "⎱";
var $560639d49e3c9a19$var$rmoustache = "⎱";
var $560639d49e3c9a19$var$rnmid = "⫮";
var $560639d49e3c9a19$var$roang = "⟭";
var $560639d49e3c9a19$var$roarr = "⇾";
var $560639d49e3c9a19$var$robrk = "⟧";
var $560639d49e3c9a19$var$ropar = "⦆";
var $560639d49e3c9a19$var$ropf = "𝕣";
var $560639d49e3c9a19$var$roplus = "⨮";
var $560639d49e3c9a19$var$rotimes = "⨵";
var $560639d49e3c9a19$var$rpar = ")";
var $560639d49e3c9a19$var$rpargt = "⦔";
var $560639d49e3c9a19$var$rppolint = "⨒";
var $560639d49e3c9a19$var$rrarr = "⇉";
var $560639d49e3c9a19$var$rsaquo$1 = "›";
var $560639d49e3c9a19$var$rscr = "𝓇";
var $560639d49e3c9a19$var$rsh = "↱";
var $560639d49e3c9a19$var$rsqb = "]";
var $560639d49e3c9a19$var$rsquo$1 = "’";
var $560639d49e3c9a19$var$rsquor = "’";
var $560639d49e3c9a19$var$rthree = "⋌";
var $560639d49e3c9a19$var$rtimes = "⋊";
var $560639d49e3c9a19$var$rtri = "▹";
var $560639d49e3c9a19$var$rtrie = "⊵";
var $560639d49e3c9a19$var$rtrif = "▸";
var $560639d49e3c9a19$var$rtriltri = "⧎";
var $560639d49e3c9a19$var$ruluhar = "⥨";
var $560639d49e3c9a19$var$rx = "℞";
var $560639d49e3c9a19$var$sacute = "ś";
var $560639d49e3c9a19$var$sbquo$1 = "‚";
var $560639d49e3c9a19$var$sc = "≻";
var $560639d49e3c9a19$var$scE = "⪴";
var $560639d49e3c9a19$var$scap = "⪸";
var $560639d49e3c9a19$var$scaron$1 = "š";
var $560639d49e3c9a19$var$sccue = "≽";
var $560639d49e3c9a19$var$sce = "⪰";
var $560639d49e3c9a19$var$scedil = "ş";
var $560639d49e3c9a19$var$scirc = "ŝ";
var $560639d49e3c9a19$var$scnE = "⪶";
var $560639d49e3c9a19$var$scnap = "⪺";
var $560639d49e3c9a19$var$scnsim = "⋩";
var $560639d49e3c9a19$var$scpolint = "⨓";
var $560639d49e3c9a19$var$scsim = "≿";
var $560639d49e3c9a19$var$scy = "с";
var $560639d49e3c9a19$var$sdot$1 = "⋅";
var $560639d49e3c9a19$var$sdotb = "⊡";
var $560639d49e3c9a19$var$sdote = "⩦";
var $560639d49e3c9a19$var$seArr = "⇘";
var $560639d49e3c9a19$var$searhk = "⤥";
var $560639d49e3c9a19$var$searr = "↘";
var $560639d49e3c9a19$var$searrow = "↘";
var $560639d49e3c9a19$var$sec = "§";
var $560639d49e3c9a19$var$sect$1 = "§";
var $560639d49e3c9a19$var$semi = ";";
var $560639d49e3c9a19$var$seswar = "⤩";
var $560639d49e3c9a19$var$setminus = "∖";
var $560639d49e3c9a19$var$setmn = "∖";
var $560639d49e3c9a19$var$sext = "✶";
var $560639d49e3c9a19$var$sfr = "𝔰";
var $560639d49e3c9a19$var$sfrown = "⌢";
var $560639d49e3c9a19$var$sharp = "♯";
var $560639d49e3c9a19$var$shchcy = "щ";
var $560639d49e3c9a19$var$shcy = "ш";
var $560639d49e3c9a19$var$shortmid = "∣";
var $560639d49e3c9a19$var$shortparallel = "∥";
var $560639d49e3c9a19$var$sh = "­";
var $560639d49e3c9a19$var$shy$1 = "­";
var $560639d49e3c9a19$var$sigma$1 = "σ";
var $560639d49e3c9a19$var$sigmaf$1 = "ς";
var $560639d49e3c9a19$var$sigmav = "ς";
var $560639d49e3c9a19$var$sim$1 = "∼";
var $560639d49e3c9a19$var$simdot = "⩪";
var $560639d49e3c9a19$var$sime = "≃";
var $560639d49e3c9a19$var$simeq = "≃";
var $560639d49e3c9a19$var$simg = "⪞";
var $560639d49e3c9a19$var$simgE = "⪠";
var $560639d49e3c9a19$var$siml = "⪝";
var $560639d49e3c9a19$var$simlE = "⪟";
var $560639d49e3c9a19$var$simne = "≆";
var $560639d49e3c9a19$var$simplus = "⨤";
var $560639d49e3c9a19$var$simrarr = "⥲";
var $560639d49e3c9a19$var$slarr = "←";
var $560639d49e3c9a19$var$smallsetminus = "∖";
var $560639d49e3c9a19$var$smashp = "⨳";
var $560639d49e3c9a19$var$smeparsl = "⧤";
var $560639d49e3c9a19$var$smid = "∣";
var $560639d49e3c9a19$var$smile = "⌣";
var $560639d49e3c9a19$var$smt = "⪪";
var $560639d49e3c9a19$var$smte = "⪬";
var $560639d49e3c9a19$var$smtes = "⪬︀";
var $560639d49e3c9a19$var$softcy = "ь";
var $560639d49e3c9a19$var$sol = "/";
var $560639d49e3c9a19$var$solb = "⧄";
var $560639d49e3c9a19$var$solbar = "⌿";
var $560639d49e3c9a19$var$sopf = "𝕤";
var $560639d49e3c9a19$var$spades$1 = "♠";
var $560639d49e3c9a19$var$spadesuit = "♠";
var $560639d49e3c9a19$var$spar = "∥";
var $560639d49e3c9a19$var$sqcap = "⊓";
var $560639d49e3c9a19$var$sqcaps = "⊓︀";
var $560639d49e3c9a19$var$sqcup = "⊔";
var $560639d49e3c9a19$var$sqcups = "⊔︀";
var $560639d49e3c9a19$var$sqsub = "⊏";
var $560639d49e3c9a19$var$sqsube = "⊑";
var $560639d49e3c9a19$var$sqsubset = "⊏";
var $560639d49e3c9a19$var$sqsubseteq = "⊑";
var $560639d49e3c9a19$var$sqsup = "⊐";
var $560639d49e3c9a19$var$sqsupe = "⊒";
var $560639d49e3c9a19$var$sqsupset = "⊐";
var $560639d49e3c9a19$var$sqsupseteq = "⊒";
var $560639d49e3c9a19$var$squ = "□";
var $560639d49e3c9a19$var$square = "□";
var $560639d49e3c9a19$var$squarf = "▪";
var $560639d49e3c9a19$var$squf = "▪";
var $560639d49e3c9a19$var$srarr = "→";
var $560639d49e3c9a19$var$sscr = "𝓈";
var $560639d49e3c9a19$var$ssetmn = "∖";
var $560639d49e3c9a19$var$ssmile = "⌣";
var $560639d49e3c9a19$var$sstarf = "⋆";
var $560639d49e3c9a19$var$star = "☆";
var $560639d49e3c9a19$var$starf = "★";
var $560639d49e3c9a19$var$straightepsilon = "ϵ";
var $560639d49e3c9a19$var$straightphi = "ϕ";
var $560639d49e3c9a19$var$strns = "¯";
var $560639d49e3c9a19$var$sub$1 = "⊂";
var $560639d49e3c9a19$var$subE = "⫅";
var $560639d49e3c9a19$var$subdot = "⪽";
var $560639d49e3c9a19$var$sube$1 = "⊆";
var $560639d49e3c9a19$var$subedot = "⫃";
var $560639d49e3c9a19$var$submult = "⫁";
var $560639d49e3c9a19$var$subnE = "⫋";
var $560639d49e3c9a19$var$subne = "⊊";
var $560639d49e3c9a19$var$subplus = "⪿";
var $560639d49e3c9a19$var$subrarr = "⥹";
var $560639d49e3c9a19$var$subset = "⊂";
var $560639d49e3c9a19$var$subseteq = "⊆";
var $560639d49e3c9a19$var$subseteqq = "⫅";
var $560639d49e3c9a19$var$subsetneq = "⊊";
var $560639d49e3c9a19$var$subsetneqq = "⫋";
var $560639d49e3c9a19$var$subsim = "⫇";
var $560639d49e3c9a19$var$subsub = "⫕";
var $560639d49e3c9a19$var$subsup = "⫓";
var $560639d49e3c9a19$var$succ = "≻";
var $560639d49e3c9a19$var$succapprox = "⪸";
var $560639d49e3c9a19$var$succcurlyeq = "≽";
var $560639d49e3c9a19$var$succeq = "⪰";
var $560639d49e3c9a19$var$succnapprox = "⪺";
var $560639d49e3c9a19$var$succneqq = "⪶";
var $560639d49e3c9a19$var$succnsim = "⋩";
var $560639d49e3c9a19$var$succsim = "≿";
var $560639d49e3c9a19$var$sum$1 = "∑";
var $560639d49e3c9a19$var$sung = "♪";
var $560639d49e3c9a19$var$sup$1 = "⊃";
var $560639d49e3c9a19$var$sup1$1 = "¹";
var $560639d49e3c9a19$var$sup2$1 = "²";
var $560639d49e3c9a19$var$sup3$1 = "³";
var $560639d49e3c9a19$var$supE = "⫆";
var $560639d49e3c9a19$var$supdot = "⪾";
var $560639d49e3c9a19$var$supdsub = "⫘";
var $560639d49e3c9a19$var$supe$1 = "⊇";
var $560639d49e3c9a19$var$supedot = "⫄";
var $560639d49e3c9a19$var$suphsol = "⟉";
var $560639d49e3c9a19$var$suphsub = "⫗";
var $560639d49e3c9a19$var$suplarr = "⥻";
var $560639d49e3c9a19$var$supmult = "⫂";
var $560639d49e3c9a19$var$supnE = "⫌";
var $560639d49e3c9a19$var$supne = "⊋";
var $560639d49e3c9a19$var$supplus = "⫀";
var $560639d49e3c9a19$var$supset = "⊃";
var $560639d49e3c9a19$var$supseteq = "⊇";
var $560639d49e3c9a19$var$supseteqq = "⫆";
var $560639d49e3c9a19$var$supsetneq = "⊋";
var $560639d49e3c9a19$var$supsetneqq = "⫌";
var $560639d49e3c9a19$var$supsim = "⫈";
var $560639d49e3c9a19$var$supsub = "⫔";
var $560639d49e3c9a19$var$supsup = "⫖";
var $560639d49e3c9a19$var$swArr = "⇙";
var $560639d49e3c9a19$var$swarhk = "⤦";
var $560639d49e3c9a19$var$swarr = "↙";
var $560639d49e3c9a19$var$swarrow = "↙";
var $560639d49e3c9a19$var$swnwar = "⤪";
var $560639d49e3c9a19$var$szli = "ß";
var $560639d49e3c9a19$var$szlig$1 = "ß";
var $560639d49e3c9a19$var$target = "⌖";
var $560639d49e3c9a19$var$tau$1 = "τ";
var $560639d49e3c9a19$var$tbrk = "⎴";
var $560639d49e3c9a19$var$tcaron = "ť";
var $560639d49e3c9a19$var$tcedil = "ţ";
var $560639d49e3c9a19$var$tcy = "т";
var $560639d49e3c9a19$var$tdot = "⃛";
var $560639d49e3c9a19$var$telrec = "⌕";
var $560639d49e3c9a19$var$tfr = "𝔱";
var $560639d49e3c9a19$var$there4$1 = "∴";
var $560639d49e3c9a19$var$therefore = "∴";
var $560639d49e3c9a19$var$theta$1 = "θ";
var $560639d49e3c9a19$var$thetasym$1 = "ϑ";
var $560639d49e3c9a19$var$thetav = "ϑ";
var $560639d49e3c9a19$var$thickapprox = "≈";
var $560639d49e3c9a19$var$thicksim = "∼";
var $560639d49e3c9a19$var$thinsp$1 = " ";
var $560639d49e3c9a19$var$thkap = "≈";
var $560639d49e3c9a19$var$thksim = "∼";
var $560639d49e3c9a19$var$thor = "þ";
var $560639d49e3c9a19$var$thorn$1 = "þ";
var $560639d49e3c9a19$var$tilde$4 = "˜";
var $560639d49e3c9a19$var$time = "×";
var $560639d49e3c9a19$var$times$1 = "×";
var $560639d49e3c9a19$var$timesb = "⊠";
var $560639d49e3c9a19$var$timesbar = "⨱";
var $560639d49e3c9a19$var$timesd = "⨰";
var $560639d49e3c9a19$var$tint = "∭";
var $560639d49e3c9a19$var$toea = "⤨";
var $560639d49e3c9a19$var$top = "⊤";
var $560639d49e3c9a19$var$topbot = "⌶";
var $560639d49e3c9a19$var$topcir = "⫱";
var $560639d49e3c9a19$var$topf = "𝕥";
var $560639d49e3c9a19$var$topfork = "⫚";
var $560639d49e3c9a19$var$tosa = "⤩";
var $560639d49e3c9a19$var$tprime = "‴";
var $560639d49e3c9a19$var$trade$1 = "™";
var $560639d49e3c9a19$var$triangle = "▵";
var $560639d49e3c9a19$var$triangledown = "▿";
var $560639d49e3c9a19$var$triangleleft = "◃";
var $560639d49e3c9a19$var$trianglelefteq = "⊴";
var $560639d49e3c9a19$var$triangleq = "≜";
var $560639d49e3c9a19$var$triangleright = "▹";
var $560639d49e3c9a19$var$trianglerighteq = "⊵";
var $560639d49e3c9a19$var$tridot = "◬";
var $560639d49e3c9a19$var$trie = "≜";
var $560639d49e3c9a19$var$triminus = "⨺";
var $560639d49e3c9a19$var$triplus = "⨹";
var $560639d49e3c9a19$var$trisb = "⧍";
var $560639d49e3c9a19$var$tritime = "⨻";
var $560639d49e3c9a19$var$trpezium = "⏢";
var $560639d49e3c9a19$var$tscr = "𝓉";
var $560639d49e3c9a19$var$tscy = "ц";
var $560639d49e3c9a19$var$tshcy = "ћ";
var $560639d49e3c9a19$var$tstrok = "ŧ";
var $560639d49e3c9a19$var$twixt = "≬";
var $560639d49e3c9a19$var$twoheadleftarrow = "↞";
var $560639d49e3c9a19$var$twoheadrightarrow = "↠";
var $560639d49e3c9a19$var$uArr$1 = "⇑";
var $560639d49e3c9a19$var$uHar = "⥣";
var $560639d49e3c9a19$var$uacut = "ú";
var $560639d49e3c9a19$var$uacute$1 = "ú";
var $560639d49e3c9a19$var$uarr$1 = "↑";
var $560639d49e3c9a19$var$ubrcy = "ў";
var $560639d49e3c9a19$var$ubreve = "ŭ";
var $560639d49e3c9a19$var$ucir = "û";
var $560639d49e3c9a19$var$ucirc$1 = "û";
var $560639d49e3c9a19$var$ucy = "у";
var $560639d49e3c9a19$var$udarr = "⇅";
var $560639d49e3c9a19$var$udblac = "ű";
var $560639d49e3c9a19$var$udhar = "⥮";
var $560639d49e3c9a19$var$ufisht = "⥾";
var $560639d49e3c9a19$var$ufr = "𝔲";
var $560639d49e3c9a19$var$ugrav = "ù";
var $560639d49e3c9a19$var$ugrave$1 = "ù";
var $560639d49e3c9a19$var$uharl = "↿";
var $560639d49e3c9a19$var$uharr = "↾";
var $560639d49e3c9a19$var$uhblk = "▀";
var $560639d49e3c9a19$var$ulcorn = "⌜";
var $560639d49e3c9a19$var$ulcorner = "⌜";
var $560639d49e3c9a19$var$ulcrop = "⌏";
var $560639d49e3c9a19$var$ultri = "◸";
var $560639d49e3c9a19$var$umacr = "ū";
var $560639d49e3c9a19$var$um = "¨";
var $560639d49e3c9a19$var$uml$1 = "¨";
var $560639d49e3c9a19$var$uogon = "ų";
var $560639d49e3c9a19$var$uopf = "𝕦";
var $560639d49e3c9a19$var$uparrow = "↑";
var $560639d49e3c9a19$var$updownarrow = "↕";
var $560639d49e3c9a19$var$upharpoonleft = "↿";
var $560639d49e3c9a19$var$upharpoonright = "↾";
var $560639d49e3c9a19$var$uplus = "⊎";
var $560639d49e3c9a19$var$upsi = "υ";
var $560639d49e3c9a19$var$upsih$1 = "ϒ";
var $560639d49e3c9a19$var$upsilon$1 = "υ";
var $560639d49e3c9a19$var$upuparrows = "⇈";
var $560639d49e3c9a19$var$urcorn = "⌝";
var $560639d49e3c9a19$var$urcorner = "⌝";
var $560639d49e3c9a19$var$urcrop = "⌎";
var $560639d49e3c9a19$var$uring = "ů";
var $560639d49e3c9a19$var$urtri = "◹";
var $560639d49e3c9a19$var$uscr = "𝓊";
var $560639d49e3c9a19$var$utdot = "⋰";
var $560639d49e3c9a19$var$utilde = "ũ";
var $560639d49e3c9a19$var$utri = "▵";
var $560639d49e3c9a19$var$utrif = "▴";
var $560639d49e3c9a19$var$uuarr = "⇈";
var $560639d49e3c9a19$var$uum = "ü";
var $560639d49e3c9a19$var$uuml$1 = "ü";
var $560639d49e3c9a19$var$uwangle = "⦧";
var $560639d49e3c9a19$var$vArr = "⇕";
var $560639d49e3c9a19$var$vBar = "⫨";
var $560639d49e3c9a19$var$vBarv = "⫩";
var $560639d49e3c9a19$var$vDash = "⊨";
var $560639d49e3c9a19$var$vangrt = "⦜";
var $560639d49e3c9a19$var$varepsilon = "ϵ";
var $560639d49e3c9a19$var$varkappa = "ϰ";
var $560639d49e3c9a19$var$varnothing = "∅";
var $560639d49e3c9a19$var$varphi = "ϕ";
var $560639d49e3c9a19$var$varpi = "ϖ";
var $560639d49e3c9a19$var$varpropto = "∝";
var $560639d49e3c9a19$var$varr = "↕";
var $560639d49e3c9a19$var$varrho = "ϱ";
var $560639d49e3c9a19$var$varsigma = "ς";
var $560639d49e3c9a19$var$varsubsetneq = "⊊︀";
var $560639d49e3c9a19$var$varsubsetneqq = "⫋︀";
var $560639d49e3c9a19$var$varsupsetneq = "⊋︀";
var $560639d49e3c9a19$var$varsupsetneqq = "⫌︀";
var $560639d49e3c9a19$var$vartheta = "ϑ";
var $560639d49e3c9a19$var$vartriangleleft = "⊲";
var $560639d49e3c9a19$var$vartriangleright = "⊳";
var $560639d49e3c9a19$var$vcy = "в";
var $560639d49e3c9a19$var$vdash = "⊢";
var $560639d49e3c9a19$var$vee = "∨";
var $560639d49e3c9a19$var$veebar = "⊻";
var $560639d49e3c9a19$var$veeeq = "≚";
var $560639d49e3c9a19$var$vellip = "⋮";
var $560639d49e3c9a19$var$verbar = "|";
var $560639d49e3c9a19$var$vert = "|";
var $560639d49e3c9a19$var$vfr = "𝔳";
var $560639d49e3c9a19$var$vltri = "⊲";
var $560639d49e3c9a19$var$vnsub = "⊂⃒";
var $560639d49e3c9a19$var$vnsup = "⊃⃒";
var $560639d49e3c9a19$var$vopf = "𝕧";
var $560639d49e3c9a19$var$vprop = "∝";
var $560639d49e3c9a19$var$vrtri = "⊳";
var $560639d49e3c9a19$var$vscr = "𝓋";
var $560639d49e3c9a19$var$vsubnE = "⫋︀";
var $560639d49e3c9a19$var$vsubne = "⊊︀";
var $560639d49e3c9a19$var$vsupnE = "⫌︀";
var $560639d49e3c9a19$var$vsupne = "⊋︀";
var $560639d49e3c9a19$var$vzigzag = "⦚";
var $560639d49e3c9a19$var$wcirc = "ŵ";
var $560639d49e3c9a19$var$wedbar = "⩟";
var $560639d49e3c9a19$var$wedge = "∧";
var $560639d49e3c9a19$var$wedgeq = "≙";
var $560639d49e3c9a19$var$weierp$1 = "℘";
var $560639d49e3c9a19$var$wfr = "𝔴";
var $560639d49e3c9a19$var$wopf = "𝕨";
var $560639d49e3c9a19$var$wp = "℘";
var $560639d49e3c9a19$var$wr = "≀";
var $560639d49e3c9a19$var$wreath = "≀";
var $560639d49e3c9a19$var$wscr = "𝓌";
var $560639d49e3c9a19$var$xcap = "⋂";
var $560639d49e3c9a19$var$xcirc = "◯";
var $560639d49e3c9a19$var$xcup = "⋃";
var $560639d49e3c9a19$var$xdtri = "▽";
var $560639d49e3c9a19$var$xfr = "𝔵";
var $560639d49e3c9a19$var$xhArr = "⟺";
var $560639d49e3c9a19$var$xharr = "⟷";
var $560639d49e3c9a19$var$xi$1 = "ξ";
var $560639d49e3c9a19$var$xlArr = "⟸";
var $560639d49e3c9a19$var$xlarr = "⟵";
var $560639d49e3c9a19$var$xmap = "⟼";
var $560639d49e3c9a19$var$xnis = "⋻";
var $560639d49e3c9a19$var$xodot = "⨀";
var $560639d49e3c9a19$var$xopf = "𝕩";
var $560639d49e3c9a19$var$xoplus = "⨁";
var $560639d49e3c9a19$var$xotime = "⨂";
var $560639d49e3c9a19$var$xrArr = "⟹";
var $560639d49e3c9a19$var$xrarr = "⟶";
var $560639d49e3c9a19$var$xscr = "𝓍";
var $560639d49e3c9a19$var$xsqcup = "⨆";
var $560639d49e3c9a19$var$xuplus = "⨄";
var $560639d49e3c9a19$var$xutri = "△";
var $560639d49e3c9a19$var$xvee = "⋁";
var $560639d49e3c9a19$var$xwedge = "⋀";
var $560639d49e3c9a19$var$yacut = "ý";
var $560639d49e3c9a19$var$yacute$1 = "ý";
var $560639d49e3c9a19$var$yacy = "я";
var $560639d49e3c9a19$var$ycirc = "ŷ";
var $560639d49e3c9a19$var$ycy = "ы";
var $560639d49e3c9a19$var$ye = "¥";
var $560639d49e3c9a19$var$yen$1 = "¥";
var $560639d49e3c9a19$var$yfr = "𝔶";
var $560639d49e3c9a19$var$yicy = "ї";
var $560639d49e3c9a19$var$yopf = "𝕪";
var $560639d49e3c9a19$var$yscr = "𝓎";
var $560639d49e3c9a19$var$yucy = "ю";
var $560639d49e3c9a19$var$yum = "ÿ";
var $560639d49e3c9a19$var$yuml$1 = "ÿ";
var $560639d49e3c9a19$var$zacute = "ź";
var $560639d49e3c9a19$var$zcaron = "ž";
var $560639d49e3c9a19$var$zcy = "з";
var $560639d49e3c9a19$var$zdot = "ż";
var $560639d49e3c9a19$var$zeetrf = "ℨ";
var $560639d49e3c9a19$var$zeta$1 = "ζ";
var $560639d49e3c9a19$var$zfr = "𝔷";
var $560639d49e3c9a19$var$zhcy = "ж";
var $560639d49e3c9a19$var$zigrarr = "⇝";
var $560639d49e3c9a19$var$zopf = "𝕫";
var $560639d49e3c9a19$var$zscr = "𝓏";
var $560639d49e3c9a19$var$zwj$1 = "‍";
var $560639d49e3c9a19$var$zwnj$1 = "‌";
var $560639d49e3c9a19$var$index$3 = {
  AEli: $560639d49e3c9a19$var$AEli,
  AElig: $560639d49e3c9a19$var$AElig$1,
  AM: $560639d49e3c9a19$var$AM,
  AMP: $560639d49e3c9a19$var$AMP$1,
  Aacut: $560639d49e3c9a19$var$Aacut,
  Aacute: $560639d49e3c9a19$var$Aacute$1,
  Abreve: $560639d49e3c9a19$var$Abreve,
  Acir: $560639d49e3c9a19$var$Acir,
  Acirc: $560639d49e3c9a19$var$Acirc$1,
  Acy: $560639d49e3c9a19$var$Acy,
  Afr: $560639d49e3c9a19$var$Afr,
  Agrav: $560639d49e3c9a19$var$Agrav,
  Agrave: $560639d49e3c9a19$var$Agrave$1,
  Alpha: $560639d49e3c9a19$var$Alpha$1,
  Amacr: $560639d49e3c9a19$var$Amacr,
  And: $560639d49e3c9a19$var$And,
  Aogon: $560639d49e3c9a19$var$Aogon,
  Aopf: $560639d49e3c9a19$var$Aopf,
  ApplyFunction: $560639d49e3c9a19$var$ApplyFunction,
  Arin: $560639d49e3c9a19$var$Arin,
  Aring: $560639d49e3c9a19$var$Aring$1,
  Ascr: $560639d49e3c9a19$var$Ascr,
  Assign: $560639d49e3c9a19$var$Assign,
  Atild: $560639d49e3c9a19$var$Atild,
  Atilde: $560639d49e3c9a19$var$Atilde$1,
  Aum: $560639d49e3c9a19$var$Aum,
  Auml: $560639d49e3c9a19$var$Auml$1,
  Backslash: $560639d49e3c9a19$var$Backslash,
  Barv: $560639d49e3c9a19$var$Barv,
  Barwed: $560639d49e3c9a19$var$Barwed,
  Bcy: $560639d49e3c9a19$var$Bcy,
  Because: $560639d49e3c9a19$var$Because,
  Bernoullis: $560639d49e3c9a19$var$Bernoullis,
  Beta: $560639d49e3c9a19$var$Beta$1,
  Bfr: $560639d49e3c9a19$var$Bfr,
  Bopf: $560639d49e3c9a19$var$Bopf,
  Breve: $560639d49e3c9a19$var$Breve,
  Bscr: $560639d49e3c9a19$var$Bscr,
  Bumpeq: $560639d49e3c9a19$var$Bumpeq,
  CHcy: $560639d49e3c9a19$var$CHcy,
  COP: $560639d49e3c9a19$var$COP,
  COPY: $560639d49e3c9a19$var$COPY,
  Cacute: $560639d49e3c9a19$var$Cacute,
  Cap: $560639d49e3c9a19$var$Cap,
  CapitalDifferentialD: $560639d49e3c9a19$var$CapitalDifferentialD,
  Cayleys: $560639d49e3c9a19$var$Cayleys,
  Ccaron: $560639d49e3c9a19$var$Ccaron,
  Ccedi: $560639d49e3c9a19$var$Ccedi,
  Ccedil: $560639d49e3c9a19$var$Ccedil$1,
  Ccirc: $560639d49e3c9a19$var$Ccirc,
  Cconint: $560639d49e3c9a19$var$Cconint,
  Cdot: $560639d49e3c9a19$var$Cdot,
  Cedilla: $560639d49e3c9a19$var$Cedilla,
  CenterDot: $560639d49e3c9a19$var$CenterDot,
  Cfr: $560639d49e3c9a19$var$Cfr,
  Chi: $560639d49e3c9a19$var$Chi$1,
  CircleDot: $560639d49e3c9a19$var$CircleDot,
  CircleMinus: $560639d49e3c9a19$var$CircleMinus,
  CirclePlus: $560639d49e3c9a19$var$CirclePlus,
  CircleTimes: $560639d49e3c9a19$var$CircleTimes,
  ClockwiseContourIntegral: $560639d49e3c9a19$var$ClockwiseContourIntegral,
  CloseCurlyDoubleQuote: $560639d49e3c9a19$var$CloseCurlyDoubleQuote,
  CloseCurlyQuote: $560639d49e3c9a19$var$CloseCurlyQuote,
  Colon: $560639d49e3c9a19$var$Colon,
  Colone: $560639d49e3c9a19$var$Colone,
  Congruent: $560639d49e3c9a19$var$Congruent,
  Conint: $560639d49e3c9a19$var$Conint,
  ContourIntegral: $560639d49e3c9a19$var$ContourIntegral,
  Copf: $560639d49e3c9a19$var$Copf,
  Coproduct: $560639d49e3c9a19$var$Coproduct,
  CounterClockwiseContourIntegral: $560639d49e3c9a19$var$CounterClockwiseContourIntegral,
  Cross: $560639d49e3c9a19$var$Cross,
  Cscr: $560639d49e3c9a19$var$Cscr,
  Cup: $560639d49e3c9a19$var$Cup,
  CupCap: $560639d49e3c9a19$var$CupCap,
  DD: $560639d49e3c9a19$var$DD,
  DDotrahd: $560639d49e3c9a19$var$DDotrahd,
  DJcy: $560639d49e3c9a19$var$DJcy,
  DScy: $560639d49e3c9a19$var$DScy,
  DZcy: $560639d49e3c9a19$var$DZcy,
  Dagger: $560639d49e3c9a19$var$Dagger$1,
  Darr: $560639d49e3c9a19$var$Darr,
  Dashv: $560639d49e3c9a19$var$Dashv,
  Dcaron: $560639d49e3c9a19$var$Dcaron,
  Dcy: $560639d49e3c9a19$var$Dcy,
  Del: $560639d49e3c9a19$var$Del,
  Delta: $560639d49e3c9a19$var$Delta$1,
  Dfr: $560639d49e3c9a19$var$Dfr,
  DiacriticalAcute: $560639d49e3c9a19$var$DiacriticalAcute,
  DiacriticalDot: $560639d49e3c9a19$var$DiacriticalDot,
  DiacriticalDoubleAcute: $560639d49e3c9a19$var$DiacriticalDoubleAcute,
  DiacriticalGrave: $560639d49e3c9a19$var$DiacriticalGrave,
  DiacriticalTilde: $560639d49e3c9a19$var$DiacriticalTilde,
  Diamond: $560639d49e3c9a19$var$Diamond,
  DifferentialD: $560639d49e3c9a19$var$DifferentialD,
  Dopf: $560639d49e3c9a19$var$Dopf,
  Dot: $560639d49e3c9a19$var$Dot,
  DotDot: $560639d49e3c9a19$var$DotDot,
  DotEqual: $560639d49e3c9a19$var$DotEqual,
  DoubleContourIntegral: $560639d49e3c9a19$var$DoubleContourIntegral,
  DoubleDot: $560639d49e3c9a19$var$DoubleDot,
  DoubleDownArrow: $560639d49e3c9a19$var$DoubleDownArrow,
  DoubleLeftArrow: $560639d49e3c9a19$var$DoubleLeftArrow,
  DoubleLeftRightArrow: $560639d49e3c9a19$var$DoubleLeftRightArrow,
  DoubleLeftTee: $560639d49e3c9a19$var$DoubleLeftTee,
  DoubleLongLeftArrow: $560639d49e3c9a19$var$DoubleLongLeftArrow,
  DoubleLongLeftRightArrow: $560639d49e3c9a19$var$DoubleLongLeftRightArrow,
  DoubleLongRightArrow: $560639d49e3c9a19$var$DoubleLongRightArrow,
  DoubleRightArrow: $560639d49e3c9a19$var$DoubleRightArrow,
  DoubleRightTee: $560639d49e3c9a19$var$DoubleRightTee,
  DoubleUpArrow: $560639d49e3c9a19$var$DoubleUpArrow,
  DoubleUpDownArrow: $560639d49e3c9a19$var$DoubleUpDownArrow,
  DoubleVerticalBar: $560639d49e3c9a19$var$DoubleVerticalBar,
  DownArrow: $560639d49e3c9a19$var$DownArrow,
  DownArrowBar: $560639d49e3c9a19$var$DownArrowBar,
  DownArrowUpArrow: $560639d49e3c9a19$var$DownArrowUpArrow,
  DownBreve: $560639d49e3c9a19$var$DownBreve,
  DownLeftRightVector: $560639d49e3c9a19$var$DownLeftRightVector,
  DownLeftTeeVector: $560639d49e3c9a19$var$DownLeftTeeVector,
  DownLeftVector: $560639d49e3c9a19$var$DownLeftVector,
  DownLeftVectorBar: $560639d49e3c9a19$var$DownLeftVectorBar,
  DownRightTeeVector: $560639d49e3c9a19$var$DownRightTeeVector,
  DownRightVector: $560639d49e3c9a19$var$DownRightVector,
  DownRightVectorBar: $560639d49e3c9a19$var$DownRightVectorBar,
  DownTee: $560639d49e3c9a19$var$DownTee,
  DownTeeArrow: $560639d49e3c9a19$var$DownTeeArrow,
  Downarrow: $560639d49e3c9a19$var$Downarrow,
  Dscr: $560639d49e3c9a19$var$Dscr,
  Dstrok: $560639d49e3c9a19$var$Dstrok,
  ENG: $560639d49e3c9a19$var$ENG,
  ET: $560639d49e3c9a19$var$ET,
  ETH: $560639d49e3c9a19$var$ETH$1,
  Eacut: $560639d49e3c9a19$var$Eacut,
  Eacute: $560639d49e3c9a19$var$Eacute$1,
  Ecaron: $560639d49e3c9a19$var$Ecaron,
  Ecir: $560639d49e3c9a19$var$Ecir,
  Ecirc: $560639d49e3c9a19$var$Ecirc$1,
  Ecy: $560639d49e3c9a19$var$Ecy,
  Edot: $560639d49e3c9a19$var$Edot,
  Efr: $560639d49e3c9a19$var$Efr,
  Egrav: $560639d49e3c9a19$var$Egrav,
  Egrave: $560639d49e3c9a19$var$Egrave$1,
  Element: $560639d49e3c9a19$var$Element,
  Emacr: $560639d49e3c9a19$var$Emacr,
  EmptySmallSquare: $560639d49e3c9a19$var$EmptySmallSquare,
  EmptyVerySmallSquare: $560639d49e3c9a19$var$EmptyVerySmallSquare,
  Eogon: $560639d49e3c9a19$var$Eogon,
  Eopf: $560639d49e3c9a19$var$Eopf,
  Epsilon: $560639d49e3c9a19$var$Epsilon$1,
  Equal: $560639d49e3c9a19$var$Equal,
  EqualTilde: $560639d49e3c9a19$var$EqualTilde,
  Equilibrium: $560639d49e3c9a19$var$Equilibrium,
  Escr: $560639d49e3c9a19$var$Escr,
  Esim: $560639d49e3c9a19$var$Esim,
  Eta: $560639d49e3c9a19$var$Eta$1,
  Eum: $560639d49e3c9a19$var$Eum,
  Euml: $560639d49e3c9a19$var$Euml$1,
  Exists: $560639d49e3c9a19$var$Exists,
  ExponentialE: $560639d49e3c9a19$var$ExponentialE,
  Fcy: $560639d49e3c9a19$var$Fcy,
  Ffr: $560639d49e3c9a19$var$Ffr,
  FilledSmallSquare: $560639d49e3c9a19$var$FilledSmallSquare,
  FilledVerySmallSquare: $560639d49e3c9a19$var$FilledVerySmallSquare,
  Fopf: $560639d49e3c9a19$var$Fopf,
  ForAll: $560639d49e3c9a19$var$ForAll,
  Fouriertrf: $560639d49e3c9a19$var$Fouriertrf,
  Fscr: $560639d49e3c9a19$var$Fscr,
  GJcy: $560639d49e3c9a19$var$GJcy,
  G: $560639d49e3c9a19$var$G,
  GT: $560639d49e3c9a19$var$GT$1,
  Gamma: $560639d49e3c9a19$var$Gamma$1,
  Gammad: $560639d49e3c9a19$var$Gammad,
  Gbreve: $560639d49e3c9a19$var$Gbreve,
  Gcedil: $560639d49e3c9a19$var$Gcedil,
  Gcirc: $560639d49e3c9a19$var$Gcirc,
  Gcy: $560639d49e3c9a19$var$Gcy,
  Gdot: $560639d49e3c9a19$var$Gdot,
  Gfr: $560639d49e3c9a19$var$Gfr,
  Gg: $560639d49e3c9a19$var$Gg,
  Gopf: $560639d49e3c9a19$var$Gopf,
  GreaterEqual: $560639d49e3c9a19$var$GreaterEqual,
  GreaterEqualLess: $560639d49e3c9a19$var$GreaterEqualLess,
  GreaterFullEqual: $560639d49e3c9a19$var$GreaterFullEqual,
  GreaterGreater: $560639d49e3c9a19$var$GreaterGreater,
  GreaterLess: $560639d49e3c9a19$var$GreaterLess,
  GreaterSlantEqual: $560639d49e3c9a19$var$GreaterSlantEqual,
  GreaterTilde: $560639d49e3c9a19$var$GreaterTilde,
  Gscr: $560639d49e3c9a19$var$Gscr,
  Gt: $560639d49e3c9a19$var$Gt,
  HARDcy: $560639d49e3c9a19$var$HARDcy,
  Hacek: $560639d49e3c9a19$var$Hacek,
  Hat: $560639d49e3c9a19$var$Hat,
  Hcirc: $560639d49e3c9a19$var$Hcirc,
  Hfr: $560639d49e3c9a19$var$Hfr,
  HilbertSpace: $560639d49e3c9a19$var$HilbertSpace,
  Hopf: $560639d49e3c9a19$var$Hopf,
  HorizontalLine: $560639d49e3c9a19$var$HorizontalLine,
  Hscr: $560639d49e3c9a19$var$Hscr,
  Hstrok: $560639d49e3c9a19$var$Hstrok,
  HumpDownHump: $560639d49e3c9a19$var$HumpDownHump,
  HumpEqual: $560639d49e3c9a19$var$HumpEqual,
  IEcy: $560639d49e3c9a19$var$IEcy,
  IJlig: $560639d49e3c9a19$var$IJlig,
  IOcy: $560639d49e3c9a19$var$IOcy,
  Iacut: $560639d49e3c9a19$var$Iacut,
  Iacute: $560639d49e3c9a19$var$Iacute$1,
  Icir: $560639d49e3c9a19$var$Icir,
  Icirc: $560639d49e3c9a19$var$Icirc$1,
  Icy: $560639d49e3c9a19$var$Icy,
  Idot: $560639d49e3c9a19$var$Idot,
  Ifr: $560639d49e3c9a19$var$Ifr,
  Igrav: $560639d49e3c9a19$var$Igrav,
  Igrave: $560639d49e3c9a19$var$Igrave$1,
  Im: $560639d49e3c9a19$var$Im,
  Imacr: $560639d49e3c9a19$var$Imacr,
  ImaginaryI: $560639d49e3c9a19$var$ImaginaryI,
  Implies: $560639d49e3c9a19$var$Implies,
  Int: $560639d49e3c9a19$var$Int,
  Integral: $560639d49e3c9a19$var$Integral,
  Intersection: $560639d49e3c9a19$var$Intersection,
  InvisibleComma: $560639d49e3c9a19$var$InvisibleComma,
  InvisibleTimes: $560639d49e3c9a19$var$InvisibleTimes,
  Iogon: $560639d49e3c9a19$var$Iogon,
  Iopf: $560639d49e3c9a19$var$Iopf,
  Iota: $560639d49e3c9a19$var$Iota$1,
  Iscr: $560639d49e3c9a19$var$Iscr,
  Itilde: $560639d49e3c9a19$var$Itilde,
  Iukcy: $560639d49e3c9a19$var$Iukcy,
  Ium: $560639d49e3c9a19$var$Ium,
  Iuml: $560639d49e3c9a19$var$Iuml$1,
  Jcirc: $560639d49e3c9a19$var$Jcirc,
  Jcy: $560639d49e3c9a19$var$Jcy,
  Jfr: $560639d49e3c9a19$var$Jfr,
  Jopf: $560639d49e3c9a19$var$Jopf,
  Jscr: $560639d49e3c9a19$var$Jscr,
  Jsercy: $560639d49e3c9a19$var$Jsercy,
  Jukcy: $560639d49e3c9a19$var$Jukcy,
  KHcy: $560639d49e3c9a19$var$KHcy,
  KJcy: $560639d49e3c9a19$var$KJcy,
  Kappa: $560639d49e3c9a19$var$Kappa$1,
  Kcedil: $560639d49e3c9a19$var$Kcedil,
  Kcy: $560639d49e3c9a19$var$Kcy,
  Kfr: $560639d49e3c9a19$var$Kfr,
  Kopf: $560639d49e3c9a19$var$Kopf,
  Kscr: $560639d49e3c9a19$var$Kscr,
  LJcy: $560639d49e3c9a19$var$LJcy,
  L: $560639d49e3c9a19$var$L,
  LT: $560639d49e3c9a19$var$LT$1,
  Lacute: $560639d49e3c9a19$var$Lacute,
  Lambda: $560639d49e3c9a19$var$Lambda$1,
  Lang: $560639d49e3c9a19$var$Lang,
  Laplacetrf: $560639d49e3c9a19$var$Laplacetrf,
  Larr: $560639d49e3c9a19$var$Larr,
  Lcaron: $560639d49e3c9a19$var$Lcaron,
  Lcedil: $560639d49e3c9a19$var$Lcedil,
  Lcy: $560639d49e3c9a19$var$Lcy,
  LeftAngleBracket: $560639d49e3c9a19$var$LeftAngleBracket,
  LeftArrow: $560639d49e3c9a19$var$LeftArrow,
  LeftArrowBar: $560639d49e3c9a19$var$LeftArrowBar,
  LeftArrowRightArrow: $560639d49e3c9a19$var$LeftArrowRightArrow,
  LeftCeiling: $560639d49e3c9a19$var$LeftCeiling,
  LeftDoubleBracket: $560639d49e3c9a19$var$LeftDoubleBracket,
  LeftDownTeeVector: $560639d49e3c9a19$var$LeftDownTeeVector,
  LeftDownVector: $560639d49e3c9a19$var$LeftDownVector,
  LeftDownVectorBar: $560639d49e3c9a19$var$LeftDownVectorBar,
  LeftFloor: $560639d49e3c9a19$var$LeftFloor,
  LeftRightArrow: $560639d49e3c9a19$var$LeftRightArrow,
  LeftRightVector: $560639d49e3c9a19$var$LeftRightVector,
  LeftTee: $560639d49e3c9a19$var$LeftTee,
  LeftTeeArrow: $560639d49e3c9a19$var$LeftTeeArrow,
  LeftTeeVector: $560639d49e3c9a19$var$LeftTeeVector,
  LeftTriangle: $560639d49e3c9a19$var$LeftTriangle,
  LeftTriangleBar: $560639d49e3c9a19$var$LeftTriangleBar,
  LeftTriangleEqual: $560639d49e3c9a19$var$LeftTriangleEqual,
  LeftUpDownVector: $560639d49e3c9a19$var$LeftUpDownVector,
  LeftUpTeeVector: $560639d49e3c9a19$var$LeftUpTeeVector,
  LeftUpVector: $560639d49e3c9a19$var$LeftUpVector,
  LeftUpVectorBar: $560639d49e3c9a19$var$LeftUpVectorBar,
  LeftVector: $560639d49e3c9a19$var$LeftVector,
  LeftVectorBar: $560639d49e3c9a19$var$LeftVectorBar,
  Leftarrow: $560639d49e3c9a19$var$Leftarrow,
  Leftrightarrow: $560639d49e3c9a19$var$Leftrightarrow,
  LessEqualGreater: $560639d49e3c9a19$var$LessEqualGreater,
  LessFullEqual: $560639d49e3c9a19$var$LessFullEqual,
  LessGreater: $560639d49e3c9a19$var$LessGreater,
  LessLess: $560639d49e3c9a19$var$LessLess,
  LessSlantEqual: $560639d49e3c9a19$var$LessSlantEqual,
  LessTilde: $560639d49e3c9a19$var$LessTilde,
  Lfr: $560639d49e3c9a19$var$Lfr,
  Ll: $560639d49e3c9a19$var$Ll,
  Lleftarrow: $560639d49e3c9a19$var$Lleftarrow,
  Lmidot: $560639d49e3c9a19$var$Lmidot,
  LongLeftArrow: $560639d49e3c9a19$var$LongLeftArrow,
  LongLeftRightArrow: $560639d49e3c9a19$var$LongLeftRightArrow,
  LongRightArrow: $560639d49e3c9a19$var$LongRightArrow,
  Longleftarrow: $560639d49e3c9a19$var$Longleftarrow,
  Longleftrightarrow: $560639d49e3c9a19$var$Longleftrightarrow,
  Longrightarrow: $560639d49e3c9a19$var$Longrightarrow,
  Lopf: $560639d49e3c9a19$var$Lopf,
  LowerLeftArrow: $560639d49e3c9a19$var$LowerLeftArrow,
  LowerRightArrow: $560639d49e3c9a19$var$LowerRightArrow,
  Lscr: $560639d49e3c9a19$var$Lscr,
  Lsh: $560639d49e3c9a19$var$Lsh,
  Lstrok: $560639d49e3c9a19$var$Lstrok,
  Lt: $560639d49e3c9a19$var$Lt,
  "Map": "⤅",
  Mcy: $560639d49e3c9a19$var$Mcy,
  MediumSpace: $560639d49e3c9a19$var$MediumSpace,
  Mellintrf: $560639d49e3c9a19$var$Mellintrf,
  Mfr: $560639d49e3c9a19$var$Mfr,
  MinusPlus: $560639d49e3c9a19$var$MinusPlus,
  Mopf: $560639d49e3c9a19$var$Mopf,
  Mscr: $560639d49e3c9a19$var$Mscr,
  Mu: $560639d49e3c9a19$var$Mu$1,
  NJcy: $560639d49e3c9a19$var$NJcy,
  Nacute: $560639d49e3c9a19$var$Nacute,
  Ncaron: $560639d49e3c9a19$var$Ncaron,
  Ncedil: $560639d49e3c9a19$var$Ncedil,
  Ncy: $560639d49e3c9a19$var$Ncy,
  NegativeMediumSpace: $560639d49e3c9a19$var$NegativeMediumSpace,
  NegativeThickSpace: $560639d49e3c9a19$var$NegativeThickSpace,
  NegativeThinSpace: $560639d49e3c9a19$var$NegativeThinSpace,
  NegativeVeryThinSpace: $560639d49e3c9a19$var$NegativeVeryThinSpace,
  NestedGreaterGreater: $560639d49e3c9a19$var$NestedGreaterGreater,
  NestedLessLess: $560639d49e3c9a19$var$NestedLessLess,
  NewLine: $560639d49e3c9a19$var$NewLine,
  Nfr: $560639d49e3c9a19$var$Nfr,
  NoBreak: $560639d49e3c9a19$var$NoBreak,
  NonBreakingSpace: $560639d49e3c9a19$var$NonBreakingSpace,
  Nopf: $560639d49e3c9a19$var$Nopf,
  Not: $560639d49e3c9a19$var$Not,
  NotCongruent: $560639d49e3c9a19$var$NotCongruent,
  NotCupCap: $560639d49e3c9a19$var$NotCupCap,
  NotDoubleVerticalBar: $560639d49e3c9a19$var$NotDoubleVerticalBar,
  NotElement: $560639d49e3c9a19$var$NotElement,
  NotEqual: $560639d49e3c9a19$var$NotEqual,
  NotEqualTilde: $560639d49e3c9a19$var$NotEqualTilde,
  NotExists: $560639d49e3c9a19$var$NotExists,
  NotGreater: $560639d49e3c9a19$var$NotGreater,
  NotGreaterEqual: $560639d49e3c9a19$var$NotGreaterEqual,
  NotGreaterFullEqual: $560639d49e3c9a19$var$NotGreaterFullEqual,
  NotGreaterGreater: $560639d49e3c9a19$var$NotGreaterGreater,
  NotGreaterLess: $560639d49e3c9a19$var$NotGreaterLess,
  NotGreaterSlantEqual: $560639d49e3c9a19$var$NotGreaterSlantEqual,
  NotGreaterTilde: $560639d49e3c9a19$var$NotGreaterTilde,
  NotHumpDownHump: $560639d49e3c9a19$var$NotHumpDownHump,
  NotHumpEqual: $560639d49e3c9a19$var$NotHumpEqual,
  NotLeftTriangle: $560639d49e3c9a19$var$NotLeftTriangle,
  NotLeftTriangleBar: $560639d49e3c9a19$var$NotLeftTriangleBar,
  NotLeftTriangleEqual: $560639d49e3c9a19$var$NotLeftTriangleEqual,
  NotLess: $560639d49e3c9a19$var$NotLess,
  NotLessEqual: $560639d49e3c9a19$var$NotLessEqual,
  NotLessGreater: $560639d49e3c9a19$var$NotLessGreater,
  NotLessLess: $560639d49e3c9a19$var$NotLessLess,
  NotLessSlantEqual: $560639d49e3c9a19$var$NotLessSlantEqual,
  NotLessTilde: $560639d49e3c9a19$var$NotLessTilde,
  NotNestedGreaterGreater: $560639d49e3c9a19$var$NotNestedGreaterGreater,
  NotNestedLessLess: $560639d49e3c9a19$var$NotNestedLessLess,
  NotPrecedes: $560639d49e3c9a19$var$NotPrecedes,
  NotPrecedesEqual: $560639d49e3c9a19$var$NotPrecedesEqual,
  NotPrecedesSlantEqual: $560639d49e3c9a19$var$NotPrecedesSlantEqual,
  NotReverseElement: $560639d49e3c9a19$var$NotReverseElement,
  NotRightTriangle: $560639d49e3c9a19$var$NotRightTriangle,
  NotRightTriangleBar: $560639d49e3c9a19$var$NotRightTriangleBar,
  NotRightTriangleEqual: $560639d49e3c9a19$var$NotRightTriangleEqual,
  NotSquareSubset: $560639d49e3c9a19$var$NotSquareSubset,
  NotSquareSubsetEqual: $560639d49e3c9a19$var$NotSquareSubsetEqual,
  NotSquareSuperset: $560639d49e3c9a19$var$NotSquareSuperset,
  NotSquareSupersetEqual: $560639d49e3c9a19$var$NotSquareSupersetEqual,
  NotSubset: $560639d49e3c9a19$var$NotSubset,
  NotSubsetEqual: $560639d49e3c9a19$var$NotSubsetEqual,
  NotSucceeds: $560639d49e3c9a19$var$NotSucceeds,
  NotSucceedsEqual: $560639d49e3c9a19$var$NotSucceedsEqual,
  NotSucceedsSlantEqual: $560639d49e3c9a19$var$NotSucceedsSlantEqual,
  NotSucceedsTilde: $560639d49e3c9a19$var$NotSucceedsTilde,
  NotSuperset: $560639d49e3c9a19$var$NotSuperset,
  NotSupersetEqual: $560639d49e3c9a19$var$NotSupersetEqual,
  NotTilde: $560639d49e3c9a19$var$NotTilde,
  NotTildeEqual: $560639d49e3c9a19$var$NotTildeEqual,
  NotTildeFullEqual: $560639d49e3c9a19$var$NotTildeFullEqual,
  NotTildeTilde: $560639d49e3c9a19$var$NotTildeTilde,
  NotVerticalBar: $560639d49e3c9a19$var$NotVerticalBar,
  Nscr: $560639d49e3c9a19$var$Nscr,
  Ntild: $560639d49e3c9a19$var$Ntild,
  Ntilde: $560639d49e3c9a19$var$Ntilde$1,
  Nu: $560639d49e3c9a19$var$Nu$1,
  OElig: $560639d49e3c9a19$var$OElig$1,
  Oacut: $560639d49e3c9a19$var$Oacut,
  Oacute: $560639d49e3c9a19$var$Oacute$1,
  Ocir: $560639d49e3c9a19$var$Ocir,
  Ocirc: $560639d49e3c9a19$var$Ocirc$1,
  Ocy: $560639d49e3c9a19$var$Ocy,
  Odblac: $560639d49e3c9a19$var$Odblac,
  Ofr: $560639d49e3c9a19$var$Ofr,
  Ograv: $560639d49e3c9a19$var$Ograv,
  Ograve: $560639d49e3c9a19$var$Ograve$1,
  Omacr: $560639d49e3c9a19$var$Omacr,
  Omega: $560639d49e3c9a19$var$Omega$1,
  Omicron: $560639d49e3c9a19$var$Omicron$1,
  Oopf: $560639d49e3c9a19$var$Oopf,
  OpenCurlyDoubleQuote: $560639d49e3c9a19$var$OpenCurlyDoubleQuote,
  OpenCurlyQuote: $560639d49e3c9a19$var$OpenCurlyQuote,
  Or: $560639d49e3c9a19$var$Or,
  Oscr: $560639d49e3c9a19$var$Oscr,
  Oslas: $560639d49e3c9a19$var$Oslas,
  Oslash: $560639d49e3c9a19$var$Oslash$1,
  Otild: $560639d49e3c9a19$var$Otild,
  Otilde: $560639d49e3c9a19$var$Otilde$1,
  Otimes: $560639d49e3c9a19$var$Otimes,
  Oum: $560639d49e3c9a19$var$Oum,
  Ouml: $560639d49e3c9a19$var$Ouml$1,
  OverBar: $560639d49e3c9a19$var$OverBar,
  OverBrace: $560639d49e3c9a19$var$OverBrace,
  OverBracket: $560639d49e3c9a19$var$OverBracket,
  OverParenthesis: $560639d49e3c9a19$var$OverParenthesis,
  PartialD: $560639d49e3c9a19$var$PartialD,
  Pcy: $560639d49e3c9a19$var$Pcy,
  Pfr: $560639d49e3c9a19$var$Pfr,
  Phi: $560639d49e3c9a19$var$Phi$1,
  Pi: $560639d49e3c9a19$var$Pi$1,
  PlusMinus: $560639d49e3c9a19$var$PlusMinus,
  Poincareplane: $560639d49e3c9a19$var$Poincareplane,
  Popf: $560639d49e3c9a19$var$Popf,
  Pr: $560639d49e3c9a19$var$Pr,
  Precedes: $560639d49e3c9a19$var$Precedes,
  PrecedesEqual: $560639d49e3c9a19$var$PrecedesEqual,
  PrecedesSlantEqual: $560639d49e3c9a19$var$PrecedesSlantEqual,
  PrecedesTilde: $560639d49e3c9a19$var$PrecedesTilde,
  Prime: $560639d49e3c9a19$var$Prime$1,
  Product: $560639d49e3c9a19$var$Product,
  Proportion: $560639d49e3c9a19$var$Proportion,
  Proportional: $560639d49e3c9a19$var$Proportional,
  Pscr: $560639d49e3c9a19$var$Pscr,
  Psi: $560639d49e3c9a19$var$Psi$1,
  QUO: $560639d49e3c9a19$var$QUO,
  QUOT: $560639d49e3c9a19$var$QUOT,
  Qfr: $560639d49e3c9a19$var$Qfr,
  Qopf: $560639d49e3c9a19$var$Qopf,
  Qscr: $560639d49e3c9a19$var$Qscr,
  RBarr: $560639d49e3c9a19$var$RBarr,
  RE: $560639d49e3c9a19$var$RE,
  REG: $560639d49e3c9a19$var$REG,
  Racute: $560639d49e3c9a19$var$Racute,
  Rang: $560639d49e3c9a19$var$Rang,
  Rarr: $560639d49e3c9a19$var$Rarr,
  Rarrtl: $560639d49e3c9a19$var$Rarrtl,
  Rcaron: $560639d49e3c9a19$var$Rcaron,
  Rcedil: $560639d49e3c9a19$var$Rcedil,
  Rcy: $560639d49e3c9a19$var$Rcy,
  Re: $560639d49e3c9a19$var$Re,
  ReverseElement: $560639d49e3c9a19$var$ReverseElement,
  ReverseEquilibrium: $560639d49e3c9a19$var$ReverseEquilibrium,
  ReverseUpEquilibrium: $560639d49e3c9a19$var$ReverseUpEquilibrium,
  Rfr: $560639d49e3c9a19$var$Rfr,
  Rho: $560639d49e3c9a19$var$Rho$1,
  RightAngleBracket: $560639d49e3c9a19$var$RightAngleBracket,
  RightArrow: $560639d49e3c9a19$var$RightArrow,
  RightArrowBar: $560639d49e3c9a19$var$RightArrowBar,
  RightArrowLeftArrow: $560639d49e3c9a19$var$RightArrowLeftArrow,
  RightCeiling: $560639d49e3c9a19$var$RightCeiling,
  RightDoubleBracket: $560639d49e3c9a19$var$RightDoubleBracket,
  RightDownTeeVector: $560639d49e3c9a19$var$RightDownTeeVector,
  RightDownVector: $560639d49e3c9a19$var$RightDownVector,
  RightDownVectorBar: $560639d49e3c9a19$var$RightDownVectorBar,
  RightFloor: $560639d49e3c9a19$var$RightFloor,
  RightTee: $560639d49e3c9a19$var$RightTee,
  RightTeeArrow: $560639d49e3c9a19$var$RightTeeArrow,
  RightTeeVector: $560639d49e3c9a19$var$RightTeeVector,
  RightTriangle: $560639d49e3c9a19$var$RightTriangle,
  RightTriangleBar: $560639d49e3c9a19$var$RightTriangleBar,
  RightTriangleEqual: $560639d49e3c9a19$var$RightTriangleEqual,
  RightUpDownVector: $560639d49e3c9a19$var$RightUpDownVector,
  RightUpTeeVector: $560639d49e3c9a19$var$RightUpTeeVector,
  RightUpVector: $560639d49e3c9a19$var$RightUpVector,
  RightUpVectorBar: $560639d49e3c9a19$var$RightUpVectorBar,
  RightVector: $560639d49e3c9a19$var$RightVector,
  RightVectorBar: $560639d49e3c9a19$var$RightVectorBar,
  Rightarrow: $560639d49e3c9a19$var$Rightarrow,
  Ropf: $560639d49e3c9a19$var$Ropf,
  RoundImplies: $560639d49e3c9a19$var$RoundImplies,
  Rrightarrow: $560639d49e3c9a19$var$Rrightarrow,
  Rscr: $560639d49e3c9a19$var$Rscr,
  Rsh: $560639d49e3c9a19$var$Rsh,
  RuleDelayed: $560639d49e3c9a19$var$RuleDelayed,
  SHCHcy: $560639d49e3c9a19$var$SHCHcy,
  SHcy: $560639d49e3c9a19$var$SHcy,
  SOFTcy: $560639d49e3c9a19$var$SOFTcy,
  Sacute: $560639d49e3c9a19$var$Sacute,
  Sc: $560639d49e3c9a19$var$Sc,
  Scaron: $560639d49e3c9a19$var$Scaron$1,
  Scedil: $560639d49e3c9a19$var$Scedil,
  Scirc: $560639d49e3c9a19$var$Scirc,
  Scy: $560639d49e3c9a19$var$Scy,
  Sfr: $560639d49e3c9a19$var$Sfr,
  ShortDownArrow: $560639d49e3c9a19$var$ShortDownArrow,
  ShortLeftArrow: $560639d49e3c9a19$var$ShortLeftArrow,
  ShortRightArrow: $560639d49e3c9a19$var$ShortRightArrow,
  ShortUpArrow: $560639d49e3c9a19$var$ShortUpArrow,
  Sigma: $560639d49e3c9a19$var$Sigma$1,
  SmallCircle: $560639d49e3c9a19$var$SmallCircle,
  Sopf: $560639d49e3c9a19$var$Sopf,
  Sqrt: $560639d49e3c9a19$var$Sqrt,
  Square: $560639d49e3c9a19$var$Square,
  SquareIntersection: $560639d49e3c9a19$var$SquareIntersection,
  SquareSubset: $560639d49e3c9a19$var$SquareSubset,
  SquareSubsetEqual: $560639d49e3c9a19$var$SquareSubsetEqual,
  SquareSuperset: $560639d49e3c9a19$var$SquareSuperset,
  SquareSupersetEqual: $560639d49e3c9a19$var$SquareSupersetEqual,
  SquareUnion: $560639d49e3c9a19$var$SquareUnion,
  Sscr: $560639d49e3c9a19$var$Sscr,
  Star: $560639d49e3c9a19$var$Star,
  Sub: $560639d49e3c9a19$var$Sub,
  Subset: $560639d49e3c9a19$var$Subset,
  SubsetEqual: $560639d49e3c9a19$var$SubsetEqual,
  Succeeds: $560639d49e3c9a19$var$Succeeds,
  SucceedsEqual: $560639d49e3c9a19$var$SucceedsEqual,
  SucceedsSlantEqual: $560639d49e3c9a19$var$SucceedsSlantEqual,
  SucceedsTilde: $560639d49e3c9a19$var$SucceedsTilde,
  SuchThat: $560639d49e3c9a19$var$SuchThat,
  Sum: $560639d49e3c9a19$var$Sum,
  Sup: $560639d49e3c9a19$var$Sup,
  Superset: $560639d49e3c9a19$var$Superset,
  SupersetEqual: $560639d49e3c9a19$var$SupersetEqual,
  Supset: $560639d49e3c9a19$var$Supset,
  THOR: $560639d49e3c9a19$var$THOR,
  THORN: $560639d49e3c9a19$var$THORN$1,
  TRADE: $560639d49e3c9a19$var$TRADE,
  TSHcy: $560639d49e3c9a19$var$TSHcy,
  TScy: $560639d49e3c9a19$var$TScy,
  Tab: $560639d49e3c9a19$var$Tab,
  Tau: $560639d49e3c9a19$var$Tau$1,
  Tcaron: $560639d49e3c9a19$var$Tcaron,
  Tcedil: $560639d49e3c9a19$var$Tcedil,
  Tcy: $560639d49e3c9a19$var$Tcy,
  Tfr: $560639d49e3c9a19$var$Tfr,
  Therefore: $560639d49e3c9a19$var$Therefore,
  Theta: $560639d49e3c9a19$var$Theta$1,
  ThickSpace: $560639d49e3c9a19$var$ThickSpace,
  ThinSpace: $560639d49e3c9a19$var$ThinSpace,
  Tilde: $560639d49e3c9a19$var$Tilde,
  TildeEqual: $560639d49e3c9a19$var$TildeEqual,
  TildeFullEqual: $560639d49e3c9a19$var$TildeFullEqual,
  TildeTilde: $560639d49e3c9a19$var$TildeTilde,
  Topf: $560639d49e3c9a19$var$Topf,
  TripleDot: $560639d49e3c9a19$var$TripleDot,
  Tscr: $560639d49e3c9a19$var$Tscr,
  Tstrok: $560639d49e3c9a19$var$Tstrok,
  Uacut: $560639d49e3c9a19$var$Uacut,
  Uacute: $560639d49e3c9a19$var$Uacute$1,
  Uarr: $560639d49e3c9a19$var$Uarr,
  Uarrocir: $560639d49e3c9a19$var$Uarrocir,
  Ubrcy: $560639d49e3c9a19$var$Ubrcy,
  Ubreve: $560639d49e3c9a19$var$Ubreve,
  Ucir: $560639d49e3c9a19$var$Ucir,
  Ucirc: $560639d49e3c9a19$var$Ucirc$1,
  Ucy: $560639d49e3c9a19$var$Ucy,
  Udblac: $560639d49e3c9a19$var$Udblac,
  Ufr: $560639d49e3c9a19$var$Ufr,
  Ugrav: $560639d49e3c9a19$var$Ugrav,
  Ugrave: $560639d49e3c9a19$var$Ugrave$1,
  Umacr: $560639d49e3c9a19$var$Umacr,
  UnderBar: $560639d49e3c9a19$var$UnderBar,
  UnderBrace: $560639d49e3c9a19$var$UnderBrace,
  UnderBracket: $560639d49e3c9a19$var$UnderBracket,
  UnderParenthesis: $560639d49e3c9a19$var$UnderParenthesis,
  Union: $560639d49e3c9a19$var$Union,
  UnionPlus: $560639d49e3c9a19$var$UnionPlus,
  Uogon: $560639d49e3c9a19$var$Uogon,
  Uopf: $560639d49e3c9a19$var$Uopf,
  UpArrow: $560639d49e3c9a19$var$UpArrow,
  UpArrowBar: $560639d49e3c9a19$var$UpArrowBar,
  UpArrowDownArrow: $560639d49e3c9a19$var$UpArrowDownArrow,
  UpDownArrow: $560639d49e3c9a19$var$UpDownArrow,
  UpEquilibrium: $560639d49e3c9a19$var$UpEquilibrium,
  UpTee: $560639d49e3c9a19$var$UpTee,
  UpTeeArrow: $560639d49e3c9a19$var$UpTeeArrow,
  Uparrow: $560639d49e3c9a19$var$Uparrow,
  Updownarrow: $560639d49e3c9a19$var$Updownarrow,
  UpperLeftArrow: $560639d49e3c9a19$var$UpperLeftArrow,
  UpperRightArrow: $560639d49e3c9a19$var$UpperRightArrow,
  Upsi: $560639d49e3c9a19$var$Upsi,
  Upsilon: $560639d49e3c9a19$var$Upsilon$1,
  Uring: $560639d49e3c9a19$var$Uring,
  Uscr: $560639d49e3c9a19$var$Uscr,
  Utilde: $560639d49e3c9a19$var$Utilde,
  Uum: $560639d49e3c9a19$var$Uum,
  Uuml: $560639d49e3c9a19$var$Uuml$1,
  VDash: $560639d49e3c9a19$var$VDash,
  Vbar: $560639d49e3c9a19$var$Vbar,
  Vcy: $560639d49e3c9a19$var$Vcy,
  Vdash: $560639d49e3c9a19$var$Vdash,
  Vdashl: $560639d49e3c9a19$var$Vdashl,
  Vee: $560639d49e3c9a19$var$Vee,
  Verbar: $560639d49e3c9a19$var$Verbar,
  Vert: $560639d49e3c9a19$var$Vert,
  VerticalBar: $560639d49e3c9a19$var$VerticalBar,
  VerticalLine: $560639d49e3c9a19$var$VerticalLine,
  VerticalSeparator: $560639d49e3c9a19$var$VerticalSeparator,
  VerticalTilde: $560639d49e3c9a19$var$VerticalTilde,
  VeryThinSpace: $560639d49e3c9a19$var$VeryThinSpace,
  Vfr: $560639d49e3c9a19$var$Vfr,
  Vopf: $560639d49e3c9a19$var$Vopf,
  Vscr: $560639d49e3c9a19$var$Vscr,
  Vvdash: $560639d49e3c9a19$var$Vvdash,
  Wcirc: $560639d49e3c9a19$var$Wcirc,
  Wedge: $560639d49e3c9a19$var$Wedge,
  Wfr: $560639d49e3c9a19$var$Wfr,
  Wopf: $560639d49e3c9a19$var$Wopf,
  Wscr: $560639d49e3c9a19$var$Wscr,
  Xfr: $560639d49e3c9a19$var$Xfr,
  Xi: $560639d49e3c9a19$var$Xi$1,
  Xopf: $560639d49e3c9a19$var$Xopf,
  Xscr: $560639d49e3c9a19$var$Xscr,
  YAcy: $560639d49e3c9a19$var$YAcy,
  YIcy: $560639d49e3c9a19$var$YIcy,
  YUcy: $560639d49e3c9a19$var$YUcy,
  Yacut: $560639d49e3c9a19$var$Yacut,
  Yacute: $560639d49e3c9a19$var$Yacute$1,
  Ycirc: $560639d49e3c9a19$var$Ycirc,
  Ycy: $560639d49e3c9a19$var$Ycy,
  Yfr: $560639d49e3c9a19$var$Yfr,
  Yopf: $560639d49e3c9a19$var$Yopf,
  Yscr: $560639d49e3c9a19$var$Yscr,
  Yuml: $560639d49e3c9a19$var$Yuml$1,
  ZHcy: $560639d49e3c9a19$var$ZHcy,
  Zacute: $560639d49e3c9a19$var$Zacute,
  Zcaron: $560639d49e3c9a19$var$Zcaron,
  Zcy: $560639d49e3c9a19$var$Zcy,
  Zdot: $560639d49e3c9a19$var$Zdot,
  ZeroWidthSpace: $560639d49e3c9a19$var$ZeroWidthSpace,
  Zeta: $560639d49e3c9a19$var$Zeta$1,
  Zfr: $560639d49e3c9a19$var$Zfr,
  Zopf: $560639d49e3c9a19$var$Zopf,
  Zscr: $560639d49e3c9a19$var$Zscr,
  aacut: $560639d49e3c9a19$var$aacut,
  aacute: $560639d49e3c9a19$var$aacute$1,
  abreve: $560639d49e3c9a19$var$abreve,
  ac: $560639d49e3c9a19$var$ac,
  acE: $560639d49e3c9a19$var$acE,
  acd: $560639d49e3c9a19$var$acd,
  acir: $560639d49e3c9a19$var$acir,
  acirc: $560639d49e3c9a19$var$acirc$1,
  acut: $560639d49e3c9a19$var$acut,
  acute: $560639d49e3c9a19$var$acute$1,
  acy: $560639d49e3c9a19$var$acy,
  aeli: $560639d49e3c9a19$var$aeli,
  aelig: $560639d49e3c9a19$var$aelig$1,
  af: $560639d49e3c9a19$var$af,
  afr: $560639d49e3c9a19$var$afr,
  agrav: $560639d49e3c9a19$var$agrav,
  agrave: $560639d49e3c9a19$var$agrave$1,
  alefsym: $560639d49e3c9a19$var$alefsym$1,
  aleph: $560639d49e3c9a19$var$aleph,
  alpha: $560639d49e3c9a19$var$alpha$1,
  amacr: $560639d49e3c9a19$var$amacr,
  amalg: $560639d49e3c9a19$var$amalg,
  am: $560639d49e3c9a19$var$am,
  amp: $560639d49e3c9a19$var$amp$1,
  and: $560639d49e3c9a19$var$and$1,
  andand: $560639d49e3c9a19$var$andand,
  andd: $560639d49e3c9a19$var$andd,
  andslope: $560639d49e3c9a19$var$andslope,
  andv: $560639d49e3c9a19$var$andv,
  ang: $560639d49e3c9a19$var$ang$1,
  ange: $560639d49e3c9a19$var$ange,
  angle: $560639d49e3c9a19$var$angle,
  angmsd: $560639d49e3c9a19$var$angmsd,
  angmsdaa: $560639d49e3c9a19$var$angmsdaa,
  angmsdab: $560639d49e3c9a19$var$angmsdab,
  angmsdac: $560639d49e3c9a19$var$angmsdac,
  angmsdad: $560639d49e3c9a19$var$angmsdad,
  angmsdae: $560639d49e3c9a19$var$angmsdae,
  angmsdaf: $560639d49e3c9a19$var$angmsdaf,
  angmsdag: $560639d49e3c9a19$var$angmsdag,
  angmsdah: $560639d49e3c9a19$var$angmsdah,
  angrt: $560639d49e3c9a19$var$angrt,
  angrtvb: $560639d49e3c9a19$var$angrtvb,
  angrtvbd: $560639d49e3c9a19$var$angrtvbd,
  angsph: $560639d49e3c9a19$var$angsph,
  angst: $560639d49e3c9a19$var$angst,
  angzarr: $560639d49e3c9a19$var$angzarr,
  aogon: $560639d49e3c9a19$var$aogon,
  aopf: $560639d49e3c9a19$var$aopf,
  ap: $560639d49e3c9a19$var$ap,
  apE: $560639d49e3c9a19$var$apE,
  apacir: $560639d49e3c9a19$var$apacir,
  ape: $560639d49e3c9a19$var$ape,
  apid: $560639d49e3c9a19$var$apid,
  apos: $560639d49e3c9a19$var$apos,
  approx: $560639d49e3c9a19$var$approx,
  approxeq: $560639d49e3c9a19$var$approxeq,
  arin: $560639d49e3c9a19$var$arin,
  aring: $560639d49e3c9a19$var$aring$1,
  ascr: $560639d49e3c9a19$var$ascr,
  ast: $560639d49e3c9a19$var$ast,
  asymp: $560639d49e3c9a19$var$asymp$1,
  asympeq: $560639d49e3c9a19$var$asympeq,
  atild: $560639d49e3c9a19$var$atild,
  atilde: $560639d49e3c9a19$var$atilde$1,
  aum: $560639d49e3c9a19$var$aum,
  auml: $560639d49e3c9a19$var$auml$1,
  awconint: $560639d49e3c9a19$var$awconint,
  awint: $560639d49e3c9a19$var$awint,
  bNot: $560639d49e3c9a19$var$bNot,
  backcong: $560639d49e3c9a19$var$backcong,
  backepsilon: $560639d49e3c9a19$var$backepsilon,
  backprime: $560639d49e3c9a19$var$backprime,
  backsim: $560639d49e3c9a19$var$backsim,
  backsimeq: $560639d49e3c9a19$var$backsimeq,
  barvee: $560639d49e3c9a19$var$barvee,
  barwed: $560639d49e3c9a19$var$barwed,
  barwedge: $560639d49e3c9a19$var$barwedge,
  bbrk: $560639d49e3c9a19$var$bbrk,
  bbrktbrk: $560639d49e3c9a19$var$bbrktbrk,
  bcong: $560639d49e3c9a19$var$bcong,
  bcy: $560639d49e3c9a19$var$bcy,
  bdquo: $560639d49e3c9a19$var$bdquo$1,
  becaus: $560639d49e3c9a19$var$becaus,
  because: $560639d49e3c9a19$var$because,
  bemptyv: $560639d49e3c9a19$var$bemptyv,
  bepsi: $560639d49e3c9a19$var$bepsi,
  bernou: $560639d49e3c9a19$var$bernou,
  beta: $560639d49e3c9a19$var$beta$1,
  beth: $560639d49e3c9a19$var$beth,
  between: $560639d49e3c9a19$var$between,
  bfr: $560639d49e3c9a19$var$bfr,
  bigcap: $560639d49e3c9a19$var$bigcap,
  bigcirc: $560639d49e3c9a19$var$bigcirc,
  bigcup: $560639d49e3c9a19$var$bigcup,
  bigodot: $560639d49e3c9a19$var$bigodot,
  bigoplus: $560639d49e3c9a19$var$bigoplus,
  bigotimes: $560639d49e3c9a19$var$bigotimes,
  bigsqcup: $560639d49e3c9a19$var$bigsqcup,
  bigstar: $560639d49e3c9a19$var$bigstar,
  bigtriangledown: $560639d49e3c9a19$var$bigtriangledown,
  bigtriangleup: $560639d49e3c9a19$var$bigtriangleup,
  biguplus: $560639d49e3c9a19$var$biguplus,
  bigvee: $560639d49e3c9a19$var$bigvee,
  bigwedge: $560639d49e3c9a19$var$bigwedge,
  bkarow: $560639d49e3c9a19$var$bkarow,
  blacklozenge: $560639d49e3c9a19$var$blacklozenge,
  blacksquare: $560639d49e3c9a19$var$blacksquare,
  blacktriangle: $560639d49e3c9a19$var$blacktriangle,
  blacktriangledown: $560639d49e3c9a19$var$blacktriangledown,
  blacktriangleleft: $560639d49e3c9a19$var$blacktriangleleft,
  blacktriangleright: $560639d49e3c9a19$var$blacktriangleright,
  blank: $560639d49e3c9a19$var$blank,
  blk12: $560639d49e3c9a19$var$blk12,
  blk14: $560639d49e3c9a19$var$blk14,
  blk34: $560639d49e3c9a19$var$blk34,
  block: $560639d49e3c9a19$var$block,
  bne: $560639d49e3c9a19$var$bne,
  bnequiv: $560639d49e3c9a19$var$bnequiv,
  bnot: $560639d49e3c9a19$var$bnot,
  bopf: $560639d49e3c9a19$var$bopf,
  bot: $560639d49e3c9a19$var$bot,
  bottom: $560639d49e3c9a19$var$bottom,
  bowtie: $560639d49e3c9a19$var$bowtie,
  boxDL: $560639d49e3c9a19$var$boxDL,
  boxDR: $560639d49e3c9a19$var$boxDR,
  boxDl: $560639d49e3c9a19$var$boxDl,
  boxDr: $560639d49e3c9a19$var$boxDr,
  boxH: $560639d49e3c9a19$var$boxH,
  boxHD: $560639d49e3c9a19$var$boxHD,
  boxHU: $560639d49e3c9a19$var$boxHU,
  boxHd: $560639d49e3c9a19$var$boxHd,
  boxHu: $560639d49e3c9a19$var$boxHu,
  boxUL: $560639d49e3c9a19$var$boxUL,
  boxUR: $560639d49e3c9a19$var$boxUR,
  boxUl: $560639d49e3c9a19$var$boxUl,
  boxUr: $560639d49e3c9a19$var$boxUr,
  boxV: $560639d49e3c9a19$var$boxV,
  boxVH: $560639d49e3c9a19$var$boxVH,
  boxVL: $560639d49e3c9a19$var$boxVL,
  boxVR: $560639d49e3c9a19$var$boxVR,
  boxVh: $560639d49e3c9a19$var$boxVh,
  boxVl: $560639d49e3c9a19$var$boxVl,
  boxVr: $560639d49e3c9a19$var$boxVr,
  boxbox: $560639d49e3c9a19$var$boxbox,
  boxdL: $560639d49e3c9a19$var$boxdL,
  boxdR: $560639d49e3c9a19$var$boxdR,
  boxdl: $560639d49e3c9a19$var$boxdl,
  boxdr: $560639d49e3c9a19$var$boxdr,
  boxh: $560639d49e3c9a19$var$boxh,
  boxhD: $560639d49e3c9a19$var$boxhD,
  boxhU: $560639d49e3c9a19$var$boxhU,
  boxhd: $560639d49e3c9a19$var$boxhd,
  boxhu: $560639d49e3c9a19$var$boxhu,
  boxminus: $560639d49e3c9a19$var$boxminus,
  boxplus: $560639d49e3c9a19$var$boxplus,
  boxtimes: $560639d49e3c9a19$var$boxtimes,
  boxuL: $560639d49e3c9a19$var$boxuL,
  boxuR: $560639d49e3c9a19$var$boxuR,
  boxul: $560639d49e3c9a19$var$boxul,
  boxur: $560639d49e3c9a19$var$boxur,
  boxv: $560639d49e3c9a19$var$boxv,
  boxvH: $560639d49e3c9a19$var$boxvH,
  boxvL: $560639d49e3c9a19$var$boxvL,
  boxvR: $560639d49e3c9a19$var$boxvR,
  boxvh: $560639d49e3c9a19$var$boxvh,
  boxvl: $560639d49e3c9a19$var$boxvl,
  boxvr: $560639d49e3c9a19$var$boxvr,
  bprime: $560639d49e3c9a19$var$bprime,
  breve: $560639d49e3c9a19$var$breve,
  brvba: $560639d49e3c9a19$var$brvba,
  brvbar: $560639d49e3c9a19$var$brvbar$1,
  bscr: $560639d49e3c9a19$var$bscr,
  bsemi: $560639d49e3c9a19$var$bsemi,
  bsim: $560639d49e3c9a19$var$bsim,
  bsime: $560639d49e3c9a19$var$bsime,
  bsol: $560639d49e3c9a19$var$bsol,
  bsolb: $560639d49e3c9a19$var$bsolb,
  bsolhsub: $560639d49e3c9a19$var$bsolhsub,
  bull: $560639d49e3c9a19$var$bull$1,
  bullet: $560639d49e3c9a19$var$bullet,
  bump: $560639d49e3c9a19$var$bump,
  bumpE: $560639d49e3c9a19$var$bumpE,
  bumpe: $560639d49e3c9a19$var$bumpe,
  bumpeq: $560639d49e3c9a19$var$bumpeq,
  cacute: $560639d49e3c9a19$var$cacute,
  cap: $560639d49e3c9a19$var$cap$2,
  capand: $560639d49e3c9a19$var$capand,
  capbrcup: $560639d49e3c9a19$var$capbrcup,
  capcap: $560639d49e3c9a19$var$capcap,
  capcup: $560639d49e3c9a19$var$capcup,
  capdot: $560639d49e3c9a19$var$capdot,
  caps: $560639d49e3c9a19$var$caps,
  caret: $560639d49e3c9a19$var$caret,
  caron: $560639d49e3c9a19$var$caron,
  ccaps: $560639d49e3c9a19$var$ccaps,
  ccaron: $560639d49e3c9a19$var$ccaron,
  ccedi: $560639d49e3c9a19$var$ccedi,
  ccedil: $560639d49e3c9a19$var$ccedil$1,
  ccirc: $560639d49e3c9a19$var$ccirc,
  ccups: $560639d49e3c9a19$var$ccups,
  ccupssm: $560639d49e3c9a19$var$ccupssm,
  cdot: $560639d49e3c9a19$var$cdot,
  cedi: $560639d49e3c9a19$var$cedi,
  cedil: $560639d49e3c9a19$var$cedil$1,
  cemptyv: $560639d49e3c9a19$var$cemptyv,
  cen: $560639d49e3c9a19$var$cen,
  cent: $560639d49e3c9a19$var$cent$1,
  centerdot: $560639d49e3c9a19$var$centerdot,
  cfr: $560639d49e3c9a19$var$cfr,
  chcy: $560639d49e3c9a19$var$chcy,
  check: $560639d49e3c9a19$var$check,
  checkmark: $560639d49e3c9a19$var$checkmark,
  chi: $560639d49e3c9a19$var$chi$1,
  cir: $560639d49e3c9a19$var$cir,
  cirE: $560639d49e3c9a19$var$cirE,
  circ: $560639d49e3c9a19$var$circ$1,
  circeq: $560639d49e3c9a19$var$circeq,
  circlearrowleft: $560639d49e3c9a19$var$circlearrowleft,
  circlearrowright: $560639d49e3c9a19$var$circlearrowright,
  circledR: $560639d49e3c9a19$var$circledR,
  circledS: $560639d49e3c9a19$var$circledS,
  circledast: $560639d49e3c9a19$var$circledast,
  circledcirc: $560639d49e3c9a19$var$circledcirc,
  circleddash: $560639d49e3c9a19$var$circleddash,
  cire: $560639d49e3c9a19$var$cire,
  cirfnint: $560639d49e3c9a19$var$cirfnint,
  cirmid: $560639d49e3c9a19$var$cirmid,
  cirscir: $560639d49e3c9a19$var$cirscir,
  clubs: $560639d49e3c9a19$var$clubs$1,
  clubsuit: $560639d49e3c9a19$var$clubsuit,
  colon: $560639d49e3c9a19$var$colon$3,
  colone: $560639d49e3c9a19$var$colone,
  coloneq: $560639d49e3c9a19$var$coloneq,
  comma: $560639d49e3c9a19$var$comma$2,
  commat: $560639d49e3c9a19$var$commat,
  comp: $560639d49e3c9a19$var$comp,
  compfn: $560639d49e3c9a19$var$compfn,
  complement: $560639d49e3c9a19$var$complement,
  complexes: $560639d49e3c9a19$var$complexes,
  cong: $560639d49e3c9a19$var$cong$1,
  congdot: $560639d49e3c9a19$var$congdot,
  conint: $560639d49e3c9a19$var$conint,
  copf: $560639d49e3c9a19$var$copf,
  coprod: $560639d49e3c9a19$var$coprod,
  cop: $560639d49e3c9a19$var$cop,
  copy: $560639d49e3c9a19$var$copy$1,
  copysr: $560639d49e3c9a19$var$copysr,
  crarr: $560639d49e3c9a19$var$crarr$1,
  cross: $560639d49e3c9a19$var$cross,
  cscr: $560639d49e3c9a19$var$cscr,
  csub: $560639d49e3c9a19$var$csub,
  csube: $560639d49e3c9a19$var$csube,
  csup: $560639d49e3c9a19$var$csup,
  csupe: $560639d49e3c9a19$var$csupe,
  ctdot: $560639d49e3c9a19$var$ctdot,
  cudarrl: $560639d49e3c9a19$var$cudarrl,
  cudarrr: $560639d49e3c9a19$var$cudarrr,
  cuepr: $560639d49e3c9a19$var$cuepr,
  cuesc: $560639d49e3c9a19$var$cuesc,
  cularr: $560639d49e3c9a19$var$cularr,
  cularrp: $560639d49e3c9a19$var$cularrp,
  cup: $560639d49e3c9a19$var$cup$1,
  cupbrcap: $560639d49e3c9a19$var$cupbrcap,
  cupcap: $560639d49e3c9a19$var$cupcap,
  cupcup: $560639d49e3c9a19$var$cupcup,
  cupdot: $560639d49e3c9a19$var$cupdot,
  cupor: $560639d49e3c9a19$var$cupor,
  cups: $560639d49e3c9a19$var$cups,
  curarr: $560639d49e3c9a19$var$curarr,
  curarrm: $560639d49e3c9a19$var$curarrm,
  curlyeqprec: $560639d49e3c9a19$var$curlyeqprec,
  curlyeqsucc: $560639d49e3c9a19$var$curlyeqsucc,
  curlyvee: $560639d49e3c9a19$var$curlyvee,
  curlywedge: $560639d49e3c9a19$var$curlywedge,
  curre: $560639d49e3c9a19$var$curre,
  curren: $560639d49e3c9a19$var$curren$1,
  curvearrowleft: $560639d49e3c9a19$var$curvearrowleft,
  curvearrowright: $560639d49e3c9a19$var$curvearrowright,
  cuvee: $560639d49e3c9a19$var$cuvee,
  cuwed: $560639d49e3c9a19$var$cuwed,
  cwconint: $560639d49e3c9a19$var$cwconint,
  cwint: $560639d49e3c9a19$var$cwint,
  cylcty: $560639d49e3c9a19$var$cylcty,
  dArr: $560639d49e3c9a19$var$dArr$1,
  dHar: $560639d49e3c9a19$var$dHar,
  dagger: $560639d49e3c9a19$var$dagger$1,
  daleth: $560639d49e3c9a19$var$daleth,
  darr: $560639d49e3c9a19$var$darr$1,
  dash: $560639d49e3c9a19$var$dash$8,
  dashv: $560639d49e3c9a19$var$dashv,
  dbkarow: $560639d49e3c9a19$var$dbkarow,
  dblac: $560639d49e3c9a19$var$dblac,
  dcaron: $560639d49e3c9a19$var$dcaron,
  dcy: $560639d49e3c9a19$var$dcy,
  dd: $560639d49e3c9a19$var$dd$1,
  ddagger: $560639d49e3c9a19$var$ddagger,
  ddarr: $560639d49e3c9a19$var$ddarr,
  ddotseq: $560639d49e3c9a19$var$ddotseq,
  de: $560639d49e3c9a19$var$de,
  deg: $560639d49e3c9a19$var$deg$1,
  delta: $560639d49e3c9a19$var$delta$1,
  demptyv: $560639d49e3c9a19$var$demptyv,
  dfisht: $560639d49e3c9a19$var$dfisht,
  dfr: $560639d49e3c9a19$var$dfr,
  dharl: $560639d49e3c9a19$var$dharl,
  dharr: $560639d49e3c9a19$var$dharr,
  diam: $560639d49e3c9a19$var$diam,
  diamond: $560639d49e3c9a19$var$diamond,
  diamondsuit: $560639d49e3c9a19$var$diamondsuit,
  diams: $560639d49e3c9a19$var$diams$1,
  die: $560639d49e3c9a19$var$die,
  digamma: $560639d49e3c9a19$var$digamma,
  disin: $560639d49e3c9a19$var$disin,
  div: $560639d49e3c9a19$var$div,
  divid: $560639d49e3c9a19$var$divid,
  divide: $560639d49e3c9a19$var$divide$1,
  divideontimes: $560639d49e3c9a19$var$divideontimes,
  divonx: $560639d49e3c9a19$var$divonx,
  djcy: $560639d49e3c9a19$var$djcy,
  dlcorn: $560639d49e3c9a19$var$dlcorn,
  dlcrop: $560639d49e3c9a19$var$dlcrop,
  dollar: $560639d49e3c9a19$var$dollar,
  dopf: $560639d49e3c9a19$var$dopf,
  dot: $560639d49e3c9a19$var$dot$4,
  doteq: $560639d49e3c9a19$var$doteq,
  doteqdot: $560639d49e3c9a19$var$doteqdot,
  dotminus: $560639d49e3c9a19$var$dotminus,
  dotplus: $560639d49e3c9a19$var$dotplus,
  dotsquare: $560639d49e3c9a19$var$dotsquare,
  doublebarwedge: $560639d49e3c9a19$var$doublebarwedge,
  downarrow: $560639d49e3c9a19$var$downarrow,
  downdownarrows: $560639d49e3c9a19$var$downdownarrows,
  downharpoonleft: $560639d49e3c9a19$var$downharpoonleft,
  downharpoonright: $560639d49e3c9a19$var$downharpoonright,
  drbkarow: $560639d49e3c9a19$var$drbkarow,
  drcorn: $560639d49e3c9a19$var$drcorn,
  drcrop: $560639d49e3c9a19$var$drcrop,
  dscr: $560639d49e3c9a19$var$dscr,
  dscy: $560639d49e3c9a19$var$dscy,
  dsol: $560639d49e3c9a19$var$dsol,
  dstrok: $560639d49e3c9a19$var$dstrok,
  dtdot: $560639d49e3c9a19$var$dtdot,
  dtri: $560639d49e3c9a19$var$dtri,
  dtrif: $560639d49e3c9a19$var$dtrif,
  duarr: $560639d49e3c9a19$var$duarr,
  duhar: $560639d49e3c9a19$var$duhar,
  dwangle: $560639d49e3c9a19$var$dwangle,
  dzcy: $560639d49e3c9a19$var$dzcy,
  dzigrarr: $560639d49e3c9a19$var$dzigrarr,
  eDDot: $560639d49e3c9a19$var$eDDot,
  eDot: $560639d49e3c9a19$var$eDot,
  eacut: $560639d49e3c9a19$var$eacut,
  eacute: $560639d49e3c9a19$var$eacute$1,
  easter: $560639d49e3c9a19$var$easter,
  ecaron: $560639d49e3c9a19$var$ecaron,
  ecir: $560639d49e3c9a19$var$ecir,
  ecirc: $560639d49e3c9a19$var$ecirc$1,
  ecolon: $560639d49e3c9a19$var$ecolon,
  ecy: $560639d49e3c9a19$var$ecy,
  edot: $560639d49e3c9a19$var$edot,
  ee: $560639d49e3c9a19$var$ee,
  efDot: $560639d49e3c9a19$var$efDot,
  efr: $560639d49e3c9a19$var$efr,
  eg: $560639d49e3c9a19$var$eg,
  egrav: $560639d49e3c9a19$var$egrav,
  egrave: $560639d49e3c9a19$var$egrave$1,
  egs: $560639d49e3c9a19$var$egs,
  egsdot: $560639d49e3c9a19$var$egsdot,
  el: $560639d49e3c9a19$var$el,
  elinters: $560639d49e3c9a19$var$elinters,
  ell: $560639d49e3c9a19$var$ell,
  els: $560639d49e3c9a19$var$els,
  elsdot: $560639d49e3c9a19$var$elsdot,
  emacr: $560639d49e3c9a19$var$emacr,
  empty: $560639d49e3c9a19$var$empty$3,
  emptyset: $560639d49e3c9a19$var$emptyset,
  emptyv: $560639d49e3c9a19$var$emptyv,
  emsp13: $560639d49e3c9a19$var$emsp13,
  emsp14: $560639d49e3c9a19$var$emsp14,
  emsp: $560639d49e3c9a19$var$emsp$1,
  eng: $560639d49e3c9a19$var$eng,
  ensp: $560639d49e3c9a19$var$ensp$1,
  eogon: $560639d49e3c9a19$var$eogon,
  eopf: $560639d49e3c9a19$var$eopf,
  epar: $560639d49e3c9a19$var$epar,
  eparsl: $560639d49e3c9a19$var$eparsl,
  eplus: $560639d49e3c9a19$var$eplus,
  epsi: $560639d49e3c9a19$var$epsi,
  epsilon: $560639d49e3c9a19$var$epsilon$1,
  epsiv: $560639d49e3c9a19$var$epsiv,
  eqcirc: $560639d49e3c9a19$var$eqcirc,
  eqcolon: $560639d49e3c9a19$var$eqcolon,
  eqsim: $560639d49e3c9a19$var$eqsim,
  eqslantgtr: $560639d49e3c9a19$var$eqslantgtr,
  eqslantless: $560639d49e3c9a19$var$eqslantless,
  equals: $560639d49e3c9a19$var$equals,
  equest: $560639d49e3c9a19$var$equest,
  equiv: $560639d49e3c9a19$var$equiv$1,
  equivDD: $560639d49e3c9a19$var$equivDD,
  eqvparsl: $560639d49e3c9a19$var$eqvparsl,
  erDot: $560639d49e3c9a19$var$erDot,
  erarr: $560639d49e3c9a19$var$erarr,
  escr: $560639d49e3c9a19$var$escr,
  esdot: $560639d49e3c9a19$var$esdot,
  esim: $560639d49e3c9a19$var$esim,
  eta: $560639d49e3c9a19$var$eta$1,
  et: $560639d49e3c9a19$var$et,
  eth: $560639d49e3c9a19$var$eth$1,
  eum: $560639d49e3c9a19$var$eum,
  euml: $560639d49e3c9a19$var$euml$1,
  euro: $560639d49e3c9a19$var$euro$1,
  excl: $560639d49e3c9a19$var$excl,
  exist: $560639d49e3c9a19$var$exist$1,
  expectation: $560639d49e3c9a19$var$expectation,
  exponentiale: $560639d49e3c9a19$var$exponentiale,
  fallingdotseq: $560639d49e3c9a19$var$fallingdotseq,
  fcy: $560639d49e3c9a19$var$fcy,
  female: $560639d49e3c9a19$var$female,
  ffilig: $560639d49e3c9a19$var$ffilig,
  fflig: $560639d49e3c9a19$var$fflig,
  ffllig: $560639d49e3c9a19$var$ffllig,
  ffr: $560639d49e3c9a19$var$ffr,
  filig: $560639d49e3c9a19$var$filig,
  fjlig: $560639d49e3c9a19$var$fjlig,
  flat: $560639d49e3c9a19$var$flat,
  fllig: $560639d49e3c9a19$var$fllig,
  fltns: $560639d49e3c9a19$var$fltns,
  fnof: $560639d49e3c9a19$var$fnof$1,
  fopf: $560639d49e3c9a19$var$fopf,
  forall: $560639d49e3c9a19$var$forall$1,
  fork: $560639d49e3c9a19$var$fork,
  forkv: $560639d49e3c9a19$var$forkv,
  fpartint: $560639d49e3c9a19$var$fpartint,
  frac1: $560639d49e3c9a19$var$frac1,
  frac12: $560639d49e3c9a19$var$frac12$1,
  frac13: $560639d49e3c9a19$var$frac13,
  frac14: $560639d49e3c9a19$var$frac14$1,
  frac15: $560639d49e3c9a19$var$frac15,
  frac16: $560639d49e3c9a19$var$frac16,
  frac18: $560639d49e3c9a19$var$frac18,
  frac23: $560639d49e3c9a19$var$frac23,
  frac25: $560639d49e3c9a19$var$frac25,
  frac3: $560639d49e3c9a19$var$frac3,
  frac34: $560639d49e3c9a19$var$frac34$1,
  frac35: $560639d49e3c9a19$var$frac35,
  frac38: $560639d49e3c9a19$var$frac38,
  frac45: $560639d49e3c9a19$var$frac45,
  frac56: $560639d49e3c9a19$var$frac56,
  frac58: $560639d49e3c9a19$var$frac58,
  frac78: $560639d49e3c9a19$var$frac78,
  frasl: $560639d49e3c9a19$var$frasl$1,
  frown: $560639d49e3c9a19$var$frown,
  fscr: $560639d49e3c9a19$var$fscr,
  gE: $560639d49e3c9a19$var$gE,
  gEl: $560639d49e3c9a19$var$gEl,
  gacute: $560639d49e3c9a19$var$gacute,
  gamma: $560639d49e3c9a19$var$gamma$1,
  gammad: $560639d49e3c9a19$var$gammad,
  gap: $560639d49e3c9a19$var$gap,
  gbreve: $560639d49e3c9a19$var$gbreve,
  gcirc: $560639d49e3c9a19$var$gcirc,
  gcy: $560639d49e3c9a19$var$gcy,
  gdot: $560639d49e3c9a19$var$gdot,
  ge: $560639d49e3c9a19$var$ge$1,
  gel: $560639d49e3c9a19$var$gel,
  geq: $560639d49e3c9a19$var$geq,
  geqq: $560639d49e3c9a19$var$geqq,
  geqslant: $560639d49e3c9a19$var$geqslant,
  ges: $560639d49e3c9a19$var$ges,
  gescc: $560639d49e3c9a19$var$gescc,
  gesdot: $560639d49e3c9a19$var$gesdot,
  gesdoto: $560639d49e3c9a19$var$gesdoto,
  gesdotol: $560639d49e3c9a19$var$gesdotol,
  gesl: $560639d49e3c9a19$var$gesl,
  gesles: $560639d49e3c9a19$var$gesles,
  gfr: $560639d49e3c9a19$var$gfr,
  gg: $560639d49e3c9a19$var$gg,
  ggg: $560639d49e3c9a19$var$ggg,
  gimel: $560639d49e3c9a19$var$gimel,
  gjcy: $560639d49e3c9a19$var$gjcy,
  gl: $560639d49e3c9a19$var$gl,
  glE: $560639d49e3c9a19$var$glE,
  gla: $560639d49e3c9a19$var$gla,
  glj: $560639d49e3c9a19$var$glj,
  gnE: $560639d49e3c9a19$var$gnE,
  gnap: $560639d49e3c9a19$var$gnap,
  gnapprox: $560639d49e3c9a19$var$gnapprox,
  gne: $560639d49e3c9a19$var$gne,
  gneq: $560639d49e3c9a19$var$gneq,
  gneqq: $560639d49e3c9a19$var$gneqq,
  gnsim: $560639d49e3c9a19$var$gnsim,
  gopf: $560639d49e3c9a19$var$gopf,
  grave: $560639d49e3c9a19$var$grave,
  gscr: $560639d49e3c9a19$var$gscr,
  gsim: $560639d49e3c9a19$var$gsim,
  gsime: $560639d49e3c9a19$var$gsime,
  gsiml: $560639d49e3c9a19$var$gsiml,
  g: $560639d49e3c9a19$var$g,
  gt: $560639d49e3c9a19$var$gt$1,
  gtcc: $560639d49e3c9a19$var$gtcc,
  gtcir: $560639d49e3c9a19$var$gtcir,
  gtdot: $560639d49e3c9a19$var$gtdot,
  gtlPar: $560639d49e3c9a19$var$gtlPar,
  gtquest: $560639d49e3c9a19$var$gtquest,
  gtrapprox: $560639d49e3c9a19$var$gtrapprox,
  gtrarr: $560639d49e3c9a19$var$gtrarr,
  gtrdot: $560639d49e3c9a19$var$gtrdot,
  gtreqless: $560639d49e3c9a19$var$gtreqless,
  gtreqqless: $560639d49e3c9a19$var$gtreqqless,
  gtrless: $560639d49e3c9a19$var$gtrless,
  gtrsim: $560639d49e3c9a19$var$gtrsim,
  gvertneqq: $560639d49e3c9a19$var$gvertneqq,
  gvnE: $560639d49e3c9a19$var$gvnE,
  hArr: $560639d49e3c9a19$var$hArr$1,
  hairsp: $560639d49e3c9a19$var$hairsp,
  half: $560639d49e3c9a19$var$half,
  hamilt: $560639d49e3c9a19$var$hamilt,
  hardcy: $560639d49e3c9a19$var$hardcy,
  harr: $560639d49e3c9a19$var$harr$1,
  harrcir: $560639d49e3c9a19$var$harrcir,
  harrw: $560639d49e3c9a19$var$harrw,
  hbar: $560639d49e3c9a19$var$hbar,
  hcirc: $560639d49e3c9a19$var$hcirc,
  hearts: $560639d49e3c9a19$var$hearts$1,
  heartsuit: $560639d49e3c9a19$var$heartsuit,
  hellip: $560639d49e3c9a19$var$hellip$1,
  hercon: $560639d49e3c9a19$var$hercon,
  hfr: $560639d49e3c9a19$var$hfr,
  hksearow: $560639d49e3c9a19$var$hksearow,
  hkswarow: $560639d49e3c9a19$var$hkswarow,
  hoarr: $560639d49e3c9a19$var$hoarr,
  homtht: $560639d49e3c9a19$var$homtht,
  hookleftarrow: $560639d49e3c9a19$var$hookleftarrow,
  hookrightarrow: $560639d49e3c9a19$var$hookrightarrow,
  hopf: $560639d49e3c9a19$var$hopf,
  horbar: $560639d49e3c9a19$var$horbar,
  hscr: $560639d49e3c9a19$var$hscr,
  hslash: $560639d49e3c9a19$var$hslash,
  hstrok: $560639d49e3c9a19$var$hstrok,
  hybull: $560639d49e3c9a19$var$hybull,
  hyphen: $560639d49e3c9a19$var$hyphen,
  iacut: $560639d49e3c9a19$var$iacut,
  iacute: $560639d49e3c9a19$var$iacute$1,
  ic: $560639d49e3c9a19$var$ic,
  icir: $560639d49e3c9a19$var$icir,
  icirc: $560639d49e3c9a19$var$icirc$1,
  icy: $560639d49e3c9a19$var$icy,
  iecy: $560639d49e3c9a19$var$iecy,
  iexc: $560639d49e3c9a19$var$iexc,
  iexcl: $560639d49e3c9a19$var$iexcl$1,
  iff: $560639d49e3c9a19$var$iff,
  ifr: $560639d49e3c9a19$var$ifr,
  igrav: $560639d49e3c9a19$var$igrav,
  igrave: $560639d49e3c9a19$var$igrave$1,
  ii: $560639d49e3c9a19$var$ii,
  iiiint: $560639d49e3c9a19$var$iiiint,
  iiint: $560639d49e3c9a19$var$iiint,
  iinfin: $560639d49e3c9a19$var$iinfin,
  iiota: $560639d49e3c9a19$var$iiota,
  ijlig: $560639d49e3c9a19$var$ijlig,
  imacr: $560639d49e3c9a19$var$imacr,
  image: $560639d49e3c9a19$var$image$3,
  imagline: $560639d49e3c9a19$var$imagline,
  imagpart: $560639d49e3c9a19$var$imagpart,
  imath: $560639d49e3c9a19$var$imath,
  imof: $560639d49e3c9a19$var$imof,
  imped: $560639d49e3c9a19$var$imped,
  "in": "∈",
  incare: $560639d49e3c9a19$var$incare,
  infin: $560639d49e3c9a19$var$infin$1,
  infintie: $560639d49e3c9a19$var$infintie,
  inodot: $560639d49e3c9a19$var$inodot,
  int: $560639d49e3c9a19$var$int$1,
  intcal: $560639d49e3c9a19$var$intcal,
  integers: $560639d49e3c9a19$var$integers,
  intercal: $560639d49e3c9a19$var$intercal,
  intlarhk: $560639d49e3c9a19$var$intlarhk,
  intprod: $560639d49e3c9a19$var$intprod,
  iocy: $560639d49e3c9a19$var$iocy,
  iogon: $560639d49e3c9a19$var$iogon,
  iopf: $560639d49e3c9a19$var$iopf,
  iota: $560639d49e3c9a19$var$iota$1,
  iprod: $560639d49e3c9a19$var$iprod,
  iques: $560639d49e3c9a19$var$iques,
  iquest: $560639d49e3c9a19$var$iquest$1,
  iscr: $560639d49e3c9a19$var$iscr,
  isin: $560639d49e3c9a19$var$isin$1,
  isinE: $560639d49e3c9a19$var$isinE,
  isindot: $560639d49e3c9a19$var$isindot,
  isins: $560639d49e3c9a19$var$isins,
  isinsv: $560639d49e3c9a19$var$isinsv,
  isinv: $560639d49e3c9a19$var$isinv,
  it: $560639d49e3c9a19$var$it,
  itilde: $560639d49e3c9a19$var$itilde,
  iukcy: $560639d49e3c9a19$var$iukcy,
  ium: $560639d49e3c9a19$var$ium,
  iuml: $560639d49e3c9a19$var$iuml$1,
  jcirc: $560639d49e3c9a19$var$jcirc,
  jcy: $560639d49e3c9a19$var$jcy,
  jfr: $560639d49e3c9a19$var$jfr,
  jmath: $560639d49e3c9a19$var$jmath,
  jopf: $560639d49e3c9a19$var$jopf,
  jscr: $560639d49e3c9a19$var$jscr,
  jsercy: $560639d49e3c9a19$var$jsercy,
  jukcy: $560639d49e3c9a19$var$jukcy,
  kappa: $560639d49e3c9a19$var$kappa$1,
  kappav: $560639d49e3c9a19$var$kappav,
  kcedil: $560639d49e3c9a19$var$kcedil,
  kcy: $560639d49e3c9a19$var$kcy,
  kfr: $560639d49e3c9a19$var$kfr,
  kgreen: $560639d49e3c9a19$var$kgreen,
  khcy: $560639d49e3c9a19$var$khcy,
  kjcy: $560639d49e3c9a19$var$kjcy,
  kopf: $560639d49e3c9a19$var$kopf,
  kscr: $560639d49e3c9a19$var$kscr,
  lAarr: $560639d49e3c9a19$var$lAarr,
  lArr: $560639d49e3c9a19$var$lArr$1,
  lAtail: $560639d49e3c9a19$var$lAtail,
  lBarr: $560639d49e3c9a19$var$lBarr,
  lE: $560639d49e3c9a19$var$lE,
  lEg: $560639d49e3c9a19$var$lEg,
  lHar: $560639d49e3c9a19$var$lHar,
  lacute: $560639d49e3c9a19$var$lacute,
  laemptyv: $560639d49e3c9a19$var$laemptyv,
  lagran: $560639d49e3c9a19$var$lagran,
  lambda: $560639d49e3c9a19$var$lambda$1,
  lang: $560639d49e3c9a19$var$lang$1,
  langd: $560639d49e3c9a19$var$langd,
  langle: $560639d49e3c9a19$var$langle,
  lap: $560639d49e3c9a19$var$lap,
  laqu: $560639d49e3c9a19$var$laqu,
  laquo: $560639d49e3c9a19$var$laquo$1,
  larr: $560639d49e3c9a19$var$larr$1,
  larrb: $560639d49e3c9a19$var$larrb,
  larrbfs: $560639d49e3c9a19$var$larrbfs,
  larrfs: $560639d49e3c9a19$var$larrfs,
  larrhk: $560639d49e3c9a19$var$larrhk,
  larrlp: $560639d49e3c9a19$var$larrlp,
  larrpl: $560639d49e3c9a19$var$larrpl,
  larrsim: $560639d49e3c9a19$var$larrsim,
  larrtl: $560639d49e3c9a19$var$larrtl,
  lat: $560639d49e3c9a19$var$lat,
  latail: $560639d49e3c9a19$var$latail,
  late: $560639d49e3c9a19$var$late,
  lates: $560639d49e3c9a19$var$lates,
  lbarr: $560639d49e3c9a19$var$lbarr,
  lbbrk: $560639d49e3c9a19$var$lbbrk,
  lbrace: $560639d49e3c9a19$var$lbrace,
  lbrack: $560639d49e3c9a19$var$lbrack,
  lbrke: $560639d49e3c9a19$var$lbrke,
  lbrksld: $560639d49e3c9a19$var$lbrksld,
  lbrkslu: $560639d49e3c9a19$var$lbrkslu,
  lcaron: $560639d49e3c9a19$var$lcaron,
  lcedil: $560639d49e3c9a19$var$lcedil,
  lceil: $560639d49e3c9a19$var$lceil$1,
  lcub: $560639d49e3c9a19$var$lcub,
  lcy: $560639d49e3c9a19$var$lcy,
  ldca: $560639d49e3c9a19$var$ldca,
  ldquo: $560639d49e3c9a19$var$ldquo$1,
  ldquor: $560639d49e3c9a19$var$ldquor,
  ldrdhar: $560639d49e3c9a19$var$ldrdhar,
  ldrushar: $560639d49e3c9a19$var$ldrushar,
  ldsh: $560639d49e3c9a19$var$ldsh,
  le: $560639d49e3c9a19$var$le$1,
  leftarrow: $560639d49e3c9a19$var$leftarrow,
  leftarrowtail: $560639d49e3c9a19$var$leftarrowtail,
  leftharpoondown: $560639d49e3c9a19$var$leftharpoondown,
  leftharpoonup: $560639d49e3c9a19$var$leftharpoonup,
  leftleftarrows: $560639d49e3c9a19$var$leftleftarrows,
  leftrightarrow: $560639d49e3c9a19$var$leftrightarrow,
  leftrightarrows: $560639d49e3c9a19$var$leftrightarrows,
  leftrightharpoons: $560639d49e3c9a19$var$leftrightharpoons,
  leftrightsquigarrow: $560639d49e3c9a19$var$leftrightsquigarrow,
  leftthreetimes: $560639d49e3c9a19$var$leftthreetimes,
  leg: $560639d49e3c9a19$var$leg,
  leq: $560639d49e3c9a19$var$leq,
  leqq: $560639d49e3c9a19$var$leqq,
  leqslant: $560639d49e3c9a19$var$leqslant,
  les: $560639d49e3c9a19$var$les,
  lescc: $560639d49e3c9a19$var$lescc,
  lesdot: $560639d49e3c9a19$var$lesdot,
  lesdoto: $560639d49e3c9a19$var$lesdoto,
  lesdotor: $560639d49e3c9a19$var$lesdotor,
  lesg: $560639d49e3c9a19$var$lesg,
  lesges: $560639d49e3c9a19$var$lesges,
  lessapprox: $560639d49e3c9a19$var$lessapprox,
  lessdot: $560639d49e3c9a19$var$lessdot,
  lesseqgtr: $560639d49e3c9a19$var$lesseqgtr,
  lesseqqgtr: $560639d49e3c9a19$var$lesseqqgtr,
  lessgtr: $560639d49e3c9a19$var$lessgtr,
  lesssim: $560639d49e3c9a19$var$lesssim,
  lfisht: $560639d49e3c9a19$var$lfisht,
  lfloor: $560639d49e3c9a19$var$lfloor$1,
  lfr: $560639d49e3c9a19$var$lfr,
  lg: $560639d49e3c9a19$var$lg,
  lgE: $560639d49e3c9a19$var$lgE,
  lhard: $560639d49e3c9a19$var$lhard,
  lharu: $560639d49e3c9a19$var$lharu,
  lharul: $560639d49e3c9a19$var$lharul,
  lhblk: $560639d49e3c9a19$var$lhblk,
  ljcy: $560639d49e3c9a19$var$ljcy,
  ll: $560639d49e3c9a19$var$ll,
  llarr: $560639d49e3c9a19$var$llarr,
  llcorner: $560639d49e3c9a19$var$llcorner,
  llhard: $560639d49e3c9a19$var$llhard,
  lltri: $560639d49e3c9a19$var$lltri,
  lmidot: $560639d49e3c9a19$var$lmidot,
  lmoust: $560639d49e3c9a19$var$lmoust,
  lmoustache: $560639d49e3c9a19$var$lmoustache,
  lnE: $560639d49e3c9a19$var$lnE,
  lnap: $560639d49e3c9a19$var$lnap,
  lnapprox: $560639d49e3c9a19$var$lnapprox,
  lne: $560639d49e3c9a19$var$lne,
  lneq: $560639d49e3c9a19$var$lneq,
  lneqq: $560639d49e3c9a19$var$lneqq,
  lnsim: $560639d49e3c9a19$var$lnsim,
  loang: $560639d49e3c9a19$var$loang,
  loarr: $560639d49e3c9a19$var$loarr,
  lobrk: $560639d49e3c9a19$var$lobrk,
  longleftarrow: $560639d49e3c9a19$var$longleftarrow,
  longleftrightarrow: $560639d49e3c9a19$var$longleftrightarrow,
  longmapsto: $560639d49e3c9a19$var$longmapsto,
  longrightarrow: $560639d49e3c9a19$var$longrightarrow,
  looparrowleft: $560639d49e3c9a19$var$looparrowleft,
  looparrowright: $560639d49e3c9a19$var$looparrowright,
  lopar: $560639d49e3c9a19$var$lopar,
  lopf: $560639d49e3c9a19$var$lopf,
  loplus: $560639d49e3c9a19$var$loplus,
  lotimes: $560639d49e3c9a19$var$lotimes,
  lowast: $560639d49e3c9a19$var$lowast$1,
  lowbar: $560639d49e3c9a19$var$lowbar,
  loz: $560639d49e3c9a19$var$loz$1,
  lozenge: $560639d49e3c9a19$var$lozenge,
  lozf: $560639d49e3c9a19$var$lozf,
  lpar: $560639d49e3c9a19$var$lpar,
  lparlt: $560639d49e3c9a19$var$lparlt,
  lrarr: $560639d49e3c9a19$var$lrarr,
  lrcorner: $560639d49e3c9a19$var$lrcorner,
  lrhar: $560639d49e3c9a19$var$lrhar,
  lrhard: $560639d49e3c9a19$var$lrhard,
  lrm: $560639d49e3c9a19$var$lrm$1,
  lrtri: $560639d49e3c9a19$var$lrtri,
  lsaquo: $560639d49e3c9a19$var$lsaquo$1,
  lscr: $560639d49e3c9a19$var$lscr,
  lsh: $560639d49e3c9a19$var$lsh,
  lsim: $560639d49e3c9a19$var$lsim,
  lsime: $560639d49e3c9a19$var$lsime,
  lsimg: $560639d49e3c9a19$var$lsimg,
  lsqb: $560639d49e3c9a19$var$lsqb,
  lsquo: $560639d49e3c9a19$var$lsquo$1,
  lsquor: $560639d49e3c9a19$var$lsquor,
  lstrok: $560639d49e3c9a19$var$lstrok,
  l: $560639d49e3c9a19$var$l,
  lt: $560639d49e3c9a19$var$lt$1,
  ltcc: $560639d49e3c9a19$var$ltcc,
  ltcir: $560639d49e3c9a19$var$ltcir,
  ltdot: $560639d49e3c9a19$var$ltdot,
  lthree: $560639d49e3c9a19$var$lthree,
  ltimes: $560639d49e3c9a19$var$ltimes,
  ltlarr: $560639d49e3c9a19$var$ltlarr,
  ltquest: $560639d49e3c9a19$var$ltquest,
  ltrPar: $560639d49e3c9a19$var$ltrPar,
  ltri: $560639d49e3c9a19$var$ltri,
  ltrie: $560639d49e3c9a19$var$ltrie,
  ltrif: $560639d49e3c9a19$var$ltrif,
  lurdshar: $560639d49e3c9a19$var$lurdshar,
  luruhar: $560639d49e3c9a19$var$luruhar,
  lvertneqq: $560639d49e3c9a19$var$lvertneqq,
  lvnE: $560639d49e3c9a19$var$lvnE,
  mDDot: $560639d49e3c9a19$var$mDDot,
  mac: $560639d49e3c9a19$var$mac,
  macr: $560639d49e3c9a19$var$macr$1,
  male: $560639d49e3c9a19$var$male,
  malt: $560639d49e3c9a19$var$malt,
  maltese: $560639d49e3c9a19$var$maltese,
  map: $560639d49e3c9a19$var$map$1,
  mapsto: $560639d49e3c9a19$var$mapsto,
  mapstodown: $560639d49e3c9a19$var$mapstodown,
  mapstoleft: $560639d49e3c9a19$var$mapstoleft,
  mapstoup: $560639d49e3c9a19$var$mapstoup,
  marker: $560639d49e3c9a19$var$marker,
  mcomma: $560639d49e3c9a19$var$mcomma,
  mcy: $560639d49e3c9a19$var$mcy,
  mdash: $560639d49e3c9a19$var$mdash$1,
  measuredangle: $560639d49e3c9a19$var$measuredangle,
  mfr: $560639d49e3c9a19$var$mfr,
  mho: $560639d49e3c9a19$var$mho,
  micr: $560639d49e3c9a19$var$micr,
  micro: $560639d49e3c9a19$var$micro$1,
  mid: $560639d49e3c9a19$var$mid,
  midast: $560639d49e3c9a19$var$midast,
  midcir: $560639d49e3c9a19$var$midcir,
  middo: $560639d49e3c9a19$var$middo,
  middot: $560639d49e3c9a19$var$middot$1,
  minus: $560639d49e3c9a19$var$minus$1,
  minusb: $560639d49e3c9a19$var$minusb,
  minusd: $560639d49e3c9a19$var$minusd,
  minusdu: $560639d49e3c9a19$var$minusdu,
  mlcp: $560639d49e3c9a19$var$mlcp,
  mldr: $560639d49e3c9a19$var$mldr,
  mnplus: $560639d49e3c9a19$var$mnplus,
  models: $560639d49e3c9a19$var$models,
  mopf: $560639d49e3c9a19$var$mopf,
  mp: $560639d49e3c9a19$var$mp,
  mscr: $560639d49e3c9a19$var$mscr,
  mstpos: $560639d49e3c9a19$var$mstpos,
  mu: $560639d49e3c9a19$var$mu$1,
  multimap: $560639d49e3c9a19$var$multimap,
  mumap: $560639d49e3c9a19$var$mumap,
  nGg: $560639d49e3c9a19$var$nGg,
  nGt: $560639d49e3c9a19$var$nGt,
  nGtv: $560639d49e3c9a19$var$nGtv,
  nLeftarrow: $560639d49e3c9a19$var$nLeftarrow,
  nLeftrightarrow: $560639d49e3c9a19$var$nLeftrightarrow,
  nLl: $560639d49e3c9a19$var$nLl,
  nLt: $560639d49e3c9a19$var$nLt,
  nLtv: $560639d49e3c9a19$var$nLtv,
  nRightarrow: $560639d49e3c9a19$var$nRightarrow,
  nVDash: $560639d49e3c9a19$var$nVDash,
  nVdash: $560639d49e3c9a19$var$nVdash,
  nabla: $560639d49e3c9a19$var$nabla$1,
  nacute: $560639d49e3c9a19$var$nacute,
  nang: $560639d49e3c9a19$var$nang,
  nap: $560639d49e3c9a19$var$nap,
  napE: $560639d49e3c9a19$var$napE,
  napid: $560639d49e3c9a19$var$napid,
  napos: $560639d49e3c9a19$var$napos,
  napprox: $560639d49e3c9a19$var$napprox,
  natur: $560639d49e3c9a19$var$natur,
  natural: $560639d49e3c9a19$var$natural,
  naturals: $560639d49e3c9a19$var$naturals,
  nbs: $560639d49e3c9a19$var$nbs,
  nbsp: $560639d49e3c9a19$var$nbsp$1,
  nbump: $560639d49e3c9a19$var$nbump,
  nbumpe: $560639d49e3c9a19$var$nbumpe,
  ncap: $560639d49e3c9a19$var$ncap,
  ncaron: $560639d49e3c9a19$var$ncaron,
  ncedil: $560639d49e3c9a19$var$ncedil,
  ncong: $560639d49e3c9a19$var$ncong,
  ncongdot: $560639d49e3c9a19$var$ncongdot,
  ncup: $560639d49e3c9a19$var$ncup,
  ncy: $560639d49e3c9a19$var$ncy,
  ndash: $560639d49e3c9a19$var$ndash$1,
  ne: $560639d49e3c9a19$var$ne$1,
  neArr: $560639d49e3c9a19$var$neArr,
  nearhk: $560639d49e3c9a19$var$nearhk,
  nearr: $560639d49e3c9a19$var$nearr,
  nearrow: $560639d49e3c9a19$var$nearrow,
  nedot: $560639d49e3c9a19$var$nedot,
  nequiv: $560639d49e3c9a19$var$nequiv,
  nesear: $560639d49e3c9a19$var$nesear,
  nesim: $560639d49e3c9a19$var$nesim,
  nexist: $560639d49e3c9a19$var$nexist,
  nexists: $560639d49e3c9a19$var$nexists,
  nfr: $560639d49e3c9a19$var$nfr,
  ngE: $560639d49e3c9a19$var$ngE,
  nge: $560639d49e3c9a19$var$nge,
  ngeq: $560639d49e3c9a19$var$ngeq,
  ngeqq: $560639d49e3c9a19$var$ngeqq,
  ngeqslant: $560639d49e3c9a19$var$ngeqslant,
  nges: $560639d49e3c9a19$var$nges,
  ngsim: $560639d49e3c9a19$var$ngsim,
  ngt: $560639d49e3c9a19$var$ngt,
  ngtr: $560639d49e3c9a19$var$ngtr,
  nhArr: $560639d49e3c9a19$var$nhArr,
  nharr: $560639d49e3c9a19$var$nharr,
  nhpar: $560639d49e3c9a19$var$nhpar,
  ni: $560639d49e3c9a19$var$ni$1,
  nis: $560639d49e3c9a19$var$nis,
  nisd: $560639d49e3c9a19$var$nisd,
  niv: $560639d49e3c9a19$var$niv,
  njcy: $560639d49e3c9a19$var$njcy,
  nlArr: $560639d49e3c9a19$var$nlArr,
  nlE: $560639d49e3c9a19$var$nlE,
  nlarr: $560639d49e3c9a19$var$nlarr,
  nldr: $560639d49e3c9a19$var$nldr,
  nle: $560639d49e3c9a19$var$nle,
  nleftarrow: $560639d49e3c9a19$var$nleftarrow,
  nleftrightarrow: $560639d49e3c9a19$var$nleftrightarrow,
  nleq: $560639d49e3c9a19$var$nleq,
  nleqq: $560639d49e3c9a19$var$nleqq,
  nleqslant: $560639d49e3c9a19$var$nleqslant,
  nles: $560639d49e3c9a19$var$nles,
  nless: $560639d49e3c9a19$var$nless,
  nlsim: $560639d49e3c9a19$var$nlsim,
  nlt: $560639d49e3c9a19$var$nlt,
  nltri: $560639d49e3c9a19$var$nltri,
  nltrie: $560639d49e3c9a19$var$nltrie,
  nmid: $560639d49e3c9a19$var$nmid,
  nopf: $560639d49e3c9a19$var$nopf,
  no: $560639d49e3c9a19$var$no,
  not: $560639d49e3c9a19$var$not$1,
  notin: $560639d49e3c9a19$var$notin$1,
  notinE: $560639d49e3c9a19$var$notinE,
  notindot: $560639d49e3c9a19$var$notindot,
  notinva: $560639d49e3c9a19$var$notinva,
  notinvb: $560639d49e3c9a19$var$notinvb,
  notinvc: $560639d49e3c9a19$var$notinvc,
  notni: $560639d49e3c9a19$var$notni,
  notniva: $560639d49e3c9a19$var$notniva,
  notnivb: $560639d49e3c9a19$var$notnivb,
  notnivc: $560639d49e3c9a19$var$notnivc,
  npar: $560639d49e3c9a19$var$npar,
  nparallel: $560639d49e3c9a19$var$nparallel,
  nparsl: $560639d49e3c9a19$var$nparsl,
  npart: $560639d49e3c9a19$var$npart,
  npolint: $560639d49e3c9a19$var$npolint,
  npr: $560639d49e3c9a19$var$npr,
  nprcue: $560639d49e3c9a19$var$nprcue,
  npre: $560639d49e3c9a19$var$npre,
  nprec: $560639d49e3c9a19$var$nprec,
  npreceq: $560639d49e3c9a19$var$npreceq,
  nrArr: $560639d49e3c9a19$var$nrArr,
  nrarr: $560639d49e3c9a19$var$nrarr,
  nrarrc: $560639d49e3c9a19$var$nrarrc,
  nrarrw: $560639d49e3c9a19$var$nrarrw,
  nrightarrow: $560639d49e3c9a19$var$nrightarrow,
  nrtri: $560639d49e3c9a19$var$nrtri,
  nrtrie: $560639d49e3c9a19$var$nrtrie,
  nsc: $560639d49e3c9a19$var$nsc,
  nsccue: $560639d49e3c9a19$var$nsccue,
  nsce: $560639d49e3c9a19$var$nsce,
  nscr: $560639d49e3c9a19$var$nscr,
  nshortmid: $560639d49e3c9a19$var$nshortmid,
  nshortparallel: $560639d49e3c9a19$var$nshortparallel,
  nsim: $560639d49e3c9a19$var$nsim,
  nsime: $560639d49e3c9a19$var$nsime,
  nsimeq: $560639d49e3c9a19$var$nsimeq,
  nsmid: $560639d49e3c9a19$var$nsmid,
  nspar: $560639d49e3c9a19$var$nspar,
  nsqsube: $560639d49e3c9a19$var$nsqsube,
  nsqsupe: $560639d49e3c9a19$var$nsqsupe,
  nsub: $560639d49e3c9a19$var$nsub$1,
  nsubE: $560639d49e3c9a19$var$nsubE,
  nsube: $560639d49e3c9a19$var$nsube,
  nsubset: $560639d49e3c9a19$var$nsubset,
  nsubseteq: $560639d49e3c9a19$var$nsubseteq,
  nsubseteqq: $560639d49e3c9a19$var$nsubseteqq,
  nsucc: $560639d49e3c9a19$var$nsucc,
  nsucceq: $560639d49e3c9a19$var$nsucceq,
  nsup: $560639d49e3c9a19$var$nsup,
  nsupE: $560639d49e3c9a19$var$nsupE,
  nsupe: $560639d49e3c9a19$var$nsupe,
  nsupset: $560639d49e3c9a19$var$nsupset,
  nsupseteq: $560639d49e3c9a19$var$nsupseteq,
  nsupseteqq: $560639d49e3c9a19$var$nsupseteqq,
  ntgl: $560639d49e3c9a19$var$ntgl,
  ntild: $560639d49e3c9a19$var$ntild,
  ntilde: $560639d49e3c9a19$var$ntilde$1,
  ntlg: $560639d49e3c9a19$var$ntlg,
  ntriangleleft: $560639d49e3c9a19$var$ntriangleleft,
  ntrianglelefteq: $560639d49e3c9a19$var$ntrianglelefteq,
  ntriangleright: $560639d49e3c9a19$var$ntriangleright,
  ntrianglerighteq: $560639d49e3c9a19$var$ntrianglerighteq,
  nu: $560639d49e3c9a19$var$nu$1,
  num: $560639d49e3c9a19$var$num,
  numero: $560639d49e3c9a19$var$numero,
  numsp: $560639d49e3c9a19$var$numsp,
  nvDash: $560639d49e3c9a19$var$nvDash,
  nvHarr: $560639d49e3c9a19$var$nvHarr,
  nvap: $560639d49e3c9a19$var$nvap,
  nvdash: $560639d49e3c9a19$var$nvdash,
  nvge: $560639d49e3c9a19$var$nvge,
  nvgt: $560639d49e3c9a19$var$nvgt,
  nvinfin: $560639d49e3c9a19$var$nvinfin,
  nvlArr: $560639d49e3c9a19$var$nvlArr,
  nvle: $560639d49e3c9a19$var$nvle,
  nvlt: $560639d49e3c9a19$var$nvlt,
  nvltrie: $560639d49e3c9a19$var$nvltrie,
  nvrArr: $560639d49e3c9a19$var$nvrArr,
  nvrtrie: $560639d49e3c9a19$var$nvrtrie,
  nvsim: $560639d49e3c9a19$var$nvsim,
  nwArr: $560639d49e3c9a19$var$nwArr,
  nwarhk: $560639d49e3c9a19$var$nwarhk,
  nwarr: $560639d49e3c9a19$var$nwarr,
  nwarrow: $560639d49e3c9a19$var$nwarrow,
  nwnear: $560639d49e3c9a19$var$nwnear,
  oS: $560639d49e3c9a19$var$oS,
  oacut: $560639d49e3c9a19$var$oacut,
  oacute: $560639d49e3c9a19$var$oacute$1,
  oast: $560639d49e3c9a19$var$oast,
  ocir: $560639d49e3c9a19$var$ocir,
  ocirc: $560639d49e3c9a19$var$ocirc$1,
  ocy: $560639d49e3c9a19$var$ocy,
  odash: $560639d49e3c9a19$var$odash,
  odblac: $560639d49e3c9a19$var$odblac,
  odiv: $560639d49e3c9a19$var$odiv,
  odot: $560639d49e3c9a19$var$odot,
  odsold: $560639d49e3c9a19$var$odsold,
  oelig: $560639d49e3c9a19$var$oelig$1,
  ofcir: $560639d49e3c9a19$var$ofcir,
  ofr: $560639d49e3c9a19$var$ofr,
  ogon: $560639d49e3c9a19$var$ogon,
  ograv: $560639d49e3c9a19$var$ograv,
  ograve: $560639d49e3c9a19$var$ograve$1,
  ogt: $560639d49e3c9a19$var$ogt,
  ohbar: $560639d49e3c9a19$var$ohbar,
  ohm: $560639d49e3c9a19$var$ohm,
  oint: $560639d49e3c9a19$var$oint,
  olarr: $560639d49e3c9a19$var$olarr,
  olcir: $560639d49e3c9a19$var$olcir,
  olcross: $560639d49e3c9a19$var$olcross,
  oline: $560639d49e3c9a19$var$oline$1,
  olt: $560639d49e3c9a19$var$olt,
  omacr: $560639d49e3c9a19$var$omacr,
  omega: $560639d49e3c9a19$var$omega$1,
  omicron: $560639d49e3c9a19$var$omicron$1,
  omid: $560639d49e3c9a19$var$omid,
  ominus: $560639d49e3c9a19$var$ominus,
  oopf: $560639d49e3c9a19$var$oopf,
  opar: $560639d49e3c9a19$var$opar,
  operp: $560639d49e3c9a19$var$operp,
  oplus: $560639d49e3c9a19$var$oplus$1,
  or: $560639d49e3c9a19$var$or$1,
  orarr: $560639d49e3c9a19$var$orarr,
  ord: $560639d49e3c9a19$var$ord,
  order: $560639d49e3c9a19$var$order,
  orderof: $560639d49e3c9a19$var$orderof,
  ordf: $560639d49e3c9a19$var$ordf$1,
  ordm: $560639d49e3c9a19$var$ordm$1,
  origof: $560639d49e3c9a19$var$origof,
  oror: $560639d49e3c9a19$var$oror,
  orslope: $560639d49e3c9a19$var$orslope,
  orv: $560639d49e3c9a19$var$orv,
  oscr: $560639d49e3c9a19$var$oscr,
  oslas: $560639d49e3c9a19$var$oslas,
  oslash: $560639d49e3c9a19$var$oslash$1,
  osol: $560639d49e3c9a19$var$osol,
  otild: $560639d49e3c9a19$var$otild,
  otilde: $560639d49e3c9a19$var$otilde$1,
  otimes: $560639d49e3c9a19$var$otimes$1,
  otimesas: $560639d49e3c9a19$var$otimesas,
  oum: $560639d49e3c9a19$var$oum,
  ouml: $560639d49e3c9a19$var$ouml$1,
  ovbar: $560639d49e3c9a19$var$ovbar,
  par: $560639d49e3c9a19$var$par,
  para: $560639d49e3c9a19$var$para$1,
  parallel: $560639d49e3c9a19$var$parallel,
  parsim: $560639d49e3c9a19$var$parsim,
  parsl: $560639d49e3c9a19$var$parsl,
  part: $560639d49e3c9a19$var$part$1,
  pcy: $560639d49e3c9a19$var$pcy,
  percnt: $560639d49e3c9a19$var$percnt,
  period: $560639d49e3c9a19$var$period,
  permil: $560639d49e3c9a19$var$permil$1,
  perp: $560639d49e3c9a19$var$perp$1,
  pertenk: $560639d49e3c9a19$var$pertenk,
  pfr: $560639d49e3c9a19$var$pfr,
  phi: $560639d49e3c9a19$var$phi$1,
  phiv: $560639d49e3c9a19$var$phiv,
  phmmat: $560639d49e3c9a19$var$phmmat,
  phone: $560639d49e3c9a19$var$phone,
  pi: $560639d49e3c9a19$var$pi$1,
  pitchfork: $560639d49e3c9a19$var$pitchfork,
  piv: $560639d49e3c9a19$var$piv$1,
  planck: $560639d49e3c9a19$var$planck,
  planckh: $560639d49e3c9a19$var$planckh,
  plankv: $560639d49e3c9a19$var$plankv,
  plus: $560639d49e3c9a19$var$plus,
  plusacir: $560639d49e3c9a19$var$plusacir,
  plusb: $560639d49e3c9a19$var$plusb,
  pluscir: $560639d49e3c9a19$var$pluscir,
  plusdo: $560639d49e3c9a19$var$plusdo,
  plusdu: $560639d49e3c9a19$var$plusdu,
  pluse: $560639d49e3c9a19$var$pluse,
  plusm: $560639d49e3c9a19$var$plusm,
  plusmn: $560639d49e3c9a19$var$plusmn$1,
  plussim: $560639d49e3c9a19$var$plussim,
  plustwo: $560639d49e3c9a19$var$plustwo,
  pm: $560639d49e3c9a19$var$pm,
  pointint: $560639d49e3c9a19$var$pointint,
  popf: $560639d49e3c9a19$var$popf,
  poun: $560639d49e3c9a19$var$poun,
  pound: $560639d49e3c9a19$var$pound$1,
  pr: $560639d49e3c9a19$var$pr,
  prE: $560639d49e3c9a19$var$prE,
  prap: $560639d49e3c9a19$var$prap,
  prcue: $560639d49e3c9a19$var$prcue,
  pre: $560639d49e3c9a19$var$pre,
  prec: $560639d49e3c9a19$var$prec,
  precapprox: $560639d49e3c9a19$var$precapprox,
  preccurlyeq: $560639d49e3c9a19$var$preccurlyeq,
  preceq: $560639d49e3c9a19$var$preceq,
  precnapprox: $560639d49e3c9a19$var$precnapprox,
  precneqq: $560639d49e3c9a19$var$precneqq,
  precnsim: $560639d49e3c9a19$var$precnsim,
  precsim: $560639d49e3c9a19$var$precsim,
  prime: $560639d49e3c9a19$var$prime$1,
  primes: $560639d49e3c9a19$var$primes,
  prnE: $560639d49e3c9a19$var$prnE,
  prnap: $560639d49e3c9a19$var$prnap,
  prnsim: $560639d49e3c9a19$var$prnsim,
  prod: $560639d49e3c9a19$var$prod$1,
  profalar: $560639d49e3c9a19$var$profalar,
  profline: $560639d49e3c9a19$var$profline,
  profsurf: $560639d49e3c9a19$var$profsurf,
  prop: $560639d49e3c9a19$var$prop$1,
  propto: $560639d49e3c9a19$var$propto,
  prsim: $560639d49e3c9a19$var$prsim,
  prurel: $560639d49e3c9a19$var$prurel,
  pscr: $560639d49e3c9a19$var$pscr,
  psi: $560639d49e3c9a19$var$psi$1,
  puncsp: $560639d49e3c9a19$var$puncsp,
  qfr: $560639d49e3c9a19$var$qfr,
  qint: $560639d49e3c9a19$var$qint,
  qopf: $560639d49e3c9a19$var$qopf,
  qprime: $560639d49e3c9a19$var$qprime,
  qscr: $560639d49e3c9a19$var$qscr,
  quaternions: $560639d49e3c9a19$var$quaternions,
  quatint: $560639d49e3c9a19$var$quatint,
  quest: $560639d49e3c9a19$var$quest,
  questeq: $560639d49e3c9a19$var$questeq,
  quo: $560639d49e3c9a19$var$quo,
  quot: $560639d49e3c9a19$var$quot$1,
  rAarr: $560639d49e3c9a19$var$rAarr,
  rArr: $560639d49e3c9a19$var$rArr$1,
  rAtail: $560639d49e3c9a19$var$rAtail,
  rBarr: $560639d49e3c9a19$var$rBarr,
  rHar: $560639d49e3c9a19$var$rHar,
  race: $560639d49e3c9a19$var$race,
  racute: $560639d49e3c9a19$var$racute,
  radic: $560639d49e3c9a19$var$radic$1,
  raemptyv: $560639d49e3c9a19$var$raemptyv,
  rang: $560639d49e3c9a19$var$rang$1,
  rangd: $560639d49e3c9a19$var$rangd,
  range: $560639d49e3c9a19$var$range,
  rangle: $560639d49e3c9a19$var$rangle,
  raqu: $560639d49e3c9a19$var$raqu,
  raquo: $560639d49e3c9a19$var$raquo$1,
  rarr: $560639d49e3c9a19$var$rarr$1,
  rarrap: $560639d49e3c9a19$var$rarrap,
  rarrb: $560639d49e3c9a19$var$rarrb,
  rarrbfs: $560639d49e3c9a19$var$rarrbfs,
  rarrc: $560639d49e3c9a19$var$rarrc,
  rarrfs: $560639d49e3c9a19$var$rarrfs,
  rarrhk: $560639d49e3c9a19$var$rarrhk,
  rarrlp: $560639d49e3c9a19$var$rarrlp,
  rarrpl: $560639d49e3c9a19$var$rarrpl,
  rarrsim: $560639d49e3c9a19$var$rarrsim,
  rarrtl: $560639d49e3c9a19$var$rarrtl,
  rarrw: $560639d49e3c9a19$var$rarrw,
  ratail: $560639d49e3c9a19$var$ratail,
  ratio: $560639d49e3c9a19$var$ratio,
  rationals: $560639d49e3c9a19$var$rationals,
  rbarr: $560639d49e3c9a19$var$rbarr,
  rbbrk: $560639d49e3c9a19$var$rbbrk,
  rbrace: $560639d49e3c9a19$var$rbrace,
  rbrack: $560639d49e3c9a19$var$rbrack,
  rbrke: $560639d49e3c9a19$var$rbrke,
  rbrksld: $560639d49e3c9a19$var$rbrksld,
  rbrkslu: $560639d49e3c9a19$var$rbrkslu,
  rcaron: $560639d49e3c9a19$var$rcaron,
  rcedil: $560639d49e3c9a19$var$rcedil,
  rceil: $560639d49e3c9a19$var$rceil$1,
  rcub: $560639d49e3c9a19$var$rcub,
  rcy: $560639d49e3c9a19$var$rcy,
  rdca: $560639d49e3c9a19$var$rdca,
  rdldhar: $560639d49e3c9a19$var$rdldhar,
  rdquo: $560639d49e3c9a19$var$rdquo$1,
  rdquor: $560639d49e3c9a19$var$rdquor,
  rdsh: $560639d49e3c9a19$var$rdsh,
  real: $560639d49e3c9a19$var$real$1,
  realine: $560639d49e3c9a19$var$realine,
  realpart: $560639d49e3c9a19$var$realpart,
  reals: $560639d49e3c9a19$var$reals,
  rect: $560639d49e3c9a19$var$rect,
  re: $560639d49e3c9a19$var$re$3,
  reg: $560639d49e3c9a19$var$reg$1,
  rfisht: $560639d49e3c9a19$var$rfisht,
  rfloor: $560639d49e3c9a19$var$rfloor$1,
  rfr: $560639d49e3c9a19$var$rfr,
  rhard: $560639d49e3c9a19$var$rhard,
  rharu: $560639d49e3c9a19$var$rharu,
  rharul: $560639d49e3c9a19$var$rharul,
  rho: $560639d49e3c9a19$var$rho$1,
  rhov: $560639d49e3c9a19$var$rhov,
  rightarrow: $560639d49e3c9a19$var$rightarrow,
  rightarrowtail: $560639d49e3c9a19$var$rightarrowtail,
  rightharpoondown: $560639d49e3c9a19$var$rightharpoondown,
  rightharpoonup: $560639d49e3c9a19$var$rightharpoonup,
  rightleftarrows: $560639d49e3c9a19$var$rightleftarrows,
  rightleftharpoons: $560639d49e3c9a19$var$rightleftharpoons,
  rightrightarrows: $560639d49e3c9a19$var$rightrightarrows,
  rightsquigarrow: $560639d49e3c9a19$var$rightsquigarrow,
  rightthreetimes: $560639d49e3c9a19$var$rightthreetimes,
  ring: $560639d49e3c9a19$var$ring,
  risingdotseq: $560639d49e3c9a19$var$risingdotseq,
  rlarr: $560639d49e3c9a19$var$rlarr,
  rlhar: $560639d49e3c9a19$var$rlhar,
  rlm: $560639d49e3c9a19$var$rlm$1,
  rmoust: $560639d49e3c9a19$var$rmoust,
  rmoustache: $560639d49e3c9a19$var$rmoustache,
  rnmid: $560639d49e3c9a19$var$rnmid,
  roang: $560639d49e3c9a19$var$roang,
  roarr: $560639d49e3c9a19$var$roarr,
  robrk: $560639d49e3c9a19$var$robrk,
  ropar: $560639d49e3c9a19$var$ropar,
  ropf: $560639d49e3c9a19$var$ropf,
  roplus: $560639d49e3c9a19$var$roplus,
  rotimes: $560639d49e3c9a19$var$rotimes,
  rpar: $560639d49e3c9a19$var$rpar,
  rpargt: $560639d49e3c9a19$var$rpargt,
  rppolint: $560639d49e3c9a19$var$rppolint,
  rrarr: $560639d49e3c9a19$var$rrarr,
  rsaquo: $560639d49e3c9a19$var$rsaquo$1,
  rscr: $560639d49e3c9a19$var$rscr,
  rsh: $560639d49e3c9a19$var$rsh,
  rsqb: $560639d49e3c9a19$var$rsqb,
  rsquo: $560639d49e3c9a19$var$rsquo$1,
  rsquor: $560639d49e3c9a19$var$rsquor,
  rthree: $560639d49e3c9a19$var$rthree,
  rtimes: $560639d49e3c9a19$var$rtimes,
  rtri: $560639d49e3c9a19$var$rtri,
  rtrie: $560639d49e3c9a19$var$rtrie,
  rtrif: $560639d49e3c9a19$var$rtrif,
  rtriltri: $560639d49e3c9a19$var$rtriltri,
  ruluhar: $560639d49e3c9a19$var$ruluhar,
  rx: $560639d49e3c9a19$var$rx,
  sacute: $560639d49e3c9a19$var$sacute,
  sbquo: $560639d49e3c9a19$var$sbquo$1,
  sc: $560639d49e3c9a19$var$sc,
  scE: $560639d49e3c9a19$var$scE,
  scap: $560639d49e3c9a19$var$scap,
  scaron: $560639d49e3c9a19$var$scaron$1,
  sccue: $560639d49e3c9a19$var$sccue,
  sce: $560639d49e3c9a19$var$sce,
  scedil: $560639d49e3c9a19$var$scedil,
  scirc: $560639d49e3c9a19$var$scirc,
  scnE: $560639d49e3c9a19$var$scnE,
  scnap: $560639d49e3c9a19$var$scnap,
  scnsim: $560639d49e3c9a19$var$scnsim,
  scpolint: $560639d49e3c9a19$var$scpolint,
  scsim: $560639d49e3c9a19$var$scsim,
  scy: $560639d49e3c9a19$var$scy,
  sdot: $560639d49e3c9a19$var$sdot$1,
  sdotb: $560639d49e3c9a19$var$sdotb,
  sdote: $560639d49e3c9a19$var$sdote,
  seArr: $560639d49e3c9a19$var$seArr,
  searhk: $560639d49e3c9a19$var$searhk,
  searr: $560639d49e3c9a19$var$searr,
  searrow: $560639d49e3c9a19$var$searrow,
  sec: $560639d49e3c9a19$var$sec,
  sect: $560639d49e3c9a19$var$sect$1,
  semi: $560639d49e3c9a19$var$semi,
  seswar: $560639d49e3c9a19$var$seswar,
  setminus: $560639d49e3c9a19$var$setminus,
  setmn: $560639d49e3c9a19$var$setmn,
  sext: $560639d49e3c9a19$var$sext,
  sfr: $560639d49e3c9a19$var$sfr,
  sfrown: $560639d49e3c9a19$var$sfrown,
  sharp: $560639d49e3c9a19$var$sharp,
  shchcy: $560639d49e3c9a19$var$shchcy,
  shcy: $560639d49e3c9a19$var$shcy,
  shortmid: $560639d49e3c9a19$var$shortmid,
  shortparallel: $560639d49e3c9a19$var$shortparallel,
  sh: $560639d49e3c9a19$var$sh,
  shy: $560639d49e3c9a19$var$shy$1,
  sigma: $560639d49e3c9a19$var$sigma$1,
  sigmaf: $560639d49e3c9a19$var$sigmaf$1,
  sigmav: $560639d49e3c9a19$var$sigmav,
  sim: $560639d49e3c9a19$var$sim$1,
  simdot: $560639d49e3c9a19$var$simdot,
  sime: $560639d49e3c9a19$var$sime,
  simeq: $560639d49e3c9a19$var$simeq,
  simg: $560639d49e3c9a19$var$simg,
  simgE: $560639d49e3c9a19$var$simgE,
  siml: $560639d49e3c9a19$var$siml,
  simlE: $560639d49e3c9a19$var$simlE,
  simne: $560639d49e3c9a19$var$simne,
  simplus: $560639d49e3c9a19$var$simplus,
  simrarr: $560639d49e3c9a19$var$simrarr,
  slarr: $560639d49e3c9a19$var$slarr,
  smallsetminus: $560639d49e3c9a19$var$smallsetminus,
  smashp: $560639d49e3c9a19$var$smashp,
  smeparsl: $560639d49e3c9a19$var$smeparsl,
  smid: $560639d49e3c9a19$var$smid,
  smile: $560639d49e3c9a19$var$smile,
  smt: $560639d49e3c9a19$var$smt,
  smte: $560639d49e3c9a19$var$smte,
  smtes: $560639d49e3c9a19$var$smtes,
  softcy: $560639d49e3c9a19$var$softcy,
  sol: $560639d49e3c9a19$var$sol,
  solb: $560639d49e3c9a19$var$solb,
  solbar: $560639d49e3c9a19$var$solbar,
  sopf: $560639d49e3c9a19$var$sopf,
  spades: $560639d49e3c9a19$var$spades$1,
  spadesuit: $560639d49e3c9a19$var$spadesuit,
  spar: $560639d49e3c9a19$var$spar,
  sqcap: $560639d49e3c9a19$var$sqcap,
  sqcaps: $560639d49e3c9a19$var$sqcaps,
  sqcup: $560639d49e3c9a19$var$sqcup,
  sqcups: $560639d49e3c9a19$var$sqcups,
  sqsub: $560639d49e3c9a19$var$sqsub,
  sqsube: $560639d49e3c9a19$var$sqsube,
  sqsubset: $560639d49e3c9a19$var$sqsubset,
  sqsubseteq: $560639d49e3c9a19$var$sqsubseteq,
  sqsup: $560639d49e3c9a19$var$sqsup,
  sqsupe: $560639d49e3c9a19$var$sqsupe,
  sqsupset: $560639d49e3c9a19$var$sqsupset,
  sqsupseteq: $560639d49e3c9a19$var$sqsupseteq,
  squ: $560639d49e3c9a19$var$squ,
  square: $560639d49e3c9a19$var$square,
  squarf: $560639d49e3c9a19$var$squarf,
  squf: $560639d49e3c9a19$var$squf,
  srarr: $560639d49e3c9a19$var$srarr,
  sscr: $560639d49e3c9a19$var$sscr,
  ssetmn: $560639d49e3c9a19$var$ssetmn,
  ssmile: $560639d49e3c9a19$var$ssmile,
  sstarf: $560639d49e3c9a19$var$sstarf,
  star: $560639d49e3c9a19$var$star,
  starf: $560639d49e3c9a19$var$starf,
  straightepsilon: $560639d49e3c9a19$var$straightepsilon,
  straightphi: $560639d49e3c9a19$var$straightphi,
  strns: $560639d49e3c9a19$var$strns,
  sub: $560639d49e3c9a19$var$sub$1,
  subE: $560639d49e3c9a19$var$subE,
  subdot: $560639d49e3c9a19$var$subdot,
  sube: $560639d49e3c9a19$var$sube$1,
  subedot: $560639d49e3c9a19$var$subedot,
  submult: $560639d49e3c9a19$var$submult,
  subnE: $560639d49e3c9a19$var$subnE,
  subne: $560639d49e3c9a19$var$subne,
  subplus: $560639d49e3c9a19$var$subplus,
  subrarr: $560639d49e3c9a19$var$subrarr,
  subset: $560639d49e3c9a19$var$subset,
  subseteq: $560639d49e3c9a19$var$subseteq,
  subseteqq: $560639d49e3c9a19$var$subseteqq,
  subsetneq: $560639d49e3c9a19$var$subsetneq,
  subsetneqq: $560639d49e3c9a19$var$subsetneqq,
  subsim: $560639d49e3c9a19$var$subsim,
  subsub: $560639d49e3c9a19$var$subsub,
  subsup: $560639d49e3c9a19$var$subsup,
  succ: $560639d49e3c9a19$var$succ,
  succapprox: $560639d49e3c9a19$var$succapprox,
  succcurlyeq: $560639d49e3c9a19$var$succcurlyeq,
  succeq: $560639d49e3c9a19$var$succeq,
  succnapprox: $560639d49e3c9a19$var$succnapprox,
  succneqq: $560639d49e3c9a19$var$succneqq,
  succnsim: $560639d49e3c9a19$var$succnsim,
  succsim: $560639d49e3c9a19$var$succsim,
  sum: $560639d49e3c9a19$var$sum$1,
  sung: $560639d49e3c9a19$var$sung,
  sup: $560639d49e3c9a19$var$sup$1,
  sup1: $560639d49e3c9a19$var$sup1$1,
  sup2: $560639d49e3c9a19$var$sup2$1,
  sup3: $560639d49e3c9a19$var$sup3$1,
  supE: $560639d49e3c9a19$var$supE,
  supdot: $560639d49e3c9a19$var$supdot,
  supdsub: $560639d49e3c9a19$var$supdsub,
  supe: $560639d49e3c9a19$var$supe$1,
  supedot: $560639d49e3c9a19$var$supedot,
  suphsol: $560639d49e3c9a19$var$suphsol,
  suphsub: $560639d49e3c9a19$var$suphsub,
  suplarr: $560639d49e3c9a19$var$suplarr,
  supmult: $560639d49e3c9a19$var$supmult,
  supnE: $560639d49e3c9a19$var$supnE,
  supne: $560639d49e3c9a19$var$supne,
  supplus: $560639d49e3c9a19$var$supplus,
  supset: $560639d49e3c9a19$var$supset,
  supseteq: $560639d49e3c9a19$var$supseteq,
  supseteqq: $560639d49e3c9a19$var$supseteqq,
  supsetneq: $560639d49e3c9a19$var$supsetneq,
  supsetneqq: $560639d49e3c9a19$var$supsetneqq,
  supsim: $560639d49e3c9a19$var$supsim,
  supsub: $560639d49e3c9a19$var$supsub,
  supsup: $560639d49e3c9a19$var$supsup,
  swArr: $560639d49e3c9a19$var$swArr,
  swarhk: $560639d49e3c9a19$var$swarhk,
  swarr: $560639d49e3c9a19$var$swarr,
  swarrow: $560639d49e3c9a19$var$swarrow,
  swnwar: $560639d49e3c9a19$var$swnwar,
  szli: $560639d49e3c9a19$var$szli,
  szlig: $560639d49e3c9a19$var$szlig$1,
  target: $560639d49e3c9a19$var$target,
  tau: $560639d49e3c9a19$var$tau$1,
  tbrk: $560639d49e3c9a19$var$tbrk,
  tcaron: $560639d49e3c9a19$var$tcaron,
  tcedil: $560639d49e3c9a19$var$tcedil,
  tcy: $560639d49e3c9a19$var$tcy,
  tdot: $560639d49e3c9a19$var$tdot,
  telrec: $560639d49e3c9a19$var$telrec,
  tfr: $560639d49e3c9a19$var$tfr,
  there4: $560639d49e3c9a19$var$there4$1,
  therefore: $560639d49e3c9a19$var$therefore,
  theta: $560639d49e3c9a19$var$theta$1,
  thetasym: $560639d49e3c9a19$var$thetasym$1,
  thetav: $560639d49e3c9a19$var$thetav,
  thickapprox: $560639d49e3c9a19$var$thickapprox,
  thicksim: $560639d49e3c9a19$var$thicksim,
  thinsp: $560639d49e3c9a19$var$thinsp$1,
  thkap: $560639d49e3c9a19$var$thkap,
  thksim: $560639d49e3c9a19$var$thksim,
  thor: $560639d49e3c9a19$var$thor,
  thorn: $560639d49e3c9a19$var$thorn$1,
  tilde: $560639d49e3c9a19$var$tilde$4,
  time: $560639d49e3c9a19$var$time,
  times: $560639d49e3c9a19$var$times$1,
  timesb: $560639d49e3c9a19$var$timesb,
  timesbar: $560639d49e3c9a19$var$timesbar,
  timesd: $560639d49e3c9a19$var$timesd,
  tint: $560639d49e3c9a19$var$tint,
  toea: $560639d49e3c9a19$var$toea,
  top: $560639d49e3c9a19$var$top,
  topbot: $560639d49e3c9a19$var$topbot,
  topcir: $560639d49e3c9a19$var$topcir,
  topf: $560639d49e3c9a19$var$topf,
  topfork: $560639d49e3c9a19$var$topfork,
  tosa: $560639d49e3c9a19$var$tosa,
  tprime: $560639d49e3c9a19$var$tprime,
  trade: $560639d49e3c9a19$var$trade$1,
  triangle: $560639d49e3c9a19$var$triangle,
  triangledown: $560639d49e3c9a19$var$triangledown,
  triangleleft: $560639d49e3c9a19$var$triangleleft,
  trianglelefteq: $560639d49e3c9a19$var$trianglelefteq,
  triangleq: $560639d49e3c9a19$var$triangleq,
  triangleright: $560639d49e3c9a19$var$triangleright,
  trianglerighteq: $560639d49e3c9a19$var$trianglerighteq,
  tridot: $560639d49e3c9a19$var$tridot,
  trie: $560639d49e3c9a19$var$trie,
  triminus: $560639d49e3c9a19$var$triminus,
  triplus: $560639d49e3c9a19$var$triplus,
  trisb: $560639d49e3c9a19$var$trisb,
  tritime: $560639d49e3c9a19$var$tritime,
  trpezium: $560639d49e3c9a19$var$trpezium,
  tscr: $560639d49e3c9a19$var$tscr,
  tscy: $560639d49e3c9a19$var$tscy,
  tshcy: $560639d49e3c9a19$var$tshcy,
  tstrok: $560639d49e3c9a19$var$tstrok,
  twixt: $560639d49e3c9a19$var$twixt,
  twoheadleftarrow: $560639d49e3c9a19$var$twoheadleftarrow,
  twoheadrightarrow: $560639d49e3c9a19$var$twoheadrightarrow,
  uArr: $560639d49e3c9a19$var$uArr$1,
  uHar: $560639d49e3c9a19$var$uHar,
  uacut: $560639d49e3c9a19$var$uacut,
  uacute: $560639d49e3c9a19$var$uacute$1,
  uarr: $560639d49e3c9a19$var$uarr$1,
  ubrcy: $560639d49e3c9a19$var$ubrcy,
  ubreve: $560639d49e3c9a19$var$ubreve,
  ucir: $560639d49e3c9a19$var$ucir,
  ucirc: $560639d49e3c9a19$var$ucirc$1,
  ucy: $560639d49e3c9a19$var$ucy,
  udarr: $560639d49e3c9a19$var$udarr,
  udblac: $560639d49e3c9a19$var$udblac,
  udhar: $560639d49e3c9a19$var$udhar,
  ufisht: $560639d49e3c9a19$var$ufisht,
  ufr: $560639d49e3c9a19$var$ufr,
  ugrav: $560639d49e3c9a19$var$ugrav,
  ugrave: $560639d49e3c9a19$var$ugrave$1,
  uharl: $560639d49e3c9a19$var$uharl,
  uharr: $560639d49e3c9a19$var$uharr,
  uhblk: $560639d49e3c9a19$var$uhblk,
  ulcorn: $560639d49e3c9a19$var$ulcorn,
  ulcorner: $560639d49e3c9a19$var$ulcorner,
  ulcrop: $560639d49e3c9a19$var$ulcrop,
  ultri: $560639d49e3c9a19$var$ultri,
  umacr: $560639d49e3c9a19$var$umacr,
  um: $560639d49e3c9a19$var$um,
  uml: $560639d49e3c9a19$var$uml$1,
  uogon: $560639d49e3c9a19$var$uogon,
  uopf: $560639d49e3c9a19$var$uopf,
  uparrow: $560639d49e3c9a19$var$uparrow,
  updownarrow: $560639d49e3c9a19$var$updownarrow,
  upharpoonleft: $560639d49e3c9a19$var$upharpoonleft,
  upharpoonright: $560639d49e3c9a19$var$upharpoonright,
  uplus: $560639d49e3c9a19$var$uplus,
  upsi: $560639d49e3c9a19$var$upsi,
  upsih: $560639d49e3c9a19$var$upsih$1,
  upsilon: $560639d49e3c9a19$var$upsilon$1,
  upuparrows: $560639d49e3c9a19$var$upuparrows,
  urcorn: $560639d49e3c9a19$var$urcorn,
  urcorner: $560639d49e3c9a19$var$urcorner,
  urcrop: $560639d49e3c9a19$var$urcrop,
  uring: $560639d49e3c9a19$var$uring,
  urtri: $560639d49e3c9a19$var$urtri,
  uscr: $560639d49e3c9a19$var$uscr,
  utdot: $560639d49e3c9a19$var$utdot,
  utilde: $560639d49e3c9a19$var$utilde,
  utri: $560639d49e3c9a19$var$utri,
  utrif: $560639d49e3c9a19$var$utrif,
  uuarr: $560639d49e3c9a19$var$uuarr,
  uum: $560639d49e3c9a19$var$uum,
  uuml: $560639d49e3c9a19$var$uuml$1,
  uwangle: $560639d49e3c9a19$var$uwangle,
  vArr: $560639d49e3c9a19$var$vArr,
  vBar: $560639d49e3c9a19$var$vBar,
  vBarv: $560639d49e3c9a19$var$vBarv,
  vDash: $560639d49e3c9a19$var$vDash,
  vangrt: $560639d49e3c9a19$var$vangrt,
  varepsilon: $560639d49e3c9a19$var$varepsilon,
  varkappa: $560639d49e3c9a19$var$varkappa,
  varnothing: $560639d49e3c9a19$var$varnothing,
  varphi: $560639d49e3c9a19$var$varphi,
  varpi: $560639d49e3c9a19$var$varpi,
  varpropto: $560639d49e3c9a19$var$varpropto,
  varr: $560639d49e3c9a19$var$varr,
  varrho: $560639d49e3c9a19$var$varrho,
  varsigma: $560639d49e3c9a19$var$varsigma,
  varsubsetneq: $560639d49e3c9a19$var$varsubsetneq,
  varsubsetneqq: $560639d49e3c9a19$var$varsubsetneqq,
  varsupsetneq: $560639d49e3c9a19$var$varsupsetneq,
  varsupsetneqq: $560639d49e3c9a19$var$varsupsetneqq,
  vartheta: $560639d49e3c9a19$var$vartheta,
  vartriangleleft: $560639d49e3c9a19$var$vartriangleleft,
  vartriangleright: $560639d49e3c9a19$var$vartriangleright,
  vcy: $560639d49e3c9a19$var$vcy,
  vdash: $560639d49e3c9a19$var$vdash,
  vee: $560639d49e3c9a19$var$vee,
  veebar: $560639d49e3c9a19$var$veebar,
  veeeq: $560639d49e3c9a19$var$veeeq,
  vellip: $560639d49e3c9a19$var$vellip,
  verbar: $560639d49e3c9a19$var$verbar,
  vert: $560639d49e3c9a19$var$vert,
  vfr: $560639d49e3c9a19$var$vfr,
  vltri: $560639d49e3c9a19$var$vltri,
  vnsub: $560639d49e3c9a19$var$vnsub,
  vnsup: $560639d49e3c9a19$var$vnsup,
  vopf: $560639d49e3c9a19$var$vopf,
  vprop: $560639d49e3c9a19$var$vprop,
  vrtri: $560639d49e3c9a19$var$vrtri,
  vscr: $560639d49e3c9a19$var$vscr,
  vsubnE: $560639d49e3c9a19$var$vsubnE,
  vsubne: $560639d49e3c9a19$var$vsubne,
  vsupnE: $560639d49e3c9a19$var$vsupnE,
  vsupne: $560639d49e3c9a19$var$vsupne,
  vzigzag: $560639d49e3c9a19$var$vzigzag,
  wcirc: $560639d49e3c9a19$var$wcirc,
  wedbar: $560639d49e3c9a19$var$wedbar,
  wedge: $560639d49e3c9a19$var$wedge,
  wedgeq: $560639d49e3c9a19$var$wedgeq,
  weierp: $560639d49e3c9a19$var$weierp$1,
  wfr: $560639d49e3c9a19$var$wfr,
  wopf: $560639d49e3c9a19$var$wopf,
  wp: $560639d49e3c9a19$var$wp,
  wr: $560639d49e3c9a19$var$wr,
  wreath: $560639d49e3c9a19$var$wreath,
  wscr: $560639d49e3c9a19$var$wscr,
  xcap: $560639d49e3c9a19$var$xcap,
  xcirc: $560639d49e3c9a19$var$xcirc,
  xcup: $560639d49e3c9a19$var$xcup,
  xdtri: $560639d49e3c9a19$var$xdtri,
  xfr: $560639d49e3c9a19$var$xfr,
  xhArr: $560639d49e3c9a19$var$xhArr,
  xharr: $560639d49e3c9a19$var$xharr,
  xi: $560639d49e3c9a19$var$xi$1,
  xlArr: $560639d49e3c9a19$var$xlArr,
  xlarr: $560639d49e3c9a19$var$xlarr,
  xmap: $560639d49e3c9a19$var$xmap,
  xnis: $560639d49e3c9a19$var$xnis,
  xodot: $560639d49e3c9a19$var$xodot,
  xopf: $560639d49e3c9a19$var$xopf,
  xoplus: $560639d49e3c9a19$var$xoplus,
  xotime: $560639d49e3c9a19$var$xotime,
  xrArr: $560639d49e3c9a19$var$xrArr,
  xrarr: $560639d49e3c9a19$var$xrarr,
  xscr: $560639d49e3c9a19$var$xscr,
  xsqcup: $560639d49e3c9a19$var$xsqcup,
  xuplus: $560639d49e3c9a19$var$xuplus,
  xutri: $560639d49e3c9a19$var$xutri,
  xvee: $560639d49e3c9a19$var$xvee,
  xwedge: $560639d49e3c9a19$var$xwedge,
  yacut: $560639d49e3c9a19$var$yacut,
  yacute: $560639d49e3c9a19$var$yacute$1,
  yacy: $560639d49e3c9a19$var$yacy,
  ycirc: $560639d49e3c9a19$var$ycirc,
  ycy: $560639d49e3c9a19$var$ycy,
  ye: $560639d49e3c9a19$var$ye,
  yen: $560639d49e3c9a19$var$yen$1,
  yfr: $560639d49e3c9a19$var$yfr,
  yicy: $560639d49e3c9a19$var$yicy,
  yopf: $560639d49e3c9a19$var$yopf,
  yscr: $560639d49e3c9a19$var$yscr,
  yucy: $560639d49e3c9a19$var$yucy,
  yum: $560639d49e3c9a19$var$yum,
  yuml: $560639d49e3c9a19$var$yuml$1,
  zacute: $560639d49e3c9a19$var$zacute,
  zcaron: $560639d49e3c9a19$var$zcaron,
  zcy: $560639d49e3c9a19$var$zcy,
  zdot: $560639d49e3c9a19$var$zdot,
  zeetrf: $560639d49e3c9a19$var$zeetrf,
  zeta: $560639d49e3c9a19$var$zeta$1,
  zfr: $560639d49e3c9a19$var$zfr,
  zhcy: $560639d49e3c9a19$var$zhcy,
  zigrarr: $560639d49e3c9a19$var$zigrarr,
  zopf: $560639d49e3c9a19$var$zopf,
  zscr: $560639d49e3c9a19$var$zscr,
  zwj: $560639d49e3c9a19$var$zwj$1,
  zwnj: $560639d49e3c9a19$var$zwnj$1
};
var $560639d49e3c9a19$var$characterEntities$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AEli: $560639d49e3c9a19$var$AEli,
  AElig: $560639d49e3c9a19$var$AElig$1,
  AM: $560639d49e3c9a19$var$AM,
  AMP: $560639d49e3c9a19$var$AMP$1,
  Aacut: $560639d49e3c9a19$var$Aacut,
  Aacute: $560639d49e3c9a19$var$Aacute$1,
  Abreve: $560639d49e3c9a19$var$Abreve,
  Acir: $560639d49e3c9a19$var$Acir,
  Acirc: $560639d49e3c9a19$var$Acirc$1,
  Acy: $560639d49e3c9a19$var$Acy,
  Afr: $560639d49e3c9a19$var$Afr,
  Agrav: $560639d49e3c9a19$var$Agrav,
  Agrave: $560639d49e3c9a19$var$Agrave$1,
  Alpha: $560639d49e3c9a19$var$Alpha$1,
  Amacr: $560639d49e3c9a19$var$Amacr,
  And: $560639d49e3c9a19$var$And,
  Aogon: $560639d49e3c9a19$var$Aogon,
  Aopf: $560639d49e3c9a19$var$Aopf,
  ApplyFunction: $560639d49e3c9a19$var$ApplyFunction,
  Arin: $560639d49e3c9a19$var$Arin,
  Aring: $560639d49e3c9a19$var$Aring$1,
  Ascr: $560639d49e3c9a19$var$Ascr,
  Assign: $560639d49e3c9a19$var$Assign,
  Atild: $560639d49e3c9a19$var$Atild,
  Atilde: $560639d49e3c9a19$var$Atilde$1,
  Aum: $560639d49e3c9a19$var$Aum,
  Auml: $560639d49e3c9a19$var$Auml$1,
  Backslash: $560639d49e3c9a19$var$Backslash,
  Barv: $560639d49e3c9a19$var$Barv,
  Barwed: $560639d49e3c9a19$var$Barwed,
  Bcy: $560639d49e3c9a19$var$Bcy,
  Because: $560639d49e3c9a19$var$Because,
  Bernoullis: $560639d49e3c9a19$var$Bernoullis,
  Beta: $560639d49e3c9a19$var$Beta$1,
  Bfr: $560639d49e3c9a19$var$Bfr,
  Bopf: $560639d49e3c9a19$var$Bopf,
  Breve: $560639d49e3c9a19$var$Breve,
  Bscr: $560639d49e3c9a19$var$Bscr,
  Bumpeq: $560639d49e3c9a19$var$Bumpeq,
  CHcy: $560639d49e3c9a19$var$CHcy,
  COP: $560639d49e3c9a19$var$COP,
  COPY: $560639d49e3c9a19$var$COPY,
  Cacute: $560639d49e3c9a19$var$Cacute,
  Cap: $560639d49e3c9a19$var$Cap,
  CapitalDifferentialD: $560639d49e3c9a19$var$CapitalDifferentialD,
  Cayleys: $560639d49e3c9a19$var$Cayleys,
  Ccaron: $560639d49e3c9a19$var$Ccaron,
  Ccedi: $560639d49e3c9a19$var$Ccedi,
  Ccedil: $560639d49e3c9a19$var$Ccedil$1,
  Ccirc: $560639d49e3c9a19$var$Ccirc,
  Cconint: $560639d49e3c9a19$var$Cconint,
  Cdot: $560639d49e3c9a19$var$Cdot,
  Cedilla: $560639d49e3c9a19$var$Cedilla,
  CenterDot: $560639d49e3c9a19$var$CenterDot,
  Cfr: $560639d49e3c9a19$var$Cfr,
  Chi: $560639d49e3c9a19$var$Chi$1,
  CircleDot: $560639d49e3c9a19$var$CircleDot,
  CircleMinus: $560639d49e3c9a19$var$CircleMinus,
  CirclePlus: $560639d49e3c9a19$var$CirclePlus,
  CircleTimes: $560639d49e3c9a19$var$CircleTimes,
  ClockwiseContourIntegral: $560639d49e3c9a19$var$ClockwiseContourIntegral,
  CloseCurlyDoubleQuote: $560639d49e3c9a19$var$CloseCurlyDoubleQuote,
  CloseCurlyQuote: $560639d49e3c9a19$var$CloseCurlyQuote,
  Colon: $560639d49e3c9a19$var$Colon,
  Colone: $560639d49e3c9a19$var$Colone,
  Congruent: $560639d49e3c9a19$var$Congruent,
  Conint: $560639d49e3c9a19$var$Conint,
  ContourIntegral: $560639d49e3c9a19$var$ContourIntegral,
  Copf: $560639d49e3c9a19$var$Copf,
  Coproduct: $560639d49e3c9a19$var$Coproduct,
  CounterClockwiseContourIntegral: $560639d49e3c9a19$var$CounterClockwiseContourIntegral,
  Cross: $560639d49e3c9a19$var$Cross,
  Cscr: $560639d49e3c9a19$var$Cscr,
  Cup: $560639d49e3c9a19$var$Cup,
  CupCap: $560639d49e3c9a19$var$CupCap,
  DD: $560639d49e3c9a19$var$DD,
  DDotrahd: $560639d49e3c9a19$var$DDotrahd,
  DJcy: $560639d49e3c9a19$var$DJcy,
  DScy: $560639d49e3c9a19$var$DScy,
  DZcy: $560639d49e3c9a19$var$DZcy,
  Dagger: $560639d49e3c9a19$var$Dagger$1,
  Darr: $560639d49e3c9a19$var$Darr,
  Dashv: $560639d49e3c9a19$var$Dashv,
  Dcaron: $560639d49e3c9a19$var$Dcaron,
  Dcy: $560639d49e3c9a19$var$Dcy,
  Del: $560639d49e3c9a19$var$Del,
  Delta: $560639d49e3c9a19$var$Delta$1,
  Dfr: $560639d49e3c9a19$var$Dfr,
  DiacriticalAcute: $560639d49e3c9a19$var$DiacriticalAcute,
  DiacriticalDot: $560639d49e3c9a19$var$DiacriticalDot,
  DiacriticalDoubleAcute: $560639d49e3c9a19$var$DiacriticalDoubleAcute,
  DiacriticalGrave: $560639d49e3c9a19$var$DiacriticalGrave,
  DiacriticalTilde: $560639d49e3c9a19$var$DiacriticalTilde,
  Diamond: $560639d49e3c9a19$var$Diamond,
  DifferentialD: $560639d49e3c9a19$var$DifferentialD,
  Dopf: $560639d49e3c9a19$var$Dopf,
  Dot: $560639d49e3c9a19$var$Dot,
  DotDot: $560639d49e3c9a19$var$DotDot,
  DotEqual: $560639d49e3c9a19$var$DotEqual,
  DoubleContourIntegral: $560639d49e3c9a19$var$DoubleContourIntegral,
  DoubleDot: $560639d49e3c9a19$var$DoubleDot,
  DoubleDownArrow: $560639d49e3c9a19$var$DoubleDownArrow,
  DoubleLeftArrow: $560639d49e3c9a19$var$DoubleLeftArrow,
  DoubleLeftRightArrow: $560639d49e3c9a19$var$DoubleLeftRightArrow,
  DoubleLeftTee: $560639d49e3c9a19$var$DoubleLeftTee,
  DoubleLongLeftArrow: $560639d49e3c9a19$var$DoubleLongLeftArrow,
  DoubleLongLeftRightArrow: $560639d49e3c9a19$var$DoubleLongLeftRightArrow,
  DoubleLongRightArrow: $560639d49e3c9a19$var$DoubleLongRightArrow,
  DoubleRightArrow: $560639d49e3c9a19$var$DoubleRightArrow,
  DoubleRightTee: $560639d49e3c9a19$var$DoubleRightTee,
  DoubleUpArrow: $560639d49e3c9a19$var$DoubleUpArrow,
  DoubleUpDownArrow: $560639d49e3c9a19$var$DoubleUpDownArrow,
  DoubleVerticalBar: $560639d49e3c9a19$var$DoubleVerticalBar,
  DownArrow: $560639d49e3c9a19$var$DownArrow,
  DownArrowBar: $560639d49e3c9a19$var$DownArrowBar,
  DownArrowUpArrow: $560639d49e3c9a19$var$DownArrowUpArrow,
  DownBreve: $560639d49e3c9a19$var$DownBreve,
  DownLeftRightVector: $560639d49e3c9a19$var$DownLeftRightVector,
  DownLeftTeeVector: $560639d49e3c9a19$var$DownLeftTeeVector,
  DownLeftVector: $560639d49e3c9a19$var$DownLeftVector,
  DownLeftVectorBar: $560639d49e3c9a19$var$DownLeftVectorBar,
  DownRightTeeVector: $560639d49e3c9a19$var$DownRightTeeVector,
  DownRightVector: $560639d49e3c9a19$var$DownRightVector,
  DownRightVectorBar: $560639d49e3c9a19$var$DownRightVectorBar,
  DownTee: $560639d49e3c9a19$var$DownTee,
  DownTeeArrow: $560639d49e3c9a19$var$DownTeeArrow,
  Downarrow: $560639d49e3c9a19$var$Downarrow,
  Dscr: $560639d49e3c9a19$var$Dscr,
  Dstrok: $560639d49e3c9a19$var$Dstrok,
  ENG: $560639d49e3c9a19$var$ENG,
  ET: $560639d49e3c9a19$var$ET,
  ETH: $560639d49e3c9a19$var$ETH$1,
  Eacut: $560639d49e3c9a19$var$Eacut,
  Eacute: $560639d49e3c9a19$var$Eacute$1,
  Ecaron: $560639d49e3c9a19$var$Ecaron,
  Ecir: $560639d49e3c9a19$var$Ecir,
  Ecirc: $560639d49e3c9a19$var$Ecirc$1,
  Ecy: $560639d49e3c9a19$var$Ecy,
  Edot: $560639d49e3c9a19$var$Edot,
  Efr: $560639d49e3c9a19$var$Efr,
  Egrav: $560639d49e3c9a19$var$Egrav,
  Egrave: $560639d49e3c9a19$var$Egrave$1,
  Element: $560639d49e3c9a19$var$Element,
  Emacr: $560639d49e3c9a19$var$Emacr,
  EmptySmallSquare: $560639d49e3c9a19$var$EmptySmallSquare,
  EmptyVerySmallSquare: $560639d49e3c9a19$var$EmptyVerySmallSquare,
  Eogon: $560639d49e3c9a19$var$Eogon,
  Eopf: $560639d49e3c9a19$var$Eopf,
  Epsilon: $560639d49e3c9a19$var$Epsilon$1,
  Equal: $560639d49e3c9a19$var$Equal,
  EqualTilde: $560639d49e3c9a19$var$EqualTilde,
  Equilibrium: $560639d49e3c9a19$var$Equilibrium,
  Escr: $560639d49e3c9a19$var$Escr,
  Esim: $560639d49e3c9a19$var$Esim,
  Eta: $560639d49e3c9a19$var$Eta$1,
  Eum: $560639d49e3c9a19$var$Eum,
  Euml: $560639d49e3c9a19$var$Euml$1,
  Exists: $560639d49e3c9a19$var$Exists,
  ExponentialE: $560639d49e3c9a19$var$ExponentialE,
  Fcy: $560639d49e3c9a19$var$Fcy,
  Ffr: $560639d49e3c9a19$var$Ffr,
  FilledSmallSquare: $560639d49e3c9a19$var$FilledSmallSquare,
  FilledVerySmallSquare: $560639d49e3c9a19$var$FilledVerySmallSquare,
  Fopf: $560639d49e3c9a19$var$Fopf,
  ForAll: $560639d49e3c9a19$var$ForAll,
  Fouriertrf: $560639d49e3c9a19$var$Fouriertrf,
  Fscr: $560639d49e3c9a19$var$Fscr,
  GJcy: $560639d49e3c9a19$var$GJcy,
  G: $560639d49e3c9a19$var$G,
  GT: $560639d49e3c9a19$var$GT$1,
  Gamma: $560639d49e3c9a19$var$Gamma$1,
  Gammad: $560639d49e3c9a19$var$Gammad,
  Gbreve: $560639d49e3c9a19$var$Gbreve,
  Gcedil: $560639d49e3c9a19$var$Gcedil,
  Gcirc: $560639d49e3c9a19$var$Gcirc,
  Gcy: $560639d49e3c9a19$var$Gcy,
  Gdot: $560639d49e3c9a19$var$Gdot,
  Gfr: $560639d49e3c9a19$var$Gfr,
  Gg: $560639d49e3c9a19$var$Gg,
  Gopf: $560639d49e3c9a19$var$Gopf,
  GreaterEqual: $560639d49e3c9a19$var$GreaterEqual,
  GreaterEqualLess: $560639d49e3c9a19$var$GreaterEqualLess,
  GreaterFullEqual: $560639d49e3c9a19$var$GreaterFullEqual,
  GreaterGreater: $560639d49e3c9a19$var$GreaterGreater,
  GreaterLess: $560639d49e3c9a19$var$GreaterLess,
  GreaterSlantEqual: $560639d49e3c9a19$var$GreaterSlantEqual,
  GreaterTilde: $560639d49e3c9a19$var$GreaterTilde,
  Gscr: $560639d49e3c9a19$var$Gscr,
  Gt: $560639d49e3c9a19$var$Gt,
  HARDcy: $560639d49e3c9a19$var$HARDcy,
  Hacek: $560639d49e3c9a19$var$Hacek,
  Hat: $560639d49e3c9a19$var$Hat,
  Hcirc: $560639d49e3c9a19$var$Hcirc,
  Hfr: $560639d49e3c9a19$var$Hfr,
  HilbertSpace: $560639d49e3c9a19$var$HilbertSpace,
  Hopf: $560639d49e3c9a19$var$Hopf,
  HorizontalLine: $560639d49e3c9a19$var$HorizontalLine,
  Hscr: $560639d49e3c9a19$var$Hscr,
  Hstrok: $560639d49e3c9a19$var$Hstrok,
  HumpDownHump: $560639d49e3c9a19$var$HumpDownHump,
  HumpEqual: $560639d49e3c9a19$var$HumpEqual,
  IEcy: $560639d49e3c9a19$var$IEcy,
  IJlig: $560639d49e3c9a19$var$IJlig,
  IOcy: $560639d49e3c9a19$var$IOcy,
  Iacut: $560639d49e3c9a19$var$Iacut,
  Iacute: $560639d49e3c9a19$var$Iacute$1,
  Icir: $560639d49e3c9a19$var$Icir,
  Icirc: $560639d49e3c9a19$var$Icirc$1,
  Icy: $560639d49e3c9a19$var$Icy,
  Idot: $560639d49e3c9a19$var$Idot,
  Ifr: $560639d49e3c9a19$var$Ifr,
  Igrav: $560639d49e3c9a19$var$Igrav,
  Igrave: $560639d49e3c9a19$var$Igrave$1,
  Im: $560639d49e3c9a19$var$Im,
  Imacr: $560639d49e3c9a19$var$Imacr,
  ImaginaryI: $560639d49e3c9a19$var$ImaginaryI,
  Implies: $560639d49e3c9a19$var$Implies,
  Int: $560639d49e3c9a19$var$Int,
  Integral: $560639d49e3c9a19$var$Integral,
  Intersection: $560639d49e3c9a19$var$Intersection,
  InvisibleComma: $560639d49e3c9a19$var$InvisibleComma,
  InvisibleTimes: $560639d49e3c9a19$var$InvisibleTimes,
  Iogon: $560639d49e3c9a19$var$Iogon,
  Iopf: $560639d49e3c9a19$var$Iopf,
  Iota: $560639d49e3c9a19$var$Iota$1,
  Iscr: $560639d49e3c9a19$var$Iscr,
  Itilde: $560639d49e3c9a19$var$Itilde,
  Iukcy: $560639d49e3c9a19$var$Iukcy,
  Ium: $560639d49e3c9a19$var$Ium,
  Iuml: $560639d49e3c9a19$var$Iuml$1,
  Jcirc: $560639d49e3c9a19$var$Jcirc,
  Jcy: $560639d49e3c9a19$var$Jcy,
  Jfr: $560639d49e3c9a19$var$Jfr,
  Jopf: $560639d49e3c9a19$var$Jopf,
  Jscr: $560639d49e3c9a19$var$Jscr,
  Jsercy: $560639d49e3c9a19$var$Jsercy,
  Jukcy: $560639d49e3c9a19$var$Jukcy,
  KHcy: $560639d49e3c9a19$var$KHcy,
  KJcy: $560639d49e3c9a19$var$KJcy,
  Kappa: $560639d49e3c9a19$var$Kappa$1,
  Kcedil: $560639d49e3c9a19$var$Kcedil,
  Kcy: $560639d49e3c9a19$var$Kcy,
  Kfr: $560639d49e3c9a19$var$Kfr,
  Kopf: $560639d49e3c9a19$var$Kopf,
  Kscr: $560639d49e3c9a19$var$Kscr,
  LJcy: $560639d49e3c9a19$var$LJcy,
  L: $560639d49e3c9a19$var$L,
  LT: $560639d49e3c9a19$var$LT$1,
  Lacute: $560639d49e3c9a19$var$Lacute,
  Lambda: $560639d49e3c9a19$var$Lambda$1,
  Lang: $560639d49e3c9a19$var$Lang,
  Laplacetrf: $560639d49e3c9a19$var$Laplacetrf,
  Larr: $560639d49e3c9a19$var$Larr,
  Lcaron: $560639d49e3c9a19$var$Lcaron,
  Lcedil: $560639d49e3c9a19$var$Lcedil,
  Lcy: $560639d49e3c9a19$var$Lcy,
  LeftAngleBracket: $560639d49e3c9a19$var$LeftAngleBracket,
  LeftArrow: $560639d49e3c9a19$var$LeftArrow,
  LeftArrowBar: $560639d49e3c9a19$var$LeftArrowBar,
  LeftArrowRightArrow: $560639d49e3c9a19$var$LeftArrowRightArrow,
  LeftCeiling: $560639d49e3c9a19$var$LeftCeiling,
  LeftDoubleBracket: $560639d49e3c9a19$var$LeftDoubleBracket,
  LeftDownTeeVector: $560639d49e3c9a19$var$LeftDownTeeVector,
  LeftDownVector: $560639d49e3c9a19$var$LeftDownVector,
  LeftDownVectorBar: $560639d49e3c9a19$var$LeftDownVectorBar,
  LeftFloor: $560639d49e3c9a19$var$LeftFloor,
  LeftRightArrow: $560639d49e3c9a19$var$LeftRightArrow,
  LeftRightVector: $560639d49e3c9a19$var$LeftRightVector,
  LeftTee: $560639d49e3c9a19$var$LeftTee,
  LeftTeeArrow: $560639d49e3c9a19$var$LeftTeeArrow,
  LeftTeeVector: $560639d49e3c9a19$var$LeftTeeVector,
  LeftTriangle: $560639d49e3c9a19$var$LeftTriangle,
  LeftTriangleBar: $560639d49e3c9a19$var$LeftTriangleBar,
  LeftTriangleEqual: $560639d49e3c9a19$var$LeftTriangleEqual,
  LeftUpDownVector: $560639d49e3c9a19$var$LeftUpDownVector,
  LeftUpTeeVector: $560639d49e3c9a19$var$LeftUpTeeVector,
  LeftUpVector: $560639d49e3c9a19$var$LeftUpVector,
  LeftUpVectorBar: $560639d49e3c9a19$var$LeftUpVectorBar,
  LeftVector: $560639d49e3c9a19$var$LeftVector,
  LeftVectorBar: $560639d49e3c9a19$var$LeftVectorBar,
  Leftarrow: $560639d49e3c9a19$var$Leftarrow,
  Leftrightarrow: $560639d49e3c9a19$var$Leftrightarrow,
  LessEqualGreater: $560639d49e3c9a19$var$LessEqualGreater,
  LessFullEqual: $560639d49e3c9a19$var$LessFullEqual,
  LessGreater: $560639d49e3c9a19$var$LessGreater,
  LessLess: $560639d49e3c9a19$var$LessLess,
  LessSlantEqual: $560639d49e3c9a19$var$LessSlantEqual,
  LessTilde: $560639d49e3c9a19$var$LessTilde,
  Lfr: $560639d49e3c9a19$var$Lfr,
  Ll: $560639d49e3c9a19$var$Ll,
  Lleftarrow: $560639d49e3c9a19$var$Lleftarrow,
  Lmidot: $560639d49e3c9a19$var$Lmidot,
  LongLeftArrow: $560639d49e3c9a19$var$LongLeftArrow,
  LongLeftRightArrow: $560639d49e3c9a19$var$LongLeftRightArrow,
  LongRightArrow: $560639d49e3c9a19$var$LongRightArrow,
  Longleftarrow: $560639d49e3c9a19$var$Longleftarrow,
  Longleftrightarrow: $560639d49e3c9a19$var$Longleftrightarrow,
  Longrightarrow: $560639d49e3c9a19$var$Longrightarrow,
  Lopf: $560639d49e3c9a19$var$Lopf,
  LowerLeftArrow: $560639d49e3c9a19$var$LowerLeftArrow,
  LowerRightArrow: $560639d49e3c9a19$var$LowerRightArrow,
  Lscr: $560639d49e3c9a19$var$Lscr,
  Lsh: $560639d49e3c9a19$var$Lsh,
  Lstrok: $560639d49e3c9a19$var$Lstrok,
  Lt: $560639d49e3c9a19$var$Lt,
  Mcy: $560639d49e3c9a19$var$Mcy,
  MediumSpace: $560639d49e3c9a19$var$MediumSpace,
  Mellintrf: $560639d49e3c9a19$var$Mellintrf,
  Mfr: $560639d49e3c9a19$var$Mfr,
  MinusPlus: $560639d49e3c9a19$var$MinusPlus,
  Mopf: $560639d49e3c9a19$var$Mopf,
  Mscr: $560639d49e3c9a19$var$Mscr,
  Mu: $560639d49e3c9a19$var$Mu$1,
  NJcy: $560639d49e3c9a19$var$NJcy,
  Nacute: $560639d49e3c9a19$var$Nacute,
  Ncaron: $560639d49e3c9a19$var$Ncaron,
  Ncedil: $560639d49e3c9a19$var$Ncedil,
  Ncy: $560639d49e3c9a19$var$Ncy,
  NegativeMediumSpace: $560639d49e3c9a19$var$NegativeMediumSpace,
  NegativeThickSpace: $560639d49e3c9a19$var$NegativeThickSpace,
  NegativeThinSpace: $560639d49e3c9a19$var$NegativeThinSpace,
  NegativeVeryThinSpace: $560639d49e3c9a19$var$NegativeVeryThinSpace,
  NestedGreaterGreater: $560639d49e3c9a19$var$NestedGreaterGreater,
  NestedLessLess: $560639d49e3c9a19$var$NestedLessLess,
  NewLine: $560639d49e3c9a19$var$NewLine,
  Nfr: $560639d49e3c9a19$var$Nfr,
  NoBreak: $560639d49e3c9a19$var$NoBreak,
  NonBreakingSpace: $560639d49e3c9a19$var$NonBreakingSpace,
  Nopf: $560639d49e3c9a19$var$Nopf,
  Not: $560639d49e3c9a19$var$Not,
  NotCongruent: $560639d49e3c9a19$var$NotCongruent,
  NotCupCap: $560639d49e3c9a19$var$NotCupCap,
  NotDoubleVerticalBar: $560639d49e3c9a19$var$NotDoubleVerticalBar,
  NotElement: $560639d49e3c9a19$var$NotElement,
  NotEqual: $560639d49e3c9a19$var$NotEqual,
  NotEqualTilde: $560639d49e3c9a19$var$NotEqualTilde,
  NotExists: $560639d49e3c9a19$var$NotExists,
  NotGreater: $560639d49e3c9a19$var$NotGreater,
  NotGreaterEqual: $560639d49e3c9a19$var$NotGreaterEqual,
  NotGreaterFullEqual: $560639d49e3c9a19$var$NotGreaterFullEqual,
  NotGreaterGreater: $560639d49e3c9a19$var$NotGreaterGreater,
  NotGreaterLess: $560639d49e3c9a19$var$NotGreaterLess,
  NotGreaterSlantEqual: $560639d49e3c9a19$var$NotGreaterSlantEqual,
  NotGreaterTilde: $560639d49e3c9a19$var$NotGreaterTilde,
  NotHumpDownHump: $560639d49e3c9a19$var$NotHumpDownHump,
  NotHumpEqual: $560639d49e3c9a19$var$NotHumpEqual,
  NotLeftTriangle: $560639d49e3c9a19$var$NotLeftTriangle,
  NotLeftTriangleBar: $560639d49e3c9a19$var$NotLeftTriangleBar,
  NotLeftTriangleEqual: $560639d49e3c9a19$var$NotLeftTriangleEqual,
  NotLess: $560639d49e3c9a19$var$NotLess,
  NotLessEqual: $560639d49e3c9a19$var$NotLessEqual,
  NotLessGreater: $560639d49e3c9a19$var$NotLessGreater,
  NotLessLess: $560639d49e3c9a19$var$NotLessLess,
  NotLessSlantEqual: $560639d49e3c9a19$var$NotLessSlantEqual,
  NotLessTilde: $560639d49e3c9a19$var$NotLessTilde,
  NotNestedGreaterGreater: $560639d49e3c9a19$var$NotNestedGreaterGreater,
  NotNestedLessLess: $560639d49e3c9a19$var$NotNestedLessLess,
  NotPrecedes: $560639d49e3c9a19$var$NotPrecedes,
  NotPrecedesEqual: $560639d49e3c9a19$var$NotPrecedesEqual,
  NotPrecedesSlantEqual: $560639d49e3c9a19$var$NotPrecedesSlantEqual,
  NotReverseElement: $560639d49e3c9a19$var$NotReverseElement,
  NotRightTriangle: $560639d49e3c9a19$var$NotRightTriangle,
  NotRightTriangleBar: $560639d49e3c9a19$var$NotRightTriangleBar,
  NotRightTriangleEqual: $560639d49e3c9a19$var$NotRightTriangleEqual,
  NotSquareSubset: $560639d49e3c9a19$var$NotSquareSubset,
  NotSquareSubsetEqual: $560639d49e3c9a19$var$NotSquareSubsetEqual,
  NotSquareSuperset: $560639d49e3c9a19$var$NotSquareSuperset,
  NotSquareSupersetEqual: $560639d49e3c9a19$var$NotSquareSupersetEqual,
  NotSubset: $560639d49e3c9a19$var$NotSubset,
  NotSubsetEqual: $560639d49e3c9a19$var$NotSubsetEqual,
  NotSucceeds: $560639d49e3c9a19$var$NotSucceeds,
  NotSucceedsEqual: $560639d49e3c9a19$var$NotSucceedsEqual,
  NotSucceedsSlantEqual: $560639d49e3c9a19$var$NotSucceedsSlantEqual,
  NotSucceedsTilde: $560639d49e3c9a19$var$NotSucceedsTilde,
  NotSuperset: $560639d49e3c9a19$var$NotSuperset,
  NotSupersetEqual: $560639d49e3c9a19$var$NotSupersetEqual,
  NotTilde: $560639d49e3c9a19$var$NotTilde,
  NotTildeEqual: $560639d49e3c9a19$var$NotTildeEqual,
  NotTildeFullEqual: $560639d49e3c9a19$var$NotTildeFullEqual,
  NotTildeTilde: $560639d49e3c9a19$var$NotTildeTilde,
  NotVerticalBar: $560639d49e3c9a19$var$NotVerticalBar,
  Nscr: $560639d49e3c9a19$var$Nscr,
  Ntild: $560639d49e3c9a19$var$Ntild,
  Ntilde: $560639d49e3c9a19$var$Ntilde$1,
  Nu: $560639d49e3c9a19$var$Nu$1,
  OElig: $560639d49e3c9a19$var$OElig$1,
  Oacut: $560639d49e3c9a19$var$Oacut,
  Oacute: $560639d49e3c9a19$var$Oacute$1,
  Ocir: $560639d49e3c9a19$var$Ocir,
  Ocirc: $560639d49e3c9a19$var$Ocirc$1,
  Ocy: $560639d49e3c9a19$var$Ocy,
  Odblac: $560639d49e3c9a19$var$Odblac,
  Ofr: $560639d49e3c9a19$var$Ofr,
  Ograv: $560639d49e3c9a19$var$Ograv,
  Ograve: $560639d49e3c9a19$var$Ograve$1,
  Omacr: $560639d49e3c9a19$var$Omacr,
  Omega: $560639d49e3c9a19$var$Omega$1,
  Omicron: $560639d49e3c9a19$var$Omicron$1,
  Oopf: $560639d49e3c9a19$var$Oopf,
  OpenCurlyDoubleQuote: $560639d49e3c9a19$var$OpenCurlyDoubleQuote,
  OpenCurlyQuote: $560639d49e3c9a19$var$OpenCurlyQuote,
  Or: $560639d49e3c9a19$var$Or,
  Oscr: $560639d49e3c9a19$var$Oscr,
  Oslas: $560639d49e3c9a19$var$Oslas,
  Oslash: $560639d49e3c9a19$var$Oslash$1,
  Otild: $560639d49e3c9a19$var$Otild,
  Otilde: $560639d49e3c9a19$var$Otilde$1,
  Otimes: $560639d49e3c9a19$var$Otimes,
  Oum: $560639d49e3c9a19$var$Oum,
  Ouml: $560639d49e3c9a19$var$Ouml$1,
  OverBar: $560639d49e3c9a19$var$OverBar,
  OverBrace: $560639d49e3c9a19$var$OverBrace,
  OverBracket: $560639d49e3c9a19$var$OverBracket,
  OverParenthesis: $560639d49e3c9a19$var$OverParenthesis,
  PartialD: $560639d49e3c9a19$var$PartialD,
  Pcy: $560639d49e3c9a19$var$Pcy,
  Pfr: $560639d49e3c9a19$var$Pfr,
  Phi: $560639d49e3c9a19$var$Phi$1,
  Pi: $560639d49e3c9a19$var$Pi$1,
  PlusMinus: $560639d49e3c9a19$var$PlusMinus,
  Poincareplane: $560639d49e3c9a19$var$Poincareplane,
  Popf: $560639d49e3c9a19$var$Popf,
  Pr: $560639d49e3c9a19$var$Pr,
  Precedes: $560639d49e3c9a19$var$Precedes,
  PrecedesEqual: $560639d49e3c9a19$var$PrecedesEqual,
  PrecedesSlantEqual: $560639d49e3c9a19$var$PrecedesSlantEqual,
  PrecedesTilde: $560639d49e3c9a19$var$PrecedesTilde,
  Prime: $560639d49e3c9a19$var$Prime$1,
  Product: $560639d49e3c9a19$var$Product,
  Proportion: $560639d49e3c9a19$var$Proportion,
  Proportional: $560639d49e3c9a19$var$Proportional,
  Pscr: $560639d49e3c9a19$var$Pscr,
  Psi: $560639d49e3c9a19$var$Psi$1,
  QUO: $560639d49e3c9a19$var$QUO,
  QUOT: $560639d49e3c9a19$var$QUOT,
  Qfr: $560639d49e3c9a19$var$Qfr,
  Qopf: $560639d49e3c9a19$var$Qopf,
  Qscr: $560639d49e3c9a19$var$Qscr,
  RBarr: $560639d49e3c9a19$var$RBarr,
  RE: $560639d49e3c9a19$var$RE,
  REG: $560639d49e3c9a19$var$REG,
  Racute: $560639d49e3c9a19$var$Racute,
  Rang: $560639d49e3c9a19$var$Rang,
  Rarr: $560639d49e3c9a19$var$Rarr,
  Rarrtl: $560639d49e3c9a19$var$Rarrtl,
  Rcaron: $560639d49e3c9a19$var$Rcaron,
  Rcedil: $560639d49e3c9a19$var$Rcedil,
  Rcy: $560639d49e3c9a19$var$Rcy,
  Re: $560639d49e3c9a19$var$Re,
  ReverseElement: $560639d49e3c9a19$var$ReverseElement,
  ReverseEquilibrium: $560639d49e3c9a19$var$ReverseEquilibrium,
  ReverseUpEquilibrium: $560639d49e3c9a19$var$ReverseUpEquilibrium,
  Rfr: $560639d49e3c9a19$var$Rfr,
  Rho: $560639d49e3c9a19$var$Rho$1,
  RightAngleBracket: $560639d49e3c9a19$var$RightAngleBracket,
  RightArrow: $560639d49e3c9a19$var$RightArrow,
  RightArrowBar: $560639d49e3c9a19$var$RightArrowBar,
  RightArrowLeftArrow: $560639d49e3c9a19$var$RightArrowLeftArrow,
  RightCeiling: $560639d49e3c9a19$var$RightCeiling,
  RightDoubleBracket: $560639d49e3c9a19$var$RightDoubleBracket,
  RightDownTeeVector: $560639d49e3c9a19$var$RightDownTeeVector,
  RightDownVector: $560639d49e3c9a19$var$RightDownVector,
  RightDownVectorBar: $560639d49e3c9a19$var$RightDownVectorBar,
  RightFloor: $560639d49e3c9a19$var$RightFloor,
  RightTee: $560639d49e3c9a19$var$RightTee,
  RightTeeArrow: $560639d49e3c9a19$var$RightTeeArrow,
  RightTeeVector: $560639d49e3c9a19$var$RightTeeVector,
  RightTriangle: $560639d49e3c9a19$var$RightTriangle,
  RightTriangleBar: $560639d49e3c9a19$var$RightTriangleBar,
  RightTriangleEqual: $560639d49e3c9a19$var$RightTriangleEqual,
  RightUpDownVector: $560639d49e3c9a19$var$RightUpDownVector,
  RightUpTeeVector: $560639d49e3c9a19$var$RightUpTeeVector,
  RightUpVector: $560639d49e3c9a19$var$RightUpVector,
  RightUpVectorBar: $560639d49e3c9a19$var$RightUpVectorBar,
  RightVector: $560639d49e3c9a19$var$RightVector,
  RightVectorBar: $560639d49e3c9a19$var$RightVectorBar,
  Rightarrow: $560639d49e3c9a19$var$Rightarrow,
  Ropf: $560639d49e3c9a19$var$Ropf,
  RoundImplies: $560639d49e3c9a19$var$RoundImplies,
  Rrightarrow: $560639d49e3c9a19$var$Rrightarrow,
  Rscr: $560639d49e3c9a19$var$Rscr,
  Rsh: $560639d49e3c9a19$var$Rsh,
  RuleDelayed: $560639d49e3c9a19$var$RuleDelayed,
  SHCHcy: $560639d49e3c9a19$var$SHCHcy,
  SHcy: $560639d49e3c9a19$var$SHcy,
  SOFTcy: $560639d49e3c9a19$var$SOFTcy,
  Sacute: $560639d49e3c9a19$var$Sacute,
  Sc: $560639d49e3c9a19$var$Sc,
  Scaron: $560639d49e3c9a19$var$Scaron$1,
  Scedil: $560639d49e3c9a19$var$Scedil,
  Scirc: $560639d49e3c9a19$var$Scirc,
  Scy: $560639d49e3c9a19$var$Scy,
  Sfr: $560639d49e3c9a19$var$Sfr,
  ShortDownArrow: $560639d49e3c9a19$var$ShortDownArrow,
  ShortLeftArrow: $560639d49e3c9a19$var$ShortLeftArrow,
  ShortRightArrow: $560639d49e3c9a19$var$ShortRightArrow,
  ShortUpArrow: $560639d49e3c9a19$var$ShortUpArrow,
  Sigma: $560639d49e3c9a19$var$Sigma$1,
  SmallCircle: $560639d49e3c9a19$var$SmallCircle,
  Sopf: $560639d49e3c9a19$var$Sopf,
  Sqrt: $560639d49e3c9a19$var$Sqrt,
  Square: $560639d49e3c9a19$var$Square,
  SquareIntersection: $560639d49e3c9a19$var$SquareIntersection,
  SquareSubset: $560639d49e3c9a19$var$SquareSubset,
  SquareSubsetEqual: $560639d49e3c9a19$var$SquareSubsetEqual,
  SquareSuperset: $560639d49e3c9a19$var$SquareSuperset,
  SquareSupersetEqual: $560639d49e3c9a19$var$SquareSupersetEqual,
  SquareUnion: $560639d49e3c9a19$var$SquareUnion,
  Sscr: $560639d49e3c9a19$var$Sscr,
  Star: $560639d49e3c9a19$var$Star,
  Sub: $560639d49e3c9a19$var$Sub,
  Subset: $560639d49e3c9a19$var$Subset,
  SubsetEqual: $560639d49e3c9a19$var$SubsetEqual,
  Succeeds: $560639d49e3c9a19$var$Succeeds,
  SucceedsEqual: $560639d49e3c9a19$var$SucceedsEqual,
  SucceedsSlantEqual: $560639d49e3c9a19$var$SucceedsSlantEqual,
  SucceedsTilde: $560639d49e3c9a19$var$SucceedsTilde,
  SuchThat: $560639d49e3c9a19$var$SuchThat,
  Sum: $560639d49e3c9a19$var$Sum,
  Sup: $560639d49e3c9a19$var$Sup,
  Superset: $560639d49e3c9a19$var$Superset,
  SupersetEqual: $560639d49e3c9a19$var$SupersetEqual,
  Supset: $560639d49e3c9a19$var$Supset,
  THOR: $560639d49e3c9a19$var$THOR,
  THORN: $560639d49e3c9a19$var$THORN$1,
  TRADE: $560639d49e3c9a19$var$TRADE,
  TSHcy: $560639d49e3c9a19$var$TSHcy,
  TScy: $560639d49e3c9a19$var$TScy,
  Tab: $560639d49e3c9a19$var$Tab,
  Tau: $560639d49e3c9a19$var$Tau$1,
  Tcaron: $560639d49e3c9a19$var$Tcaron,
  Tcedil: $560639d49e3c9a19$var$Tcedil,
  Tcy: $560639d49e3c9a19$var$Tcy,
  Tfr: $560639d49e3c9a19$var$Tfr,
  Therefore: $560639d49e3c9a19$var$Therefore,
  Theta: $560639d49e3c9a19$var$Theta$1,
  ThickSpace: $560639d49e3c9a19$var$ThickSpace,
  ThinSpace: $560639d49e3c9a19$var$ThinSpace,
  Tilde: $560639d49e3c9a19$var$Tilde,
  TildeEqual: $560639d49e3c9a19$var$TildeEqual,
  TildeFullEqual: $560639d49e3c9a19$var$TildeFullEqual,
  TildeTilde: $560639d49e3c9a19$var$TildeTilde,
  Topf: $560639d49e3c9a19$var$Topf,
  TripleDot: $560639d49e3c9a19$var$TripleDot,
  Tscr: $560639d49e3c9a19$var$Tscr,
  Tstrok: $560639d49e3c9a19$var$Tstrok,
  Uacut: $560639d49e3c9a19$var$Uacut,
  Uacute: $560639d49e3c9a19$var$Uacute$1,
  Uarr: $560639d49e3c9a19$var$Uarr,
  Uarrocir: $560639d49e3c9a19$var$Uarrocir,
  Ubrcy: $560639d49e3c9a19$var$Ubrcy,
  Ubreve: $560639d49e3c9a19$var$Ubreve,
  Ucir: $560639d49e3c9a19$var$Ucir,
  Ucirc: $560639d49e3c9a19$var$Ucirc$1,
  Ucy: $560639d49e3c9a19$var$Ucy,
  Udblac: $560639d49e3c9a19$var$Udblac,
  Ufr: $560639d49e3c9a19$var$Ufr,
  Ugrav: $560639d49e3c9a19$var$Ugrav,
  Ugrave: $560639d49e3c9a19$var$Ugrave$1,
  Umacr: $560639d49e3c9a19$var$Umacr,
  UnderBar: $560639d49e3c9a19$var$UnderBar,
  UnderBrace: $560639d49e3c9a19$var$UnderBrace,
  UnderBracket: $560639d49e3c9a19$var$UnderBracket,
  UnderParenthesis: $560639d49e3c9a19$var$UnderParenthesis,
  Union: $560639d49e3c9a19$var$Union,
  UnionPlus: $560639d49e3c9a19$var$UnionPlus,
  Uogon: $560639d49e3c9a19$var$Uogon,
  Uopf: $560639d49e3c9a19$var$Uopf,
  UpArrow: $560639d49e3c9a19$var$UpArrow,
  UpArrowBar: $560639d49e3c9a19$var$UpArrowBar,
  UpArrowDownArrow: $560639d49e3c9a19$var$UpArrowDownArrow,
  UpDownArrow: $560639d49e3c9a19$var$UpDownArrow,
  UpEquilibrium: $560639d49e3c9a19$var$UpEquilibrium,
  UpTee: $560639d49e3c9a19$var$UpTee,
  UpTeeArrow: $560639d49e3c9a19$var$UpTeeArrow,
  Uparrow: $560639d49e3c9a19$var$Uparrow,
  Updownarrow: $560639d49e3c9a19$var$Updownarrow,
  UpperLeftArrow: $560639d49e3c9a19$var$UpperLeftArrow,
  UpperRightArrow: $560639d49e3c9a19$var$UpperRightArrow,
  Upsi: $560639d49e3c9a19$var$Upsi,
  Upsilon: $560639d49e3c9a19$var$Upsilon$1,
  Uring: $560639d49e3c9a19$var$Uring,
  Uscr: $560639d49e3c9a19$var$Uscr,
  Utilde: $560639d49e3c9a19$var$Utilde,
  Uum: $560639d49e3c9a19$var$Uum,
  Uuml: $560639d49e3c9a19$var$Uuml$1,
  VDash: $560639d49e3c9a19$var$VDash,
  Vbar: $560639d49e3c9a19$var$Vbar,
  Vcy: $560639d49e3c9a19$var$Vcy,
  Vdash: $560639d49e3c9a19$var$Vdash,
  Vdashl: $560639d49e3c9a19$var$Vdashl,
  Vee: $560639d49e3c9a19$var$Vee,
  Verbar: $560639d49e3c9a19$var$Verbar,
  Vert: $560639d49e3c9a19$var$Vert,
  VerticalBar: $560639d49e3c9a19$var$VerticalBar,
  VerticalLine: $560639d49e3c9a19$var$VerticalLine,
  VerticalSeparator: $560639d49e3c9a19$var$VerticalSeparator,
  VerticalTilde: $560639d49e3c9a19$var$VerticalTilde,
  VeryThinSpace: $560639d49e3c9a19$var$VeryThinSpace,
  Vfr: $560639d49e3c9a19$var$Vfr,
  Vopf: $560639d49e3c9a19$var$Vopf,
  Vscr: $560639d49e3c9a19$var$Vscr,
  Vvdash: $560639d49e3c9a19$var$Vvdash,
  Wcirc: $560639d49e3c9a19$var$Wcirc,
  Wedge: $560639d49e3c9a19$var$Wedge,
  Wfr: $560639d49e3c9a19$var$Wfr,
  Wopf: $560639d49e3c9a19$var$Wopf,
  Wscr: $560639d49e3c9a19$var$Wscr,
  Xfr: $560639d49e3c9a19$var$Xfr,
  Xi: $560639d49e3c9a19$var$Xi$1,
  Xopf: $560639d49e3c9a19$var$Xopf,
  Xscr: $560639d49e3c9a19$var$Xscr,
  YAcy: $560639d49e3c9a19$var$YAcy,
  YIcy: $560639d49e3c9a19$var$YIcy,
  YUcy: $560639d49e3c9a19$var$YUcy,
  Yacut: $560639d49e3c9a19$var$Yacut,
  Yacute: $560639d49e3c9a19$var$Yacute$1,
  Ycirc: $560639d49e3c9a19$var$Ycirc,
  Ycy: $560639d49e3c9a19$var$Ycy,
  Yfr: $560639d49e3c9a19$var$Yfr,
  Yopf: $560639d49e3c9a19$var$Yopf,
  Yscr: $560639d49e3c9a19$var$Yscr,
  Yuml: $560639d49e3c9a19$var$Yuml$1,
  ZHcy: $560639d49e3c9a19$var$ZHcy,
  Zacute: $560639d49e3c9a19$var$Zacute,
  Zcaron: $560639d49e3c9a19$var$Zcaron,
  Zcy: $560639d49e3c9a19$var$Zcy,
  Zdot: $560639d49e3c9a19$var$Zdot,
  ZeroWidthSpace: $560639d49e3c9a19$var$ZeroWidthSpace,
  Zeta: $560639d49e3c9a19$var$Zeta$1,
  Zfr: $560639d49e3c9a19$var$Zfr,
  Zopf: $560639d49e3c9a19$var$Zopf,
  Zscr: $560639d49e3c9a19$var$Zscr,
  aacut: $560639d49e3c9a19$var$aacut,
  aacute: $560639d49e3c9a19$var$aacute$1,
  abreve: $560639d49e3c9a19$var$abreve,
  ac: $560639d49e3c9a19$var$ac,
  acE: $560639d49e3c9a19$var$acE,
  acd: $560639d49e3c9a19$var$acd,
  acir: $560639d49e3c9a19$var$acir,
  acirc: $560639d49e3c9a19$var$acirc$1,
  acut: $560639d49e3c9a19$var$acut,
  acute: $560639d49e3c9a19$var$acute$1,
  acy: $560639d49e3c9a19$var$acy,
  aeli: $560639d49e3c9a19$var$aeli,
  aelig: $560639d49e3c9a19$var$aelig$1,
  af: $560639d49e3c9a19$var$af,
  afr: $560639d49e3c9a19$var$afr,
  agrav: $560639d49e3c9a19$var$agrav,
  agrave: $560639d49e3c9a19$var$agrave$1,
  alefsym: $560639d49e3c9a19$var$alefsym$1,
  aleph: $560639d49e3c9a19$var$aleph,
  alpha: $560639d49e3c9a19$var$alpha$1,
  amacr: $560639d49e3c9a19$var$amacr,
  amalg: $560639d49e3c9a19$var$amalg,
  am: $560639d49e3c9a19$var$am,
  amp: $560639d49e3c9a19$var$amp$1,
  and: $560639d49e3c9a19$var$and$1,
  andand: $560639d49e3c9a19$var$andand,
  andd: $560639d49e3c9a19$var$andd,
  andslope: $560639d49e3c9a19$var$andslope,
  andv: $560639d49e3c9a19$var$andv,
  ang: $560639d49e3c9a19$var$ang$1,
  ange: $560639d49e3c9a19$var$ange,
  angle: $560639d49e3c9a19$var$angle,
  angmsd: $560639d49e3c9a19$var$angmsd,
  angmsdaa: $560639d49e3c9a19$var$angmsdaa,
  angmsdab: $560639d49e3c9a19$var$angmsdab,
  angmsdac: $560639d49e3c9a19$var$angmsdac,
  angmsdad: $560639d49e3c9a19$var$angmsdad,
  angmsdae: $560639d49e3c9a19$var$angmsdae,
  angmsdaf: $560639d49e3c9a19$var$angmsdaf,
  angmsdag: $560639d49e3c9a19$var$angmsdag,
  angmsdah: $560639d49e3c9a19$var$angmsdah,
  angrt: $560639d49e3c9a19$var$angrt,
  angrtvb: $560639d49e3c9a19$var$angrtvb,
  angrtvbd: $560639d49e3c9a19$var$angrtvbd,
  angsph: $560639d49e3c9a19$var$angsph,
  angst: $560639d49e3c9a19$var$angst,
  angzarr: $560639d49e3c9a19$var$angzarr,
  aogon: $560639d49e3c9a19$var$aogon,
  aopf: $560639d49e3c9a19$var$aopf,
  ap: $560639d49e3c9a19$var$ap,
  apE: $560639d49e3c9a19$var$apE,
  apacir: $560639d49e3c9a19$var$apacir,
  ape: $560639d49e3c9a19$var$ape,
  apid: $560639d49e3c9a19$var$apid,
  apos: $560639d49e3c9a19$var$apos,
  approx: $560639d49e3c9a19$var$approx,
  approxeq: $560639d49e3c9a19$var$approxeq,
  arin: $560639d49e3c9a19$var$arin,
  aring: $560639d49e3c9a19$var$aring$1,
  ascr: $560639d49e3c9a19$var$ascr,
  ast: $560639d49e3c9a19$var$ast,
  asymp: $560639d49e3c9a19$var$asymp$1,
  asympeq: $560639d49e3c9a19$var$asympeq,
  atild: $560639d49e3c9a19$var$atild,
  atilde: $560639d49e3c9a19$var$atilde$1,
  aum: $560639d49e3c9a19$var$aum,
  auml: $560639d49e3c9a19$var$auml$1,
  awconint: $560639d49e3c9a19$var$awconint,
  awint: $560639d49e3c9a19$var$awint,
  bNot: $560639d49e3c9a19$var$bNot,
  backcong: $560639d49e3c9a19$var$backcong,
  backepsilon: $560639d49e3c9a19$var$backepsilon,
  backprime: $560639d49e3c9a19$var$backprime,
  backsim: $560639d49e3c9a19$var$backsim,
  backsimeq: $560639d49e3c9a19$var$backsimeq,
  barvee: $560639d49e3c9a19$var$barvee,
  barwed: $560639d49e3c9a19$var$barwed,
  barwedge: $560639d49e3c9a19$var$barwedge,
  bbrk: $560639d49e3c9a19$var$bbrk,
  bbrktbrk: $560639d49e3c9a19$var$bbrktbrk,
  bcong: $560639d49e3c9a19$var$bcong,
  bcy: $560639d49e3c9a19$var$bcy,
  bdquo: $560639d49e3c9a19$var$bdquo$1,
  becaus: $560639d49e3c9a19$var$becaus,
  because: $560639d49e3c9a19$var$because,
  bemptyv: $560639d49e3c9a19$var$bemptyv,
  bepsi: $560639d49e3c9a19$var$bepsi,
  bernou: $560639d49e3c9a19$var$bernou,
  beta: $560639d49e3c9a19$var$beta$1,
  beth: $560639d49e3c9a19$var$beth,
  between: $560639d49e3c9a19$var$between,
  bfr: $560639d49e3c9a19$var$bfr,
  bigcap: $560639d49e3c9a19$var$bigcap,
  bigcirc: $560639d49e3c9a19$var$bigcirc,
  bigcup: $560639d49e3c9a19$var$bigcup,
  bigodot: $560639d49e3c9a19$var$bigodot,
  bigoplus: $560639d49e3c9a19$var$bigoplus,
  bigotimes: $560639d49e3c9a19$var$bigotimes,
  bigsqcup: $560639d49e3c9a19$var$bigsqcup,
  bigstar: $560639d49e3c9a19$var$bigstar,
  bigtriangledown: $560639d49e3c9a19$var$bigtriangledown,
  bigtriangleup: $560639d49e3c9a19$var$bigtriangleup,
  biguplus: $560639d49e3c9a19$var$biguplus,
  bigvee: $560639d49e3c9a19$var$bigvee,
  bigwedge: $560639d49e3c9a19$var$bigwedge,
  bkarow: $560639d49e3c9a19$var$bkarow,
  blacklozenge: $560639d49e3c9a19$var$blacklozenge,
  blacksquare: $560639d49e3c9a19$var$blacksquare,
  blacktriangle: $560639d49e3c9a19$var$blacktriangle,
  blacktriangledown: $560639d49e3c9a19$var$blacktriangledown,
  blacktriangleleft: $560639d49e3c9a19$var$blacktriangleleft,
  blacktriangleright: $560639d49e3c9a19$var$blacktriangleright,
  blank: $560639d49e3c9a19$var$blank,
  blk12: $560639d49e3c9a19$var$blk12,
  blk14: $560639d49e3c9a19$var$blk14,
  blk34: $560639d49e3c9a19$var$blk34,
  block: $560639d49e3c9a19$var$block,
  bne: $560639d49e3c9a19$var$bne,
  bnequiv: $560639d49e3c9a19$var$bnequiv,
  bnot: $560639d49e3c9a19$var$bnot,
  bopf: $560639d49e3c9a19$var$bopf,
  bot: $560639d49e3c9a19$var$bot,
  bottom: $560639d49e3c9a19$var$bottom,
  bowtie: $560639d49e3c9a19$var$bowtie,
  boxDL: $560639d49e3c9a19$var$boxDL,
  boxDR: $560639d49e3c9a19$var$boxDR,
  boxDl: $560639d49e3c9a19$var$boxDl,
  boxDr: $560639d49e3c9a19$var$boxDr,
  boxH: $560639d49e3c9a19$var$boxH,
  boxHD: $560639d49e3c9a19$var$boxHD,
  boxHU: $560639d49e3c9a19$var$boxHU,
  boxHd: $560639d49e3c9a19$var$boxHd,
  boxHu: $560639d49e3c9a19$var$boxHu,
  boxUL: $560639d49e3c9a19$var$boxUL,
  boxUR: $560639d49e3c9a19$var$boxUR,
  boxUl: $560639d49e3c9a19$var$boxUl,
  boxUr: $560639d49e3c9a19$var$boxUr,
  boxV: $560639d49e3c9a19$var$boxV,
  boxVH: $560639d49e3c9a19$var$boxVH,
  boxVL: $560639d49e3c9a19$var$boxVL,
  boxVR: $560639d49e3c9a19$var$boxVR,
  boxVh: $560639d49e3c9a19$var$boxVh,
  boxVl: $560639d49e3c9a19$var$boxVl,
  boxVr: $560639d49e3c9a19$var$boxVr,
  boxbox: $560639d49e3c9a19$var$boxbox,
  boxdL: $560639d49e3c9a19$var$boxdL,
  boxdR: $560639d49e3c9a19$var$boxdR,
  boxdl: $560639d49e3c9a19$var$boxdl,
  boxdr: $560639d49e3c9a19$var$boxdr,
  boxh: $560639d49e3c9a19$var$boxh,
  boxhD: $560639d49e3c9a19$var$boxhD,
  boxhU: $560639d49e3c9a19$var$boxhU,
  boxhd: $560639d49e3c9a19$var$boxhd,
  boxhu: $560639d49e3c9a19$var$boxhu,
  boxminus: $560639d49e3c9a19$var$boxminus,
  boxplus: $560639d49e3c9a19$var$boxplus,
  boxtimes: $560639d49e3c9a19$var$boxtimes,
  boxuL: $560639d49e3c9a19$var$boxuL,
  boxuR: $560639d49e3c9a19$var$boxuR,
  boxul: $560639d49e3c9a19$var$boxul,
  boxur: $560639d49e3c9a19$var$boxur,
  boxv: $560639d49e3c9a19$var$boxv,
  boxvH: $560639d49e3c9a19$var$boxvH,
  boxvL: $560639d49e3c9a19$var$boxvL,
  boxvR: $560639d49e3c9a19$var$boxvR,
  boxvh: $560639d49e3c9a19$var$boxvh,
  boxvl: $560639d49e3c9a19$var$boxvl,
  boxvr: $560639d49e3c9a19$var$boxvr,
  bprime: $560639d49e3c9a19$var$bprime,
  breve: $560639d49e3c9a19$var$breve,
  brvba: $560639d49e3c9a19$var$brvba,
  brvbar: $560639d49e3c9a19$var$brvbar$1,
  bscr: $560639d49e3c9a19$var$bscr,
  bsemi: $560639d49e3c9a19$var$bsemi,
  bsim: $560639d49e3c9a19$var$bsim,
  bsime: $560639d49e3c9a19$var$bsime,
  bsol: $560639d49e3c9a19$var$bsol,
  bsolb: $560639d49e3c9a19$var$bsolb,
  bsolhsub: $560639d49e3c9a19$var$bsolhsub,
  bull: $560639d49e3c9a19$var$bull$1,
  bullet: $560639d49e3c9a19$var$bullet,
  bump: $560639d49e3c9a19$var$bump,
  bumpE: $560639d49e3c9a19$var$bumpE,
  bumpe: $560639d49e3c9a19$var$bumpe,
  bumpeq: $560639d49e3c9a19$var$bumpeq,
  cacute: $560639d49e3c9a19$var$cacute,
  cap: $560639d49e3c9a19$var$cap$2,
  capand: $560639d49e3c9a19$var$capand,
  capbrcup: $560639d49e3c9a19$var$capbrcup,
  capcap: $560639d49e3c9a19$var$capcap,
  capcup: $560639d49e3c9a19$var$capcup,
  capdot: $560639d49e3c9a19$var$capdot,
  caps: $560639d49e3c9a19$var$caps,
  caret: $560639d49e3c9a19$var$caret,
  caron: $560639d49e3c9a19$var$caron,
  ccaps: $560639d49e3c9a19$var$ccaps,
  ccaron: $560639d49e3c9a19$var$ccaron,
  ccedi: $560639d49e3c9a19$var$ccedi,
  ccedil: $560639d49e3c9a19$var$ccedil$1,
  ccirc: $560639d49e3c9a19$var$ccirc,
  ccups: $560639d49e3c9a19$var$ccups,
  ccupssm: $560639d49e3c9a19$var$ccupssm,
  cdot: $560639d49e3c9a19$var$cdot,
  cedi: $560639d49e3c9a19$var$cedi,
  cedil: $560639d49e3c9a19$var$cedil$1,
  cemptyv: $560639d49e3c9a19$var$cemptyv,
  cen: $560639d49e3c9a19$var$cen,
  cent: $560639d49e3c9a19$var$cent$1,
  centerdot: $560639d49e3c9a19$var$centerdot,
  cfr: $560639d49e3c9a19$var$cfr,
  chcy: $560639d49e3c9a19$var$chcy,
  check: $560639d49e3c9a19$var$check,
  checkmark: $560639d49e3c9a19$var$checkmark,
  chi: $560639d49e3c9a19$var$chi$1,
  cir: $560639d49e3c9a19$var$cir,
  cirE: $560639d49e3c9a19$var$cirE,
  circ: $560639d49e3c9a19$var$circ$1,
  circeq: $560639d49e3c9a19$var$circeq,
  circlearrowleft: $560639d49e3c9a19$var$circlearrowleft,
  circlearrowright: $560639d49e3c9a19$var$circlearrowright,
  circledR: $560639d49e3c9a19$var$circledR,
  circledS: $560639d49e3c9a19$var$circledS,
  circledast: $560639d49e3c9a19$var$circledast,
  circledcirc: $560639d49e3c9a19$var$circledcirc,
  circleddash: $560639d49e3c9a19$var$circleddash,
  cire: $560639d49e3c9a19$var$cire,
  cirfnint: $560639d49e3c9a19$var$cirfnint,
  cirmid: $560639d49e3c9a19$var$cirmid,
  cirscir: $560639d49e3c9a19$var$cirscir,
  clubs: $560639d49e3c9a19$var$clubs$1,
  clubsuit: $560639d49e3c9a19$var$clubsuit,
  colon: $560639d49e3c9a19$var$colon$3,
  colone: $560639d49e3c9a19$var$colone,
  coloneq: $560639d49e3c9a19$var$coloneq,
  comma: $560639d49e3c9a19$var$comma$2,
  commat: $560639d49e3c9a19$var$commat,
  comp: $560639d49e3c9a19$var$comp,
  compfn: $560639d49e3c9a19$var$compfn,
  complement: $560639d49e3c9a19$var$complement,
  complexes: $560639d49e3c9a19$var$complexes,
  cong: $560639d49e3c9a19$var$cong$1,
  congdot: $560639d49e3c9a19$var$congdot,
  conint: $560639d49e3c9a19$var$conint,
  copf: $560639d49e3c9a19$var$copf,
  coprod: $560639d49e3c9a19$var$coprod,
  cop: $560639d49e3c9a19$var$cop,
  copy: $560639d49e3c9a19$var$copy$1,
  copysr: $560639d49e3c9a19$var$copysr,
  crarr: $560639d49e3c9a19$var$crarr$1,
  cross: $560639d49e3c9a19$var$cross,
  cscr: $560639d49e3c9a19$var$cscr,
  csub: $560639d49e3c9a19$var$csub,
  csube: $560639d49e3c9a19$var$csube,
  csup: $560639d49e3c9a19$var$csup,
  csupe: $560639d49e3c9a19$var$csupe,
  ctdot: $560639d49e3c9a19$var$ctdot,
  cudarrl: $560639d49e3c9a19$var$cudarrl,
  cudarrr: $560639d49e3c9a19$var$cudarrr,
  cuepr: $560639d49e3c9a19$var$cuepr,
  cuesc: $560639d49e3c9a19$var$cuesc,
  cularr: $560639d49e3c9a19$var$cularr,
  cularrp: $560639d49e3c9a19$var$cularrp,
  cup: $560639d49e3c9a19$var$cup$1,
  cupbrcap: $560639d49e3c9a19$var$cupbrcap,
  cupcap: $560639d49e3c9a19$var$cupcap,
  cupcup: $560639d49e3c9a19$var$cupcup,
  cupdot: $560639d49e3c9a19$var$cupdot,
  cupor: $560639d49e3c9a19$var$cupor,
  cups: $560639d49e3c9a19$var$cups,
  curarr: $560639d49e3c9a19$var$curarr,
  curarrm: $560639d49e3c9a19$var$curarrm,
  curlyeqprec: $560639d49e3c9a19$var$curlyeqprec,
  curlyeqsucc: $560639d49e3c9a19$var$curlyeqsucc,
  curlyvee: $560639d49e3c9a19$var$curlyvee,
  curlywedge: $560639d49e3c9a19$var$curlywedge,
  curre: $560639d49e3c9a19$var$curre,
  curren: $560639d49e3c9a19$var$curren$1,
  curvearrowleft: $560639d49e3c9a19$var$curvearrowleft,
  curvearrowright: $560639d49e3c9a19$var$curvearrowright,
  cuvee: $560639d49e3c9a19$var$cuvee,
  cuwed: $560639d49e3c9a19$var$cuwed,
  cwconint: $560639d49e3c9a19$var$cwconint,
  cwint: $560639d49e3c9a19$var$cwint,
  cylcty: $560639d49e3c9a19$var$cylcty,
  dArr: $560639d49e3c9a19$var$dArr$1,
  dHar: $560639d49e3c9a19$var$dHar,
  dagger: $560639d49e3c9a19$var$dagger$1,
  daleth: $560639d49e3c9a19$var$daleth,
  darr: $560639d49e3c9a19$var$darr$1,
  dash: $560639d49e3c9a19$var$dash$8,
  dashv: $560639d49e3c9a19$var$dashv,
  dbkarow: $560639d49e3c9a19$var$dbkarow,
  dblac: $560639d49e3c9a19$var$dblac,
  dcaron: $560639d49e3c9a19$var$dcaron,
  dcy: $560639d49e3c9a19$var$dcy,
  dd: $560639d49e3c9a19$var$dd$1,
  ddagger: $560639d49e3c9a19$var$ddagger,
  ddarr: $560639d49e3c9a19$var$ddarr,
  ddotseq: $560639d49e3c9a19$var$ddotseq,
  de: $560639d49e3c9a19$var$de,
  deg: $560639d49e3c9a19$var$deg$1,
  delta: $560639d49e3c9a19$var$delta$1,
  demptyv: $560639d49e3c9a19$var$demptyv,
  dfisht: $560639d49e3c9a19$var$dfisht,
  dfr: $560639d49e3c9a19$var$dfr,
  dharl: $560639d49e3c9a19$var$dharl,
  dharr: $560639d49e3c9a19$var$dharr,
  diam: $560639d49e3c9a19$var$diam,
  diamond: $560639d49e3c9a19$var$diamond,
  diamondsuit: $560639d49e3c9a19$var$diamondsuit,
  diams: $560639d49e3c9a19$var$diams$1,
  die: $560639d49e3c9a19$var$die,
  digamma: $560639d49e3c9a19$var$digamma,
  disin: $560639d49e3c9a19$var$disin,
  div: $560639d49e3c9a19$var$div,
  divid: $560639d49e3c9a19$var$divid,
  divide: $560639d49e3c9a19$var$divide$1,
  divideontimes: $560639d49e3c9a19$var$divideontimes,
  divonx: $560639d49e3c9a19$var$divonx,
  djcy: $560639d49e3c9a19$var$djcy,
  dlcorn: $560639d49e3c9a19$var$dlcorn,
  dlcrop: $560639d49e3c9a19$var$dlcrop,
  dollar: $560639d49e3c9a19$var$dollar,
  dopf: $560639d49e3c9a19$var$dopf,
  dot: $560639d49e3c9a19$var$dot$4,
  doteq: $560639d49e3c9a19$var$doteq,
  doteqdot: $560639d49e3c9a19$var$doteqdot,
  dotminus: $560639d49e3c9a19$var$dotminus,
  dotplus: $560639d49e3c9a19$var$dotplus,
  dotsquare: $560639d49e3c9a19$var$dotsquare,
  doublebarwedge: $560639d49e3c9a19$var$doublebarwedge,
  downarrow: $560639d49e3c9a19$var$downarrow,
  downdownarrows: $560639d49e3c9a19$var$downdownarrows,
  downharpoonleft: $560639d49e3c9a19$var$downharpoonleft,
  downharpoonright: $560639d49e3c9a19$var$downharpoonright,
  drbkarow: $560639d49e3c9a19$var$drbkarow,
  drcorn: $560639d49e3c9a19$var$drcorn,
  drcrop: $560639d49e3c9a19$var$drcrop,
  dscr: $560639d49e3c9a19$var$dscr,
  dscy: $560639d49e3c9a19$var$dscy,
  dsol: $560639d49e3c9a19$var$dsol,
  dstrok: $560639d49e3c9a19$var$dstrok,
  dtdot: $560639d49e3c9a19$var$dtdot,
  dtri: $560639d49e3c9a19$var$dtri,
  dtrif: $560639d49e3c9a19$var$dtrif,
  duarr: $560639d49e3c9a19$var$duarr,
  duhar: $560639d49e3c9a19$var$duhar,
  dwangle: $560639d49e3c9a19$var$dwangle,
  dzcy: $560639d49e3c9a19$var$dzcy,
  dzigrarr: $560639d49e3c9a19$var$dzigrarr,
  eDDot: $560639d49e3c9a19$var$eDDot,
  eDot: $560639d49e3c9a19$var$eDot,
  eacut: $560639d49e3c9a19$var$eacut,
  eacute: $560639d49e3c9a19$var$eacute$1,
  easter: $560639d49e3c9a19$var$easter,
  ecaron: $560639d49e3c9a19$var$ecaron,
  ecir: $560639d49e3c9a19$var$ecir,
  ecirc: $560639d49e3c9a19$var$ecirc$1,
  ecolon: $560639d49e3c9a19$var$ecolon,
  ecy: $560639d49e3c9a19$var$ecy,
  edot: $560639d49e3c9a19$var$edot,
  ee: $560639d49e3c9a19$var$ee,
  efDot: $560639d49e3c9a19$var$efDot,
  efr: $560639d49e3c9a19$var$efr,
  eg: $560639d49e3c9a19$var$eg,
  egrav: $560639d49e3c9a19$var$egrav,
  egrave: $560639d49e3c9a19$var$egrave$1,
  egs: $560639d49e3c9a19$var$egs,
  egsdot: $560639d49e3c9a19$var$egsdot,
  el: $560639d49e3c9a19$var$el,
  elinters: $560639d49e3c9a19$var$elinters,
  ell: $560639d49e3c9a19$var$ell,
  els: $560639d49e3c9a19$var$els,
  elsdot: $560639d49e3c9a19$var$elsdot,
  emacr: $560639d49e3c9a19$var$emacr,
  empty: $560639d49e3c9a19$var$empty$3,
  emptyset: $560639d49e3c9a19$var$emptyset,
  emptyv: $560639d49e3c9a19$var$emptyv,
  emsp13: $560639d49e3c9a19$var$emsp13,
  emsp14: $560639d49e3c9a19$var$emsp14,
  emsp: $560639d49e3c9a19$var$emsp$1,
  eng: $560639d49e3c9a19$var$eng,
  ensp: $560639d49e3c9a19$var$ensp$1,
  eogon: $560639d49e3c9a19$var$eogon,
  eopf: $560639d49e3c9a19$var$eopf,
  epar: $560639d49e3c9a19$var$epar,
  eparsl: $560639d49e3c9a19$var$eparsl,
  eplus: $560639d49e3c9a19$var$eplus,
  epsi: $560639d49e3c9a19$var$epsi,
  epsilon: $560639d49e3c9a19$var$epsilon$1,
  epsiv: $560639d49e3c9a19$var$epsiv,
  eqcirc: $560639d49e3c9a19$var$eqcirc,
  eqcolon: $560639d49e3c9a19$var$eqcolon,
  eqsim: $560639d49e3c9a19$var$eqsim,
  eqslantgtr: $560639d49e3c9a19$var$eqslantgtr,
  eqslantless: $560639d49e3c9a19$var$eqslantless,
  equals: $560639d49e3c9a19$var$equals,
  equest: $560639d49e3c9a19$var$equest,
  equiv: $560639d49e3c9a19$var$equiv$1,
  equivDD: $560639d49e3c9a19$var$equivDD,
  eqvparsl: $560639d49e3c9a19$var$eqvparsl,
  erDot: $560639d49e3c9a19$var$erDot,
  erarr: $560639d49e3c9a19$var$erarr,
  escr: $560639d49e3c9a19$var$escr,
  esdot: $560639d49e3c9a19$var$esdot,
  esim: $560639d49e3c9a19$var$esim,
  eta: $560639d49e3c9a19$var$eta$1,
  et: $560639d49e3c9a19$var$et,
  eth: $560639d49e3c9a19$var$eth$1,
  eum: $560639d49e3c9a19$var$eum,
  euml: $560639d49e3c9a19$var$euml$1,
  euro: $560639d49e3c9a19$var$euro$1,
  excl: $560639d49e3c9a19$var$excl,
  exist: $560639d49e3c9a19$var$exist$1,
  expectation: $560639d49e3c9a19$var$expectation,
  exponentiale: $560639d49e3c9a19$var$exponentiale,
  fallingdotseq: $560639d49e3c9a19$var$fallingdotseq,
  fcy: $560639d49e3c9a19$var$fcy,
  female: $560639d49e3c9a19$var$female,
  ffilig: $560639d49e3c9a19$var$ffilig,
  fflig: $560639d49e3c9a19$var$fflig,
  ffllig: $560639d49e3c9a19$var$ffllig,
  ffr: $560639d49e3c9a19$var$ffr,
  filig: $560639d49e3c9a19$var$filig,
  fjlig: $560639d49e3c9a19$var$fjlig,
  flat: $560639d49e3c9a19$var$flat,
  fllig: $560639d49e3c9a19$var$fllig,
  fltns: $560639d49e3c9a19$var$fltns,
  fnof: $560639d49e3c9a19$var$fnof$1,
  fopf: $560639d49e3c9a19$var$fopf,
  forall: $560639d49e3c9a19$var$forall$1,
  fork: $560639d49e3c9a19$var$fork,
  forkv: $560639d49e3c9a19$var$forkv,
  fpartint: $560639d49e3c9a19$var$fpartint,
  frac1: $560639d49e3c9a19$var$frac1,
  frac12: $560639d49e3c9a19$var$frac12$1,
  frac13: $560639d49e3c9a19$var$frac13,
  frac14: $560639d49e3c9a19$var$frac14$1,
  frac15: $560639d49e3c9a19$var$frac15,
  frac16: $560639d49e3c9a19$var$frac16,
  frac18: $560639d49e3c9a19$var$frac18,
  frac23: $560639d49e3c9a19$var$frac23,
  frac25: $560639d49e3c9a19$var$frac25,
  frac3: $560639d49e3c9a19$var$frac3,
  frac34: $560639d49e3c9a19$var$frac34$1,
  frac35: $560639d49e3c9a19$var$frac35,
  frac38: $560639d49e3c9a19$var$frac38,
  frac45: $560639d49e3c9a19$var$frac45,
  frac56: $560639d49e3c9a19$var$frac56,
  frac58: $560639d49e3c9a19$var$frac58,
  frac78: $560639d49e3c9a19$var$frac78,
  frasl: $560639d49e3c9a19$var$frasl$1,
  frown: $560639d49e3c9a19$var$frown,
  fscr: $560639d49e3c9a19$var$fscr,
  gE: $560639d49e3c9a19$var$gE,
  gEl: $560639d49e3c9a19$var$gEl,
  gacute: $560639d49e3c9a19$var$gacute,
  gamma: $560639d49e3c9a19$var$gamma$1,
  gammad: $560639d49e3c9a19$var$gammad,
  gap: $560639d49e3c9a19$var$gap,
  gbreve: $560639d49e3c9a19$var$gbreve,
  gcirc: $560639d49e3c9a19$var$gcirc,
  gcy: $560639d49e3c9a19$var$gcy,
  gdot: $560639d49e3c9a19$var$gdot,
  ge: $560639d49e3c9a19$var$ge$1,
  gel: $560639d49e3c9a19$var$gel,
  geq: $560639d49e3c9a19$var$geq,
  geqq: $560639d49e3c9a19$var$geqq,
  geqslant: $560639d49e3c9a19$var$geqslant,
  ges: $560639d49e3c9a19$var$ges,
  gescc: $560639d49e3c9a19$var$gescc,
  gesdot: $560639d49e3c9a19$var$gesdot,
  gesdoto: $560639d49e3c9a19$var$gesdoto,
  gesdotol: $560639d49e3c9a19$var$gesdotol,
  gesl: $560639d49e3c9a19$var$gesl,
  gesles: $560639d49e3c9a19$var$gesles,
  gfr: $560639d49e3c9a19$var$gfr,
  gg: $560639d49e3c9a19$var$gg,
  ggg: $560639d49e3c9a19$var$ggg,
  gimel: $560639d49e3c9a19$var$gimel,
  gjcy: $560639d49e3c9a19$var$gjcy,
  gl: $560639d49e3c9a19$var$gl,
  glE: $560639d49e3c9a19$var$glE,
  gla: $560639d49e3c9a19$var$gla,
  glj: $560639d49e3c9a19$var$glj,
  gnE: $560639d49e3c9a19$var$gnE,
  gnap: $560639d49e3c9a19$var$gnap,
  gnapprox: $560639d49e3c9a19$var$gnapprox,
  gne: $560639d49e3c9a19$var$gne,
  gneq: $560639d49e3c9a19$var$gneq,
  gneqq: $560639d49e3c9a19$var$gneqq,
  gnsim: $560639d49e3c9a19$var$gnsim,
  gopf: $560639d49e3c9a19$var$gopf,
  grave: $560639d49e3c9a19$var$grave,
  gscr: $560639d49e3c9a19$var$gscr,
  gsim: $560639d49e3c9a19$var$gsim,
  gsime: $560639d49e3c9a19$var$gsime,
  gsiml: $560639d49e3c9a19$var$gsiml,
  g: $560639d49e3c9a19$var$g,
  gt: $560639d49e3c9a19$var$gt$1,
  gtcc: $560639d49e3c9a19$var$gtcc,
  gtcir: $560639d49e3c9a19$var$gtcir,
  gtdot: $560639d49e3c9a19$var$gtdot,
  gtlPar: $560639d49e3c9a19$var$gtlPar,
  gtquest: $560639d49e3c9a19$var$gtquest,
  gtrapprox: $560639d49e3c9a19$var$gtrapprox,
  gtrarr: $560639d49e3c9a19$var$gtrarr,
  gtrdot: $560639d49e3c9a19$var$gtrdot,
  gtreqless: $560639d49e3c9a19$var$gtreqless,
  gtreqqless: $560639d49e3c9a19$var$gtreqqless,
  gtrless: $560639d49e3c9a19$var$gtrless,
  gtrsim: $560639d49e3c9a19$var$gtrsim,
  gvertneqq: $560639d49e3c9a19$var$gvertneqq,
  gvnE: $560639d49e3c9a19$var$gvnE,
  hArr: $560639d49e3c9a19$var$hArr$1,
  hairsp: $560639d49e3c9a19$var$hairsp,
  half: $560639d49e3c9a19$var$half,
  hamilt: $560639d49e3c9a19$var$hamilt,
  hardcy: $560639d49e3c9a19$var$hardcy,
  harr: $560639d49e3c9a19$var$harr$1,
  harrcir: $560639d49e3c9a19$var$harrcir,
  harrw: $560639d49e3c9a19$var$harrw,
  hbar: $560639d49e3c9a19$var$hbar,
  hcirc: $560639d49e3c9a19$var$hcirc,
  hearts: $560639d49e3c9a19$var$hearts$1,
  heartsuit: $560639d49e3c9a19$var$heartsuit,
  hellip: $560639d49e3c9a19$var$hellip$1,
  hercon: $560639d49e3c9a19$var$hercon,
  hfr: $560639d49e3c9a19$var$hfr,
  hksearow: $560639d49e3c9a19$var$hksearow,
  hkswarow: $560639d49e3c9a19$var$hkswarow,
  hoarr: $560639d49e3c9a19$var$hoarr,
  homtht: $560639d49e3c9a19$var$homtht,
  hookleftarrow: $560639d49e3c9a19$var$hookleftarrow,
  hookrightarrow: $560639d49e3c9a19$var$hookrightarrow,
  hopf: $560639d49e3c9a19$var$hopf,
  horbar: $560639d49e3c9a19$var$horbar,
  hscr: $560639d49e3c9a19$var$hscr,
  hslash: $560639d49e3c9a19$var$hslash,
  hstrok: $560639d49e3c9a19$var$hstrok,
  hybull: $560639d49e3c9a19$var$hybull,
  hyphen: $560639d49e3c9a19$var$hyphen,
  iacut: $560639d49e3c9a19$var$iacut,
  iacute: $560639d49e3c9a19$var$iacute$1,
  ic: $560639d49e3c9a19$var$ic,
  icir: $560639d49e3c9a19$var$icir,
  icirc: $560639d49e3c9a19$var$icirc$1,
  icy: $560639d49e3c9a19$var$icy,
  iecy: $560639d49e3c9a19$var$iecy,
  iexc: $560639d49e3c9a19$var$iexc,
  iexcl: $560639d49e3c9a19$var$iexcl$1,
  iff: $560639d49e3c9a19$var$iff,
  ifr: $560639d49e3c9a19$var$ifr,
  igrav: $560639d49e3c9a19$var$igrav,
  igrave: $560639d49e3c9a19$var$igrave$1,
  ii: $560639d49e3c9a19$var$ii,
  iiiint: $560639d49e3c9a19$var$iiiint,
  iiint: $560639d49e3c9a19$var$iiint,
  iinfin: $560639d49e3c9a19$var$iinfin,
  iiota: $560639d49e3c9a19$var$iiota,
  ijlig: $560639d49e3c9a19$var$ijlig,
  imacr: $560639d49e3c9a19$var$imacr,
  image: $560639d49e3c9a19$var$image$3,
  imagline: $560639d49e3c9a19$var$imagline,
  imagpart: $560639d49e3c9a19$var$imagpart,
  imath: $560639d49e3c9a19$var$imath,
  imof: $560639d49e3c9a19$var$imof,
  imped: $560639d49e3c9a19$var$imped,
  incare: $560639d49e3c9a19$var$incare,
  infin: $560639d49e3c9a19$var$infin$1,
  infintie: $560639d49e3c9a19$var$infintie,
  inodot: $560639d49e3c9a19$var$inodot,
  int: $560639d49e3c9a19$var$int$1,
  intcal: $560639d49e3c9a19$var$intcal,
  integers: $560639d49e3c9a19$var$integers,
  intercal: $560639d49e3c9a19$var$intercal,
  intlarhk: $560639d49e3c9a19$var$intlarhk,
  intprod: $560639d49e3c9a19$var$intprod,
  iocy: $560639d49e3c9a19$var$iocy,
  iogon: $560639d49e3c9a19$var$iogon,
  iopf: $560639d49e3c9a19$var$iopf,
  iota: $560639d49e3c9a19$var$iota$1,
  iprod: $560639d49e3c9a19$var$iprod,
  iques: $560639d49e3c9a19$var$iques,
  iquest: $560639d49e3c9a19$var$iquest$1,
  iscr: $560639d49e3c9a19$var$iscr,
  isin: $560639d49e3c9a19$var$isin$1,
  isinE: $560639d49e3c9a19$var$isinE,
  isindot: $560639d49e3c9a19$var$isindot,
  isins: $560639d49e3c9a19$var$isins,
  isinsv: $560639d49e3c9a19$var$isinsv,
  isinv: $560639d49e3c9a19$var$isinv,
  it: $560639d49e3c9a19$var$it,
  itilde: $560639d49e3c9a19$var$itilde,
  iukcy: $560639d49e3c9a19$var$iukcy,
  ium: $560639d49e3c9a19$var$ium,
  iuml: $560639d49e3c9a19$var$iuml$1,
  jcirc: $560639d49e3c9a19$var$jcirc,
  jcy: $560639d49e3c9a19$var$jcy,
  jfr: $560639d49e3c9a19$var$jfr,
  jmath: $560639d49e3c9a19$var$jmath,
  jopf: $560639d49e3c9a19$var$jopf,
  jscr: $560639d49e3c9a19$var$jscr,
  jsercy: $560639d49e3c9a19$var$jsercy,
  jukcy: $560639d49e3c9a19$var$jukcy,
  kappa: $560639d49e3c9a19$var$kappa$1,
  kappav: $560639d49e3c9a19$var$kappav,
  kcedil: $560639d49e3c9a19$var$kcedil,
  kcy: $560639d49e3c9a19$var$kcy,
  kfr: $560639d49e3c9a19$var$kfr,
  kgreen: $560639d49e3c9a19$var$kgreen,
  khcy: $560639d49e3c9a19$var$khcy,
  kjcy: $560639d49e3c9a19$var$kjcy,
  kopf: $560639d49e3c9a19$var$kopf,
  kscr: $560639d49e3c9a19$var$kscr,
  lAarr: $560639d49e3c9a19$var$lAarr,
  lArr: $560639d49e3c9a19$var$lArr$1,
  lAtail: $560639d49e3c9a19$var$lAtail,
  lBarr: $560639d49e3c9a19$var$lBarr,
  lE: $560639d49e3c9a19$var$lE,
  lEg: $560639d49e3c9a19$var$lEg,
  lHar: $560639d49e3c9a19$var$lHar,
  lacute: $560639d49e3c9a19$var$lacute,
  laemptyv: $560639d49e3c9a19$var$laemptyv,
  lagran: $560639d49e3c9a19$var$lagran,
  lambda: $560639d49e3c9a19$var$lambda$1,
  lang: $560639d49e3c9a19$var$lang$1,
  langd: $560639d49e3c9a19$var$langd,
  langle: $560639d49e3c9a19$var$langle,
  lap: $560639d49e3c9a19$var$lap,
  laqu: $560639d49e3c9a19$var$laqu,
  laquo: $560639d49e3c9a19$var$laquo$1,
  larr: $560639d49e3c9a19$var$larr$1,
  larrb: $560639d49e3c9a19$var$larrb,
  larrbfs: $560639d49e3c9a19$var$larrbfs,
  larrfs: $560639d49e3c9a19$var$larrfs,
  larrhk: $560639d49e3c9a19$var$larrhk,
  larrlp: $560639d49e3c9a19$var$larrlp,
  larrpl: $560639d49e3c9a19$var$larrpl,
  larrsim: $560639d49e3c9a19$var$larrsim,
  larrtl: $560639d49e3c9a19$var$larrtl,
  lat: $560639d49e3c9a19$var$lat,
  latail: $560639d49e3c9a19$var$latail,
  late: $560639d49e3c9a19$var$late,
  lates: $560639d49e3c9a19$var$lates,
  lbarr: $560639d49e3c9a19$var$lbarr,
  lbbrk: $560639d49e3c9a19$var$lbbrk,
  lbrace: $560639d49e3c9a19$var$lbrace,
  lbrack: $560639d49e3c9a19$var$lbrack,
  lbrke: $560639d49e3c9a19$var$lbrke,
  lbrksld: $560639d49e3c9a19$var$lbrksld,
  lbrkslu: $560639d49e3c9a19$var$lbrkslu,
  lcaron: $560639d49e3c9a19$var$lcaron,
  lcedil: $560639d49e3c9a19$var$lcedil,
  lceil: $560639d49e3c9a19$var$lceil$1,
  lcub: $560639d49e3c9a19$var$lcub,
  lcy: $560639d49e3c9a19$var$lcy,
  ldca: $560639d49e3c9a19$var$ldca,
  ldquo: $560639d49e3c9a19$var$ldquo$1,
  ldquor: $560639d49e3c9a19$var$ldquor,
  ldrdhar: $560639d49e3c9a19$var$ldrdhar,
  ldrushar: $560639d49e3c9a19$var$ldrushar,
  ldsh: $560639d49e3c9a19$var$ldsh,
  le: $560639d49e3c9a19$var$le$1,
  leftarrow: $560639d49e3c9a19$var$leftarrow,
  leftarrowtail: $560639d49e3c9a19$var$leftarrowtail,
  leftharpoondown: $560639d49e3c9a19$var$leftharpoondown,
  leftharpoonup: $560639d49e3c9a19$var$leftharpoonup,
  leftleftarrows: $560639d49e3c9a19$var$leftleftarrows,
  leftrightarrow: $560639d49e3c9a19$var$leftrightarrow,
  leftrightarrows: $560639d49e3c9a19$var$leftrightarrows,
  leftrightharpoons: $560639d49e3c9a19$var$leftrightharpoons,
  leftrightsquigarrow: $560639d49e3c9a19$var$leftrightsquigarrow,
  leftthreetimes: $560639d49e3c9a19$var$leftthreetimes,
  leg: $560639d49e3c9a19$var$leg,
  leq: $560639d49e3c9a19$var$leq,
  leqq: $560639d49e3c9a19$var$leqq,
  leqslant: $560639d49e3c9a19$var$leqslant,
  les: $560639d49e3c9a19$var$les,
  lescc: $560639d49e3c9a19$var$lescc,
  lesdot: $560639d49e3c9a19$var$lesdot,
  lesdoto: $560639d49e3c9a19$var$lesdoto,
  lesdotor: $560639d49e3c9a19$var$lesdotor,
  lesg: $560639d49e3c9a19$var$lesg,
  lesges: $560639d49e3c9a19$var$lesges,
  lessapprox: $560639d49e3c9a19$var$lessapprox,
  lessdot: $560639d49e3c9a19$var$lessdot,
  lesseqgtr: $560639d49e3c9a19$var$lesseqgtr,
  lesseqqgtr: $560639d49e3c9a19$var$lesseqqgtr,
  lessgtr: $560639d49e3c9a19$var$lessgtr,
  lesssim: $560639d49e3c9a19$var$lesssim,
  lfisht: $560639d49e3c9a19$var$lfisht,
  lfloor: $560639d49e3c9a19$var$lfloor$1,
  lfr: $560639d49e3c9a19$var$lfr,
  lg: $560639d49e3c9a19$var$lg,
  lgE: $560639d49e3c9a19$var$lgE,
  lhard: $560639d49e3c9a19$var$lhard,
  lharu: $560639d49e3c9a19$var$lharu,
  lharul: $560639d49e3c9a19$var$lharul,
  lhblk: $560639d49e3c9a19$var$lhblk,
  ljcy: $560639d49e3c9a19$var$ljcy,
  ll: $560639d49e3c9a19$var$ll,
  llarr: $560639d49e3c9a19$var$llarr,
  llcorner: $560639d49e3c9a19$var$llcorner,
  llhard: $560639d49e3c9a19$var$llhard,
  lltri: $560639d49e3c9a19$var$lltri,
  lmidot: $560639d49e3c9a19$var$lmidot,
  lmoust: $560639d49e3c9a19$var$lmoust,
  lmoustache: $560639d49e3c9a19$var$lmoustache,
  lnE: $560639d49e3c9a19$var$lnE,
  lnap: $560639d49e3c9a19$var$lnap,
  lnapprox: $560639d49e3c9a19$var$lnapprox,
  lne: $560639d49e3c9a19$var$lne,
  lneq: $560639d49e3c9a19$var$lneq,
  lneqq: $560639d49e3c9a19$var$lneqq,
  lnsim: $560639d49e3c9a19$var$lnsim,
  loang: $560639d49e3c9a19$var$loang,
  loarr: $560639d49e3c9a19$var$loarr,
  lobrk: $560639d49e3c9a19$var$lobrk,
  longleftarrow: $560639d49e3c9a19$var$longleftarrow,
  longleftrightarrow: $560639d49e3c9a19$var$longleftrightarrow,
  longmapsto: $560639d49e3c9a19$var$longmapsto,
  longrightarrow: $560639d49e3c9a19$var$longrightarrow,
  looparrowleft: $560639d49e3c9a19$var$looparrowleft,
  looparrowright: $560639d49e3c9a19$var$looparrowright,
  lopar: $560639d49e3c9a19$var$lopar,
  lopf: $560639d49e3c9a19$var$lopf,
  loplus: $560639d49e3c9a19$var$loplus,
  lotimes: $560639d49e3c9a19$var$lotimes,
  lowast: $560639d49e3c9a19$var$lowast$1,
  lowbar: $560639d49e3c9a19$var$lowbar,
  loz: $560639d49e3c9a19$var$loz$1,
  lozenge: $560639d49e3c9a19$var$lozenge,
  lozf: $560639d49e3c9a19$var$lozf,
  lpar: $560639d49e3c9a19$var$lpar,
  lparlt: $560639d49e3c9a19$var$lparlt,
  lrarr: $560639d49e3c9a19$var$lrarr,
  lrcorner: $560639d49e3c9a19$var$lrcorner,
  lrhar: $560639d49e3c9a19$var$lrhar,
  lrhard: $560639d49e3c9a19$var$lrhard,
  lrm: $560639d49e3c9a19$var$lrm$1,
  lrtri: $560639d49e3c9a19$var$lrtri,
  lsaquo: $560639d49e3c9a19$var$lsaquo$1,
  lscr: $560639d49e3c9a19$var$lscr,
  lsh: $560639d49e3c9a19$var$lsh,
  lsim: $560639d49e3c9a19$var$lsim,
  lsime: $560639d49e3c9a19$var$lsime,
  lsimg: $560639d49e3c9a19$var$lsimg,
  lsqb: $560639d49e3c9a19$var$lsqb,
  lsquo: $560639d49e3c9a19$var$lsquo$1,
  lsquor: $560639d49e3c9a19$var$lsquor,
  lstrok: $560639d49e3c9a19$var$lstrok,
  l: $560639d49e3c9a19$var$l,
  lt: $560639d49e3c9a19$var$lt$1,
  ltcc: $560639d49e3c9a19$var$ltcc,
  ltcir: $560639d49e3c9a19$var$ltcir,
  ltdot: $560639d49e3c9a19$var$ltdot,
  lthree: $560639d49e3c9a19$var$lthree,
  ltimes: $560639d49e3c9a19$var$ltimes,
  ltlarr: $560639d49e3c9a19$var$ltlarr,
  ltquest: $560639d49e3c9a19$var$ltquest,
  ltrPar: $560639d49e3c9a19$var$ltrPar,
  ltri: $560639d49e3c9a19$var$ltri,
  ltrie: $560639d49e3c9a19$var$ltrie,
  ltrif: $560639d49e3c9a19$var$ltrif,
  lurdshar: $560639d49e3c9a19$var$lurdshar,
  luruhar: $560639d49e3c9a19$var$luruhar,
  lvertneqq: $560639d49e3c9a19$var$lvertneqq,
  lvnE: $560639d49e3c9a19$var$lvnE,
  mDDot: $560639d49e3c9a19$var$mDDot,
  mac: $560639d49e3c9a19$var$mac,
  macr: $560639d49e3c9a19$var$macr$1,
  male: $560639d49e3c9a19$var$male,
  malt: $560639d49e3c9a19$var$malt,
  maltese: $560639d49e3c9a19$var$maltese,
  map: $560639d49e3c9a19$var$map$1,
  mapsto: $560639d49e3c9a19$var$mapsto,
  mapstodown: $560639d49e3c9a19$var$mapstodown,
  mapstoleft: $560639d49e3c9a19$var$mapstoleft,
  mapstoup: $560639d49e3c9a19$var$mapstoup,
  marker: $560639d49e3c9a19$var$marker,
  mcomma: $560639d49e3c9a19$var$mcomma,
  mcy: $560639d49e3c9a19$var$mcy,
  mdash: $560639d49e3c9a19$var$mdash$1,
  measuredangle: $560639d49e3c9a19$var$measuredangle,
  mfr: $560639d49e3c9a19$var$mfr,
  mho: $560639d49e3c9a19$var$mho,
  micr: $560639d49e3c9a19$var$micr,
  micro: $560639d49e3c9a19$var$micro$1,
  mid: $560639d49e3c9a19$var$mid,
  midast: $560639d49e3c9a19$var$midast,
  midcir: $560639d49e3c9a19$var$midcir,
  middo: $560639d49e3c9a19$var$middo,
  middot: $560639d49e3c9a19$var$middot$1,
  minus: $560639d49e3c9a19$var$minus$1,
  minusb: $560639d49e3c9a19$var$minusb,
  minusd: $560639d49e3c9a19$var$minusd,
  minusdu: $560639d49e3c9a19$var$minusdu,
  mlcp: $560639d49e3c9a19$var$mlcp,
  mldr: $560639d49e3c9a19$var$mldr,
  mnplus: $560639d49e3c9a19$var$mnplus,
  models: $560639d49e3c9a19$var$models,
  mopf: $560639d49e3c9a19$var$mopf,
  mp: $560639d49e3c9a19$var$mp,
  mscr: $560639d49e3c9a19$var$mscr,
  mstpos: $560639d49e3c9a19$var$mstpos,
  mu: $560639d49e3c9a19$var$mu$1,
  multimap: $560639d49e3c9a19$var$multimap,
  mumap: $560639d49e3c9a19$var$mumap,
  nGg: $560639d49e3c9a19$var$nGg,
  nGt: $560639d49e3c9a19$var$nGt,
  nGtv: $560639d49e3c9a19$var$nGtv,
  nLeftarrow: $560639d49e3c9a19$var$nLeftarrow,
  nLeftrightarrow: $560639d49e3c9a19$var$nLeftrightarrow,
  nLl: $560639d49e3c9a19$var$nLl,
  nLt: $560639d49e3c9a19$var$nLt,
  nLtv: $560639d49e3c9a19$var$nLtv,
  nRightarrow: $560639d49e3c9a19$var$nRightarrow,
  nVDash: $560639d49e3c9a19$var$nVDash,
  nVdash: $560639d49e3c9a19$var$nVdash,
  nabla: $560639d49e3c9a19$var$nabla$1,
  nacute: $560639d49e3c9a19$var$nacute,
  nang: $560639d49e3c9a19$var$nang,
  nap: $560639d49e3c9a19$var$nap,
  napE: $560639d49e3c9a19$var$napE,
  napid: $560639d49e3c9a19$var$napid,
  napos: $560639d49e3c9a19$var$napos,
  napprox: $560639d49e3c9a19$var$napprox,
  natur: $560639d49e3c9a19$var$natur,
  natural: $560639d49e3c9a19$var$natural,
  naturals: $560639d49e3c9a19$var$naturals,
  nbs: $560639d49e3c9a19$var$nbs,
  nbsp: $560639d49e3c9a19$var$nbsp$1,
  nbump: $560639d49e3c9a19$var$nbump,
  nbumpe: $560639d49e3c9a19$var$nbumpe,
  ncap: $560639d49e3c9a19$var$ncap,
  ncaron: $560639d49e3c9a19$var$ncaron,
  ncedil: $560639d49e3c9a19$var$ncedil,
  ncong: $560639d49e3c9a19$var$ncong,
  ncongdot: $560639d49e3c9a19$var$ncongdot,
  ncup: $560639d49e3c9a19$var$ncup,
  ncy: $560639d49e3c9a19$var$ncy,
  ndash: $560639d49e3c9a19$var$ndash$1,
  ne: $560639d49e3c9a19$var$ne$1,
  neArr: $560639d49e3c9a19$var$neArr,
  nearhk: $560639d49e3c9a19$var$nearhk,
  nearr: $560639d49e3c9a19$var$nearr,
  nearrow: $560639d49e3c9a19$var$nearrow,
  nedot: $560639d49e3c9a19$var$nedot,
  nequiv: $560639d49e3c9a19$var$nequiv,
  nesear: $560639d49e3c9a19$var$nesear,
  nesim: $560639d49e3c9a19$var$nesim,
  nexist: $560639d49e3c9a19$var$nexist,
  nexists: $560639d49e3c9a19$var$nexists,
  nfr: $560639d49e3c9a19$var$nfr,
  ngE: $560639d49e3c9a19$var$ngE,
  nge: $560639d49e3c9a19$var$nge,
  ngeq: $560639d49e3c9a19$var$ngeq,
  ngeqq: $560639d49e3c9a19$var$ngeqq,
  ngeqslant: $560639d49e3c9a19$var$ngeqslant,
  nges: $560639d49e3c9a19$var$nges,
  ngsim: $560639d49e3c9a19$var$ngsim,
  ngt: $560639d49e3c9a19$var$ngt,
  ngtr: $560639d49e3c9a19$var$ngtr,
  nhArr: $560639d49e3c9a19$var$nhArr,
  nharr: $560639d49e3c9a19$var$nharr,
  nhpar: $560639d49e3c9a19$var$nhpar,
  ni: $560639d49e3c9a19$var$ni$1,
  nis: $560639d49e3c9a19$var$nis,
  nisd: $560639d49e3c9a19$var$nisd,
  niv: $560639d49e3c9a19$var$niv,
  njcy: $560639d49e3c9a19$var$njcy,
  nlArr: $560639d49e3c9a19$var$nlArr,
  nlE: $560639d49e3c9a19$var$nlE,
  nlarr: $560639d49e3c9a19$var$nlarr,
  nldr: $560639d49e3c9a19$var$nldr,
  nle: $560639d49e3c9a19$var$nle,
  nleftarrow: $560639d49e3c9a19$var$nleftarrow,
  nleftrightarrow: $560639d49e3c9a19$var$nleftrightarrow,
  nleq: $560639d49e3c9a19$var$nleq,
  nleqq: $560639d49e3c9a19$var$nleqq,
  nleqslant: $560639d49e3c9a19$var$nleqslant,
  nles: $560639d49e3c9a19$var$nles,
  nless: $560639d49e3c9a19$var$nless,
  nlsim: $560639d49e3c9a19$var$nlsim,
  nlt: $560639d49e3c9a19$var$nlt,
  nltri: $560639d49e3c9a19$var$nltri,
  nltrie: $560639d49e3c9a19$var$nltrie,
  nmid: $560639d49e3c9a19$var$nmid,
  nopf: $560639d49e3c9a19$var$nopf,
  no: $560639d49e3c9a19$var$no,
  not: $560639d49e3c9a19$var$not$1,
  notin: $560639d49e3c9a19$var$notin$1,
  notinE: $560639d49e3c9a19$var$notinE,
  notindot: $560639d49e3c9a19$var$notindot,
  notinva: $560639d49e3c9a19$var$notinva,
  notinvb: $560639d49e3c9a19$var$notinvb,
  notinvc: $560639d49e3c9a19$var$notinvc,
  notni: $560639d49e3c9a19$var$notni,
  notniva: $560639d49e3c9a19$var$notniva,
  notnivb: $560639d49e3c9a19$var$notnivb,
  notnivc: $560639d49e3c9a19$var$notnivc,
  npar: $560639d49e3c9a19$var$npar,
  nparallel: $560639d49e3c9a19$var$nparallel,
  nparsl: $560639d49e3c9a19$var$nparsl,
  npart: $560639d49e3c9a19$var$npart,
  npolint: $560639d49e3c9a19$var$npolint,
  npr: $560639d49e3c9a19$var$npr,
  nprcue: $560639d49e3c9a19$var$nprcue,
  npre: $560639d49e3c9a19$var$npre,
  nprec: $560639d49e3c9a19$var$nprec,
  npreceq: $560639d49e3c9a19$var$npreceq,
  nrArr: $560639d49e3c9a19$var$nrArr,
  nrarr: $560639d49e3c9a19$var$nrarr,
  nrarrc: $560639d49e3c9a19$var$nrarrc,
  nrarrw: $560639d49e3c9a19$var$nrarrw,
  nrightarrow: $560639d49e3c9a19$var$nrightarrow,
  nrtri: $560639d49e3c9a19$var$nrtri,
  nrtrie: $560639d49e3c9a19$var$nrtrie,
  nsc: $560639d49e3c9a19$var$nsc,
  nsccue: $560639d49e3c9a19$var$nsccue,
  nsce: $560639d49e3c9a19$var$nsce,
  nscr: $560639d49e3c9a19$var$nscr,
  nshortmid: $560639d49e3c9a19$var$nshortmid,
  nshortparallel: $560639d49e3c9a19$var$nshortparallel,
  nsim: $560639d49e3c9a19$var$nsim,
  nsime: $560639d49e3c9a19$var$nsime,
  nsimeq: $560639d49e3c9a19$var$nsimeq,
  nsmid: $560639d49e3c9a19$var$nsmid,
  nspar: $560639d49e3c9a19$var$nspar,
  nsqsube: $560639d49e3c9a19$var$nsqsube,
  nsqsupe: $560639d49e3c9a19$var$nsqsupe,
  nsub: $560639d49e3c9a19$var$nsub$1,
  nsubE: $560639d49e3c9a19$var$nsubE,
  nsube: $560639d49e3c9a19$var$nsube,
  nsubset: $560639d49e3c9a19$var$nsubset,
  nsubseteq: $560639d49e3c9a19$var$nsubseteq,
  nsubseteqq: $560639d49e3c9a19$var$nsubseteqq,
  nsucc: $560639d49e3c9a19$var$nsucc,
  nsucceq: $560639d49e3c9a19$var$nsucceq,
  nsup: $560639d49e3c9a19$var$nsup,
  nsupE: $560639d49e3c9a19$var$nsupE,
  nsupe: $560639d49e3c9a19$var$nsupe,
  nsupset: $560639d49e3c9a19$var$nsupset,
  nsupseteq: $560639d49e3c9a19$var$nsupseteq,
  nsupseteqq: $560639d49e3c9a19$var$nsupseteqq,
  ntgl: $560639d49e3c9a19$var$ntgl,
  ntild: $560639d49e3c9a19$var$ntild,
  ntilde: $560639d49e3c9a19$var$ntilde$1,
  ntlg: $560639d49e3c9a19$var$ntlg,
  ntriangleleft: $560639d49e3c9a19$var$ntriangleleft,
  ntrianglelefteq: $560639d49e3c9a19$var$ntrianglelefteq,
  ntriangleright: $560639d49e3c9a19$var$ntriangleright,
  ntrianglerighteq: $560639d49e3c9a19$var$ntrianglerighteq,
  nu: $560639d49e3c9a19$var$nu$1,
  num: $560639d49e3c9a19$var$num,
  numero: $560639d49e3c9a19$var$numero,
  numsp: $560639d49e3c9a19$var$numsp,
  nvDash: $560639d49e3c9a19$var$nvDash,
  nvHarr: $560639d49e3c9a19$var$nvHarr,
  nvap: $560639d49e3c9a19$var$nvap,
  nvdash: $560639d49e3c9a19$var$nvdash,
  nvge: $560639d49e3c9a19$var$nvge,
  nvgt: $560639d49e3c9a19$var$nvgt,
  nvinfin: $560639d49e3c9a19$var$nvinfin,
  nvlArr: $560639d49e3c9a19$var$nvlArr,
  nvle: $560639d49e3c9a19$var$nvle,
  nvlt: $560639d49e3c9a19$var$nvlt,
  nvltrie: $560639d49e3c9a19$var$nvltrie,
  nvrArr: $560639d49e3c9a19$var$nvrArr,
  nvrtrie: $560639d49e3c9a19$var$nvrtrie,
  nvsim: $560639d49e3c9a19$var$nvsim,
  nwArr: $560639d49e3c9a19$var$nwArr,
  nwarhk: $560639d49e3c9a19$var$nwarhk,
  nwarr: $560639d49e3c9a19$var$nwarr,
  nwarrow: $560639d49e3c9a19$var$nwarrow,
  nwnear: $560639d49e3c9a19$var$nwnear,
  oS: $560639d49e3c9a19$var$oS,
  oacut: $560639d49e3c9a19$var$oacut,
  oacute: $560639d49e3c9a19$var$oacute$1,
  oast: $560639d49e3c9a19$var$oast,
  ocir: $560639d49e3c9a19$var$ocir,
  ocirc: $560639d49e3c9a19$var$ocirc$1,
  ocy: $560639d49e3c9a19$var$ocy,
  odash: $560639d49e3c9a19$var$odash,
  odblac: $560639d49e3c9a19$var$odblac,
  odiv: $560639d49e3c9a19$var$odiv,
  odot: $560639d49e3c9a19$var$odot,
  odsold: $560639d49e3c9a19$var$odsold,
  oelig: $560639d49e3c9a19$var$oelig$1,
  ofcir: $560639d49e3c9a19$var$ofcir,
  ofr: $560639d49e3c9a19$var$ofr,
  ogon: $560639d49e3c9a19$var$ogon,
  ograv: $560639d49e3c9a19$var$ograv,
  ograve: $560639d49e3c9a19$var$ograve$1,
  ogt: $560639d49e3c9a19$var$ogt,
  ohbar: $560639d49e3c9a19$var$ohbar,
  ohm: $560639d49e3c9a19$var$ohm,
  oint: $560639d49e3c9a19$var$oint,
  olarr: $560639d49e3c9a19$var$olarr,
  olcir: $560639d49e3c9a19$var$olcir,
  olcross: $560639d49e3c9a19$var$olcross,
  oline: $560639d49e3c9a19$var$oline$1,
  olt: $560639d49e3c9a19$var$olt,
  omacr: $560639d49e3c9a19$var$omacr,
  omega: $560639d49e3c9a19$var$omega$1,
  omicron: $560639d49e3c9a19$var$omicron$1,
  omid: $560639d49e3c9a19$var$omid,
  ominus: $560639d49e3c9a19$var$ominus,
  oopf: $560639d49e3c9a19$var$oopf,
  opar: $560639d49e3c9a19$var$opar,
  operp: $560639d49e3c9a19$var$operp,
  oplus: $560639d49e3c9a19$var$oplus$1,
  or: $560639d49e3c9a19$var$or$1,
  orarr: $560639d49e3c9a19$var$orarr,
  ord: $560639d49e3c9a19$var$ord,
  order: $560639d49e3c9a19$var$order,
  orderof: $560639d49e3c9a19$var$orderof,
  ordf: $560639d49e3c9a19$var$ordf$1,
  ordm: $560639d49e3c9a19$var$ordm$1,
  origof: $560639d49e3c9a19$var$origof,
  oror: $560639d49e3c9a19$var$oror,
  orslope: $560639d49e3c9a19$var$orslope,
  orv: $560639d49e3c9a19$var$orv,
  oscr: $560639d49e3c9a19$var$oscr,
  oslas: $560639d49e3c9a19$var$oslas,
  oslash: $560639d49e3c9a19$var$oslash$1,
  osol: $560639d49e3c9a19$var$osol,
  otild: $560639d49e3c9a19$var$otild,
  otilde: $560639d49e3c9a19$var$otilde$1,
  otimes: $560639d49e3c9a19$var$otimes$1,
  otimesas: $560639d49e3c9a19$var$otimesas,
  oum: $560639d49e3c9a19$var$oum,
  ouml: $560639d49e3c9a19$var$ouml$1,
  ovbar: $560639d49e3c9a19$var$ovbar,
  par: $560639d49e3c9a19$var$par,
  para: $560639d49e3c9a19$var$para$1,
  parallel: $560639d49e3c9a19$var$parallel,
  parsim: $560639d49e3c9a19$var$parsim,
  parsl: $560639d49e3c9a19$var$parsl,
  part: $560639d49e3c9a19$var$part$1,
  pcy: $560639d49e3c9a19$var$pcy,
  percnt: $560639d49e3c9a19$var$percnt,
  period: $560639d49e3c9a19$var$period,
  permil: $560639d49e3c9a19$var$permil$1,
  perp: $560639d49e3c9a19$var$perp$1,
  pertenk: $560639d49e3c9a19$var$pertenk,
  pfr: $560639d49e3c9a19$var$pfr,
  phi: $560639d49e3c9a19$var$phi$1,
  phiv: $560639d49e3c9a19$var$phiv,
  phmmat: $560639d49e3c9a19$var$phmmat,
  phone: $560639d49e3c9a19$var$phone,
  pi: $560639d49e3c9a19$var$pi$1,
  pitchfork: $560639d49e3c9a19$var$pitchfork,
  piv: $560639d49e3c9a19$var$piv$1,
  planck: $560639d49e3c9a19$var$planck,
  planckh: $560639d49e3c9a19$var$planckh,
  plankv: $560639d49e3c9a19$var$plankv,
  plus: $560639d49e3c9a19$var$plus,
  plusacir: $560639d49e3c9a19$var$plusacir,
  plusb: $560639d49e3c9a19$var$plusb,
  pluscir: $560639d49e3c9a19$var$pluscir,
  plusdo: $560639d49e3c9a19$var$plusdo,
  plusdu: $560639d49e3c9a19$var$plusdu,
  pluse: $560639d49e3c9a19$var$pluse,
  plusm: $560639d49e3c9a19$var$plusm,
  plusmn: $560639d49e3c9a19$var$plusmn$1,
  plussim: $560639d49e3c9a19$var$plussim,
  plustwo: $560639d49e3c9a19$var$plustwo,
  pm: $560639d49e3c9a19$var$pm,
  pointint: $560639d49e3c9a19$var$pointint,
  popf: $560639d49e3c9a19$var$popf,
  poun: $560639d49e3c9a19$var$poun,
  pound: $560639d49e3c9a19$var$pound$1,
  pr: $560639d49e3c9a19$var$pr,
  prE: $560639d49e3c9a19$var$prE,
  prap: $560639d49e3c9a19$var$prap,
  prcue: $560639d49e3c9a19$var$prcue,
  pre: $560639d49e3c9a19$var$pre,
  prec: $560639d49e3c9a19$var$prec,
  precapprox: $560639d49e3c9a19$var$precapprox,
  preccurlyeq: $560639d49e3c9a19$var$preccurlyeq,
  preceq: $560639d49e3c9a19$var$preceq,
  precnapprox: $560639d49e3c9a19$var$precnapprox,
  precneqq: $560639d49e3c9a19$var$precneqq,
  precnsim: $560639d49e3c9a19$var$precnsim,
  precsim: $560639d49e3c9a19$var$precsim,
  prime: $560639d49e3c9a19$var$prime$1,
  primes: $560639d49e3c9a19$var$primes,
  prnE: $560639d49e3c9a19$var$prnE,
  prnap: $560639d49e3c9a19$var$prnap,
  prnsim: $560639d49e3c9a19$var$prnsim,
  prod: $560639d49e3c9a19$var$prod$1,
  profalar: $560639d49e3c9a19$var$profalar,
  profline: $560639d49e3c9a19$var$profline,
  profsurf: $560639d49e3c9a19$var$profsurf,
  prop: $560639d49e3c9a19$var$prop$1,
  propto: $560639d49e3c9a19$var$propto,
  prsim: $560639d49e3c9a19$var$prsim,
  prurel: $560639d49e3c9a19$var$prurel,
  pscr: $560639d49e3c9a19$var$pscr,
  psi: $560639d49e3c9a19$var$psi$1,
  puncsp: $560639d49e3c9a19$var$puncsp,
  qfr: $560639d49e3c9a19$var$qfr,
  qint: $560639d49e3c9a19$var$qint,
  qopf: $560639d49e3c9a19$var$qopf,
  qprime: $560639d49e3c9a19$var$qprime,
  qscr: $560639d49e3c9a19$var$qscr,
  quaternions: $560639d49e3c9a19$var$quaternions,
  quatint: $560639d49e3c9a19$var$quatint,
  quest: $560639d49e3c9a19$var$quest,
  questeq: $560639d49e3c9a19$var$questeq,
  quo: $560639d49e3c9a19$var$quo,
  quot: $560639d49e3c9a19$var$quot$1,
  rAarr: $560639d49e3c9a19$var$rAarr,
  rArr: $560639d49e3c9a19$var$rArr$1,
  rAtail: $560639d49e3c9a19$var$rAtail,
  rBarr: $560639d49e3c9a19$var$rBarr,
  rHar: $560639d49e3c9a19$var$rHar,
  race: $560639d49e3c9a19$var$race,
  racute: $560639d49e3c9a19$var$racute,
  radic: $560639d49e3c9a19$var$radic$1,
  raemptyv: $560639d49e3c9a19$var$raemptyv,
  rang: $560639d49e3c9a19$var$rang$1,
  rangd: $560639d49e3c9a19$var$rangd,
  range: $560639d49e3c9a19$var$range,
  rangle: $560639d49e3c9a19$var$rangle,
  raqu: $560639d49e3c9a19$var$raqu,
  raquo: $560639d49e3c9a19$var$raquo$1,
  rarr: $560639d49e3c9a19$var$rarr$1,
  rarrap: $560639d49e3c9a19$var$rarrap,
  rarrb: $560639d49e3c9a19$var$rarrb,
  rarrbfs: $560639d49e3c9a19$var$rarrbfs,
  rarrc: $560639d49e3c9a19$var$rarrc,
  rarrfs: $560639d49e3c9a19$var$rarrfs,
  rarrhk: $560639d49e3c9a19$var$rarrhk,
  rarrlp: $560639d49e3c9a19$var$rarrlp,
  rarrpl: $560639d49e3c9a19$var$rarrpl,
  rarrsim: $560639d49e3c9a19$var$rarrsim,
  rarrtl: $560639d49e3c9a19$var$rarrtl,
  rarrw: $560639d49e3c9a19$var$rarrw,
  ratail: $560639d49e3c9a19$var$ratail,
  ratio: $560639d49e3c9a19$var$ratio,
  rationals: $560639d49e3c9a19$var$rationals,
  rbarr: $560639d49e3c9a19$var$rbarr,
  rbbrk: $560639d49e3c9a19$var$rbbrk,
  rbrace: $560639d49e3c9a19$var$rbrace,
  rbrack: $560639d49e3c9a19$var$rbrack,
  rbrke: $560639d49e3c9a19$var$rbrke,
  rbrksld: $560639d49e3c9a19$var$rbrksld,
  rbrkslu: $560639d49e3c9a19$var$rbrkslu,
  rcaron: $560639d49e3c9a19$var$rcaron,
  rcedil: $560639d49e3c9a19$var$rcedil,
  rceil: $560639d49e3c9a19$var$rceil$1,
  rcub: $560639d49e3c9a19$var$rcub,
  rcy: $560639d49e3c9a19$var$rcy,
  rdca: $560639d49e3c9a19$var$rdca,
  rdldhar: $560639d49e3c9a19$var$rdldhar,
  rdquo: $560639d49e3c9a19$var$rdquo$1,
  rdquor: $560639d49e3c9a19$var$rdquor,
  rdsh: $560639d49e3c9a19$var$rdsh,
  real: $560639d49e3c9a19$var$real$1,
  realine: $560639d49e3c9a19$var$realine,
  realpart: $560639d49e3c9a19$var$realpart,
  reals: $560639d49e3c9a19$var$reals,
  rect: $560639d49e3c9a19$var$rect,
  re: $560639d49e3c9a19$var$re$3,
  reg: $560639d49e3c9a19$var$reg$1,
  rfisht: $560639d49e3c9a19$var$rfisht,
  rfloor: $560639d49e3c9a19$var$rfloor$1,
  rfr: $560639d49e3c9a19$var$rfr,
  rhard: $560639d49e3c9a19$var$rhard,
  rharu: $560639d49e3c9a19$var$rharu,
  rharul: $560639d49e3c9a19$var$rharul,
  rho: $560639d49e3c9a19$var$rho$1,
  rhov: $560639d49e3c9a19$var$rhov,
  rightarrow: $560639d49e3c9a19$var$rightarrow,
  rightarrowtail: $560639d49e3c9a19$var$rightarrowtail,
  rightharpoondown: $560639d49e3c9a19$var$rightharpoondown,
  rightharpoonup: $560639d49e3c9a19$var$rightharpoonup,
  rightleftarrows: $560639d49e3c9a19$var$rightleftarrows,
  rightleftharpoons: $560639d49e3c9a19$var$rightleftharpoons,
  rightrightarrows: $560639d49e3c9a19$var$rightrightarrows,
  rightsquigarrow: $560639d49e3c9a19$var$rightsquigarrow,
  rightthreetimes: $560639d49e3c9a19$var$rightthreetimes,
  ring: $560639d49e3c9a19$var$ring,
  risingdotseq: $560639d49e3c9a19$var$risingdotseq,
  rlarr: $560639d49e3c9a19$var$rlarr,
  rlhar: $560639d49e3c9a19$var$rlhar,
  rlm: $560639d49e3c9a19$var$rlm$1,
  rmoust: $560639d49e3c9a19$var$rmoust,
  rmoustache: $560639d49e3c9a19$var$rmoustache,
  rnmid: $560639d49e3c9a19$var$rnmid,
  roang: $560639d49e3c9a19$var$roang,
  roarr: $560639d49e3c9a19$var$roarr,
  robrk: $560639d49e3c9a19$var$robrk,
  ropar: $560639d49e3c9a19$var$ropar,
  ropf: $560639d49e3c9a19$var$ropf,
  roplus: $560639d49e3c9a19$var$roplus,
  rotimes: $560639d49e3c9a19$var$rotimes,
  rpar: $560639d49e3c9a19$var$rpar,
  rpargt: $560639d49e3c9a19$var$rpargt,
  rppolint: $560639d49e3c9a19$var$rppolint,
  rrarr: $560639d49e3c9a19$var$rrarr,
  rsaquo: $560639d49e3c9a19$var$rsaquo$1,
  rscr: $560639d49e3c9a19$var$rscr,
  rsh: $560639d49e3c9a19$var$rsh,
  rsqb: $560639d49e3c9a19$var$rsqb,
  rsquo: $560639d49e3c9a19$var$rsquo$1,
  rsquor: $560639d49e3c9a19$var$rsquor,
  rthree: $560639d49e3c9a19$var$rthree,
  rtimes: $560639d49e3c9a19$var$rtimes,
  rtri: $560639d49e3c9a19$var$rtri,
  rtrie: $560639d49e3c9a19$var$rtrie,
  rtrif: $560639d49e3c9a19$var$rtrif,
  rtriltri: $560639d49e3c9a19$var$rtriltri,
  ruluhar: $560639d49e3c9a19$var$ruluhar,
  rx: $560639d49e3c9a19$var$rx,
  sacute: $560639d49e3c9a19$var$sacute,
  sbquo: $560639d49e3c9a19$var$sbquo$1,
  sc: $560639d49e3c9a19$var$sc,
  scE: $560639d49e3c9a19$var$scE,
  scap: $560639d49e3c9a19$var$scap,
  scaron: $560639d49e3c9a19$var$scaron$1,
  sccue: $560639d49e3c9a19$var$sccue,
  sce: $560639d49e3c9a19$var$sce,
  scedil: $560639d49e3c9a19$var$scedil,
  scirc: $560639d49e3c9a19$var$scirc,
  scnE: $560639d49e3c9a19$var$scnE,
  scnap: $560639d49e3c9a19$var$scnap,
  scnsim: $560639d49e3c9a19$var$scnsim,
  scpolint: $560639d49e3c9a19$var$scpolint,
  scsim: $560639d49e3c9a19$var$scsim,
  scy: $560639d49e3c9a19$var$scy,
  sdot: $560639d49e3c9a19$var$sdot$1,
  sdotb: $560639d49e3c9a19$var$sdotb,
  sdote: $560639d49e3c9a19$var$sdote,
  seArr: $560639d49e3c9a19$var$seArr,
  searhk: $560639d49e3c9a19$var$searhk,
  searr: $560639d49e3c9a19$var$searr,
  searrow: $560639d49e3c9a19$var$searrow,
  sec: $560639d49e3c9a19$var$sec,
  sect: $560639d49e3c9a19$var$sect$1,
  semi: $560639d49e3c9a19$var$semi,
  seswar: $560639d49e3c9a19$var$seswar,
  setminus: $560639d49e3c9a19$var$setminus,
  setmn: $560639d49e3c9a19$var$setmn,
  sext: $560639d49e3c9a19$var$sext,
  sfr: $560639d49e3c9a19$var$sfr,
  sfrown: $560639d49e3c9a19$var$sfrown,
  sharp: $560639d49e3c9a19$var$sharp,
  shchcy: $560639d49e3c9a19$var$shchcy,
  shcy: $560639d49e3c9a19$var$shcy,
  shortmid: $560639d49e3c9a19$var$shortmid,
  shortparallel: $560639d49e3c9a19$var$shortparallel,
  sh: $560639d49e3c9a19$var$sh,
  shy: $560639d49e3c9a19$var$shy$1,
  sigma: $560639d49e3c9a19$var$sigma$1,
  sigmaf: $560639d49e3c9a19$var$sigmaf$1,
  sigmav: $560639d49e3c9a19$var$sigmav,
  sim: $560639d49e3c9a19$var$sim$1,
  simdot: $560639d49e3c9a19$var$simdot,
  sime: $560639d49e3c9a19$var$sime,
  simeq: $560639d49e3c9a19$var$simeq,
  simg: $560639d49e3c9a19$var$simg,
  simgE: $560639d49e3c9a19$var$simgE,
  siml: $560639d49e3c9a19$var$siml,
  simlE: $560639d49e3c9a19$var$simlE,
  simne: $560639d49e3c9a19$var$simne,
  simplus: $560639d49e3c9a19$var$simplus,
  simrarr: $560639d49e3c9a19$var$simrarr,
  slarr: $560639d49e3c9a19$var$slarr,
  smallsetminus: $560639d49e3c9a19$var$smallsetminus,
  smashp: $560639d49e3c9a19$var$smashp,
  smeparsl: $560639d49e3c9a19$var$smeparsl,
  smid: $560639d49e3c9a19$var$smid,
  smile: $560639d49e3c9a19$var$smile,
  smt: $560639d49e3c9a19$var$smt,
  smte: $560639d49e3c9a19$var$smte,
  smtes: $560639d49e3c9a19$var$smtes,
  softcy: $560639d49e3c9a19$var$softcy,
  sol: $560639d49e3c9a19$var$sol,
  solb: $560639d49e3c9a19$var$solb,
  solbar: $560639d49e3c9a19$var$solbar,
  sopf: $560639d49e3c9a19$var$sopf,
  spades: $560639d49e3c9a19$var$spades$1,
  spadesuit: $560639d49e3c9a19$var$spadesuit,
  spar: $560639d49e3c9a19$var$spar,
  sqcap: $560639d49e3c9a19$var$sqcap,
  sqcaps: $560639d49e3c9a19$var$sqcaps,
  sqcup: $560639d49e3c9a19$var$sqcup,
  sqcups: $560639d49e3c9a19$var$sqcups,
  sqsub: $560639d49e3c9a19$var$sqsub,
  sqsube: $560639d49e3c9a19$var$sqsube,
  sqsubset: $560639d49e3c9a19$var$sqsubset,
  sqsubseteq: $560639d49e3c9a19$var$sqsubseteq,
  sqsup: $560639d49e3c9a19$var$sqsup,
  sqsupe: $560639d49e3c9a19$var$sqsupe,
  sqsupset: $560639d49e3c9a19$var$sqsupset,
  sqsupseteq: $560639d49e3c9a19$var$sqsupseteq,
  squ: $560639d49e3c9a19$var$squ,
  square: $560639d49e3c9a19$var$square,
  squarf: $560639d49e3c9a19$var$squarf,
  squf: $560639d49e3c9a19$var$squf,
  srarr: $560639d49e3c9a19$var$srarr,
  sscr: $560639d49e3c9a19$var$sscr,
  ssetmn: $560639d49e3c9a19$var$ssetmn,
  ssmile: $560639d49e3c9a19$var$ssmile,
  sstarf: $560639d49e3c9a19$var$sstarf,
  star: $560639d49e3c9a19$var$star,
  starf: $560639d49e3c9a19$var$starf,
  straightepsilon: $560639d49e3c9a19$var$straightepsilon,
  straightphi: $560639d49e3c9a19$var$straightphi,
  strns: $560639d49e3c9a19$var$strns,
  sub: $560639d49e3c9a19$var$sub$1,
  subE: $560639d49e3c9a19$var$subE,
  subdot: $560639d49e3c9a19$var$subdot,
  sube: $560639d49e3c9a19$var$sube$1,
  subedot: $560639d49e3c9a19$var$subedot,
  submult: $560639d49e3c9a19$var$submult,
  subnE: $560639d49e3c9a19$var$subnE,
  subne: $560639d49e3c9a19$var$subne,
  subplus: $560639d49e3c9a19$var$subplus,
  subrarr: $560639d49e3c9a19$var$subrarr,
  subset: $560639d49e3c9a19$var$subset,
  subseteq: $560639d49e3c9a19$var$subseteq,
  subseteqq: $560639d49e3c9a19$var$subseteqq,
  subsetneq: $560639d49e3c9a19$var$subsetneq,
  subsetneqq: $560639d49e3c9a19$var$subsetneqq,
  subsim: $560639d49e3c9a19$var$subsim,
  subsub: $560639d49e3c9a19$var$subsub,
  subsup: $560639d49e3c9a19$var$subsup,
  succ: $560639d49e3c9a19$var$succ,
  succapprox: $560639d49e3c9a19$var$succapprox,
  succcurlyeq: $560639d49e3c9a19$var$succcurlyeq,
  succeq: $560639d49e3c9a19$var$succeq,
  succnapprox: $560639d49e3c9a19$var$succnapprox,
  succneqq: $560639d49e3c9a19$var$succneqq,
  succnsim: $560639d49e3c9a19$var$succnsim,
  succsim: $560639d49e3c9a19$var$succsim,
  sum: $560639d49e3c9a19$var$sum$1,
  sung: $560639d49e3c9a19$var$sung,
  sup: $560639d49e3c9a19$var$sup$1,
  sup1: $560639d49e3c9a19$var$sup1$1,
  sup2: $560639d49e3c9a19$var$sup2$1,
  sup3: $560639d49e3c9a19$var$sup3$1,
  supE: $560639d49e3c9a19$var$supE,
  supdot: $560639d49e3c9a19$var$supdot,
  supdsub: $560639d49e3c9a19$var$supdsub,
  supe: $560639d49e3c9a19$var$supe$1,
  supedot: $560639d49e3c9a19$var$supedot,
  suphsol: $560639d49e3c9a19$var$suphsol,
  suphsub: $560639d49e3c9a19$var$suphsub,
  suplarr: $560639d49e3c9a19$var$suplarr,
  supmult: $560639d49e3c9a19$var$supmult,
  supnE: $560639d49e3c9a19$var$supnE,
  supne: $560639d49e3c9a19$var$supne,
  supplus: $560639d49e3c9a19$var$supplus,
  supset: $560639d49e3c9a19$var$supset,
  supseteq: $560639d49e3c9a19$var$supseteq,
  supseteqq: $560639d49e3c9a19$var$supseteqq,
  supsetneq: $560639d49e3c9a19$var$supsetneq,
  supsetneqq: $560639d49e3c9a19$var$supsetneqq,
  supsim: $560639d49e3c9a19$var$supsim,
  supsub: $560639d49e3c9a19$var$supsub,
  supsup: $560639d49e3c9a19$var$supsup,
  swArr: $560639d49e3c9a19$var$swArr,
  swarhk: $560639d49e3c9a19$var$swarhk,
  swarr: $560639d49e3c9a19$var$swarr,
  swarrow: $560639d49e3c9a19$var$swarrow,
  swnwar: $560639d49e3c9a19$var$swnwar,
  szli: $560639d49e3c9a19$var$szli,
  szlig: $560639d49e3c9a19$var$szlig$1,
  target: $560639d49e3c9a19$var$target,
  tau: $560639d49e3c9a19$var$tau$1,
  tbrk: $560639d49e3c9a19$var$tbrk,
  tcaron: $560639d49e3c9a19$var$tcaron,
  tcedil: $560639d49e3c9a19$var$tcedil,
  tcy: $560639d49e3c9a19$var$tcy,
  tdot: $560639d49e3c9a19$var$tdot,
  telrec: $560639d49e3c9a19$var$telrec,
  tfr: $560639d49e3c9a19$var$tfr,
  there4: $560639d49e3c9a19$var$there4$1,
  therefore: $560639d49e3c9a19$var$therefore,
  theta: $560639d49e3c9a19$var$theta$1,
  thetasym: $560639d49e3c9a19$var$thetasym$1,
  thetav: $560639d49e3c9a19$var$thetav,
  thickapprox: $560639d49e3c9a19$var$thickapprox,
  thicksim: $560639d49e3c9a19$var$thicksim,
  thinsp: $560639d49e3c9a19$var$thinsp$1,
  thkap: $560639d49e3c9a19$var$thkap,
  thksim: $560639d49e3c9a19$var$thksim,
  thor: $560639d49e3c9a19$var$thor,
  thorn: $560639d49e3c9a19$var$thorn$1,
  tilde: $560639d49e3c9a19$var$tilde$4,
  time: $560639d49e3c9a19$var$time,
  times: $560639d49e3c9a19$var$times$1,
  timesb: $560639d49e3c9a19$var$timesb,
  timesbar: $560639d49e3c9a19$var$timesbar,
  timesd: $560639d49e3c9a19$var$timesd,
  tint: $560639d49e3c9a19$var$tint,
  toea: $560639d49e3c9a19$var$toea,
  top: $560639d49e3c9a19$var$top,
  topbot: $560639d49e3c9a19$var$topbot,
  topcir: $560639d49e3c9a19$var$topcir,
  topf: $560639d49e3c9a19$var$topf,
  topfork: $560639d49e3c9a19$var$topfork,
  tosa: $560639d49e3c9a19$var$tosa,
  tprime: $560639d49e3c9a19$var$tprime,
  trade: $560639d49e3c9a19$var$trade$1,
  triangle: $560639d49e3c9a19$var$triangle,
  triangledown: $560639d49e3c9a19$var$triangledown,
  triangleleft: $560639d49e3c9a19$var$triangleleft,
  trianglelefteq: $560639d49e3c9a19$var$trianglelefteq,
  triangleq: $560639d49e3c9a19$var$triangleq,
  triangleright: $560639d49e3c9a19$var$triangleright,
  trianglerighteq: $560639d49e3c9a19$var$trianglerighteq,
  tridot: $560639d49e3c9a19$var$tridot,
  trie: $560639d49e3c9a19$var$trie,
  triminus: $560639d49e3c9a19$var$triminus,
  triplus: $560639d49e3c9a19$var$triplus,
  trisb: $560639d49e3c9a19$var$trisb,
  tritime: $560639d49e3c9a19$var$tritime,
  trpezium: $560639d49e3c9a19$var$trpezium,
  tscr: $560639d49e3c9a19$var$tscr,
  tscy: $560639d49e3c9a19$var$tscy,
  tshcy: $560639d49e3c9a19$var$tshcy,
  tstrok: $560639d49e3c9a19$var$tstrok,
  twixt: $560639d49e3c9a19$var$twixt,
  twoheadleftarrow: $560639d49e3c9a19$var$twoheadleftarrow,
  twoheadrightarrow: $560639d49e3c9a19$var$twoheadrightarrow,
  uArr: $560639d49e3c9a19$var$uArr$1,
  uHar: $560639d49e3c9a19$var$uHar,
  uacut: $560639d49e3c9a19$var$uacut,
  uacute: $560639d49e3c9a19$var$uacute$1,
  uarr: $560639d49e3c9a19$var$uarr$1,
  ubrcy: $560639d49e3c9a19$var$ubrcy,
  ubreve: $560639d49e3c9a19$var$ubreve,
  ucir: $560639d49e3c9a19$var$ucir,
  ucirc: $560639d49e3c9a19$var$ucirc$1,
  ucy: $560639d49e3c9a19$var$ucy,
  udarr: $560639d49e3c9a19$var$udarr,
  udblac: $560639d49e3c9a19$var$udblac,
  udhar: $560639d49e3c9a19$var$udhar,
  ufisht: $560639d49e3c9a19$var$ufisht,
  ufr: $560639d49e3c9a19$var$ufr,
  ugrav: $560639d49e3c9a19$var$ugrav,
  ugrave: $560639d49e3c9a19$var$ugrave$1,
  uharl: $560639d49e3c9a19$var$uharl,
  uharr: $560639d49e3c9a19$var$uharr,
  uhblk: $560639d49e3c9a19$var$uhblk,
  ulcorn: $560639d49e3c9a19$var$ulcorn,
  ulcorner: $560639d49e3c9a19$var$ulcorner,
  ulcrop: $560639d49e3c9a19$var$ulcrop,
  ultri: $560639d49e3c9a19$var$ultri,
  umacr: $560639d49e3c9a19$var$umacr,
  um: $560639d49e3c9a19$var$um,
  uml: $560639d49e3c9a19$var$uml$1,
  uogon: $560639d49e3c9a19$var$uogon,
  uopf: $560639d49e3c9a19$var$uopf,
  uparrow: $560639d49e3c9a19$var$uparrow,
  updownarrow: $560639d49e3c9a19$var$updownarrow,
  upharpoonleft: $560639d49e3c9a19$var$upharpoonleft,
  upharpoonright: $560639d49e3c9a19$var$upharpoonright,
  uplus: $560639d49e3c9a19$var$uplus,
  upsi: $560639d49e3c9a19$var$upsi,
  upsih: $560639d49e3c9a19$var$upsih$1,
  upsilon: $560639d49e3c9a19$var$upsilon$1,
  upuparrows: $560639d49e3c9a19$var$upuparrows,
  urcorn: $560639d49e3c9a19$var$urcorn,
  urcorner: $560639d49e3c9a19$var$urcorner,
  urcrop: $560639d49e3c9a19$var$urcrop,
  uring: $560639d49e3c9a19$var$uring,
  urtri: $560639d49e3c9a19$var$urtri,
  uscr: $560639d49e3c9a19$var$uscr,
  utdot: $560639d49e3c9a19$var$utdot,
  utilde: $560639d49e3c9a19$var$utilde,
  utri: $560639d49e3c9a19$var$utri,
  utrif: $560639d49e3c9a19$var$utrif,
  uuarr: $560639d49e3c9a19$var$uuarr,
  uum: $560639d49e3c9a19$var$uum,
  uuml: $560639d49e3c9a19$var$uuml$1,
  uwangle: $560639d49e3c9a19$var$uwangle,
  vArr: $560639d49e3c9a19$var$vArr,
  vBar: $560639d49e3c9a19$var$vBar,
  vBarv: $560639d49e3c9a19$var$vBarv,
  vDash: $560639d49e3c9a19$var$vDash,
  vangrt: $560639d49e3c9a19$var$vangrt,
  varepsilon: $560639d49e3c9a19$var$varepsilon,
  varkappa: $560639d49e3c9a19$var$varkappa,
  varnothing: $560639d49e3c9a19$var$varnothing,
  varphi: $560639d49e3c9a19$var$varphi,
  varpi: $560639d49e3c9a19$var$varpi,
  varpropto: $560639d49e3c9a19$var$varpropto,
  varr: $560639d49e3c9a19$var$varr,
  varrho: $560639d49e3c9a19$var$varrho,
  varsigma: $560639d49e3c9a19$var$varsigma,
  varsubsetneq: $560639d49e3c9a19$var$varsubsetneq,
  varsubsetneqq: $560639d49e3c9a19$var$varsubsetneqq,
  varsupsetneq: $560639d49e3c9a19$var$varsupsetneq,
  varsupsetneqq: $560639d49e3c9a19$var$varsupsetneqq,
  vartheta: $560639d49e3c9a19$var$vartheta,
  vartriangleleft: $560639d49e3c9a19$var$vartriangleleft,
  vartriangleright: $560639d49e3c9a19$var$vartriangleright,
  vcy: $560639d49e3c9a19$var$vcy,
  vdash: $560639d49e3c9a19$var$vdash,
  vee: $560639d49e3c9a19$var$vee,
  veebar: $560639d49e3c9a19$var$veebar,
  veeeq: $560639d49e3c9a19$var$veeeq,
  vellip: $560639d49e3c9a19$var$vellip,
  verbar: $560639d49e3c9a19$var$verbar,
  vert: $560639d49e3c9a19$var$vert,
  vfr: $560639d49e3c9a19$var$vfr,
  vltri: $560639d49e3c9a19$var$vltri,
  vnsub: $560639d49e3c9a19$var$vnsub,
  vnsup: $560639d49e3c9a19$var$vnsup,
  vopf: $560639d49e3c9a19$var$vopf,
  vprop: $560639d49e3c9a19$var$vprop,
  vrtri: $560639d49e3c9a19$var$vrtri,
  vscr: $560639d49e3c9a19$var$vscr,
  vsubnE: $560639d49e3c9a19$var$vsubnE,
  vsubne: $560639d49e3c9a19$var$vsubne,
  vsupnE: $560639d49e3c9a19$var$vsupnE,
  vsupne: $560639d49e3c9a19$var$vsupne,
  vzigzag: $560639d49e3c9a19$var$vzigzag,
  wcirc: $560639d49e3c9a19$var$wcirc,
  wedbar: $560639d49e3c9a19$var$wedbar,
  wedge: $560639d49e3c9a19$var$wedge,
  wedgeq: $560639d49e3c9a19$var$wedgeq,
  weierp: $560639d49e3c9a19$var$weierp$1,
  wfr: $560639d49e3c9a19$var$wfr,
  wopf: $560639d49e3c9a19$var$wopf,
  wp: $560639d49e3c9a19$var$wp,
  wr: $560639d49e3c9a19$var$wr,
  wreath: $560639d49e3c9a19$var$wreath,
  wscr: $560639d49e3c9a19$var$wscr,
  xcap: $560639d49e3c9a19$var$xcap,
  xcirc: $560639d49e3c9a19$var$xcirc,
  xcup: $560639d49e3c9a19$var$xcup,
  xdtri: $560639d49e3c9a19$var$xdtri,
  xfr: $560639d49e3c9a19$var$xfr,
  xhArr: $560639d49e3c9a19$var$xhArr,
  xharr: $560639d49e3c9a19$var$xharr,
  xi: $560639d49e3c9a19$var$xi$1,
  xlArr: $560639d49e3c9a19$var$xlArr,
  xlarr: $560639d49e3c9a19$var$xlarr,
  xmap: $560639d49e3c9a19$var$xmap,
  xnis: $560639d49e3c9a19$var$xnis,
  xodot: $560639d49e3c9a19$var$xodot,
  xopf: $560639d49e3c9a19$var$xopf,
  xoplus: $560639d49e3c9a19$var$xoplus,
  xotime: $560639d49e3c9a19$var$xotime,
  xrArr: $560639d49e3c9a19$var$xrArr,
  xrarr: $560639d49e3c9a19$var$xrarr,
  xscr: $560639d49e3c9a19$var$xscr,
  xsqcup: $560639d49e3c9a19$var$xsqcup,
  xuplus: $560639d49e3c9a19$var$xuplus,
  xutri: $560639d49e3c9a19$var$xutri,
  xvee: $560639d49e3c9a19$var$xvee,
  xwedge: $560639d49e3c9a19$var$xwedge,
  yacut: $560639d49e3c9a19$var$yacut,
  yacute: $560639d49e3c9a19$var$yacute$1,
  yacy: $560639d49e3c9a19$var$yacy,
  ycirc: $560639d49e3c9a19$var$ycirc,
  ycy: $560639d49e3c9a19$var$ycy,
  ye: $560639d49e3c9a19$var$ye,
  yen: $560639d49e3c9a19$var$yen$1,
  yfr: $560639d49e3c9a19$var$yfr,
  yicy: $560639d49e3c9a19$var$yicy,
  yopf: $560639d49e3c9a19$var$yopf,
  yscr: $560639d49e3c9a19$var$yscr,
  yucy: $560639d49e3c9a19$var$yucy,
  yum: $560639d49e3c9a19$var$yum,
  yuml: $560639d49e3c9a19$var$yuml$1,
  zacute: $560639d49e3c9a19$var$zacute,
  zcaron: $560639d49e3c9a19$var$zcaron,
  zcy: $560639d49e3c9a19$var$zcy,
  zdot: $560639d49e3c9a19$var$zdot,
  zeetrf: $560639d49e3c9a19$var$zeetrf,
  zeta: $560639d49e3c9a19$var$zeta$1,
  zfr: $560639d49e3c9a19$var$zfr,
  zhcy: $560639d49e3c9a19$var$zhcy,
  zigrarr: $560639d49e3c9a19$var$zigrarr,
  zopf: $560639d49e3c9a19$var$zopf,
  zscr: $560639d49e3c9a19$var$zscr,
  zwj: $560639d49e3c9a19$var$zwj$1,
  zwnj: $560639d49e3c9a19$var$zwnj$1,
  "default": $560639d49e3c9a19$var$index$3
});
var $560639d49e3c9a19$var$characterEntities = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntities$1);
var $560639d49e3c9a19$var$decodeEntity_1 = $560639d49e3c9a19$var$decodeEntity;
var $560639d49e3c9a19$var$own$c = {}.hasOwnProperty;
function $560639d49e3c9a19$var$decodeEntity(characters) {
  return $560639d49e3c9a19$var$own$c.call($560639d49e3c9a19$var$characterEntities, characters) ? $560639d49e3c9a19$var$characterEntities[characters] : false;
}
var $560639d49e3c9a19$var$legacy = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntitiesLegacy);
var $560639d49e3c9a19$var$invalid = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterReferenceInvalid);
var $560639d49e3c9a19$var$parseEntities_1 = $560639d49e3c9a19$var$parseEntities;
var $560639d49e3c9a19$var$own$b = {}.hasOwnProperty;
var $560639d49e3c9a19$var$fromCharCode = String.fromCharCode;
var $560639d49e3c9a19$var$noop = Function.prototype;
var $560639d49e3c9a19$var$defaults$3 = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};
var $560639d49e3c9a19$var$tab$e = 9;
var $560639d49e3c9a19$var$lineFeed$j = 10;
var $560639d49e3c9a19$var$formFeed = 12;
var $560639d49e3c9a19$var$space$j = 32;
var $560639d49e3c9a19$var$ampersand$1 = 38;
var $560639d49e3c9a19$var$semicolon$1 = 59;
var $560639d49e3c9a19$var$lessThan$8 = 60;
var $560639d49e3c9a19$var$equalsTo$2 = 61;
var $560639d49e3c9a19$var$numberSign$1 = 35;
var $560639d49e3c9a19$var$uppercaseX = 88;
var $560639d49e3c9a19$var$lowercaseX$1 = 120;
var $560639d49e3c9a19$var$replacementCharacter = 65533;
var $560639d49e3c9a19$var$name$1 = "named";
var $560639d49e3c9a19$var$hexa = "hexadecimal";
var $560639d49e3c9a19$var$deci = "decimal";
var $560639d49e3c9a19$var$bases = {};
$560639d49e3c9a19$var$bases[$560639d49e3c9a19$var$hexa] = 16;
$560639d49e3c9a19$var$bases[$560639d49e3c9a19$var$deci] = 10;
var $560639d49e3c9a19$var$tests = {};
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$name$1] = $560639d49e3c9a19$var$isAlphanumerical;
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$deci] = $560639d49e3c9a19$var$isDecimal;
$560639d49e3c9a19$var$tests[$560639d49e3c9a19$var$hexa] = $560639d49e3c9a19$var$isHexadecimal;
var $560639d49e3c9a19$var$namedNotTerminated = 1;
var $560639d49e3c9a19$var$numericNotTerminated = 2;
var $560639d49e3c9a19$var$namedEmpty = 3;
var $560639d49e3c9a19$var$numericEmpty = 4;
var $560639d49e3c9a19$var$namedUnknown = 5;
var $560639d49e3c9a19$var$numericDisallowed = 6;
var $560639d49e3c9a19$var$numericProhibited = 7;
var $560639d49e3c9a19$var$messages = {};
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedNotTerminated] = "Named character references must be terminated by a semicolon";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedEmpty] = "Named character references cannot be empty";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericEmpty] = "Numeric character references cannot be empty";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$namedUnknown] = "Named character references must be known";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericDisallowed] = "Numeric character references cannot be disallowed";
$560639d49e3c9a19$var$messages[$560639d49e3c9a19$var$numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function $560639d49e3c9a19$var$parseEntities(value, options) {
  var settings = {};
  var option;
  var key;
  if (!options)
    options = {};
  for (key in $560639d49e3c9a19$var$defaults$3) {
    option = options[key];
    settings[key] = option === null || option === void 0 ? $560639d49e3c9a19$var$defaults$3[key] : option;
  }
  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }
  return $560639d49e3c9a19$var$parse$7(value, settings);
}
function $560639d49e3c9a19$var$parse$7(value, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value.length;
  var index = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = "";
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type;
  var test;
  var prev;
  var next;
  var diff;
  var end;
  if (typeof additional === "string")
    additional = additional.charCodeAt(0);
  prev = now();
  warning = handleWarning ? parseError : $560639d49e3c9a19$var$noop;
  index--;
  length++;
  while (++index < length) {
    if (character === $560639d49e3c9a19$var$lineFeed$j)
      column = indent[lines] || 1;
    character = value.charCodeAt(index);
    if (character === $560639d49e3c9a19$var$ampersand$1) {
      following = value.charCodeAt(index + 1);
      if (following === $560639d49e3c9a19$var$tab$e || following === $560639d49e3c9a19$var$lineFeed$j || following === $560639d49e3c9a19$var$formFeed || following === $560639d49e3c9a19$var$space$j || following === $560639d49e3c9a19$var$ampersand$1 || following === $560639d49e3c9a19$var$lessThan$8 || following !== following || additional && following === additional) {
        queue += $560639d49e3c9a19$var$fromCharCode(character);
        column++;
        continue;
      }
      start = index + 1;
      begin = start;
      end = start;
      if (following === $560639d49e3c9a19$var$numberSign$1) {
        end = ++begin;
        following = value.charCodeAt(end);
        if (following === $560639d49e3c9a19$var$uppercaseX || following === $560639d49e3c9a19$var$lowercaseX$1) {
          type = $560639d49e3c9a19$var$hexa;
          end = ++begin;
        } else
          type = $560639d49e3c9a19$var$deci;
      } else
        type = $560639d49e3c9a19$var$name$1;
      entityCharacters = "";
      entity = "";
      characters = "";
      test = $560639d49e3c9a19$var$tests[type];
      end--;
      while (++end < length) {
        following = value.charCodeAt(end);
        if (!test(following))
          break;
        characters += $560639d49e3c9a19$var$fromCharCode(following);
        if (type === $560639d49e3c9a19$var$name$1 && $560639d49e3c9a19$var$own$b.call($560639d49e3c9a19$var$legacy, characters)) {
          entityCharacters = characters;
          entity = $560639d49e3c9a19$var$legacy[characters];
        }
      }
      terminated = value.charCodeAt(end) === $560639d49e3c9a19$var$semicolon$1;
      if (terminated) {
        end++;
        namedEntity = type === $560639d49e3c9a19$var$name$1 ? $560639d49e3c9a19$var$decodeEntity_1(characters) : false;
        if (namedEntity) {
          entityCharacters = characters;
          entity = namedEntity;
        }
      }
      diff = 1 + end - start;
      if (!terminated && !nonTerminated)
        ;
      else if (!characters) {
        if (type !== $560639d49e3c9a19$var$name$1)
          warning($560639d49e3c9a19$var$numericEmpty, diff);
      } else if (type === $560639d49e3c9a19$var$name$1) {
        if (terminated && !entity)
          warning($560639d49e3c9a19$var$namedUnknown, 1);
        else {
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            reason = entityCharacters ? $560639d49e3c9a19$var$namedNotTerminated : $560639d49e3c9a19$var$namedEmpty;
            if (settings.attribute) {
              following = value.charCodeAt(end);
              if (following === $560639d49e3c9a19$var$equalsTo$2) {
                warning(reason, diff);
                entity = null;
              } else if ($560639d49e3c9a19$var$isAlphanumerical(following))
                entity = null;
              else
                warning(reason, diff);
            } else
              warning(reason, diff);
          }
        }
        reference = entity;
      } else {
        if (!terminated)
          warning($560639d49e3c9a19$var$numericNotTerminated, diff);
        reference = parseInt(characters, $560639d49e3c9a19$var$bases[type]);
        if ($560639d49e3c9a19$var$prohibited(reference)) {
          warning($560639d49e3c9a19$var$numericProhibited, diff);
          reference = $560639d49e3c9a19$var$fromCharCode($560639d49e3c9a19$var$replacementCharacter);
        } else if (reference in $560639d49e3c9a19$var$invalid) {
          warning($560639d49e3c9a19$var$numericDisallowed, diff);
          reference = $560639d49e3c9a19$var$invalid[reference];
        } else {
          output = "";
          if ($560639d49e3c9a19$var$disallowed(reference))
            warning($560639d49e3c9a19$var$numericDisallowed, diff);
          if (reference > 65535) {
            reference -= 65536;
            output += $560639d49e3c9a19$var$fromCharCode(reference >>> 10 | 55296);
            reference = 56320 | reference & 1023;
          }
          reference = output + $560639d49e3c9a19$var$fromCharCode(reference);
        }
      }
      if (reference) {
        flush();
        prev = now();
        index = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now();
        next.offset++;
        if (handleReference)
          handleReference.call(referenceContext, reference, {
            start: prev,
            end: next
          }, value.slice(start - 1, end));
        prev = next;
      } else {
        characters = value.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (character === character) {
        queue += $560639d49e3c9a19$var$fromCharCode(character);
        column++;
      } else
        flush();
    }
  }
  return result.join("");
  function now() {
    return {
      line,
      column,
      offset: index + (pos.offset || 0)
    };
  }
  function parseError(code, offset) {
    var position = now();
    position.column += offset;
    position.offset += offset;
    handleWarning.call(warningContext, $560639d49e3c9a19$var$messages[code], position, code);
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (handleText)
        handleText.call(textContext, queue, {
          start: prev,
          end: now()
        });
      queue = "";
    }
  }
}
function $560639d49e3c9a19$var$prohibited(code) {
  return code >= 55296 && code <= 57343 || code > 1114111;
}
function $560639d49e3c9a19$var$disallowed(code) {
  return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
}
var $560639d49e3c9a19$var$decode = $560639d49e3c9a19$var$factory$3;
function $560639d49e3c9a19$var$factory$3(ctx) {
  decoder.raw = decodeRaw;
  return decoder;
  function normalize(position) {
    var offsets = ctx.offset;
    var line = position.line;
    var result = [];
    while (++line) {
      if (!(line in offsets))
        break;
      result.push((offsets[line] || 0) + 1);
    }
    return {
      start: position,
      indent: result
    };
  }
  function decoder(value, position, handler) {
    $560639d49e3c9a19$var$parseEntities_1(value, {
      position: normalize(position),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }
  function decodeRaw(value, position, options) {
    return $560639d49e3c9a19$var$parseEntities_1(value, $560639d49e3c9a19$var$immutable(options, {
      position: normalize(position),
      warning: handleWarning
    }));
  }
  function handleWarning(reason, position, code) {
    if (code !== 3)
      ctx.file.message(reason, position);
  }
}
var $560639d49e3c9a19$var$tokenizer$1 = $560639d49e3c9a19$var$factory$2;
function $560639d49e3c9a19$var$factory$2(type) {
  return tokenize;
  function tokenize(value, location) {
    var self2 = this;
    var offset = self2.offset;
    var tokens = [];
    var methods = self2[type + "Methods"];
    var tokenizers = self2[type + "Tokenizers"];
    var line = location.line;
    var column = location.column;
    var index;
    var length;
    var method;
    var name;
    var matched;
    var valueLength;
    if (!value)
      return tokens;
    eat.now = now;
    eat.file = self2.file;
    updatePosition("");
    while (value) {
      index = -1;
      length = methods.length;
      matched = false;
      while (++index < length) {
        name = methods[index];
        method = tokenizers[name];
        if (method && /* istanbul ignore next */
        (!method.onlyAtStart || self2.atStart) && /* istanbul ignore next */
        (!method.notInList || !self2.inList) && /* istanbul ignore next */
        (!method.notInBlock || !self2.inBlock) && (!method.notInLink || !self2.inLink)) {
          valueLength = value.length;
          method.apply(self2, [
            eat,
            value
          ]);
          matched = valueLength !== value.length;
          if (matched)
            break;
        }
      }
      if (!matched)
        self2.file.fail(new Error("Infinite loop"), eat.now());
    }
    self2.eof = now();
    return tokens;
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index2 = subvalue.indexOf("\n");
      while (index2 !== -1) {
        line++;
        lastIndex = index2;
        index2 = subvalue.indexOf("\n", index2 + 1);
      }
      if (lastIndex === -1)
        column += subvalue.length;
      else
        column = subvalue.length - lastIndex;
      if (line in offset) {
        if (lastIndex !== -1)
          column += offset[line];
        else if (column <= offset[line])
          column = offset[line] + 1;
      }
    }
    function getOffset() {
      var indentation = [];
      var pos = line + 1;
      return function() {
        var last = line + 1;
        while (pos < last) {
          indentation.push((offset[pos] || 0) + 1);
          pos++;
        }
        return indentation;
      };
    }
    function now() {
      var pos = {
        line,
        column
      };
      pos.offset = self2.toOffset(pos);
      return pos;
    }
    function Position(start) {
      this.start = start;
      this.end = now();
    }
    function validateEat(subvalue) {
      if (value.slice(0, subvalue.length) !== subvalue)
        self2.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
    }
    function position() {
      var before = now();
      return update;
      function update(node, indent) {
        var previous = node.position;
        var start = previous ? previous.start : before;
        var combined = [];
        var n = previous && previous.end.line;
        var l = before.line;
        node.position = new Position(start);
        if (previous && indent && previous.indent) {
          combined = previous.indent;
          if (n < l) {
            while (++n < l)
              combined.push((offset[n] || 0) + 1);
            combined.push(before.column);
          }
          indent = combined.concat(indent);
        }
        node.position.indent = indent || [];
        return node;
      }
    }
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn;
      if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $560639d49e3c9a19$var$mergeable(previous) && $560639d49e3c9a19$var$mergeable(node)) {
        fn = node.type === "text" ? $560639d49e3c9a19$var$mergeText : $560639d49e3c9a19$var$mergeBlockquote;
        node = fn.call(self2, previous, node);
      }
      if (node !== previous)
        children.push(node);
      if (self2.atStart && tokens.length !== 0)
        self2.exitStart();
      return node;
    }
    function eat(subvalue) {
      var indent = getOffset();
      var pos = position();
      var current = now();
      validateEat(subvalue);
      apply.reset = reset;
      reset.test = test;
      apply.test = test;
      value = value.slice(subvalue.length);
      updatePosition(subvalue);
      indent = indent();
      return apply;
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent);
      }
      function reset() {
        var node = apply.apply(null, arguments);
        line = current.line;
        column = current.column;
        value = subvalue + value;
        return node;
      }
      function test() {
        var result = pos({});
        line = current.line;
        column = current.column;
        value = subvalue + value;
        return result.position;
      }
    }
  }
}
function $560639d49e3c9a19$var$mergeable(node) {
  var start;
  var end;
  if (node.type !== "text" || !node.position)
    return true;
  start = node.position.start;
  end = node.position.end;
  return start.line !== end.line || end.column - start.column === node.value.length;
}
function $560639d49e3c9a19$var$mergeText(previous, node) {
  previous.value += node.value;
  return previous;
}
function $560639d49e3c9a19$var$mergeBlockquote(previous, node) {
  if (this.options.commonmark || this.options.gfm)
    return node;
  previous.children = previous.children.concat(node.children);
  return previous;
}
var $560639d49e3c9a19$var$markdownEscapes = $560639d49e3c9a19$var$escapes$1;
var $560639d49e3c9a19$var$defaults$2 = [
  "\\",
  "`",
  "*",
  "{",
  "}",
  "[",
  "]",
  "(",
  ")",
  "#",
  "+",
  "-",
  ".",
  "!",
  "_",
  ">"
];
var $560639d49e3c9a19$var$gfm = $560639d49e3c9a19$var$defaults$2.concat([
  "~",
  "|"
]);
var $560639d49e3c9a19$var$commonmark = $560639d49e3c9a19$var$gfm.concat([
  "\n",
  '"',
  "$",
  "%",
  "&",
  "'",
  ",",
  "/",
  ":",
  ";",
  "<",
  "=",
  "?",
  "@",
  "^"
]);
$560639d49e3c9a19$var$escapes$1.default = $560639d49e3c9a19$var$defaults$2;
$560639d49e3c9a19$var$escapes$1.gfm = $560639d49e3c9a19$var$gfm;
$560639d49e3c9a19$var$escapes$1.commonmark = $560639d49e3c9a19$var$commonmark;
function $560639d49e3c9a19$var$escapes$1(options) {
  var settings = options || {};
  if (settings.commonmark)
    return $560639d49e3c9a19$var$commonmark;
  return settings.gfm ? $560639d49e3c9a19$var$gfm : $560639d49e3c9a19$var$defaults$2;
}
var $560639d49e3c9a19$var$blockElements = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "meta",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "pre",
  "section",
  "source",
  "title",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var $560639d49e3c9a19$var$defaults$1 = {
  position: true,
  gfm: true,
  commonmark: false,
  pedantic: false,
  blocks: $560639d49e3c9a19$var$blockElements
};
var $560639d49e3c9a19$var$setOptions_1 = $560639d49e3c9a19$var$setOptions;
function $560639d49e3c9a19$var$setOptions(options) {
  var self2 = this;
  var current = self2.options;
  var key;
  var value;
  if (options == null)
    options = {};
  else if (typeof options === "object")
    options = $560639d49e3c9a19$var$immutable(options);
  else
    throw new Error("Invalid value `" + options + "` for setting `options`");
  for (key in $560639d49e3c9a19$var$defaults$1) {
    value = options[key];
    if (value == null)
      value = current[key];
    if (key !== "blocks" && typeof value !== "boolean" || key === "blocks" && typeof value !== "object")
      throw new Error("Invalid value `" + value + "` for setting `options." + key + "`");
    options[key] = value;
  }
  self2.options = options;
  self2.escape = $560639d49e3c9a19$var$markdownEscapes(options);
  return self2;
}
var $560639d49e3c9a19$var$convert_1 = $560639d49e3c9a19$var$convert$1;
function $560639d49e3c9a19$var$convert$1(test) {
  if (test == null)
    return $560639d49e3c9a19$var$ok$1;
  if (typeof test === "string")
    return $560639d49e3c9a19$var$typeFactory$1(test);
  if (typeof test === "object")
    return "length" in test ? $560639d49e3c9a19$var$anyFactory$1(test) : $560639d49e3c9a19$var$allFactory(test);
  if (typeof test === "function")
    return test;
  throw new Error("Expected function, string, or object as test");
}
function $560639d49e3c9a19$var$allFactory(test) {
  return all;
  function all(node) {
    var key;
    for (key in test) {
      if (node[key] !== test[key])
        return false;
    }
    return true;
  }
}
function $560639d49e3c9a19$var$anyFactory$1(tests) {
  var checks = [];
  var index = -1;
  while (++index < tests.length)
    checks[index] = $560639d49e3c9a19$var$convert$1(tests[index]);
  return any;
  function any() {
    var index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].apply(this, arguments))
        return true;
    }
    return false;
  }
}
function $560639d49e3c9a19$var$typeFactory$1(test) {
  return type;
  function type(node) {
    return Boolean(node && node.type === test);
  }
}
function $560639d49e3c9a19$var$ok$1() {
  return true;
}
var $560639d49e3c9a19$var$color_1 = $560639d49e3c9a19$var$color;
function $560639d49e3c9a19$var$color(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}
var $560639d49e3c9a19$var$unistUtilVisitParents = $560639d49e3c9a19$var$visitParents;
var $560639d49e3c9a19$var$CONTINUE$1 = true;
var $560639d49e3c9a19$var$SKIP$1 = "skip";
var $560639d49e3c9a19$var$EXIT$1 = false;
$560639d49e3c9a19$var$visitParents.CONTINUE = $560639d49e3c9a19$var$CONTINUE$1;
$560639d49e3c9a19$var$visitParents.SKIP = $560639d49e3c9a19$var$SKIP$1;
$560639d49e3c9a19$var$visitParents.EXIT = $560639d49e3c9a19$var$EXIT$1;
function $560639d49e3c9a19$var$visitParents(tree, test, visitor, reverse) {
  var step;
  var is;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  is = $560639d49e3c9a19$var$convert_1(test);
  step = reverse ? -1 : 1;
  factory(tree, null, [])();
  function factory(node, index, parents) {
    var value = typeof node === "object" && node !== null ? node : {};
    var name;
    if (typeof value.type === "string") {
      name = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
      visit.displayName = "node (" + $560639d49e3c9a19$var$color_1(value.type + (name ? "<" + name + ">" : "")) + ")";
    }
    return visit;
    function visit() {
      var grandparents = parents.concat(node);
      var result = [];
      var subresult;
      var offset;
      if (!test || is(node, index, parents[parents.length - 1] || null)) {
        result = $560639d49e3c9a19$var$toResult(visitor(node, parents));
        if (result[0] === $560639d49e3c9a19$var$EXIT$1)
          return result;
      }
      if (node.children && result[0] !== $560639d49e3c9a19$var$SKIP$1) {
        offset = (reverse ? node.children.length : -1) + step;
        while (offset > -1 && offset < node.children.length) {
          subresult = factory(node.children[offset], offset, grandparents)();
          if (subresult[0] === $560639d49e3c9a19$var$EXIT$1)
            return subresult;
          offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
        }
      }
      return result;
    }
  }
}
function $560639d49e3c9a19$var$toResult(value) {
  if (value !== null && typeof value === "object" && "length" in value)
    return value;
  if (typeof value === "number")
    return [
      $560639d49e3c9a19$var$CONTINUE$1,
      value
    ];
  return [
    value
  ];
}
var $560639d49e3c9a19$var$unistUtilVisit = $560639d49e3c9a19$var$visit;
var $560639d49e3c9a19$var$CONTINUE = $560639d49e3c9a19$var$unistUtilVisitParents.CONTINUE;
var $560639d49e3c9a19$var$SKIP = $560639d49e3c9a19$var$unistUtilVisitParents.SKIP;
var $560639d49e3c9a19$var$EXIT = $560639d49e3c9a19$var$unistUtilVisitParents.EXIT;
$560639d49e3c9a19$var$visit.CONTINUE = $560639d49e3c9a19$var$CONTINUE;
$560639d49e3c9a19$var$visit.SKIP = $560639d49e3c9a19$var$SKIP;
$560639d49e3c9a19$var$visit.EXIT = $560639d49e3c9a19$var$EXIT;
function $560639d49e3c9a19$var$visit(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  $560639d49e3c9a19$var$unistUtilVisitParents(tree, test, overload, reverse);
  function overload(node, parents) {
    var parent = parents[parents.length - 1];
    var index = parent ? parent.children.indexOf(node) : null;
    return visitor(node, index, parent);
  }
}
var $560639d49e3c9a19$var$unistUtilRemovePosition = $560639d49e3c9a19$var$removePosition;
function $560639d49e3c9a19$var$removePosition(node, force) {
  $560639d49e3c9a19$var$unistUtilVisit(node, force ? $560639d49e3c9a19$var$hard : $560639d49e3c9a19$var$soft);
  return node;
}
function $560639d49e3c9a19$var$hard(node) {
  delete node.position;
}
function $560639d49e3c9a19$var$soft(node) {
  node.position = void 0;
}
var $560639d49e3c9a19$var$parse_1$2 = $560639d49e3c9a19$var$parse$6;
var $560639d49e3c9a19$var$lineFeed$i = "\n";
var $560639d49e3c9a19$var$lineBreaksExpression = /\r\n|\r/g;
function $560639d49e3c9a19$var$parse$6() {
  var self2 = this;
  var value = String(self2.file);
  var start = {
    line: 1,
    column: 1,
    offset: 0
  };
  var content = $560639d49e3c9a19$var$immutable(start);
  var node;
  value = value.replace($560639d49e3c9a19$var$lineBreaksExpression, $560639d49e3c9a19$var$lineFeed$i);
  if (value.charCodeAt(0) === 65279) {
    value = value.slice(1);
    content.column++;
    content.offset++;
  }
  node = {
    type: "root",
    children: self2.tokenizeBlock(value, content),
    position: {
      start,
      end: self2.eof || $560639d49e3c9a19$var$immutable(start)
    }
  };
  if (!self2.options.position)
    $560639d49e3c9a19$var$unistUtilRemovePosition(node, true);
  return node;
}
var $560639d49e3c9a19$var$reBlankLine = /^[ \t]*(\n|$)/;
var $560639d49e3c9a19$var$blankLine_1 = $560639d49e3c9a19$var$blankLine;
function $560639d49e3c9a19$var$blankLine(eat, value, silent) {
  var match;
  var subvalue = "";
  var index = 0;
  var length = value.length;
  while (index < length) {
    match = $560639d49e3c9a19$var$reBlankLine.exec(value.slice(index));
    if (match == null)
      break;
    index += match[0].length;
    subvalue += match[0];
  }
  if (subvalue === "")
    return;
  if (silent)
    return true;
  eat(subvalue);
}
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
var $560639d49e3c9a19$var$res = "";
var $560639d49e3c9a19$var$cache;
var $560639d49e3c9a19$var$repeatString = $560639d49e3c9a19$var$repeat$1;
function $560639d49e3c9a19$var$repeat$1(str, num) {
  if (typeof str !== "string")
    throw new TypeError("expected a string");
  if (num === 1)
    return str;
  if (num === 2)
    return str + str;
  var max = str.length * num;
  if ($560639d49e3c9a19$var$cache !== str || typeof $560639d49e3c9a19$var$cache === "undefined") {
    $560639d49e3c9a19$var$cache = str;
    $560639d49e3c9a19$var$res = "";
  } else if ($560639d49e3c9a19$var$res.length >= max)
    return $560639d49e3c9a19$var$res.substr(0, max);
  while (max > $560639d49e3c9a19$var$res.length && num > 1) {
    if (num & 1)
      $560639d49e3c9a19$var$res += str;
    num >>= 1;
    str += str;
  }
  $560639d49e3c9a19$var$res += str;
  $560639d49e3c9a19$var$res = $560639d49e3c9a19$var$res.substr(0, max);
  return $560639d49e3c9a19$var$res;
}
var $560639d49e3c9a19$var$trimTrailingLines_1 = $560639d49e3c9a19$var$trimTrailingLines;
var $560639d49e3c9a19$var$line = "\n";
function $560639d49e3c9a19$var$trimTrailingLines(value) {
  var val = String(value);
  var index = val.length;
  while (val.charAt(--index) === $560639d49e3c9a19$var$line)
    ;
  return val.slice(0, index + 1);
}
var $560639d49e3c9a19$var$codeIndented = $560639d49e3c9a19$var$indentedCode$1;
var $560639d49e3c9a19$var$lineFeed$h = "\n";
var $560639d49e3c9a19$var$tab$d = "	";
var $560639d49e3c9a19$var$space$i = " ";
var $560639d49e3c9a19$var$tabSize$4 = 4;
var $560639d49e3c9a19$var$codeIndent = $560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$i, $560639d49e3c9a19$var$tabSize$4);
function $560639d49e3c9a19$var$indentedCode$1(eat, value, silent) {
  var index = -1;
  var length = value.length;
  var subvalue = "";
  var content = "";
  var subvalueQueue = "";
  var contentQueue = "";
  var character;
  var blankQueue;
  var indent;
  while (++index < length) {
    character = value.charAt(index);
    if (indent) {
      indent = false;
      subvalue += subvalueQueue;
      content += contentQueue;
      subvalueQueue = "";
      contentQueue = "";
      if (character === $560639d49e3c9a19$var$lineFeed$h) {
        subvalueQueue = character;
        contentQueue = character;
      } else {
        subvalue += character;
        content += character;
        while (++index < length) {
          character = value.charAt(index);
          if (!character || character === $560639d49e3c9a19$var$lineFeed$h) {
            contentQueue = character;
            subvalueQueue = character;
            break;
          }
          subvalue += character;
          content += character;
        }
      }
    } else if (character === $560639d49e3c9a19$var$space$i && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {
      subvalueQueue += $560639d49e3c9a19$var$codeIndent;
      index += 3;
      indent = true;
    } else if (character === $560639d49e3c9a19$var$tab$d) {
      subvalueQueue += character;
      indent = true;
    } else {
      blankQueue = "";
      while (character === $560639d49e3c9a19$var$tab$d || character === $560639d49e3c9a19$var$space$i) {
        blankQueue += character;
        character = value.charAt(++index);
      }
      if (character !== $560639d49e3c9a19$var$lineFeed$h)
        break;
      subvalueQueue += blankQueue + character;
      contentQueue += character;
    }
  }
  if (content) {
    if (silent)
      return true;
    return eat(subvalue)({
      type: "code",
      lang: null,
      meta: null,
      value: $560639d49e3c9a19$var$trimTrailingLines_1(content)
    });
  }
}
var $560639d49e3c9a19$var$codeFenced = $560639d49e3c9a19$var$fencedCode;
var $560639d49e3c9a19$var$lineFeed$g = "\n";
var $560639d49e3c9a19$var$tab$c = "	";
var $560639d49e3c9a19$var$space$h = " ";
var $560639d49e3c9a19$var$tilde$3 = "~";
var $560639d49e3c9a19$var$graveAccent$2 = "`";
var $560639d49e3c9a19$var$minFenceCount = 3;
var $560639d49e3c9a19$var$tabSize$3 = 4;
function $560639d49e3c9a19$var$fencedCode(eat, value, silent) {
  var self2 = this;
  var gfm = self2.options.gfm;
  var length = value.length + 1;
  var index = 0;
  var subvalue = "";
  var fenceCount;
  var marker;
  var character;
  var flag;
  var lang;
  var meta;
  var queue;
  var content;
  var exdentedContent;
  var closing;
  var exdentedClosing;
  var indent;
  var now;
  if (!gfm)
    return;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c)
      break;
    subvalue += character;
    index++;
  }
  indent = index;
  character = value.charAt(index);
  if (character !== $560639d49e3c9a19$var$tilde$3 && character !== $560639d49e3c9a19$var$graveAccent$2)
    return;
  index++;
  marker = character;
  fenceCount = 1;
  subvalue += character;
  while (index < length) {
    character = value.charAt(index);
    if (character !== marker)
      break;
    subvalue += character;
    fenceCount++;
    index++;
  }
  if (fenceCount < $560639d49e3c9a19$var$minFenceCount)
    return;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c)
      break;
    subvalue += character;
    index++;
  }
  flag = "";
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$lineFeed$g || marker === $560639d49e3c9a19$var$graveAccent$2 && character === marker)
      break;
    if (character === $560639d49e3c9a19$var$space$h || character === $560639d49e3c9a19$var$tab$c)
      queue += character;
    else {
      flag += queue + character;
      queue = "";
    }
    index++;
  }
  character = value.charAt(index);
  if (character && character !== $560639d49e3c9a19$var$lineFeed$g)
    return;
  if (silent)
    return true;
  now = eat.now();
  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += flag;
  flag = self2.decode.raw(self2.unescape(flag), now);
  if (queue)
    subvalue += queue;
  queue = "";
  closing = "";
  exdentedClosing = "";
  content = "";
  exdentedContent = "";
  var skip = true;
  while (index < length) {
    character = value.charAt(index);
    content += closing;
    exdentedContent += exdentedClosing;
    closing = "";
    exdentedClosing = "";
    if (character !== $560639d49e3c9a19$var$lineFeed$g) {
      content += character;
      exdentedClosing += character;
      index++;
      continue;
    }
    if (skip) {
      subvalue += character;
      skip = false;
    } else {
      closing += character;
      exdentedClosing += character;
    }
    queue = "";
    index++;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $560639d49e3c9a19$var$space$h)
        break;
      queue += character;
      index++;
    }
    closing += queue;
    exdentedClosing += queue.slice(indent);
    if (queue.length >= $560639d49e3c9a19$var$tabSize$3)
      continue;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character !== marker)
        break;
      queue += character;
      index++;
    }
    closing += queue;
    exdentedClosing += queue;
    if (queue.length < fenceCount)
      continue;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character !== $560639d49e3c9a19$var$space$h && character !== $560639d49e3c9a19$var$tab$c)
        break;
      closing += character;
      exdentedClosing += character;
      index++;
    }
    if (!character || character === $560639d49e3c9a19$var$lineFeed$g)
      break;
  }
  subvalue += content + closing;
  index = -1;
  length = flag.length;
  while (++index < length) {
    character = flag.charAt(index);
    if (character === $560639d49e3c9a19$var$space$h || character === $560639d49e3c9a19$var$tab$c) {
      if (!lang)
        lang = flag.slice(0, index);
    } else if (lang) {
      meta = flag.slice(index);
      break;
    }
  }
  return eat(subvalue)({
    type: "code",
    lang: lang || flag || null,
    meta: meta || null,
    value: exdentedContent
  });
}
var $560639d49e3c9a19$var$trim_1 = $560639d49e3c9a19$var$createCommonjsModule(function(module, exports) {
  exports = module.exports = trim;
  function trim(str) {
    return str.replace(/^\s*|\s*$/g, "");
  }
  exports.left = function(str) {
    return str.replace(/^\s*/, "");
  };
  exports.right = function(str) {
    return str.replace(/\s*$/, "");
  };
});
$560639d49e3c9a19$var$trim_1.left;
$560639d49e3c9a19$var$trim_1.right;
var $560639d49e3c9a19$var$interrupt_1 = $560639d49e3c9a19$var$interrupt;
function $560639d49e3c9a19$var$interrupt(interruptors, tokenizers, ctx, parameters) {
  var length = interruptors.length;
  var index = -1;
  var interruptor;
  var config;
  while (++index < length) {
    interruptor = interruptors[index];
    config = interruptor[1] || {};
    if (config.pedantic !== void 0 && config.pedantic !== ctx.options.pedantic)
      continue;
    if (config.commonmark !== void 0 && config.commonmark !== ctx.options.commonmark)
      continue;
    if (tokenizers[interruptor[0]].apply(ctx, parameters))
      return true;
  }
  return false;
}
var $560639d49e3c9a19$var$blockquote_1$1 = $560639d49e3c9a19$var$blockquote$1;
var $560639d49e3c9a19$var$lineFeed$f = "\n";
var $560639d49e3c9a19$var$tab$b = "	";
var $560639d49e3c9a19$var$space$g = " ";
var $560639d49e3c9a19$var$greaterThan$4 = ">";
function $560639d49e3c9a19$var$blockquote$1(eat, value, silent) {
  var self2 = this;
  var offsets = self2.offset;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptBlockquote;
  var now = eat.now();
  var currentLine = now.line;
  var length = value.length;
  var values = [];
  var contents = [];
  var indents = [];
  var add;
  var index = 0;
  var character;
  var rest;
  var nextIndex;
  var content;
  var line;
  var startIndex;
  var prefixed;
  var exit;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$g && character !== $560639d49e3c9a19$var$tab$b)
      break;
    index++;
  }
  if (value.charAt(index) !== $560639d49e3c9a19$var$greaterThan$4)
    return;
  if (silent)
    return true;
  index = 0;
  while (index < length) {
    nextIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$f, index);
    startIndex = index;
    prefixed = false;
    if (nextIndex === -1)
      nextIndex = length;
    while (index < length) {
      character = value.charAt(index);
      if (character !== $560639d49e3c9a19$var$space$g && character !== $560639d49e3c9a19$var$tab$b)
        break;
      index++;
    }
    if (value.charAt(index) === $560639d49e3c9a19$var$greaterThan$4) {
      index++;
      prefixed = true;
      if (value.charAt(index) === $560639d49e3c9a19$var$space$g)
        index++;
    } else
      index = startIndex;
    content = value.slice(index, nextIndex);
    if (!prefixed && !$560639d49e3c9a19$var$trim_1(content)) {
      index = startIndex;
      break;
    }
    if (!prefixed) {
      rest = value.slice(index);
      if ($560639d49e3c9a19$var$interrupt_1(interruptors, tokenizers, self2, [
        eat,
        rest,
        true
      ]))
        break;
    }
    line = startIndex === index ? content : value.slice(startIndex, nextIndex);
    indents.push(index - startIndex);
    values.push(line);
    contents.push(content);
    index = nextIndex + 1;
  }
  index = -1;
  length = indents.length;
  add = eat(values.join($560639d49e3c9a19$var$lineFeed$f));
  while (++index < length) {
    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];
    currentLine++;
  }
  exit = self2.enterBlock();
  contents = self2.tokenizeBlock(contents.join($560639d49e3c9a19$var$lineFeed$f), now);
  exit();
  return add({
    type: "blockquote",
    children: contents
  });
}
var $560639d49e3c9a19$var$headingAtx = $560639d49e3c9a19$var$atxHeading;
var $560639d49e3c9a19$var$lineFeed$e = "\n";
var $560639d49e3c9a19$var$tab$a = "	";
var $560639d49e3c9a19$var$space$f = " ";
var $560639d49e3c9a19$var$numberSign = "#";
var $560639d49e3c9a19$var$maxFenceCount = 6;
function $560639d49e3c9a19$var$atxHeading(eat, value, silent) {
  var self2 = this;
  var pedantic = self2.options.pedantic;
  var length = value.length + 1;
  var index = -1;
  var now = eat.now();
  var subvalue = "";
  var content = "";
  var character;
  var queue;
  var depth;
  while (++index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a) {
      index--;
      break;
    }
    subvalue += character;
  }
  depth = 0;
  while (++index <= length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$numberSign) {
      index--;
      break;
    }
    subvalue += character;
    depth++;
  }
  if (depth > $560639d49e3c9a19$var$maxFenceCount)
    return;
  if (!depth || !pedantic && value.charAt(index + 1) === $560639d49e3c9a19$var$numberSign)
    return;
  length = value.length + 1;
  queue = "";
  while (++index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a) {
      index--;
      break;
    }
    queue += character;
  }
  if (!pedantic && queue.length === 0 && character && character !== $560639d49e3c9a19$var$lineFeed$e)
    return;
  if (silent)
    return true;
  subvalue += queue;
  queue = "";
  content = "";
  while (++index < length) {
    character = value.charAt(index);
    if (!character || character === $560639d49e3c9a19$var$lineFeed$e)
      break;
    if (character !== $560639d49e3c9a19$var$space$f && character !== $560639d49e3c9a19$var$tab$a && character !== $560639d49e3c9a19$var$numberSign) {
      content += queue + character;
      queue = "";
      continue;
    }
    while (character === $560639d49e3c9a19$var$space$f || character === $560639d49e3c9a19$var$tab$a) {
      queue += character;
      character = value.charAt(++index);
    }
    if (!pedantic && content && !queue && character === $560639d49e3c9a19$var$numberSign) {
      content += character;
      continue;
    }
    while (character === $560639d49e3c9a19$var$numberSign) {
      queue += character;
      character = value.charAt(++index);
    }
    while (character === $560639d49e3c9a19$var$space$f || character === $560639d49e3c9a19$var$tab$a) {
      queue += character;
      character = value.charAt(++index);
    }
    index--;
  }
  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;
  return eat(subvalue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now)
  });
}
var $560639d49e3c9a19$var$thematicBreak_1$1 = $560639d49e3c9a19$var$thematicBreak$1;
var $560639d49e3c9a19$var$tab$9 = "	";
var $560639d49e3c9a19$var$lineFeed$d = "\n";
var $560639d49e3c9a19$var$space$e = " ";
var $560639d49e3c9a19$var$asterisk$4 = "*";
var $560639d49e3c9a19$var$dash$7 = "-";
var $560639d49e3c9a19$var$underscore$6 = "_";
var $560639d49e3c9a19$var$maxCount = 3;
function $560639d49e3c9a19$var$thematicBreak$1(eat, value, silent) {
  var index = -1;
  var length = value.length + 1;
  var subvalue = "";
  var character;
  var marker;
  var markerCount;
  var queue;
  while (++index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$9 && character !== $560639d49e3c9a19$var$space$e)
      break;
    subvalue += character;
  }
  if (character !== $560639d49e3c9a19$var$asterisk$4 && character !== $560639d49e3c9a19$var$dash$7 && character !== $560639d49e3c9a19$var$underscore$6)
    return;
  marker = character;
  subvalue += character;
  markerCount = 1;
  queue = "";
  while (++index < length) {
    character = value.charAt(index);
    if (character === marker) {
      markerCount++;
      subvalue += queue + marker;
      queue = "";
    } else if (character === $560639d49e3c9a19$var$space$e)
      queue += character;
    else if (markerCount >= $560639d49e3c9a19$var$maxCount && (!character || character === $560639d49e3c9a19$var$lineFeed$d)) {
      subvalue += queue;
      if (silent)
        return true;
      return eat(subvalue)({
        type: "thematicBreak"
      });
    } else
      return;
  }
}
var $560639d49e3c9a19$var$getIndentation = $560639d49e3c9a19$var$indentation$1;
var $560639d49e3c9a19$var$tab$8 = "	";
var $560639d49e3c9a19$var$space$d = " ";
var $560639d49e3c9a19$var$spaceSize = 1;
var $560639d49e3c9a19$var$tabSize$2 = 4;
function $560639d49e3c9a19$var$indentation$1(value) {
  var index = 0;
  var indent = 0;
  var character = value.charAt(index);
  var stops = {};
  var size;
  var lastIndent = 0;
  while (character === $560639d49e3c9a19$var$tab$8 || character === $560639d49e3c9a19$var$space$d) {
    size = character === $560639d49e3c9a19$var$tab$8 ? $560639d49e3c9a19$var$tabSize$2 : $560639d49e3c9a19$var$spaceSize;
    indent += size;
    if (size > 1)
      indent = Math.floor(indent / size) * size;
    while (lastIndent < indent)
      stops[++lastIndent] = index;
    character = value.charAt(++index);
  }
  return {
    indent,
    stops
  };
}
var $560639d49e3c9a19$var$removeIndentation = $560639d49e3c9a19$var$indentation;
var $560639d49e3c9a19$var$lineFeed$c = "\n";
var $560639d49e3c9a19$var$space$c = " ";
var $560639d49e3c9a19$var$exclamationMark$4 = "!";
function $560639d49e3c9a19$var$indentation(value, maximum) {
  var values = value.split($560639d49e3c9a19$var$lineFeed$c);
  var position = values.length + 1;
  var minIndent = Infinity;
  var matrix = [];
  var index;
  var indentation;
  var stops;
  values.unshift($560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$c, maximum) + $560639d49e3c9a19$var$exclamationMark$4);
  while (position--) {
    indentation = $560639d49e3c9a19$var$getIndentation(values[position]);
    matrix[position] = indentation.stops;
    if ($560639d49e3c9a19$var$trim_1(values[position]).length === 0)
      continue;
    if (indentation.indent) {
      if (indentation.indent > 0 && indentation.indent < minIndent)
        minIndent = indentation.indent;
    } else {
      minIndent = Infinity;
      break;
    }
  }
  if (minIndent !== Infinity) {
    position = values.length;
    while (position--) {
      stops = matrix[position];
      index = minIndent;
      while (index && !(index in stops))
        index--;
      values[position] = values[position].slice(stops[index] + 1);
    }
  }
  values.shift();
  return values.join($560639d49e3c9a19$var$lineFeed$c);
}
var $560639d49e3c9a19$var$list_1$1 = $560639d49e3c9a19$var$list$1;
var $560639d49e3c9a19$var$asterisk$3 = "*";
var $560639d49e3c9a19$var$underscore$5 = "_";
var $560639d49e3c9a19$var$plusSign$2 = "+";
var $560639d49e3c9a19$var$dash$6 = "-";
var $560639d49e3c9a19$var$dot$3 = ".";
var $560639d49e3c9a19$var$space$b = " ";
var $560639d49e3c9a19$var$lineFeed$b = "\n";
var $560639d49e3c9a19$var$tab$7 = "	";
var $560639d49e3c9a19$var$rightParenthesis$3 = ")";
var $560639d49e3c9a19$var$lowercaseX = "x";
var $560639d49e3c9a19$var$tabSize$1 = 4;
var $560639d49e3c9a19$var$looseListItemExpression = /\n\n(?!\s*$)/;
var $560639d49e3c9a19$var$taskItemExpression = /^\[([ X\tx])][ \t]/;
var $560639d49e3c9a19$var$bulletExpression = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/;
var $560639d49e3c9a19$var$pedanticBulletExpression = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/;
var $560639d49e3c9a19$var$initialIndentExpression = /^( {1,4}|\t)?/gm;
function $560639d49e3c9a19$var$list$1(eat, value, silent) {
  var self2 = this;
  var commonmark = self2.options.commonmark;
  var pedantic = self2.options.pedantic;
  var tokenizers = self2.blockTokenizers;
  var interuptors = self2.interruptList;
  var index = 0;
  var length = value.length;
  var start = null;
  var size;
  var queue;
  var ordered;
  var character;
  var marker;
  var nextIndex;
  var startIndex;
  var prefixed;
  var currentMarker;
  var content;
  var line;
  var previousEmpty;
  var empty;
  var items;
  var allLines;
  var emptyLines;
  var item;
  var enterTop;
  var exitBlockquote;
  var spread = false;
  var node;
  var now;
  var end;
  var indented;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$7 && character !== $560639d49e3c9a19$var$space$b)
      break;
    index++;
  }
  character = value.charAt(index);
  if (character === $560639d49e3c9a19$var$asterisk$3 || character === $560639d49e3c9a19$var$plusSign$2 || character === $560639d49e3c9a19$var$dash$6) {
    marker = character;
    ordered = false;
  } else {
    ordered = true;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (!$560639d49e3c9a19$var$isDecimal(character))
        break;
      queue += character;
      index++;
    }
    character = value.charAt(index);
    if (!queue || !(character === $560639d49e3c9a19$var$dot$3 || commonmark && character === $560639d49e3c9a19$var$rightParenthesis$3))
      return;
    if (silent && queue !== "1")
      return;
    start = parseInt(queue, 10);
    marker = character;
  }
  character = value.charAt(++index);
  if (character !== $560639d49e3c9a19$var$space$b && character !== $560639d49e3c9a19$var$tab$7 && (pedantic || character !== $560639d49e3c9a19$var$lineFeed$b && character !== ""))
    return;
  if (silent)
    return true;
  index = 0;
  items = [];
  allLines = [];
  emptyLines = [];
  while (index < length) {
    nextIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$b, index);
    startIndex = index;
    prefixed = false;
    indented = false;
    if (nextIndex === -1)
      nextIndex = length;
    size = 0;
    while (index < length) {
      character = value.charAt(index);
      if (character === $560639d49e3c9a19$var$tab$7)
        size += $560639d49e3c9a19$var$tabSize$1 - size % $560639d49e3c9a19$var$tabSize$1;
      else if (character === $560639d49e3c9a19$var$space$b)
        size++;
      else
        break;
      index++;
    }
    if (item && size >= item.indent)
      indented = true;
    character = value.charAt(index);
    currentMarker = null;
    if (!indented) {
      if (character === $560639d49e3c9a19$var$asterisk$3 || character === $560639d49e3c9a19$var$plusSign$2 || character === $560639d49e3c9a19$var$dash$6) {
        currentMarker = character;
        index++;
        size++;
      } else {
        queue = "";
        while (index < length) {
          character = value.charAt(index);
          if (!$560639d49e3c9a19$var$isDecimal(character))
            break;
          queue += character;
          index++;
        }
        character = value.charAt(index);
        index++;
        if (queue && (character === $560639d49e3c9a19$var$dot$3 || commonmark && character === $560639d49e3c9a19$var$rightParenthesis$3)) {
          currentMarker = character;
          size += queue.length + 1;
        }
      }
      if (currentMarker) {
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$tab$7) {
          size += $560639d49e3c9a19$var$tabSize$1 - size % $560639d49e3c9a19$var$tabSize$1;
          index++;
        } else if (character === $560639d49e3c9a19$var$space$b) {
          end = index + $560639d49e3c9a19$var$tabSize$1;
          while (index < end) {
            if (value.charAt(index) !== $560639d49e3c9a19$var$space$b)
              break;
            index++;
            size++;
          }
          if (index === end && value.charAt(index) === $560639d49e3c9a19$var$space$b) {
            index -= $560639d49e3c9a19$var$tabSize$1 - 1;
            size -= $560639d49e3c9a19$var$tabSize$1 - 1;
          }
        } else if (character !== $560639d49e3c9a19$var$lineFeed$b && character !== "")
          currentMarker = null;
      }
    }
    if (currentMarker) {
      if (!pedantic && marker !== currentMarker)
        break;
      prefixed = true;
    } else {
      if (!commonmark && !indented && value.charAt(startIndex) === $560639d49e3c9a19$var$space$b)
        indented = true;
      else if (commonmark && item)
        indented = size >= item.indent || size > $560639d49e3c9a19$var$tabSize$1;
      prefixed = false;
      index = startIndex;
    }
    line = value.slice(startIndex, nextIndex);
    content = startIndex === index ? line : value.slice(index, nextIndex);
    if (currentMarker === $560639d49e3c9a19$var$asterisk$3 || currentMarker === $560639d49e3c9a19$var$underscore$5 || currentMarker === $560639d49e3c9a19$var$dash$6) {
      if (tokenizers.thematicBreak.call(self2, eat, line, true))
        break;
    }
    previousEmpty = empty;
    empty = !prefixed && !$560639d49e3c9a19$var$trim_1(content).length;
    if (indented && item) {
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (prefixed) {
      if (emptyLines.length !== 0) {
        spread = true;
        item.value.push("");
        item.trail = emptyLines.concat();
      }
      item = {
        value: [
          line
        ],
        indent: size,
        trail: []
      };
      items.push(item);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    } else if (empty) {
      if (previousEmpty && !commonmark)
        break;
      emptyLines.push(line);
    } else {
      if (previousEmpty)
        break;
      if ($560639d49e3c9a19$var$interrupt_1(interuptors, tokenizers, self2, [
        eat,
        line,
        true
      ]))
        break;
      item.value = item.value.concat(emptyLines, line);
      allLines = allLines.concat(emptyLines, line);
      emptyLines = [];
    }
    index = nextIndex + 1;
  }
  node = eat(allLines.join($560639d49e3c9a19$var$lineFeed$b)).reset({
    type: "list",
    ordered,
    start,
    spread,
    children: []
  });
  enterTop = self2.enterList();
  exitBlockquote = self2.enterBlock();
  index = -1;
  length = items.length;
  while (++index < length) {
    item = items[index].value.join($560639d49e3c9a19$var$lineFeed$b);
    now = eat.now();
    eat(item)($560639d49e3c9a19$var$listItem$2(self2, item, now), node);
    item = items[index].trail.join($560639d49e3c9a19$var$lineFeed$b);
    if (index !== length - 1)
      item += $560639d49e3c9a19$var$lineFeed$b;
    eat(item);
  }
  enterTop();
  exitBlockquote();
  return node;
}
function $560639d49e3c9a19$var$listItem$2(ctx, value, position) {
  var offsets = ctx.offset;
  var fn = ctx.options.pedantic ? $560639d49e3c9a19$var$pedanticListItem : $560639d49e3c9a19$var$normalListItem;
  var checked = null;
  var task;
  var indent;
  value = fn.apply(null, arguments);
  if (ctx.options.gfm) {
    task = value.match($560639d49e3c9a19$var$taskItemExpression);
    if (task) {
      indent = task[0].length;
      checked = task[1].toLowerCase() === $560639d49e3c9a19$var$lowercaseX;
      offsets[position.line] += indent;
      value = value.slice(indent);
    }
  }
  return {
    type: "listItem",
    spread: $560639d49e3c9a19$var$looseListItemExpression.test(value),
    checked,
    children: ctx.tokenizeBlock(value, position)
  };
}
function $560639d49e3c9a19$var$pedanticListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;
  value = value.replace($560639d49e3c9a19$var$pedanticBulletExpression, replacer);
  line = position.line;
  return value.replace($560639d49e3c9a19$var$initialIndentExpression, replacer);
  function replacer($0) {
    offsets[line] = (offsets[line] || 0) + $0.length;
    line++;
    return "";
  }
}
function $560639d49e3c9a19$var$normalListItem(ctx, value, position) {
  var offsets = ctx.offset;
  var line = position.line;
  var max;
  var bullet;
  var rest;
  var lines;
  var trimmedLines;
  var index;
  var length;
  value = value.replace($560639d49e3c9a19$var$bulletExpression, replacer);
  lines = value.split($560639d49e3c9a19$var$lineFeed$b);
  trimmedLines = $560639d49e3c9a19$var$removeIndentation(value, $560639d49e3c9a19$var$getIndentation(max).indent).split($560639d49e3c9a19$var$lineFeed$b);
  trimmedLines[0] = rest;
  offsets[line] = (offsets[line] || 0) + bullet.length;
  line++;
  index = 0;
  length = lines.length;
  while (++index < length) {
    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;
    line++;
  }
  return trimmedLines.join($560639d49e3c9a19$var$lineFeed$b);
  function replacer($0, $1, $2, $3, $4) {
    bullet = $1 + $2 + $3;
    rest = $4;
    if (Number($2) < 10 && bullet.length % 2 === 1)
      $2 = $560639d49e3c9a19$var$space$b + $2;
    max = $1 + $560639d49e3c9a19$var$repeatString($560639d49e3c9a19$var$space$b, $2.length) + $3;
    return max + rest;
  }
}
var $560639d49e3c9a19$var$headingSetext = $560639d49e3c9a19$var$setextHeading;
var $560639d49e3c9a19$var$lineFeed$a = "\n";
var $560639d49e3c9a19$var$tab$6 = "	";
var $560639d49e3c9a19$var$space$a = " ";
var $560639d49e3c9a19$var$equalsTo$1 = "=";
var $560639d49e3c9a19$var$dash$5 = "-";
var $560639d49e3c9a19$var$maxIndent = 3;
var $560639d49e3c9a19$var$equalsToDepth = 1;
var $560639d49e3c9a19$var$dashDepth = 2;
function $560639d49e3c9a19$var$setextHeading(eat, value, silent) {
  var self2 = this;
  var now = eat.now();
  var length = value.length;
  var index = -1;
  var subvalue = "";
  var content;
  var queue;
  var character;
  var marker;
  var depth;
  while (++index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$a || index >= $560639d49e3c9a19$var$maxIndent) {
      index--;
      break;
    }
    subvalue += character;
  }
  content = "";
  queue = "";
  while (++index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$lineFeed$a) {
      index--;
      break;
    }
    if (character === $560639d49e3c9a19$var$space$a || character === $560639d49e3c9a19$var$tab$6)
      queue += character;
    else {
      content += queue + character;
      queue = "";
    }
  }
  now.column += subvalue.length;
  now.offset += subvalue.length;
  subvalue += content + queue;
  character = value.charAt(++index);
  marker = value.charAt(++index);
  if (character !== $560639d49e3c9a19$var$lineFeed$a || marker !== $560639d49e3c9a19$var$equalsTo$1 && marker !== $560639d49e3c9a19$var$dash$5)
    return;
  subvalue += character;
  queue = marker;
  depth = marker === $560639d49e3c9a19$var$equalsTo$1 ? $560639d49e3c9a19$var$equalsToDepth : $560639d49e3c9a19$var$dashDepth;
  while (++index < length) {
    character = value.charAt(index);
    if (character !== marker) {
      if (character !== $560639d49e3c9a19$var$lineFeed$a)
        return;
      index--;
      break;
    }
    queue += character;
  }
  if (silent)
    return true;
  return eat(subvalue + queue)({
    type: "heading",
    depth,
    children: self2.tokenizeInline(content, now)
  });
}
var $560639d49e3c9a19$var$attributeName$2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var $560639d49e3c9a19$var$unquoted$2 = "[^\"'=<>`\\u0000-\\u0020]+";
var $560639d49e3c9a19$var$singleQuoted$2 = "'[^']*'";
var $560639d49e3c9a19$var$doubleQuoted$2 = '"[^"]*"';
var $560639d49e3c9a19$var$attributeValue$2 = "(?:" + $560639d49e3c9a19$var$unquoted$2 + "|" + $560639d49e3c9a19$var$singleQuoted$2 + "|" + $560639d49e3c9a19$var$doubleQuoted$2 + ")";
var $560639d49e3c9a19$var$attribute$2 = "(?:\\s+" + $560639d49e3c9a19$var$attributeName$2 + "(?:\\s*=\\s*" + $560639d49e3c9a19$var$attributeValue$2 + ")?)";
var $560639d49e3c9a19$var$openTag$1 = "<[A-Za-z][A-Za-z0-9\\-]*" + $560639d49e3c9a19$var$attribute$2 + "*\\s*\\/?>";
var $560639d49e3c9a19$var$closeTag$1 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var $560639d49e3c9a19$var$comment$1 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var $560639d49e3c9a19$var$processing = "<[?].*?[?]>";
var $560639d49e3c9a19$var$declaration = "<![A-Za-z]+\\s+[^>]*>";
var $560639d49e3c9a19$var$cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var $560639d49e3c9a19$var$openCloseTag$2 = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag$1 + "|" + $560639d49e3c9a19$var$closeTag$1 + ")");
var $560639d49e3c9a19$var$tag$2 = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag$1 + "|" + $560639d49e3c9a19$var$closeTag$1 + "|" + $560639d49e3c9a19$var$comment$1 + "|" + $560639d49e3c9a19$var$processing + "|" + $560639d49e3c9a19$var$declaration + "|" + $560639d49e3c9a19$var$cdata + ")");
var $560639d49e3c9a19$var$html$4 = {
  openCloseTag: $560639d49e3c9a19$var$openCloseTag$2,
  tag: $560639d49e3c9a19$var$tag$2
};
var $560639d49e3c9a19$var$openCloseTag$1 = $560639d49e3c9a19$var$html$4.openCloseTag;
var $560639d49e3c9a19$var$htmlBlock = $560639d49e3c9a19$var$blockHtml$1;
var $560639d49e3c9a19$var$tab$5 = "	";
var $560639d49e3c9a19$var$space$9 = " ";
var $560639d49e3c9a19$var$lineFeed$9 = "\n";
var $560639d49e3c9a19$var$lessThan$7 = "<";
var $560639d49e3c9a19$var$rawOpenExpression$1 = /^<(script|pre|style)(?=(\s|>|$))/i;
var $560639d49e3c9a19$var$rawCloseExpression$1 = /<\/(script|pre|style)>/i;
var $560639d49e3c9a19$var$commentOpenExpression$1 = /^<!--/;
var $560639d49e3c9a19$var$commentCloseExpression$1 = /-->/;
var $560639d49e3c9a19$var$instructionOpenExpression$1 = /^<\?/;
var $560639d49e3c9a19$var$instructionCloseExpression$1 = /\?>/;
var $560639d49e3c9a19$var$directiveOpenExpression$1 = /^<![A-Za-z]/;
var $560639d49e3c9a19$var$directiveCloseExpression$1 = />/;
var $560639d49e3c9a19$var$cdataOpenExpression$1 = /^<!\[CDATA\[/;
var $560639d49e3c9a19$var$cdataCloseExpression$1 = /]]>/;
var $560639d49e3c9a19$var$elementCloseExpression$1 = /^$/;
var $560639d49e3c9a19$var$otherElementOpenExpression$1 = new RegExp($560639d49e3c9a19$var$openCloseTag$1.source + "\\s*$");
function $560639d49e3c9a19$var$blockHtml$1(eat, value, silent) {
  var self2 = this;
  var blocks = self2.options.blocks.join("|");
  var elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
  var length = value.length;
  var index = 0;
  var next;
  var line;
  var offset;
  var character;
  var count;
  var sequence;
  var subvalue;
  var sequences = [
    [
      $560639d49e3c9a19$var$rawOpenExpression$1,
      $560639d49e3c9a19$var$rawCloseExpression$1,
      true
    ],
    [
      $560639d49e3c9a19$var$commentOpenExpression$1,
      $560639d49e3c9a19$var$commentCloseExpression$1,
      true
    ],
    [
      $560639d49e3c9a19$var$instructionOpenExpression$1,
      $560639d49e3c9a19$var$instructionCloseExpression$1,
      true
    ],
    [
      $560639d49e3c9a19$var$directiveOpenExpression$1,
      $560639d49e3c9a19$var$directiveCloseExpression$1,
      true
    ],
    [
      $560639d49e3c9a19$var$cdataOpenExpression$1,
      $560639d49e3c9a19$var$cdataCloseExpression$1,
      true
    ],
    [
      elementOpenExpression,
      $560639d49e3c9a19$var$elementCloseExpression$1,
      true
    ],
    [
      $560639d49e3c9a19$var$otherElementOpenExpression$1,
      $560639d49e3c9a19$var$elementCloseExpression$1,
      false
    ]
  ];
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$5 && character !== $560639d49e3c9a19$var$space$9)
      break;
    index++;
  }
  if (value.charAt(index) !== $560639d49e3c9a19$var$lessThan$7)
    return;
  next = value.indexOf($560639d49e3c9a19$var$lineFeed$9, index + 1);
  next = next === -1 ? length : next;
  line = value.slice(index, next);
  offset = -1;
  count = sequences.length;
  while (++offset < count)
    if (sequences[offset][0].test(line)) {
      sequence = sequences[offset];
      break;
    }
  if (!sequence)
    return;
  if (silent)
    return sequence[2];
  index = next;
  if (!sequence[1].test(line))
    while (index < length) {
      next = value.indexOf($560639d49e3c9a19$var$lineFeed$9, index + 1);
      next = next === -1 ? length : next;
      line = value.slice(index + 1, next);
      if (sequence[1].test(line)) {
        if (line)
          index = next;
        break;
      }
      index = next;
    }
  subvalue = value.slice(0, index);
  return eat(subvalue)({
    type: "html",
    value: subvalue
  });
}
var $560639d49e3c9a19$var$isWhitespaceCharacter = $560639d49e3c9a19$var$whitespace$1;
var $560639d49e3c9a19$var$fromCode$1 = String.fromCharCode;
var $560639d49e3c9a19$var$re$2 = /\s/;
function $560639d49e3c9a19$var$whitespace$1(character) {
  return $560639d49e3c9a19$var$re$2.test(typeof character === "number" ? $560639d49e3c9a19$var$fromCode$1(character) : character.charAt(0));
}
var $560639d49e3c9a19$var$collapseWhiteSpace = $560639d49e3c9a19$var$collapse;
function $560639d49e3c9a19$var$collapse(value) {
  return String(value).replace(/\s+/g, " ");
}
var $560639d49e3c9a19$var$normalize_1$1 = $560639d49e3c9a19$var$normalize$1;
function $560639d49e3c9a19$var$normalize$1(value) {
  return $560639d49e3c9a19$var$collapseWhiteSpace(value).toLowerCase();
}
var $560639d49e3c9a19$var$definition_1 = $560639d49e3c9a19$var$definition;
var $560639d49e3c9a19$var$quotationMark$2 = '"';
var $560639d49e3c9a19$var$apostrophe$3 = "'";
var $560639d49e3c9a19$var$backslash$6 = "\\";
var $560639d49e3c9a19$var$lineFeed$8 = "\n";
var $560639d49e3c9a19$var$tab$4 = "	";
var $560639d49e3c9a19$var$space$8 = " ";
var $560639d49e3c9a19$var$leftSquareBracket$2 = "[";
var $560639d49e3c9a19$var$rightSquareBracket$2 = "]";
var $560639d49e3c9a19$var$leftParenthesis$1 = "(";
var $560639d49e3c9a19$var$rightParenthesis$2 = ")";
var $560639d49e3c9a19$var$colon$2 = ":";
var $560639d49e3c9a19$var$lessThan$6 = "<";
var $560639d49e3c9a19$var$greaterThan$3 = ">";
function $560639d49e3c9a19$var$definition(eat, value, silent) {
  var self2 = this;
  var commonmark = self2.options.commonmark;
  var index = 0;
  var length = value.length;
  var subvalue = "";
  var beforeURL;
  var beforeTitle;
  var queue;
  var character;
  var test;
  var identifier;
  var url;
  var title;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$tab$4)
      break;
    subvalue += character;
    index++;
  }
  character = value.charAt(index);
  if (character !== $560639d49e3c9a19$var$leftSquareBracket$2)
    return;
  index++;
  subvalue += character;
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$rightSquareBracket$2)
      break;
    else if (character === $560639d49e3c9a19$var$backslash$6) {
      queue += character;
      index++;
      character = value.charAt(index);
    }
    queue += character;
    index++;
  }
  if (!queue || value.charAt(index) !== $560639d49e3c9a19$var$rightSquareBracket$2 || value.charAt(index + 1) !== $560639d49e3c9a19$var$colon$2)
    return;
  identifier = queue;
  subvalue += queue + $560639d49e3c9a19$var$rightSquareBracket$2 + $560639d49e3c9a19$var$colon$2;
  index = subvalue.length;
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$lineFeed$8)
      break;
    subvalue += character;
    index++;
  }
  character = value.charAt(index);
  queue = "";
  beforeURL = subvalue;
  if (character === $560639d49e3c9a19$var$lessThan$6) {
    index++;
    while (index < length) {
      character = value.charAt(index);
      if (!$560639d49e3c9a19$var$isEnclosedURLCharacter(character))
        break;
      queue += character;
      index++;
    }
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$isEnclosedURLCharacter.delimiter) {
      subvalue += $560639d49e3c9a19$var$lessThan$6 + queue + character;
      index++;
    } else {
      if (commonmark)
        return;
      index -= queue.length + 1;
      queue = "";
    }
  }
  if (!queue) {
    while (index < length) {
      character = value.charAt(index);
      if (!$560639d49e3c9a19$var$isUnclosedURLCharacter(character))
        break;
      queue += character;
      index++;
    }
    subvalue += queue;
  }
  if (!queue)
    return;
  url = queue;
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8 && character !== $560639d49e3c9a19$var$lineFeed$8)
      break;
    queue += character;
    index++;
  }
  character = value.charAt(index);
  test = null;
  if (character === $560639d49e3c9a19$var$quotationMark$2)
    test = $560639d49e3c9a19$var$quotationMark$2;
  else if (character === $560639d49e3c9a19$var$apostrophe$3)
    test = $560639d49e3c9a19$var$apostrophe$3;
  else if (character === $560639d49e3c9a19$var$leftParenthesis$1)
    test = $560639d49e3c9a19$var$rightParenthesis$2;
  if (!test) {
    queue = "";
    index = subvalue.length;
  } else if (queue) {
    subvalue += queue + character;
    index = subvalue.length;
    queue = "";
    while (index < length) {
      character = value.charAt(index);
      if (character === test)
        break;
      if (character === $560639d49e3c9a19$var$lineFeed$8) {
        index++;
        character = value.charAt(index);
        if (character === $560639d49e3c9a19$var$lineFeed$8 || character === test)
          return;
        queue += $560639d49e3c9a19$var$lineFeed$8;
      }
      queue += character;
      index++;
    }
    character = value.charAt(index);
    if (character !== test)
      return;
    beforeTitle = subvalue;
    subvalue += queue + character;
    index++;
    title = queue;
    queue = "";
  } else
    return;
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab$4 && character !== $560639d49e3c9a19$var$space$8)
      break;
    subvalue += character;
    index++;
  }
  character = value.charAt(index);
  if (!character || character === $560639d49e3c9a19$var$lineFeed$8) {
    if (silent)
      return true;
    beforeURL = eat(beforeURL).test().end;
    url = self2.decode.raw(self2.unescape(url), beforeURL, {
      nonTerminated: false
    });
    if (title) {
      beforeTitle = eat(beforeTitle).test().end;
      title = self2.decode.raw(self2.unescape(title), beforeTitle);
    }
    return eat(subvalue)({
      type: "definition",
      identifier: $560639d49e3c9a19$var$normalize_1$1(identifier),
      label: identifier,
      title: title || null,
      url
    });
  }
}
function $560639d49e3c9a19$var$isEnclosedURLCharacter(character) {
  return character !== $560639d49e3c9a19$var$greaterThan$3 && character !== $560639d49e3c9a19$var$leftSquareBracket$2 && character !== $560639d49e3c9a19$var$rightSquareBracket$2;
}
$560639d49e3c9a19$var$isEnclosedURLCharacter.delimiter = $560639d49e3c9a19$var$greaterThan$3;
function $560639d49e3c9a19$var$isUnclosedURLCharacter(character) {
  return character !== $560639d49e3c9a19$var$leftSquareBracket$2 && character !== $560639d49e3c9a19$var$rightSquareBracket$2 && !$560639d49e3c9a19$var$isWhitespaceCharacter(character);
}
var $560639d49e3c9a19$var$table_1$1 = $560639d49e3c9a19$var$table$1;
var $560639d49e3c9a19$var$tab$3 = "	";
var $560639d49e3c9a19$var$lineFeed$7 = "\n";
var $560639d49e3c9a19$var$space$7 = " ";
var $560639d49e3c9a19$var$dash$4 = "-";
var $560639d49e3c9a19$var$colon$1 = ":";
var $560639d49e3c9a19$var$backslash$5 = "\\";
var $560639d49e3c9a19$var$verticalBar = "|";
var $560639d49e3c9a19$var$minColumns = 1;
var $560639d49e3c9a19$var$minRows = 2;
var $560639d49e3c9a19$var$left = "left";
var $560639d49e3c9a19$var$center = "center";
var $560639d49e3c9a19$var$right = "right";
function $560639d49e3c9a19$var$table$1(eat, value, silent) {
  var self2 = this;
  var index;
  var alignments;
  var alignment;
  var subvalue;
  var row;
  var length;
  var lines;
  var queue;
  var character;
  var hasDash;
  var align;
  var cell;
  var preamble;
  var now;
  var position;
  var lineCount;
  var line;
  var rows;
  var table;
  var lineIndex;
  var pipeIndex;
  var first;
  if (!self2.options.gfm)
    return;
  index = 0;
  lineCount = 0;
  length = value.length + 1;
  lines = [];
  while (index < length) {
    lineIndex = value.indexOf($560639d49e3c9a19$var$lineFeed$7, index);
    pipeIndex = value.indexOf($560639d49e3c9a19$var$verticalBar, index + 1);
    if (lineIndex === -1)
      lineIndex = value.length;
    if (pipeIndex === -1 || pipeIndex > lineIndex) {
      if (lineCount < $560639d49e3c9a19$var$minRows)
        return;
      break;
    }
    lines.push(value.slice(index, lineIndex));
    lineCount++;
    index = lineIndex + 1;
  }
  subvalue = lines.join($560639d49e3c9a19$var$lineFeed$7);
  alignments = lines.splice(1, 1)[0] || [];
  index = 0;
  length = alignments.length;
  lineCount--;
  alignment = false;
  align = [];
  while (index < length) {
    character = alignments.charAt(index);
    if (character === $560639d49e3c9a19$var$verticalBar) {
      hasDash = null;
      if (alignment === false) {
        if (first === false)
          return;
      } else {
        align.push(alignment);
        alignment = false;
      }
      first = false;
    } else if (character === $560639d49e3c9a19$var$dash$4) {
      hasDash = true;
      alignment = alignment || null;
    } else if (character === $560639d49e3c9a19$var$colon$1) {
      if (alignment === $560639d49e3c9a19$var$left)
        alignment = $560639d49e3c9a19$var$center;
      else if (hasDash && alignment === null)
        alignment = $560639d49e3c9a19$var$right;
      else
        alignment = $560639d49e3c9a19$var$left;
    } else if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character))
      return;
    index++;
  }
  if (alignment !== false)
    align.push(alignment);
  if (align.length < $560639d49e3c9a19$var$minColumns)
    return;
  if (silent)
    return true;
  position = -1;
  rows = [];
  table = eat(subvalue).reset({
    type: "table",
    align,
    children: rows
  });
  while (++position < lineCount) {
    line = lines[position];
    row = {
      type: "tableRow",
      children: []
    };
    if (position)
      eat($560639d49e3c9a19$var$lineFeed$7);
    eat(line).reset(row, table);
    length = line.length + 1;
    index = 0;
    queue = "";
    cell = "";
    preamble = true;
    while (index < length) {
      character = line.charAt(index);
      if (character === $560639d49e3c9a19$var$tab$3 || character === $560639d49e3c9a19$var$space$7) {
        if (cell)
          queue += character;
        else
          eat(character);
        index++;
        continue;
      }
      if (character === "" || character === $560639d49e3c9a19$var$verticalBar) {
        if (preamble)
          eat(character);
        else {
          if ((cell || character) && !preamble) {
            subvalue = cell;
            if (queue.length > 1) {
              if (character) {
                subvalue += queue.slice(0, -1);
                queue = queue.charAt(queue.length - 1);
              } else {
                subvalue += queue;
                queue = "";
              }
            }
            now = eat.now();
            eat(subvalue)({
              type: "tableCell",
              children: self2.tokenizeInline(cell, now)
            }, row);
          }
          eat(queue + character);
          queue = "";
          cell = "";
        }
      } else {
        if (queue) {
          cell += queue;
          queue = "";
        }
        cell += character;
        if (character === $560639d49e3c9a19$var$backslash$5 && index !== length - 2) {
          cell += line.charAt(index + 1);
          index++;
        }
      }
      preamble = false;
      index++;
    }
    if (!position)
      eat($560639d49e3c9a19$var$lineFeed$7 + alignments);
  }
  return table;
}
var $560639d49e3c9a19$var$paragraph_1$1 = $560639d49e3c9a19$var$paragraph$1;
var $560639d49e3c9a19$var$tab$2 = "	";
var $560639d49e3c9a19$var$lineFeed$6 = "\n";
var $560639d49e3c9a19$var$space$6 = " ";
var $560639d49e3c9a19$var$tabSize = 4;
function $560639d49e3c9a19$var$paragraph$1(eat, value, silent) {
  var self2 = this;
  var settings = self2.options;
  var commonmark = settings.commonmark;
  var tokenizers = self2.blockTokenizers;
  var interruptors = self2.interruptParagraph;
  var index = value.indexOf($560639d49e3c9a19$var$lineFeed$6);
  var length = value.length;
  var position;
  var subvalue;
  var character;
  var size;
  var now;
  while (index < length) {
    if (index === -1) {
      index = length;
      break;
    }
    if (value.charAt(index + 1) === $560639d49e3c9a19$var$lineFeed$6)
      break;
    if (commonmark) {
      size = 0;
      position = index + 1;
      while (position < length) {
        character = value.charAt(position);
        if (character === $560639d49e3c9a19$var$tab$2) {
          size = $560639d49e3c9a19$var$tabSize;
          break;
        } else if (character === $560639d49e3c9a19$var$space$6)
          size++;
        else
          break;
        position++;
      }
      if (size >= $560639d49e3c9a19$var$tabSize && character !== $560639d49e3c9a19$var$lineFeed$6) {
        index = value.indexOf($560639d49e3c9a19$var$lineFeed$6, index + 1);
        continue;
      }
    }
    subvalue = value.slice(index + 1);
    if ($560639d49e3c9a19$var$interrupt_1(interruptors, tokenizers, self2, [
      eat,
      subvalue,
      true
    ]))
      break;
    position = index;
    index = value.indexOf($560639d49e3c9a19$var$lineFeed$6, index + 1);
    if (index !== -1 && $560639d49e3c9a19$var$trim_1(value.slice(position, index)) === "") {
      index = position;
      break;
    }
  }
  subvalue = value.slice(0, index);
  if (silent)
    return true;
  now = eat.now();
  subvalue = $560639d49e3c9a19$var$trimTrailingLines_1(subvalue);
  return eat(subvalue)({
    type: "paragraph",
    children: self2.tokenizeInline(subvalue, now)
  });
}
var $560639d49e3c9a19$var$_escape$1 = $560639d49e3c9a19$var$locate$9;
function $560639d49e3c9a19$var$locate$9(value, fromIndex) {
  return value.indexOf("\\", fromIndex);
}
var $560639d49e3c9a19$var$_escape = $560639d49e3c9a19$var$escape$1;
$560639d49e3c9a19$var$escape$1.locator = $560639d49e3c9a19$var$_escape$1;
var $560639d49e3c9a19$var$lineFeed$5 = "\n";
var $560639d49e3c9a19$var$backslash$4 = "\\";
function $560639d49e3c9a19$var$escape$1(eat, value, silent) {
  var self2 = this;
  var character;
  var node;
  if (value.charAt(0) === $560639d49e3c9a19$var$backslash$4) {
    character = value.charAt(1);
    if (self2.escape.indexOf(character) !== -1) {
      if (silent)
        return true;
      if (character === $560639d49e3c9a19$var$lineFeed$5)
        node = {
          type: "break"
        };
      else
        node = {
          type: "text",
          value: character
        };
      return eat($560639d49e3c9a19$var$backslash$4 + character)(node);
    }
  }
}
var $560639d49e3c9a19$var$tag$1 = $560639d49e3c9a19$var$locate$8;
function $560639d49e3c9a19$var$locate$8(value, fromIndex) {
  return value.indexOf("<", fromIndex);
}
var $560639d49e3c9a19$var$autoLink_1 = $560639d49e3c9a19$var$autoLink;
$560639d49e3c9a19$var$autoLink.locator = $560639d49e3c9a19$var$tag$1;
$560639d49e3c9a19$var$autoLink.notInLink = true;
var $560639d49e3c9a19$var$lessThan$5 = "<";
var $560639d49e3c9a19$var$greaterThan$2 = ">";
var $560639d49e3c9a19$var$atSign$1 = "@";
var $560639d49e3c9a19$var$slash$3 = "/";
var $560639d49e3c9a19$var$mailto = "mailto:";
var $560639d49e3c9a19$var$mailtoLength = $560639d49e3c9a19$var$mailto.length;
function $560639d49e3c9a19$var$autoLink(eat, value, silent) {
  var self2 = this;
  var subvalue = "";
  var length = value.length;
  var index = 0;
  var queue = "";
  var hasAtCharacter = false;
  var link = "";
  var character;
  var now;
  var content;
  var tokenizers;
  var exit;
  if (value.charAt(0) !== $560639d49e3c9a19$var$lessThan$5)
    return;
  index++;
  subvalue = $560639d49e3c9a19$var$lessThan$5;
  while (index < length) {
    character = value.charAt(index);
    if ($560639d49e3c9a19$var$isWhitespaceCharacter(character) || character === $560639d49e3c9a19$var$greaterThan$2 || character === $560639d49e3c9a19$var$atSign$1 || character === ":" && value.charAt(index + 1) === $560639d49e3c9a19$var$slash$3)
      break;
    queue += character;
    index++;
  }
  if (!queue)
    return;
  link += queue;
  queue = "";
  character = value.charAt(index);
  link += character;
  index++;
  if (character === $560639d49e3c9a19$var$atSign$1)
    hasAtCharacter = true;
  else {
    if (character !== ":" || value.charAt(index + 1) !== $560639d49e3c9a19$var$slash$3)
      return;
    link += $560639d49e3c9a19$var$slash$3;
    index++;
  }
  while (index < length) {
    character = value.charAt(index);
    if ($560639d49e3c9a19$var$isWhitespaceCharacter(character) || character === $560639d49e3c9a19$var$greaterThan$2)
      break;
    queue += character;
    index++;
  }
  character = value.charAt(index);
  if (!queue || character !== $560639d49e3c9a19$var$greaterThan$2)
    return;
  if (silent)
    return true;
  link += queue;
  content = link;
  subvalue += link + character;
  now = eat.now();
  now.column++;
  now.offset++;
  if (hasAtCharacter) {
    if (link.slice(0, $560639d49e3c9a19$var$mailtoLength).toLowerCase() === $560639d49e3c9a19$var$mailto) {
      content = content.slice($560639d49e3c9a19$var$mailtoLength);
      now.column += $560639d49e3c9a19$var$mailtoLength;
      now.offset += $560639d49e3c9a19$var$mailtoLength;
    } else
      link = $560639d49e3c9a19$var$mailto + link;
  }
  tokenizers = self2.inlineTokenizers;
  self2.inlineTokenizers = {
    text: tokenizers.text
  };
  exit = self2.enterLink();
  content = self2.tokenizeInline(content, now);
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat(subvalue)({
    type: "link",
    title: null,
    url: $560639d49e3c9a19$var$parseEntities_1(link, {
      nonTerminated: false
    }),
    children: content
  });
}
var $560639d49e3c9a19$var$ccount_1 = $560639d49e3c9a19$var$ccount;
function $560639d49e3c9a19$var$ccount(value, character) {
  var val = String(value);
  var count = 0;
  var index;
  if (typeof character !== "string" || character.length !== 1)
    throw new Error("Expected character");
  index = val.indexOf(character);
  while (index !== -1) {
    count++;
    index = val.indexOf(character, index + 1);
  }
  return count;
}
var $560639d49e3c9a19$var$url$1 = $560639d49e3c9a19$var$locate$7;
var $560639d49e3c9a19$var$values = [
  "www.",
  "http://",
  "https://"
];
function $560639d49e3c9a19$var$locate$7(value, fromIndex) {
  var min = -1;
  var index;
  var length;
  var position;
  if (!this.options.gfm)
    return min;
  length = $560639d49e3c9a19$var$values.length;
  index = -1;
  while (++index < length) {
    position = value.indexOf($560639d49e3c9a19$var$values[index], fromIndex);
    if (position !== -1 && (min === -1 || position < min))
      min = position;
  }
  return min;
}
var $560639d49e3c9a19$var$url_1 = $560639d49e3c9a19$var$url;
$560639d49e3c9a19$var$url.locator = $560639d49e3c9a19$var$url$1;
$560639d49e3c9a19$var$url.notInLink = true;
var $560639d49e3c9a19$var$exclamationMark$3 = 33;
var $560639d49e3c9a19$var$ampersand = 38;
var $560639d49e3c9a19$var$rightParenthesis$1 = 41;
var $560639d49e3c9a19$var$asterisk$2 = 42;
var $560639d49e3c9a19$var$comma$1 = 44;
var $560639d49e3c9a19$var$dash$3 = 45;
var $560639d49e3c9a19$var$dot$2 = 46;
var $560639d49e3c9a19$var$colon = 58;
var $560639d49e3c9a19$var$semicolon = 59;
var $560639d49e3c9a19$var$questionMark$1 = 63;
var $560639d49e3c9a19$var$lessThan$4 = 60;
var $560639d49e3c9a19$var$underscore$4 = 95;
var $560639d49e3c9a19$var$tilde$2 = 126;
var $560639d49e3c9a19$var$leftParenthesisCharacter = "(";
var $560639d49e3c9a19$var$rightParenthesisCharacter = ")";
function $560639d49e3c9a19$var$url(eat, value, silent) {
  var self2 = this;
  var gfm = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var length = value.length;
  var previousDot = -1;
  var protocolless = false;
  var dots;
  var lastTwoPartsStart;
  var start;
  var index;
  var pathStart;
  var path;
  var code;
  var end;
  var leftCount;
  var rightCount;
  var content;
  var children;
  var url;
  var exit;
  if (!gfm)
    return;
  if (value.slice(0, 4) === "www.") {
    protocolless = true;
    index = 4;
  } else if (value.slice(0, 7).toLowerCase() === "http://")
    index = 7;
  else if (value.slice(0, 8).toLowerCase() === "https://")
    index = 8;
  else
    return;
  previousDot = index - 1;
  start = index;
  dots = [];
  while (index < length) {
    code = value.charCodeAt(index);
    if (code === $560639d49e3c9a19$var$dot$2) {
      if (previousDot === index - 1)
        break;
      dots.push(index);
      previousDot = index;
      index++;
      continue;
    }
    if ($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$dash$3 || code === $560639d49e3c9a19$var$underscore$4) {
      index++;
      continue;
    }
    break;
  }
  if (code === $560639d49e3c9a19$var$dot$2) {
    dots.pop();
    index--;
  }
  if (dots[0] === void 0)
    return;
  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;
  if (value.slice(lastTwoPartsStart, index).indexOf("_") !== -1)
    return;
  if (silent)
    return true;
  end = index;
  pathStart = index;
  while (index < length) {
    code = value.charCodeAt(index);
    if ($560639d49e3c9a19$var$isWhitespaceCharacter(code) || code === $560639d49e3c9a19$var$lessThan$4)
      break;
    index++;
    if (code === $560639d49e3c9a19$var$exclamationMark$3 || code === $560639d49e3c9a19$var$asterisk$2 || code === $560639d49e3c9a19$var$comma$1 || code === $560639d49e3c9a19$var$dot$2 || code === $560639d49e3c9a19$var$colon || code === $560639d49e3c9a19$var$questionMark$1 || code === $560639d49e3c9a19$var$underscore$4 || code === $560639d49e3c9a19$var$tilde$2)
      ;
    else
      end = index;
  }
  index = end;
  if (value.charCodeAt(index - 1) === $560639d49e3c9a19$var$rightParenthesis$1) {
    path = value.slice(pathStart, index);
    leftCount = $560639d49e3c9a19$var$ccount_1(path, $560639d49e3c9a19$var$leftParenthesisCharacter);
    rightCount = $560639d49e3c9a19$var$ccount_1(path, $560639d49e3c9a19$var$rightParenthesisCharacter);
    while (rightCount > leftCount) {
      index = pathStart + path.lastIndexOf($560639d49e3c9a19$var$rightParenthesisCharacter);
      path = value.slice(pathStart, index);
      rightCount--;
    }
  }
  if (value.charCodeAt(index - 1) === $560639d49e3c9a19$var$semicolon) {
    index--;
    if ($560639d49e3c9a19$var$isAlphabetical(value.charCodeAt(index - 1))) {
      end = index - 2;
      while ($560639d49e3c9a19$var$isAlphabetical(value.charCodeAt(end)))
        end--;
      if (value.charCodeAt(end) === $560639d49e3c9a19$var$ampersand)
        index = end;
    }
  }
  content = value.slice(0, index);
  url = $560639d49e3c9a19$var$parseEntities_1(content, {
    nonTerminated: false
  });
  if (protocolless)
    url = "http://" + url;
  exit = self2.enterLink();
  self2.inlineTokenizers = {
    text: tokenizers.text
  };
  children = self2.tokenizeInline(content, eat.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat(content)({
    type: "link",
    title: null,
    url,
    children
  });
}
var $560639d49e3c9a19$var$plusSign$1 = 43;
var $560639d49e3c9a19$var$dash$2 = 45;
var $560639d49e3c9a19$var$dot$1 = 46;
var $560639d49e3c9a19$var$underscore$3 = 95;
var $560639d49e3c9a19$var$email$1 = $560639d49e3c9a19$var$locate$6;
function $560639d49e3c9a19$var$locate$6(value, fromIndex) {
  var self2 = this;
  var at;
  var position;
  if (!this.options.gfm)
    return -1;
  at = value.indexOf("@", fromIndex);
  if (at === -1)
    return -1;
  position = at;
  if (position === fromIndex || !$560639d49e3c9a19$var$isGfmAtext(value.charCodeAt(position - 1)))
    return $560639d49e3c9a19$var$locate$6.call(self2, value, at + 1);
  while (position > fromIndex && $560639d49e3c9a19$var$isGfmAtext(value.charCodeAt(position - 1)))
    position--;
  return position;
}
function $560639d49e3c9a19$var$isGfmAtext(code) {
  return $560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$plusSign$1 || code === $560639d49e3c9a19$var$dash$2 || code === $560639d49e3c9a19$var$dot$1 || code === $560639d49e3c9a19$var$underscore$3;
}
var $560639d49e3c9a19$var$email_1 = $560639d49e3c9a19$var$email;
$560639d49e3c9a19$var$email.locator = $560639d49e3c9a19$var$email$1;
$560639d49e3c9a19$var$email.notInLink = true;
var $560639d49e3c9a19$var$plusSign = 43;
var $560639d49e3c9a19$var$dash$1 = 45;
var $560639d49e3c9a19$var$dot = 46;
var $560639d49e3c9a19$var$atSign = 64;
var $560639d49e3c9a19$var$underscore$2 = 95;
function $560639d49e3c9a19$var$email(eat, value, silent) {
  var self2 = this;
  var gfm = self2.options.gfm;
  var tokenizers = self2.inlineTokenizers;
  var index = 0;
  var length = value.length;
  var firstDot = -1;
  var code;
  var content;
  var children;
  var exit;
  if (!gfm)
    return;
  code = value.charCodeAt(index);
  while ($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$plusSign || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$dot || code === $560639d49e3c9a19$var$underscore$2)
    code = value.charCodeAt(++index);
  if (index === 0)
    return;
  if (code !== $560639d49e3c9a19$var$atSign)
    return;
  index++;
  while (index < length) {
    code = value.charCodeAt(index);
    if ($560639d49e3c9a19$var$isDecimal(code) || $560639d49e3c9a19$var$isAlphabetical(code) || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$dot || code === $560639d49e3c9a19$var$underscore$2) {
      index++;
      if (firstDot === -1 && code === $560639d49e3c9a19$var$dot)
        firstDot = index;
      continue;
    }
    break;
  }
  if (firstDot === -1 || firstDot === index || code === $560639d49e3c9a19$var$dash$1 || code === $560639d49e3c9a19$var$underscore$2)
    return;
  if (code === $560639d49e3c9a19$var$dot)
    index--;
  content = value.slice(0, index);
  if (silent)
    return true;
  exit = self2.enterLink();
  self2.inlineTokenizers = {
    text: tokenizers.text
  };
  children = self2.tokenizeInline(content, eat.now());
  self2.inlineTokenizers = tokenizers;
  exit();
  return eat(content)({
    type: "link",
    title: null,
    url: "mailto:" + $560639d49e3c9a19$var$parseEntities_1(content, {
      nonTerminated: false
    }),
    children
  });
}
var $560639d49e3c9a19$var$tag = $560639d49e3c9a19$var$html$4.tag;
var $560639d49e3c9a19$var$htmlInline = $560639d49e3c9a19$var$inlineHTML;
$560639d49e3c9a19$var$inlineHTML.locator = $560639d49e3c9a19$var$tag$1;
var $560639d49e3c9a19$var$lessThan$3 = "<";
var $560639d49e3c9a19$var$questionMark = "?";
var $560639d49e3c9a19$var$exclamationMark$2 = "!";
var $560639d49e3c9a19$var$slash$2 = "/";
var $560639d49e3c9a19$var$htmlLinkOpenExpression = /^<a /i;
var $560639d49e3c9a19$var$htmlLinkCloseExpression = /^<\/a>/i;
function $560639d49e3c9a19$var$inlineHTML(eat, value, silent) {
  var self2 = this;
  var length = value.length;
  var character;
  var subvalue;
  if (value.charAt(0) !== $560639d49e3c9a19$var$lessThan$3 || length < 3)
    return;
  character = value.charAt(1);
  if (!$560639d49e3c9a19$var$isAlphabetical(character) && character !== $560639d49e3c9a19$var$questionMark && character !== $560639d49e3c9a19$var$exclamationMark$2 && character !== $560639d49e3c9a19$var$slash$2)
    return;
  subvalue = value.match($560639d49e3c9a19$var$tag);
  if (!subvalue)
    return;
  if (silent)
    return true;
  subvalue = subvalue[0];
  if (!self2.inLink && $560639d49e3c9a19$var$htmlLinkOpenExpression.test(subvalue))
    self2.inLink = true;
  else if (self2.inLink && $560639d49e3c9a19$var$htmlLinkCloseExpression.test(subvalue))
    self2.inLink = false;
  return eat(subvalue)({
    type: "html",
    value: subvalue
  });
}
var $560639d49e3c9a19$var$link$3 = $560639d49e3c9a19$var$locate$5;
function $560639d49e3c9a19$var$locate$5(value, fromIndex) {
  var link = value.indexOf("[", fromIndex);
  var image = value.indexOf("![", fromIndex);
  if (image === -1)
    return link;
  return link < image ? link : image;
}
var $560639d49e3c9a19$var$link_1$1 = $560639d49e3c9a19$var$link$2;
$560639d49e3c9a19$var$link$2.locator = $560639d49e3c9a19$var$link$3;
var $560639d49e3c9a19$var$lineFeed$4 = "\n";
var $560639d49e3c9a19$var$exclamationMark$1 = "!";
var $560639d49e3c9a19$var$quotationMark$1 = '"';
var $560639d49e3c9a19$var$apostrophe$2 = "'";
var $560639d49e3c9a19$var$leftParenthesis = "(";
var $560639d49e3c9a19$var$rightParenthesis = ")";
var $560639d49e3c9a19$var$lessThan$2 = "<";
var $560639d49e3c9a19$var$greaterThan$1 = ">";
var $560639d49e3c9a19$var$leftSquareBracket$1 = "[";
var $560639d49e3c9a19$var$backslash$3 = "\\";
var $560639d49e3c9a19$var$rightSquareBracket$1 = "]";
var $560639d49e3c9a19$var$graveAccent$1 = "`";
function $560639d49e3c9a19$var$link$2(eat, value, silent) {
  var self2 = this;
  var subvalue = "";
  var index = 0;
  var character = value.charAt(0);
  var pedantic = self2.options.pedantic;
  var commonmark = self2.options.commonmark;
  var gfm = self2.options.gfm;
  var closed;
  var count;
  var opening;
  var beforeURL;
  var beforeTitle;
  var subqueue;
  var hasMarker;
  var isImage;
  var content;
  var marker;
  var length;
  var title;
  var depth;
  var queue;
  var url;
  var now;
  var exit;
  var node;
  if (character === $560639d49e3c9a19$var$exclamationMark$1) {
    isImage = true;
    subvalue = character;
    character = value.charAt(++index);
  }
  if (character !== $560639d49e3c9a19$var$leftSquareBracket$1)
    return;
  if (!isImage && self2.inLink)
    return;
  subvalue += character;
  queue = "";
  index++;
  length = value.length;
  now = eat.now();
  depth = 0;
  now.column += index;
  now.offset += index;
  while (index < length) {
    character = value.charAt(index);
    subqueue = character;
    if (character === $560639d49e3c9a19$var$graveAccent$1) {
      count = 1;
      while (value.charAt(index + 1) === $560639d49e3c9a19$var$graveAccent$1) {
        subqueue += character;
        index++;
        count++;
      }
      if (!opening)
        opening = count;
      else if (count >= opening)
        opening = 0;
    } else if (character === $560639d49e3c9a19$var$backslash$3) {
      index++;
      subqueue += value.charAt(index);
    } else if ((!opening || gfm) && character === $560639d49e3c9a19$var$leftSquareBracket$1)
      depth++;
    else if ((!opening || gfm) && character === $560639d49e3c9a19$var$rightSquareBracket$1) {
      if (depth)
        depth--;
      else {
        if (value.charAt(index + 1) !== $560639d49e3c9a19$var$leftParenthesis)
          return;
        subqueue += $560639d49e3c9a19$var$leftParenthesis;
        closed = true;
        index++;
        break;
      }
    }
    queue += subqueue;
    subqueue = "";
    index++;
  }
  if (!closed)
    return;
  content = queue;
  subvalue += queue + subqueue;
  index++;
  while (index < length) {
    character = value.charAt(index);
    if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character))
      break;
    subvalue += character;
    index++;
  }
  character = value.charAt(index);
  queue = "";
  beforeURL = subvalue;
  if (character === $560639d49e3c9a19$var$lessThan$2) {
    index++;
    beforeURL += $560639d49e3c9a19$var$lessThan$2;
    while (index < length) {
      character = value.charAt(index);
      if (character === $560639d49e3c9a19$var$greaterThan$1)
        break;
      if (commonmark && character === $560639d49e3c9a19$var$lineFeed$4)
        return;
      queue += character;
      index++;
    }
    if (value.charAt(index) !== $560639d49e3c9a19$var$greaterThan$1)
      return;
    subvalue += $560639d49e3c9a19$var$lessThan$2 + queue + $560639d49e3c9a19$var$greaterThan$1;
    url = queue;
    index++;
  } else {
    character = null;
    subqueue = "";
    while (index < length) {
      character = value.charAt(index);
      if (subqueue && (character === $560639d49e3c9a19$var$quotationMark$1 || character === $560639d49e3c9a19$var$apostrophe$2 || commonmark && character === $560639d49e3c9a19$var$leftParenthesis))
        break;
      if ($560639d49e3c9a19$var$isWhitespaceCharacter(character)) {
        if (!pedantic)
          break;
        subqueue += character;
      } else {
        if (character === $560639d49e3c9a19$var$leftParenthesis)
          depth++;
        else if (character === $560639d49e3c9a19$var$rightParenthesis) {
          if (depth === 0)
            break;
          depth--;
        }
        queue += subqueue;
        subqueue = "";
        if (character === $560639d49e3c9a19$var$backslash$3) {
          queue += $560639d49e3c9a19$var$backslash$3;
          character = value.charAt(++index);
        }
        queue += character;
      }
      index++;
    }
    subvalue += queue;
    url = queue;
    index = subvalue.length;
  }
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character))
      break;
    queue += character;
    index++;
  }
  character = value.charAt(index);
  subvalue += queue;
  if (queue && (character === $560639d49e3c9a19$var$quotationMark$1 || character === $560639d49e3c9a19$var$apostrophe$2 || commonmark && character === $560639d49e3c9a19$var$leftParenthesis)) {
    index++;
    subvalue += character;
    queue = "";
    marker = character === $560639d49e3c9a19$var$leftParenthesis ? $560639d49e3c9a19$var$rightParenthesis : character;
    beforeTitle = subvalue;
    if (commonmark) {
      while (index < length) {
        character = value.charAt(index);
        if (character === marker)
          break;
        if (character === $560639d49e3c9a19$var$backslash$3) {
          queue += $560639d49e3c9a19$var$backslash$3;
          character = value.charAt(++index);
        }
        index++;
        queue += character;
      }
      character = value.charAt(index);
      if (character !== marker)
        return;
      title = queue;
      subvalue += queue + character;
      index++;
      while (index < length) {
        character = value.charAt(index);
        if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character))
          break;
        subvalue += character;
        index++;
      }
    } else {
      subqueue = "";
      while (index < length) {
        character = value.charAt(index);
        if (character === marker) {
          if (hasMarker) {
            queue += marker + subqueue;
            subqueue = "";
          }
          hasMarker = true;
        } else if (!hasMarker)
          queue += character;
        else if (character === $560639d49e3c9a19$var$rightParenthesis) {
          subvalue += queue + marker + subqueue;
          title = queue;
          break;
        } else if ($560639d49e3c9a19$var$isWhitespaceCharacter(character))
          subqueue += character;
        else {
          queue += marker + subqueue + character;
          subqueue = "";
          hasMarker = false;
        }
        index++;
      }
    }
  }
  if (value.charAt(index) !== $560639d49e3c9a19$var$rightParenthesis)
    return;
  if (silent)
    return true;
  subvalue += $560639d49e3c9a19$var$rightParenthesis;
  url = self2.decode.raw(self2.unescape(url), eat(beforeURL).test().end, {
    nonTerminated: false
  });
  if (title) {
    beforeTitle = eat(beforeTitle).test().end;
    title = self2.decode.raw(self2.unescape(title), beforeTitle);
  }
  node = {
    type: isImage ? "image" : "link",
    title: title || null,
    url
  };
  if (isImage)
    node.alt = self2.decode.raw(self2.unescape(content), now) || null;
  else {
    exit = self2.enterLink();
    node.children = self2.tokenizeInline(content, now);
    exit();
  }
  return eat(subvalue)(node);
}
var $560639d49e3c9a19$var$reference_1 = $560639d49e3c9a19$var$reference;
$560639d49e3c9a19$var$reference.locator = $560639d49e3c9a19$var$link$3;
var $560639d49e3c9a19$var$link$1 = "link";
var $560639d49e3c9a19$var$image$2 = "image";
var $560639d49e3c9a19$var$shortcut = "shortcut";
var $560639d49e3c9a19$var$collapsed = "collapsed";
var $560639d49e3c9a19$var$full = "full";
var $560639d49e3c9a19$var$exclamationMark = "!";
var $560639d49e3c9a19$var$leftSquareBracket = "[";
var $560639d49e3c9a19$var$backslash$2 = "\\";
var $560639d49e3c9a19$var$rightSquareBracket = "]";
function $560639d49e3c9a19$var$reference(eat, value, silent) {
  var self2 = this;
  var commonmark = self2.options.commonmark;
  var character = value.charAt(0);
  var index = 0;
  var length = value.length;
  var subvalue = "";
  var intro = "";
  var type = $560639d49e3c9a19$var$link$1;
  var referenceType = $560639d49e3c9a19$var$shortcut;
  var content;
  var identifier;
  var now;
  var node;
  var exit;
  var queue;
  var bracketed;
  var depth;
  if (character === $560639d49e3c9a19$var$exclamationMark) {
    type = $560639d49e3c9a19$var$image$2;
    intro = character;
    character = value.charAt(++index);
  }
  if (character !== $560639d49e3c9a19$var$leftSquareBracket)
    return;
  index++;
  intro += character;
  queue = "";
  depth = 0;
  while (index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$leftSquareBracket) {
      bracketed = true;
      depth++;
    } else if (character === $560639d49e3c9a19$var$rightSquareBracket) {
      if (!depth)
        break;
      depth--;
    }
    if (character === $560639d49e3c9a19$var$backslash$2) {
      queue += $560639d49e3c9a19$var$backslash$2;
      character = value.charAt(++index);
    }
    queue += character;
    index++;
  }
  subvalue = queue;
  content = queue;
  character = value.charAt(index);
  if (character !== $560639d49e3c9a19$var$rightSquareBracket)
    return;
  index++;
  subvalue += character;
  queue = "";
  if (!commonmark)
    while (index < length) {
      character = value.charAt(index);
      if (!$560639d49e3c9a19$var$isWhitespaceCharacter(character))
        break;
      queue += character;
      index++;
    }
  character = value.charAt(index);
  if (character === $560639d49e3c9a19$var$leftSquareBracket) {
    identifier = "";
    queue += character;
    index++;
    while (index < length) {
      character = value.charAt(index);
      if (character === $560639d49e3c9a19$var$leftSquareBracket || character === $560639d49e3c9a19$var$rightSquareBracket)
        break;
      if (character === $560639d49e3c9a19$var$backslash$2) {
        identifier += $560639d49e3c9a19$var$backslash$2;
        character = value.charAt(++index);
      }
      identifier += character;
      index++;
    }
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$rightSquareBracket) {
      referenceType = identifier ? $560639d49e3c9a19$var$full : $560639d49e3c9a19$var$collapsed;
      queue += identifier + character;
      index++;
    } else
      identifier = "";
    subvalue += queue;
    queue = "";
  } else {
    if (!content)
      return;
    identifier = content;
  }
  if (referenceType !== $560639d49e3c9a19$var$full && bracketed)
    return;
  subvalue = intro + subvalue;
  if (type === $560639d49e3c9a19$var$link$1 && self2.inLink)
    return null;
  if (silent)
    return true;
  now = eat.now();
  now.column += intro.length;
  now.offset += intro.length;
  identifier = referenceType === $560639d49e3c9a19$var$full ? identifier : content;
  node = {
    type: type + "Reference",
    identifier: $560639d49e3c9a19$var$normalize_1$1(identifier),
    label: identifier,
    referenceType
  };
  if (type === $560639d49e3c9a19$var$link$1) {
    exit = self2.enterLink();
    node.children = self2.tokenizeInline(content, now);
    exit();
  } else
    node.alt = self2.decode.raw(self2.unescape(content), now) || null;
  return eat(subvalue)(node);
}
var $560639d49e3c9a19$var$strong$2 = $560639d49e3c9a19$var$locate$4;
function $560639d49e3c9a19$var$locate$4(value, fromIndex) {
  var asterisk = value.indexOf("**", fromIndex);
  var underscore = value.indexOf("__", fromIndex);
  if (underscore === -1)
    return asterisk;
  if (asterisk === -1)
    return underscore;
  return underscore < asterisk ? underscore : asterisk;
}
var $560639d49e3c9a19$var$strong_1$1 = $560639d49e3c9a19$var$strong$1;
$560639d49e3c9a19$var$strong$1.locator = $560639d49e3c9a19$var$strong$2;
var $560639d49e3c9a19$var$backslash$1 = "\\";
var $560639d49e3c9a19$var$asterisk$1 = "*";
var $560639d49e3c9a19$var$underscore$1 = "_";
function $560639d49e3c9a19$var$strong$1(eat, value, silent) {
  var self2 = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var previous;
  if (character !== $560639d49e3c9a19$var$asterisk$1 && character !== $560639d49e3c9a19$var$underscore$1 || value.charAt(++index) !== character)
    return;
  pedantic = self2.options.pedantic;
  marker = character;
  subvalue = marker + marker;
  length = value.length;
  index++;
  queue = "";
  character = "";
  if (pedantic && $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(index)))
    return;
  while (index < length) {
    previous = character;
    character = value.charAt(index);
    if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !$560639d49e3c9a19$var$isWhitespaceCharacter(previous))) {
      character = value.charAt(index + 2);
      if (character !== marker) {
        if (!$560639d49e3c9a19$var$trim_1(queue))
          return;
        if (silent)
          return true;
        now = eat.now();
        now.column += 2;
        now.offset += 2;
        return eat(subvalue + queue + subvalue)({
          type: "strong",
          children: self2.tokenizeInline(queue, now)
        });
      }
    }
    if (!pedantic && character === $560639d49e3c9a19$var$backslash$1) {
      queue += character;
      character = value.charAt(++index);
    }
    queue += character;
    index++;
  }
}
var $560639d49e3c9a19$var$isWordCharacter = $560639d49e3c9a19$var$wordCharacter;
var $560639d49e3c9a19$var$fromCode = String.fromCharCode;
var $560639d49e3c9a19$var$re$1 = /\w/;
function $560639d49e3c9a19$var$wordCharacter(character) {
  return $560639d49e3c9a19$var$re$1.test(typeof character === "number" ? $560639d49e3c9a19$var$fromCode(character) : character.charAt(0));
}
var $560639d49e3c9a19$var$emphasis$2 = $560639d49e3c9a19$var$locate$3;
function $560639d49e3c9a19$var$locate$3(value, fromIndex) {
  var asterisk = value.indexOf("*", fromIndex);
  var underscore = value.indexOf("_", fromIndex);
  if (underscore === -1)
    return asterisk;
  if (asterisk === -1)
    return underscore;
  return underscore < asterisk ? underscore : asterisk;
}
var $560639d49e3c9a19$var$emphasis_1$1 = $560639d49e3c9a19$var$emphasis$1;
$560639d49e3c9a19$var$emphasis$1.locator = $560639d49e3c9a19$var$emphasis$2;
var $560639d49e3c9a19$var$asterisk = "*";
var $560639d49e3c9a19$var$underscore = "_";
var $560639d49e3c9a19$var$backslash = "\\";
function $560639d49e3c9a19$var$emphasis$1(eat, value, silent) {
  var self2 = this;
  var index = 0;
  var character = value.charAt(index);
  var now;
  var pedantic;
  var marker;
  var queue;
  var subvalue;
  var length;
  var previous;
  if (character !== $560639d49e3c9a19$var$asterisk && character !== $560639d49e3c9a19$var$underscore)
    return;
  pedantic = self2.options.pedantic;
  subvalue = character;
  marker = character;
  length = value.length;
  index++;
  queue = "";
  character = "";
  if (pedantic && $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(index)))
    return;
  while (index < length) {
    previous = character;
    character = value.charAt(index);
    if (character === marker && (!pedantic || !$560639d49e3c9a19$var$isWhitespaceCharacter(previous))) {
      character = value.charAt(++index);
      if (character !== marker) {
        if (!$560639d49e3c9a19$var$trim_1(queue) || previous === marker)
          return;
        if (!pedantic && marker === $560639d49e3c9a19$var$underscore && $560639d49e3c9a19$var$isWordCharacter(character)) {
          queue += marker;
          continue;
        }
        if (silent)
          return true;
        now = eat.now();
        now.column++;
        now.offset++;
        return eat(subvalue + queue + marker)({
          type: "emphasis",
          children: self2.tokenizeInline(queue, now)
        });
      }
      queue += marker;
    }
    if (!pedantic && character === $560639d49e3c9a19$var$backslash) {
      queue += character;
      character = value.charAt(++index);
    }
    queue += character;
    index++;
  }
}
var $560639d49e3c9a19$var$_delete$2 = $560639d49e3c9a19$var$locate$2;
function $560639d49e3c9a19$var$locate$2(value, fromIndex) {
  return value.indexOf("~~", fromIndex);
}
var $560639d49e3c9a19$var$_delete$1 = $560639d49e3c9a19$var$strikethrough$1;
$560639d49e3c9a19$var$strikethrough$1.locator = $560639d49e3c9a19$var$_delete$2;
var $560639d49e3c9a19$var$tilde$1 = "~";
var $560639d49e3c9a19$var$fence$1 = "~~";
function $560639d49e3c9a19$var$strikethrough$1(eat, value, silent) {
  var self2 = this;
  var character = "";
  var previous = "";
  var preceding = "";
  var subvalue = "";
  var index;
  var length;
  var now;
  if (!self2.options.gfm || value.charAt(0) !== $560639d49e3c9a19$var$tilde$1 || value.charAt(1) !== $560639d49e3c9a19$var$tilde$1 || $560639d49e3c9a19$var$isWhitespaceCharacter(value.charAt(2)))
    return;
  index = 1;
  length = value.length;
  now = eat.now();
  now.column += 2;
  now.offset += 2;
  while (++index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$tilde$1 && previous === $560639d49e3c9a19$var$tilde$1 && (!preceding || !$560639d49e3c9a19$var$isWhitespaceCharacter(preceding))) {
      if (silent)
        return true;
      return eat($560639d49e3c9a19$var$fence$1 + subvalue + $560639d49e3c9a19$var$fence$1)({
        type: "delete",
        children: self2.tokenizeInline(subvalue, now)
      });
    }
    subvalue += previous;
    preceding = previous;
    previous = character;
  }
}
var $560639d49e3c9a19$var$codeInline$1 = $560639d49e3c9a19$var$locate$1;
function $560639d49e3c9a19$var$locate$1(value, fromIndex) {
  return value.indexOf("`", fromIndex);
}
var $560639d49e3c9a19$var$codeInline = $560639d49e3c9a19$var$inlineCode$1;
$560639d49e3c9a19$var$inlineCode$1.locator = $560639d49e3c9a19$var$codeInline$1;
var $560639d49e3c9a19$var$lineFeed$3 = 10;
var $560639d49e3c9a19$var$space$5 = 32;
var $560639d49e3c9a19$var$graveAccent = 96;
function $560639d49e3c9a19$var$inlineCode$1(eat, value, silent) {
  var length = value.length;
  var index = 0;
  var openingFenceEnd;
  var closingFenceStart;
  var closingFenceEnd;
  var code;
  var next;
  var found;
  while (index < length) {
    if (value.charCodeAt(index) !== $560639d49e3c9a19$var$graveAccent)
      break;
    index++;
  }
  if (index === 0 || index === length)
    return;
  openingFenceEnd = index;
  next = value.charCodeAt(index);
  while (index < length) {
    code = next;
    next = value.charCodeAt(index + 1);
    if (code === $560639d49e3c9a19$var$graveAccent) {
      if (closingFenceStart === void 0)
        closingFenceStart = index;
      closingFenceEnd = index + 1;
      if (next !== $560639d49e3c9a19$var$graveAccent && closingFenceEnd - closingFenceStart === openingFenceEnd) {
        found = true;
        break;
      }
    } else if (closingFenceStart !== void 0) {
      closingFenceStart = void 0;
      closingFenceEnd = void 0;
    }
    index++;
  }
  if (!found)
    return;
  if (silent)
    return true;
  index = openingFenceEnd;
  length = closingFenceStart;
  code = value.charCodeAt(index);
  next = value.charCodeAt(length - 1);
  found = false;
  if (length - index > 2 && (code === $560639d49e3c9a19$var$space$5 || code === $560639d49e3c9a19$var$lineFeed$3) && (next === $560639d49e3c9a19$var$space$5 || next === $560639d49e3c9a19$var$lineFeed$3)) {
    index++;
    length--;
    while (index < length) {
      code = value.charCodeAt(index);
      if (code !== $560639d49e3c9a19$var$space$5 && code !== $560639d49e3c9a19$var$lineFeed$3) {
        found = true;
        break;
      }
      index++;
    }
    if (found === true) {
      openingFenceEnd++;
      closingFenceStart--;
    }
  }
  return eat(value.slice(0, closingFenceEnd))({
    type: "inlineCode",
    value: value.slice(openingFenceEnd, closingFenceStart)
  });
}
var $560639d49e3c9a19$var$_break$2 = $560639d49e3c9a19$var$locate;
function $560639d49e3c9a19$var$locate(value, fromIndex) {
  var index = value.indexOf("\n", fromIndex);
  while (index > fromIndex) {
    if (value.charAt(index - 1) !== " ")
      break;
    index--;
  }
  return index;
}
var $560639d49e3c9a19$var$_break$1 = $560639d49e3c9a19$var$hardBreak$1;
$560639d49e3c9a19$var$hardBreak$1.locator = $560639d49e3c9a19$var$_break$2;
var $560639d49e3c9a19$var$space$4 = " ";
var $560639d49e3c9a19$var$lineFeed$2 = "\n";
var $560639d49e3c9a19$var$minBreakLength = 2;
function $560639d49e3c9a19$var$hardBreak$1(eat, value, silent) {
  var length = value.length;
  var index = -1;
  var queue = "";
  var character;
  while (++index < length) {
    character = value.charAt(index);
    if (character === $560639d49e3c9a19$var$lineFeed$2) {
      if (index < $560639d49e3c9a19$var$minBreakLength)
        return;
      if (silent)
        return true;
      queue += character;
      return eat(queue)({
        type: "break"
      });
    }
    if (character !== $560639d49e3c9a19$var$space$4)
      return;
    queue += character;
  }
}
var $560639d49e3c9a19$var$text_1$2 = $560639d49e3c9a19$var$text$3;
function $560639d49e3c9a19$var$text$3(eat, value, silent) {
  var self2 = this;
  var methods;
  var tokenizers;
  var index;
  var length;
  var subvalue;
  var position;
  var tokenizer;
  var name;
  var min;
  var now;
  if (silent)
    return true;
  methods = self2.inlineMethods;
  length = methods.length;
  tokenizers = self2.inlineTokenizers;
  index = -1;
  min = value.length;
  while (++index < length) {
    name = methods[index];
    if (name === "text" || !tokenizers[name])
      continue;
    tokenizer = tokenizers[name].locator;
    if (!tokenizer)
      eat.file.fail("Missing locator: `" + name + "`");
    position = tokenizer.call(self2, value, 1);
    if (position !== -1 && position < min)
      min = position;
  }
  subvalue = value.slice(0, min);
  now = eat.now();
  self2.decode(subvalue, now, handler);
  function handler(content, position2, source) {
    eat(source || content)({
      type: "text",
      value: content
    });
  }
}
var $560639d49e3c9a19$var$parser$1 = $560639d49e3c9a19$var$Parser;
function $560639d49e3c9a19$var$Parser(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = $560639d49e3c9a19$var$immutable(this.options);
  this.setOptions({});
  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;
  this.toOffset = $560639d49e3c9a19$var$vfileLocation(file).toOffset;
  this.unescape = $560639d49e3c9a19$var$_unescape(this, "escape");
  this.decode = $560639d49e3c9a19$var$decode(this);
}
var $560639d49e3c9a19$var$proto$3 = $560639d49e3c9a19$var$Parser.prototype;
$560639d49e3c9a19$var$proto$3.setOptions = $560639d49e3c9a19$var$setOptions_1;
$560639d49e3c9a19$var$proto$3.parse = $560639d49e3c9a19$var$parse_1$2;
$560639d49e3c9a19$var$proto$3.options = $560639d49e3c9a19$var$defaults$1;
$560639d49e3c9a19$var$proto$3.exitStart = $560639d49e3c9a19$var$stateToggle("atStart", true);
$560639d49e3c9a19$var$proto$3.enterList = $560639d49e3c9a19$var$stateToggle("inList", false);
$560639d49e3c9a19$var$proto$3.enterLink = $560639d49e3c9a19$var$stateToggle("inLink", false);
$560639d49e3c9a19$var$proto$3.enterBlock = $560639d49e3c9a19$var$stateToggle("inBlock", false);
$560639d49e3c9a19$var$proto$3.interruptParagraph = [
  [
    "thematicBreak"
  ],
  [
    "list"
  ],
  [
    "atxHeading"
  ],
  [
    "fencedCode"
  ],
  [
    "blockquote"
  ],
  [
    "html"
  ],
  [
    "setextHeading",
    {
      commonmark: false
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$560639d49e3c9a19$var$proto$3.interruptList = [
  [
    "atxHeading",
    {
      pedantic: false
    }
  ],
  [
    "fencedCode",
    {
      pedantic: false
    }
  ],
  [
    "thematicBreak",
    {
      pedantic: false
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$560639d49e3c9a19$var$proto$3.interruptBlockquote = [
  [
    "indentedCode",
    {
      commonmark: true
    }
  ],
  [
    "fencedCode",
    {
      commonmark: true
    }
  ],
  [
    "atxHeading",
    {
      commonmark: true
    }
  ],
  [
    "setextHeading",
    {
      commonmark: true
    }
  ],
  [
    "thematicBreak",
    {
      commonmark: true
    }
  ],
  [
    "html",
    {
      commonmark: true
    }
  ],
  [
    "list",
    {
      commonmark: true
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$560639d49e3c9a19$var$proto$3.blockTokenizers = {
  blankLine: $560639d49e3c9a19$var$blankLine_1,
  indentedCode: $560639d49e3c9a19$var$codeIndented,
  fencedCode: $560639d49e3c9a19$var$codeFenced,
  blockquote: $560639d49e3c9a19$var$blockquote_1$1,
  atxHeading: $560639d49e3c9a19$var$headingAtx,
  thematicBreak: $560639d49e3c9a19$var$thematicBreak_1$1,
  list: $560639d49e3c9a19$var$list_1$1,
  setextHeading: $560639d49e3c9a19$var$headingSetext,
  html: $560639d49e3c9a19$var$htmlBlock,
  definition: $560639d49e3c9a19$var$definition_1,
  table: $560639d49e3c9a19$var$table_1$1,
  paragraph: $560639d49e3c9a19$var$paragraph_1$1
};
$560639d49e3c9a19$var$proto$3.inlineTokenizers = {
  escape: $560639d49e3c9a19$var$_escape,
  autoLink: $560639d49e3c9a19$var$autoLink_1,
  url: $560639d49e3c9a19$var$url_1,
  email: $560639d49e3c9a19$var$email_1,
  html: $560639d49e3c9a19$var$htmlInline,
  link: $560639d49e3c9a19$var$link_1$1,
  reference: $560639d49e3c9a19$var$reference_1,
  strong: $560639d49e3c9a19$var$strong_1$1,
  emphasis: $560639d49e3c9a19$var$emphasis_1$1,
  deletion: $560639d49e3c9a19$var$_delete$1,
  code: $560639d49e3c9a19$var$codeInline,
  break: $560639d49e3c9a19$var$_break$1,
  text: $560639d49e3c9a19$var$text_1$2
};
$560639d49e3c9a19$var$proto$3.blockMethods = $560639d49e3c9a19$var$keys$1($560639d49e3c9a19$var$proto$3.blockTokenizers);
$560639d49e3c9a19$var$proto$3.inlineMethods = $560639d49e3c9a19$var$keys$1($560639d49e3c9a19$var$proto$3.inlineTokenizers);
$560639d49e3c9a19$var$proto$3.tokenizeBlock = $560639d49e3c9a19$var$tokenizer$1("block");
$560639d49e3c9a19$var$proto$3.tokenizeInline = $560639d49e3c9a19$var$tokenizer$1("inline");
$560639d49e3c9a19$var$proto$3.tokenizeFactory = $560639d49e3c9a19$var$tokenizer$1;
function $560639d49e3c9a19$var$keys$1(value) {
  var result = [];
  var key;
  for (key in value)
    result.push(key);
  return result;
}
var $560639d49e3c9a19$var$remarkParse = $560639d49e3c9a19$var$parse$5;
$560639d49e3c9a19$var$parse$5.Parser = $560639d49e3c9a19$var$parser$1;
function $560639d49e3c9a19$var$parse$5(options) {
  var settings = this.data("settings");
  var Local = $560639d49e3c9a19$var$unherit_1($560639d49e3c9a19$var$parser$1);
  Local.prototype.options = $560639d49e3c9a19$var$immutable(Local.prototype.options, settings, options);
  this.Parser = Local;
}
var $560639d49e3c9a19$var$mdastUtilDefinitions$1 = $560639d49e3c9a19$var$getDefinitionFactory$1;
var $560639d49e3c9a19$var$own$a = {}.hasOwnProperty;
function $560639d49e3c9a19$var$getDefinitionFactory$1(node, options) {
  return $560639d49e3c9a19$var$getterFactory$1($560639d49e3c9a19$var$gather$1(node, options));
}
function $560639d49e3c9a19$var$gather$1(node, options) {
  var cache = {};
  if (!node || !node.type)
    throw new Error("mdast-util-definitions expected node");
  $560639d49e3c9a19$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
  return cache;
  function commonmark(definition) {
    var id = $560639d49e3c9a19$var$normalise$1(definition.identifier);
    if (!$560639d49e3c9a19$var$own$a.call(cache, id))
      cache[id] = definition;
  }
  function normal(definition) {
    cache[$560639d49e3c9a19$var$normalise$1(definition.identifier)] = definition;
  }
}
function $560639d49e3c9a19$var$getterFactory$1(cache) {
  return getter;
  function getter(identifier) {
    var id = identifier && $560639d49e3c9a19$var$normalise$1(identifier);
    return id && $560639d49e3c9a19$var$own$a.call(cache, id) ? cache[id] : null;
  }
}
function $560639d49e3c9a19$var$normalise$1(identifier) {
  return identifier.toUpperCase();
}
var $560639d49e3c9a19$var$parse_1$1 = $560639d49e3c9a19$var$parse$4;
var $560639d49e3c9a19$var$stringify_1$1 = $560639d49e3c9a19$var$stringify$3;
var $560639d49e3c9a19$var$empty$2 = "";
var $560639d49e3c9a19$var$space$3 = " ";
var $560639d49e3c9a19$var$whiteSpace$1 = /[ \t\n\r\f]+/g;
function $560639d49e3c9a19$var$parse$4(value) {
  var input = String(value || $560639d49e3c9a19$var$empty$2).trim();
  return input === $560639d49e3c9a19$var$empty$2 ? [] : input.split($560639d49e3c9a19$var$whiteSpace$1);
}
function $560639d49e3c9a19$var$stringify$3(values) {
  return values.join($560639d49e3c9a19$var$space$3).trim();
}
var $560639d49e3c9a19$var$spaceSeparatedTokens = {
  parse: $560639d49e3c9a19$var$parse_1$1,
  stringify: $560639d49e3c9a19$var$stringify_1$1
};
var $560639d49e3c9a19$var$isAbsoluteUrl = (url) => {
  if (typeof url !== "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof url}\``);
  if (/^[a-zA-Z]:\\/.test(url))
    return false;
  return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(url);
};
var $560639d49e3c9a19$var$spaceSeparated$4 = $560639d49e3c9a19$var$spaceSeparatedTokens.parse;
var $560639d49e3c9a19$var$remarkExternalLinks = $560639d49e3c9a19$var$externalLinks;
var $560639d49e3c9a19$var$defaultTarget = "_blank";
var $560639d49e3c9a19$var$defaultRel = [
  "nofollow",
  "noopener",
  "noreferrer"
];
var $560639d49e3c9a19$var$defaultProtocols = [
  "http",
  "https"
];
function $560639d49e3c9a19$var$externalLinks(options) {
  var settings = options || {};
  var target = settings.target;
  var rel = settings.rel;
  var protocols = settings.protocols || $560639d49e3c9a19$var$defaultProtocols;
  var content = settings.content;
  var contentProperties = settings.contentProperties || {};
  if (typeof rel === "string")
    rel = $560639d49e3c9a19$var$spaceSeparated$4(rel);
  if (content && typeof content === "object" && !("length" in content))
    content = [
      content
    ];
  return transform;
  function transform(tree) {
    var definition = $560639d49e3c9a19$var$mdastUtilDefinitions$1(tree);
    $560639d49e3c9a19$var$unistUtilVisit(tree, [
      "link",
      "linkReference"
    ], visitor);
    function visitor(node) {
      var ctx = node.type === "link" ? node : definition(node.identifier);
      var protocol;
      var data;
      var props;
      if (!ctx)
        return;
      protocol = ctx.url.slice(0, ctx.url.indexOf(":"));
      if ($560639d49e3c9a19$var$isAbsoluteUrl(ctx.url) && protocols.indexOf(protocol) !== -1) {
        data = node.data || (node.data = {});
        props = data.hProperties || (data.hProperties = {});
        if (target !== false)
          props.target = target || $560639d49e3c9a19$var$defaultTarget;
        if (rel !== false)
          props.rel = (rel || $560639d49e3c9a19$var$defaultRel).concat();
        if (content)
          node.children.push({
            type: "fragment",
            children: [],
            data: {
              hName: "span",
              hProperties: $560639d49e3c9a19$var$extend$2(true, contentProperties),
              hChildren: $560639d49e3c9a19$var$extend$2(true, content)
            }
          });
      }
    }
  }
}
var $560639d49e3c9a19$var$format = $560639d49e3c9a19$var$createCommonjsModule(function(module) {
  (function() {
    var namespace;
    namespace = module.exports = format;
    namespace.format = format;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function")
      namespace.printf = printf;
    function printf() {
      console.log(format.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format.apply(null, [
        fmt
      ].concat(replacements));
    }
    function format(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n = fmt.length, result = "", c, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n; ++i) {
        c = fmt[i];
        if (escaped) {
          escaped = false;
          if (c == ".") {
            leadingZero = false;
            c = fmt[++i];
          } else if (c == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c = fmt[i];
          } else
            leadingZero = true;
          precision = slurpNumber();
          switch (c) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c;
              break;
          }
        } else if (c === "%")
          escaped = true;
        else
          result += c;
      }
      return result;
    }
  })();
});
var $560639d49e3c9a19$var$fault = $560639d49e3c9a19$var$create$3(Error);
var $560639d49e3c9a19$var$fault_1 = $560639d49e3c9a19$var$fault;
$560639d49e3c9a19$var$fault.eval = $560639d49e3c9a19$var$create$3(EvalError);
$560639d49e3c9a19$var$fault.range = $560639d49e3c9a19$var$create$3(RangeError);
$560639d49e3c9a19$var$fault.reference = $560639d49e3c9a19$var$create$3(ReferenceError);
$560639d49e3c9a19$var$fault.syntax = $560639d49e3c9a19$var$create$3(SyntaxError);
$560639d49e3c9a19$var$fault.type = $560639d49e3c9a19$var$create$3(TypeError);
$560639d49e3c9a19$var$fault.uri = $560639d49e3c9a19$var$create$3(URIError);
$560639d49e3c9a19$var$fault.create = $560639d49e3c9a19$var$create$3;
function $560639d49e3c9a19$var$create$3(EConstructor) {
  FormattedError.displayName = EConstructor.displayName || EConstructor.name;
  return FormattedError;
  function FormattedError(format$1) {
    if (format$1)
      format$1 = $560639d49e3c9a19$var$format.apply(null, arguments);
    return new EConstructor(format$1);
  }
}
var $560639d49e3c9a19$var$matters_1 = $560639d49e3c9a19$var$matters;
var $560639d49e3c9a19$var$own$9 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$markers = {
  yaml: "-",
  toml: "+"
};
function $560639d49e3c9a19$var$matters(options) {
  var results = [];
  var index = -1;
  var length;
  if (typeof options === "string" || !("length" in options))
    options = [
      options
    ];
  length = options.length;
  while (++index < length)
    results[index] = $560639d49e3c9a19$var$matter(options[index]);
  return results;
}
function $560639d49e3c9a19$var$matter(option) {
  var result = option;
  if (typeof result === "string") {
    if (!$560639d49e3c9a19$var$own$9.call($560639d49e3c9a19$var$markers, result))
      throw $560639d49e3c9a19$var$fault_1("Missing matter definition for `%s`", result);
    result = {
      type: result,
      marker: $560639d49e3c9a19$var$markers[result]
    };
  } else if (typeof result !== "object")
    throw $560639d49e3c9a19$var$fault_1("Expected matter to be an object, not `%j`", result);
  if (!$560639d49e3c9a19$var$own$9.call(result, "type"))
    throw $560639d49e3c9a19$var$fault_1("Missing `type` in matter `%j`", result);
  if (!$560639d49e3c9a19$var$own$9.call(result, "fence") && !$560639d49e3c9a19$var$own$9.call(result, "marker"))
    throw $560639d49e3c9a19$var$fault_1("Missing `marker` or `fence` in matter `%j`", result);
  return result;
}
var $560639d49e3c9a19$var$fence_1 = $560639d49e3c9a19$var$fence;
function $560639d49e3c9a19$var$fence(matter, prop) {
  var marker;
  if (matter.marker) {
    marker = $560639d49e3c9a19$var$pick(matter.marker, prop);
    return marker + marker + marker;
  }
  return $560639d49e3c9a19$var$pick(matter.fence, prop);
}
function $560639d49e3c9a19$var$pick(schema, prop) {
  return typeof schema === "string" ? schema : schema[prop];
}
var $560639d49e3c9a19$var$parse$3 = $560639d49e3c9a19$var$create$2;
function $560639d49e3c9a19$var$create$2(matter) {
  var name = matter.type + "FrontMatter";
  var open = $560639d49e3c9a19$var$fence_1(matter, "open");
  var close = $560639d49e3c9a19$var$fence_1(matter, "close");
  var newline = "\n";
  var anywhere = matter.anywhere;
  frontmatter.displayName = name;
  frontmatter.onlyAtStart = typeof anywhere === "boolean" ? !anywhere : true;
  return [
    name,
    frontmatter
  ];
  function frontmatter(eat, value, silent) {
    var index = open.length;
    var offset;
    if (value.slice(0, index) !== open || value.charAt(index) !== newline)
      return;
    offset = value.indexOf(close, index);
    while (offset !== -1 && value.charAt(offset - 1) !== newline) {
      index = offset + close.length;
      offset = value.indexOf(close, index);
    }
    if (offset !== -1) {
      if (silent)
        return true;
      return eat(value.slice(0, offset + close.length))({
        type: matter.type,
        value: value.slice(open.length + 1, offset - 1)
      });
    }
  }
}
var $560639d49e3c9a19$var$compile = $560639d49e3c9a19$var$create$1;
function $560639d49e3c9a19$var$create$1(matter) {
  var type = matter.type;
  var open = $560639d49e3c9a19$var$fence_1(matter, "open");
  var close = $560639d49e3c9a19$var$fence_1(matter, "close");
  frontmatter.displayName = type + "FrontMatter";
  return [
    type,
    frontmatter
  ];
  function frontmatter(node) {
    return open + (node.value ? "\n" + node.value : "") + "\n" + close;
  }
}
var $560639d49e3c9a19$var$remarkFrontmatter = $560639d49e3c9a19$var$frontmatter;
function $560639d49e3c9a19$var$frontmatter(options) {
  var parser = this.Parser;
  var compiler = this.Compiler;
  var config = $560639d49e3c9a19$var$matters_1(options || [
    "yaml"
  ]);
  if ($560639d49e3c9a19$var$isRemarkParser(parser))
    $560639d49e3c9a19$var$attachParser(parser, config);
  if ($560639d49e3c9a19$var$isRemarkCompiler(compiler))
    $560639d49e3c9a19$var$attachCompiler(compiler, config);
}
function $560639d49e3c9a19$var$attachParser(parser, matters) {
  var proto = parser.prototype;
  var tokenizers = $560639d49e3c9a19$var$wrap$1($560639d49e3c9a19$var$parse$3, matters);
  var names = [];
  var key;
  for (key in tokenizers)
    names.push(key);
  proto.blockMethods = names.concat(proto.blockMethods);
  proto.blockTokenizers = Object.assign({}, tokenizers, proto.blockTokenizers);
}
function $560639d49e3c9a19$var$attachCompiler(compiler, matters) {
  var proto = compiler.prototype;
  proto.visitors = Object.assign({}, $560639d49e3c9a19$var$wrap$1($560639d49e3c9a19$var$compile, matters), proto.visitors);
}
function $560639d49e3c9a19$var$wrap$1(func, matters) {
  var result = {};
  var length = matters.length;
  var index = -1;
  var tuple;
  while (++index < length) {
    tuple = func(matters[index]);
    result[tuple[0]] = tuple[1];
  }
  return result;
}
function $560639d49e3c9a19$var$isRemarkParser(parser) {
  return Boolean(parser && parser.prototype && parser.prototype.blockTokenizers);
}
function $560639d49e3c9a19$var$isRemarkCompiler(compiler) {
  return Boolean(compiler && compiler.prototype && compiler.prototype.visitors);
}
var $560639d49e3c9a19$var$unistBuilder = $560639d49e3c9a19$var$u;
function $560639d49e3c9a19$var$u(type, props, value) {
  var node;
  if ((value === null || value === void 0) && (typeof props !== "object" || Array.isArray(props))) {
    value = props;
    props = {};
  }
  node = Object.assign({
    type: String(type)
  }, props);
  if (Array.isArray(value))
    node.children = value;
  else if (value !== null && value !== void 0)
    node.value = String(value);
  return node;
}
var $560639d49e3c9a19$var$start = $560639d49e3c9a19$var$factory$1("start");
var $560639d49e3c9a19$var$end = $560639d49e3c9a19$var$factory$1("end");
var $560639d49e3c9a19$var$unistUtilPosition = $560639d49e3c9a19$var$position;
$560639d49e3c9a19$var$position.start = $560639d49e3c9a19$var$start;
$560639d49e3c9a19$var$position.end = $560639d49e3c9a19$var$end;
function $560639d49e3c9a19$var$position(node) {
  return {
    start: $560639d49e3c9a19$var$start(node),
    end: $560639d49e3c9a19$var$end(node)
  };
}
function $560639d49e3c9a19$var$factory$1(type) {
  point.displayName = type;
  return point;
  function point(node) {
    var point2 = node && node.position && node.position[type] || {};
    return {
      line: point2.line || null,
      column: point2.column || null,
      offset: isNaN(point2.offset) ? null : point2.offset
    };
  }
}
var $560639d49e3c9a19$var$unistUtilGenerated = $560639d49e3c9a19$var$generated;
function $560639d49e3c9a19$var$generated(node) {
  var position = $560639d49e3c9a19$var$optional($560639d49e3c9a19$var$optional(node).position);
  var start = $560639d49e3c9a19$var$optional(position.start);
  var end = $560639d49e3c9a19$var$optional(position.end);
  return !start.line || !start.column || !end.line || !end.column;
}
function $560639d49e3c9a19$var$optional(value) {
  return value && typeof value === "object" ? value : {};
}
var $560639d49e3c9a19$var$mdastUtilDefinitions = $560639d49e3c9a19$var$getDefinitionFactory;
var $560639d49e3c9a19$var$own$8 = {}.hasOwnProperty;
function $560639d49e3c9a19$var$getDefinitionFactory(node, options) {
  return $560639d49e3c9a19$var$getterFactory($560639d49e3c9a19$var$gather(node, options));
}
function $560639d49e3c9a19$var$gather(node, options) {
  var cache = {};
  if (!node || !node.type)
    throw new Error("mdast-util-definitions expected node");
  $560639d49e3c9a19$var$unistUtilVisit(node, "definition", options && options.commonmark ? commonmark : normal);
  return cache;
  function commonmark(definition) {
    var id = $560639d49e3c9a19$var$normalise(definition.identifier);
    if (!$560639d49e3c9a19$var$own$8.call(cache, id))
      cache[id] = definition;
  }
  function normal(definition) {
    cache[$560639d49e3c9a19$var$normalise(definition.identifier)] = definition;
  }
}
function $560639d49e3c9a19$var$getterFactory(cache) {
  return getter;
  function getter(identifier) {
    var id = identifier && $560639d49e3c9a19$var$normalise(identifier);
    return id && $560639d49e3c9a19$var$own$8.call(cache, id) ? cache[id] : null;
  }
}
function $560639d49e3c9a19$var$normalise(identifier) {
  return identifier.toUpperCase();
}
var $560639d49e3c9a19$var$all_1$1 = $560639d49e3c9a19$var$all$2;
function $560639d49e3c9a19$var$all$2(h, parent) {
  var nodes = parent.children || [];
  var length = nodes.length;
  var values = [];
  var index = -1;
  var result;
  var head;
  while (++index < length) {
    result = $560639d49e3c9a19$var$one_1$1(h, nodes[index], parent);
    if (result) {
      if (index && nodes[index - 1].type === "break") {
        if (result.value)
          result.value = result.value.replace(/^\s+/, "");
        head = result.children && result.children[0];
        if (head && head.value)
          head.value = head.value.replace(/^\s+/, "");
      }
      values = values.concat(result);
    }
  }
  return values;
}
var $560639d49e3c9a19$var$one_1$1 = $560639d49e3c9a19$var$one$2;
var $560639d49e3c9a19$var$own$7 = {}.hasOwnProperty;
function $560639d49e3c9a19$var$unknown(h, node) {
  if ($560639d49e3c9a19$var$text$2(node))
    return h.augment(node, $560639d49e3c9a19$var$unistBuilder("text", node.value));
  return h(node, "div", $560639d49e3c9a19$var$all_1$1(h, node));
}
function $560639d49e3c9a19$var$one$2(h, node, parent) {
  var type = node && node.type;
  var fn = $560639d49e3c9a19$var$own$7.call(h.handlers, type) ? h.handlers[type] : h.unknownHandler;
  if (!type)
    throw new Error("Expected node, got `" + node + "`");
  return (typeof fn === "function" ? fn : $560639d49e3c9a19$var$unknown)(h, node, parent);
}
function $560639d49e3c9a19$var$text$2(node) {
  var data = node.data || {};
  if ($560639d49e3c9a19$var$own$7.call(data, "hName") || $560639d49e3c9a19$var$own$7.call(data, "hProperties") || $560639d49e3c9a19$var$own$7.call(data, "hChildren"))
    return false;
  return "value" in node;
}
var $560639d49e3c9a19$var$thematicBreak_1 = $560639d49e3c9a19$var$thematicBreak;
function $560639d49e3c9a19$var$thematicBreak(h, node) {
  return h(node, "hr");
}
var $560639d49e3c9a19$var$wrap_1 = $560639d49e3c9a19$var$wrap;
function $560639d49e3c9a19$var$wrap(nodes, loose) {
  var result = [];
  var index = -1;
  var length = nodes.length;
  if (loose)
    result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
  while (++index < length) {
    if (index)
      result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
    result.push(nodes[index]);
  }
  if (loose && nodes.length !== 0)
    result.push($560639d49e3c9a19$var$unistBuilder("text", "\n"));
  return result;
}
var $560639d49e3c9a19$var$list_1 = $560639d49e3c9a19$var$list;
function $560639d49e3c9a19$var$list(h, node) {
  var props = {};
  var name = node.ordered ? "ol" : "ul";
  var items;
  var index = -1;
  var length;
  if (typeof node.start === "number" && node.start !== 1)
    props.start = node.start;
  items = $560639d49e3c9a19$var$all_1$1(h, node);
  length = items.length;
  while (++index < length)
    if (items[index].properties.className && items[index].properties.className.indexOf("task-list-item") !== -1) {
      props.className = [
        "contains-task-list"
      ];
      break;
    }
  return h(node, name, props, $560639d49e3c9a19$var$wrap_1(items, true));
}
var $560639d49e3c9a19$var$footer = $560639d49e3c9a19$var$generateFootnotes;
function $560639d49e3c9a19$var$generateFootnotes(h) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var length = footnoteOrder.length;
  var index = -1;
  var listItems = [];
  var def;
  var backReference;
  var content;
  var tail;
  while (++index < length) {
    def = footnoteById[footnoteOrder[index].toUpperCase()];
    if (!def)
      continue;
    content = def.children.concat();
    tail = content[content.length - 1];
    backReference = {
      type: "link",
      url: "#fnref-" + def.identifier,
      data: {
        hProperties: {
          className: [
            "footnote-backref"
          ]
        }
      },
      children: [
        {
          type: "text",
          value: "↩"
        }
      ]
    };
    if (!tail || tail.type !== "paragraph") {
      tail = {
        type: "paragraph",
        children: []
      };
      content.push(tail);
    }
    tail.children.push(backReference);
    listItems.push({
      type: "listItem",
      data: {
        hProperties: {
          id: "fn-" + def.identifier
        }
      },
      children: content,
      position: def.position
    });
  }
  if (listItems.length === 0)
    return null;
  return h(null, "div", {
    className: [
      "footnotes"
    ]
  }, $560639d49e3c9a19$var$wrap_1([
    $560639d49e3c9a19$var$thematicBreak_1(h),
    $560639d49e3c9a19$var$list_1(h, {
      type: "list",
      ordered: true,
      children: listItems
    })
  ], true));
}
var $560639d49e3c9a19$var$blockquote_1 = $560639d49e3c9a19$var$blockquote;
function $560639d49e3c9a19$var$blockquote(h, node) {
  return h(node, "blockquote", $560639d49e3c9a19$var$wrap_1($560639d49e3c9a19$var$all_1$1(h, node), true));
}
var $560639d49e3c9a19$var$_break = $560639d49e3c9a19$var$hardBreak;
function $560639d49e3c9a19$var$hardBreak(h, node) {
  return [
    h(node, "br"),
    $560639d49e3c9a19$var$unistBuilder("text", "\n")
  ];
}
var $560639d49e3c9a19$var$detab_1 = $560639d49e3c9a19$var$detab;
var $560639d49e3c9a19$var$tab$1 = 9;
var $560639d49e3c9a19$var$lineFeed$1 = 10;
var $560639d49e3c9a19$var$carriageReturn = 13;
function $560639d49e3c9a19$var$detab(value, size) {
  var string = typeof value === "string";
  var length = string && value.length;
  var start = 0;
  var index = -1;
  var column = -1;
  var tabSize = size || 4;
  var results = [];
  var code;
  var add;
  if (!string)
    throw new Error("detab expected string");
  while (++index < length) {
    code = value.charCodeAt(index);
    if (code === $560639d49e3c9a19$var$tab$1) {
      add = tabSize - (column + 1) % tabSize;
      column += add;
      results.push(value.slice(start, index) + $560639d49e3c9a19$var$repeatString(" ", add));
      start = index + 1;
    } else if (code === $560639d49e3c9a19$var$lineFeed$1 || code === $560639d49e3c9a19$var$carriageReturn)
      column = -1;
    else
      column++;
  }
  results.push(value.slice(start));
  return results.join("");
}
var $560639d49e3c9a19$var$code_1 = $560639d49e3c9a19$var$code;
function $560639d49e3c9a19$var$code(h, node) {
  var value = node.value ? $560639d49e3c9a19$var$detab_1(node.value + "\n") : "";
  var lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
  var props = {};
  if (lang)
    props.className = [
      "language-" + lang
    ];
  return h(node.position, "pre", [
    h(node, "code", props, [
      $560639d49e3c9a19$var$unistBuilder("text", value)
    ])
  ]);
}
var $560639d49e3c9a19$var$_delete = $560639d49e3c9a19$var$strikethrough;
function $560639d49e3c9a19$var$strikethrough(h, node) {
  return h(node, "del", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$emphasis_1 = $560639d49e3c9a19$var$emphasis;
function $560639d49e3c9a19$var$emphasis(h, node) {
  return h(node, "em", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$footnoteReference_1 = $560639d49e3c9a19$var$footnoteReference;
function $560639d49e3c9a19$var$footnoteReference(h, node) {
  var footnoteOrder = h.footnoteOrder;
  var identifier = String(node.identifier);
  if (footnoteOrder.indexOf(identifier) === -1)
    footnoteOrder.push(identifier);
  return h(node.position, "sup", {
    id: "fnref-" + identifier
  }, [
    h(node, "a", {
      href: "#fn-" + identifier,
      className: [
        "footnote-ref"
      ]
    }, [
      $560639d49e3c9a19$var$unistBuilder("text", node.label || identifier)
    ])
  ]);
}
var $560639d49e3c9a19$var$footnote_1 = $560639d49e3c9a19$var$footnote;
function $560639d49e3c9a19$var$footnote(h, node) {
  var footnoteById = h.footnoteById;
  var footnoteOrder = h.footnoteOrder;
  var identifier = 1;
  while (identifier in footnoteById)
    identifier++;
  identifier = String(identifier);
  footnoteOrder.push(identifier);
  footnoteById[identifier] = {
    type: "footnoteDefinition",
    identifier,
    children: [
      {
        type: "paragraph",
        children: node.children
      }
    ],
    position: node.position
  };
  return $560639d49e3c9a19$var$footnoteReference_1(h, {
    type: "footnoteReference",
    identifier,
    position: node.position
  });
}
var $560639d49e3c9a19$var$heading_1 = $560639d49e3c9a19$var$heading;
function $560639d49e3c9a19$var$heading(h, node) {
  return h(node, "h" + node.depth, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$html_1$1 = $560639d49e3c9a19$var$html$3;
function $560639d49e3c9a19$var$html$3(h, node) {
  return h.dangerous ? h.augment(node, $560639d49e3c9a19$var$unistBuilder("raw", node.value)) : null;
}
var $560639d49e3c9a19$var$encodeCache = {};
function $560639d49e3c9a19$var$getEncodeCache(exclude) {
  var i, ch, cache = $560639d49e3c9a19$var$encodeCache[exclude];
  if (cache)
    return cache;
  cache = $560639d49e3c9a19$var$encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch))
      cache.push(ch);
    else
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
  }
  for (i = 0; i < exclude.length; i++)
    cache[exclude.charCodeAt(i)] = exclude[i];
  return cache;
}
function $560639d49e3c9a19$var$encode$1(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = $560639d49e3c9a19$var$encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined")
    keepEscaped = true;
  cache = $560639d49e3c9a19$var$getEncodeCache(exclude);
  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);
    if (keepEscaped && code === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code < 128) {
      result += cache[code];
      continue;
    }
    if (code >= 55296 && code <= 57343) {
      if (code >= 55296 && code <= 56319 && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
$560639d49e3c9a19$var$encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
$560639d49e3c9a19$var$encode$1.componentChars = "-_.!~*'()";
var $560639d49e3c9a19$var$encode_1 = $560639d49e3c9a19$var$encode$1;
var $560639d49e3c9a19$var$revert_1 = $560639d49e3c9a19$var$revert;
function $560639d49e3c9a19$var$revert(h, node) {
  var subtype = node.referenceType;
  var suffix = "]";
  var contents;
  var head;
  var tail;
  if (subtype === "collapsed")
    suffix += "[]";
  else if (subtype === "full")
    suffix += "[" + (node.label || node.identifier) + "]";
  if (node.type === "imageReference")
    return $560639d49e3c9a19$var$unistBuilder("text", "![" + node.alt + suffix);
  contents = $560639d49e3c9a19$var$all_1$1(h, node);
  head = contents[0];
  if (head && head.type === "text")
    head.value = "[" + head.value;
  else
    contents.unshift($560639d49e3c9a19$var$unistBuilder("text", "["));
  tail = contents[contents.length - 1];
  if (tail && tail.type === "text")
    tail.value += suffix;
  else
    contents.push($560639d49e3c9a19$var$unistBuilder("text", suffix));
  return contents;
}
var $560639d49e3c9a19$var$imageReference_1 = $560639d49e3c9a19$var$imageReference;
function $560639d49e3c9a19$var$imageReference(h, node) {
  var def = h.definition(node.identifier);
  var props;
  if (!def)
    return $560639d49e3c9a19$var$revert_1(h, node);
  props = {
    src: $560639d49e3c9a19$var$encode_1(def.url || ""),
    alt: node.alt
  };
  if (def.title !== null && def.title !== void 0)
    props.title = def.title;
  return h(node, "img", props);
}
var $560639d49e3c9a19$var$image_1 = $560639d49e3c9a19$var$image$1;
function $560639d49e3c9a19$var$image$1(h, node) {
  var props = {
    src: $560639d49e3c9a19$var$encode_1(node.url),
    alt: node.alt
  };
  if (node.title !== null && node.title !== void 0)
    props.title = node.title;
  return h(node, "img", props);
}
var $560639d49e3c9a19$var$inlineCode_1 = $560639d49e3c9a19$var$inlineCode;
function $560639d49e3c9a19$var$inlineCode(h, node) {
  return h(node, "code", [
    $560639d49e3c9a19$var$unistBuilder("text", $560639d49e3c9a19$var$collapseWhiteSpace(node.value))
  ]);
}
var $560639d49e3c9a19$var$linkReference_1 = $560639d49e3c9a19$var$linkReference;
function $560639d49e3c9a19$var$linkReference(h, node) {
  var def = h.definition(node.identifier);
  var props;
  if (!def)
    return $560639d49e3c9a19$var$revert_1(h, node);
  props = {
    href: $560639d49e3c9a19$var$encode_1(def.url || "")
  };
  if (def.title !== null && def.title !== void 0)
    props.title = def.title;
  return h(node, "a", props, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$link_1 = $560639d49e3c9a19$var$link;
function $560639d49e3c9a19$var$link(h, node) {
  var props = {
    href: $560639d49e3c9a19$var$encode_1(node.url)
  };
  if (node.title !== null && node.title !== void 0)
    props.title = node.title;
  return h(node, "a", props, $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$listItem_1 = $560639d49e3c9a19$var$listItem$1;
function $560639d49e3c9a19$var$listItem$1(h, node, parent) {
  var children = node.children;
  var head = children[0];
  var raw = $560639d49e3c9a19$var$all_1$1(h, node);
  var loose = parent ? $560639d49e3c9a19$var$listLoose(parent) : $560639d49e3c9a19$var$listItemLoose(node);
  var props = {};
  var result;
  var container;
  var index;
  var length;
  var child;
  if (loose)
    result = raw;
  else {
    result = [];
    length = raw.length;
    index = -1;
    while (++index < length) {
      child = raw[index];
      if (child.tagName === "p")
        result = result.concat(child.children);
      else
        result.push(child);
    }
  }
  if (typeof node.checked === "boolean") {
    if (loose && (!head || head.type !== "paragraph"))
      result.unshift(h(null, "p", []));
    container = loose ? result[0].children : result;
    if (container.length !== 0)
      container.unshift($560639d49e3c9a19$var$unistBuilder("text", " "));
    container.unshift(h(null, "input", {
      type: "checkbox",
      checked: node.checked,
      disabled: true
    }));
    props.className = [
      "task-list-item"
    ];
  }
  if (loose && result.length !== 0)
    result = $560639d49e3c9a19$var$wrap_1(result, true);
  return h(node, "li", props, result);
}
function $560639d49e3c9a19$var$listLoose(node) {
  var loose = node.spread;
  var children = node.children;
  var length = children.length;
  var index = -1;
  while (!loose && ++index < length)
    loose = $560639d49e3c9a19$var$listItemLoose(children[index]);
  return loose;
}
function $560639d49e3c9a19$var$listItemLoose(node) {
  var spread = node.spread;
  return spread === void 0 || spread === null ? node.children.length > 1 : spread;
}
var $560639d49e3c9a19$var$paragraph_1 = $560639d49e3c9a19$var$paragraph;
function $560639d49e3c9a19$var$paragraph(h, node) {
  return h(node, "p", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$root_1 = $560639d49e3c9a19$var$root;
function $560639d49e3c9a19$var$root(h, node) {
  return h.augment(node, $560639d49e3c9a19$var$unistBuilder("root", $560639d49e3c9a19$var$wrap_1($560639d49e3c9a19$var$all_1$1(h, node))));
}
var $560639d49e3c9a19$var$strong_1 = $560639d49e3c9a19$var$strong;
function $560639d49e3c9a19$var$strong(h, node) {
  return h(node, "strong", $560639d49e3c9a19$var$all_1$1(h, node));
}
var $560639d49e3c9a19$var$table_1 = $560639d49e3c9a19$var$table;
function $560639d49e3c9a19$var$table(h, node) {
  var rows = node.children;
  var index = rows.length;
  var align = node.align;
  var alignLength = align.length;
  var result = [];
  var pos;
  var row;
  var out;
  var name;
  var cell;
  while (index--) {
    row = rows[index].children;
    name = index === 0 ? "th" : "td";
    pos = alignLength;
    out = [];
    while (pos--) {
      cell = row[pos];
      out[pos] = h(cell, name, {
        align: align[pos]
      }, cell ? $560639d49e3c9a19$var$all_1$1(h, cell) : []);
    }
    result[index] = h(rows[index], "tr", $560639d49e3c9a19$var$wrap_1(out, true));
  }
  return h(node, "table", $560639d49e3c9a19$var$wrap_1([
    h(result[0].position, "thead", $560639d49e3c9a19$var$wrap_1([
      result[0]
    ], true)),
    h({
      start: $560639d49e3c9a19$var$unistUtilPosition.start(result[1]),
      end: $560639d49e3c9a19$var$unistUtilPosition.end(result[result.length - 1])
    }, "tbody", $560639d49e3c9a19$var$wrap_1(result.slice(1), true))
  ], true));
}
var $560639d49e3c9a19$var$trimLines_1 = $560639d49e3c9a19$var$trimLines;
var $560639d49e3c9a19$var$ws = /[ \t]*\n+[ \t]*/g;
var $560639d49e3c9a19$var$newline$1 = "\n";
function $560639d49e3c9a19$var$trimLines(value) {
  return String(value).replace($560639d49e3c9a19$var$ws, $560639d49e3c9a19$var$newline$1);
}
var $560639d49e3c9a19$var$text_1$1 = $560639d49e3c9a19$var$text$1;
function $560639d49e3c9a19$var$text$1(h, node) {
  return h.augment(node, $560639d49e3c9a19$var$unistBuilder("text", $560639d49e3c9a19$var$trimLines_1(node.value)));
}
var $560639d49e3c9a19$var$handlers$1 = {
  blockquote: $560639d49e3c9a19$var$blockquote_1,
  break: $560639d49e3c9a19$var$_break,
  code: $560639d49e3c9a19$var$code_1,
  delete: $560639d49e3c9a19$var$_delete,
  emphasis: $560639d49e3c9a19$var$emphasis_1,
  footnoteReference: $560639d49e3c9a19$var$footnoteReference_1,
  footnote: $560639d49e3c9a19$var$footnote_1,
  heading: $560639d49e3c9a19$var$heading_1,
  html: $560639d49e3c9a19$var$html_1$1,
  imageReference: $560639d49e3c9a19$var$imageReference_1,
  image: $560639d49e3c9a19$var$image_1,
  inlineCode: $560639d49e3c9a19$var$inlineCode_1,
  linkReference: $560639d49e3c9a19$var$linkReference_1,
  link: $560639d49e3c9a19$var$link_1,
  listItem: $560639d49e3c9a19$var$listItem_1,
  list: $560639d49e3c9a19$var$list_1,
  paragraph: $560639d49e3c9a19$var$paragraph_1,
  root: $560639d49e3c9a19$var$root_1,
  strong: $560639d49e3c9a19$var$strong_1,
  table: $560639d49e3c9a19$var$table_1,
  text: $560639d49e3c9a19$var$text_1$1,
  thematicBreak: $560639d49e3c9a19$var$thematicBreak_1,
  toml: $560639d49e3c9a19$var$ignore,
  yaml: $560639d49e3c9a19$var$ignore,
  definition: $560639d49e3c9a19$var$ignore,
  footnoteDefinition: $560639d49e3c9a19$var$ignore
};
function $560639d49e3c9a19$var$ignore() {
  return null;
}
var $560639d49e3c9a19$var$lib$2 = $560639d49e3c9a19$var$toHast;
var $560639d49e3c9a19$var$own$6 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$deprecationWarningIssued = false;
function $560639d49e3c9a19$var$factory(tree, options) {
  var settings = options || {};
  if (settings.allowDangerousHTML !== void 0 && !$560639d49e3c9a19$var$deprecationWarningIssued) {
    $560639d49e3c9a19$var$deprecationWarningIssued = true;
    console.warn("mdast-util-to-hast: deprecation: `allowDangerousHTML` is nonstandard, use `allowDangerousHtml` instead");
  }
  var dangerous = settings.allowDangerousHtml || settings.allowDangerousHTML;
  var footnoteById = {};
  h.dangerous = dangerous;
  h.definition = $560639d49e3c9a19$var$mdastUtilDefinitions(tree, settings);
  h.footnoteById = footnoteById;
  h.footnoteOrder = [];
  h.augment = augment;
  h.handlers = Object.assign({}, $560639d49e3c9a19$var$handlers$1, settings.handlers);
  h.unknownHandler = settings.unknownHandler;
  $560639d49e3c9a19$var$unistUtilVisit(tree, "footnoteDefinition", onfootnotedefinition);
  return h;
  function augment(left, right) {
    var data;
    var ctx;
    if (left && "data" in left) {
      data = left.data;
      if (right.type === "element" && data.hName)
        right.tagName = data.hName;
      if (right.type === "element" && data.hProperties)
        right.properties = Object.assign({}, right.properties, data.hProperties);
      if (right.children && data.hChildren)
        right.children = data.hChildren;
    }
    ctx = left && left.position ? left : {
      position: left
    };
    if (!$560639d49e3c9a19$var$unistUtilGenerated(ctx))
      right.position = {
        start: $560639d49e3c9a19$var$unistUtilPosition.start(ctx),
        end: $560639d49e3c9a19$var$unistUtilPosition.end(ctx)
      };
    return right;
  }
  function h(node, tagName, props, children) {
    if ((children === void 0 || children === null) && typeof props === "object" && "length" in props) {
      children = props;
      props = {};
    }
    return augment(node, {
      type: "element",
      tagName,
      properties: props || {},
      children: children || []
    });
  }
  function onfootnotedefinition(definition) {
    var id = String(definition.identifier).toUpperCase();
    if (!$560639d49e3c9a19$var$own$6.call(footnoteById, id))
      footnoteById[id] = definition;
  }
}
function $560639d49e3c9a19$var$toHast(tree, options) {
  var h = $560639d49e3c9a19$var$factory(tree, options);
  var node = $560639d49e3c9a19$var$one_1$1(h, tree);
  var foot = $560639d49e3c9a19$var$footer(h);
  if (foot)
    node.children = node.children.concat($560639d49e3c9a19$var$unistBuilder("text", "\n"), foot);
  return node;
}
var $560639d49e3c9a19$var$mdastUtilToHast = $560639d49e3c9a19$var$lib$2;
var $560639d49e3c9a19$var$remarkRehype = $560639d49e3c9a19$var$remark2rehype;
function $560639d49e3c9a19$var$remark2rehype(destination, options) {
  if (destination && !destination.process) {
    options = destination;
    destination = null;
  }
  return destination ? $560639d49e3c9a19$var$bridge(destination, options) : $560639d49e3c9a19$var$mutate(options);
}
function $560639d49e3c9a19$var$bridge(destination, options) {
  return transformer;
  function transformer(node, file, next) {
    destination.run($560639d49e3c9a19$var$mdastUtilToHast(node, options), file, done);
    function done(err) {
      next(err);
    }
  }
}
function $560639d49e3c9a19$var$mutate(options) {
  return transformer;
  function transformer(node) {
    return $560639d49e3c9a19$var$mdastUtilToHast(node, options);
  }
}
var $560639d49e3c9a19$var$schema$1 = $560639d49e3c9a19$var$Schema$2;
var $560639d49e3c9a19$var$proto$2 = $560639d49e3c9a19$var$Schema$2.prototype;
$560639d49e3c9a19$var$proto$2.space = null;
$560639d49e3c9a19$var$proto$2.normal = {};
$560639d49e3c9a19$var$proto$2.property = {};
function $560639d49e3c9a19$var$Schema$2(property, normal, space) {
  this.property = property;
  this.normal = normal;
  if (space)
    this.space = space;
}
var $560639d49e3c9a19$var$merge_1 = $560639d49e3c9a19$var$merge$1;
function $560639d49e3c9a19$var$merge$1(definitions) {
  var length = definitions.length;
  var property = [];
  var normal = [];
  var index = -1;
  var info;
  var space;
  while (++index < length) {
    info = definitions[index];
    property.push(info.property);
    normal.push(info.normal);
    space = info.space;
  }
  return new $560639d49e3c9a19$var$schema$1($560639d49e3c9a19$var$immutable.apply(null, property), $560639d49e3c9a19$var$immutable.apply(null, normal), space);
}
var $560639d49e3c9a19$var$normalize_1 = $560639d49e3c9a19$var$normalize;
function $560639d49e3c9a19$var$normalize(value) {
  return value.toLowerCase();
}
var $560639d49e3c9a19$var$info = $560639d49e3c9a19$var$Info;
var $560639d49e3c9a19$var$proto$1 = $560639d49e3c9a19$var$Info.prototype;
$560639d49e3c9a19$var$proto$1.space = null;
$560639d49e3c9a19$var$proto$1.attribute = null;
$560639d49e3c9a19$var$proto$1.property = null;
$560639d49e3c9a19$var$proto$1.boolean = false;
$560639d49e3c9a19$var$proto$1.booleanish = false;
$560639d49e3c9a19$var$proto$1.overloadedBoolean = false;
$560639d49e3c9a19$var$proto$1.number = false;
$560639d49e3c9a19$var$proto$1.commaSeparated = false;
$560639d49e3c9a19$var$proto$1.spaceSeparated = false;
$560639d49e3c9a19$var$proto$1.commaOrSpaceSeparated = false;
$560639d49e3c9a19$var$proto$1.mustUseProperty = false;
$560639d49e3c9a19$var$proto$1.defined = false;
function $560639d49e3c9a19$var$Info(property, attribute) {
  this.property = property;
  this.attribute = attribute;
}
var $560639d49e3c9a19$var$powers = 0;
var $560639d49e3c9a19$var$boolean_1 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$booleanish$2 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$overloadedBoolean$1 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$number$3 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$spaceSeparated$3 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$commaSeparated$2 = $560639d49e3c9a19$var$increment();
var $560639d49e3c9a19$var$commaOrSpaceSeparated$1 = $560639d49e3c9a19$var$increment();
function $560639d49e3c9a19$var$increment() {
  return Math.pow(2, ++$560639d49e3c9a19$var$powers);
}
var $560639d49e3c9a19$var$types = {
  boolean: $560639d49e3c9a19$var$boolean_1,
  booleanish: $560639d49e3c9a19$var$booleanish$2,
  overloadedBoolean: $560639d49e3c9a19$var$overloadedBoolean$1,
  number: $560639d49e3c9a19$var$number$3,
  spaceSeparated: $560639d49e3c9a19$var$spaceSeparated$3,
  commaSeparated: $560639d49e3c9a19$var$commaSeparated$2,
  commaOrSpaceSeparated: $560639d49e3c9a19$var$commaOrSpaceSeparated$1
};
var $560639d49e3c9a19$var$definedInfo = $560639d49e3c9a19$var$DefinedInfo;
$560639d49e3c9a19$var$DefinedInfo.prototype = new $560639d49e3c9a19$var$info();
$560639d49e3c9a19$var$DefinedInfo.prototype.defined = true;
var $560639d49e3c9a19$var$checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
];
var $560639d49e3c9a19$var$checksLength = $560639d49e3c9a19$var$checks.length;
function $560639d49e3c9a19$var$DefinedInfo(property, attribute, mask, space) {
  var index = -1;
  var check;
  $560639d49e3c9a19$var$mark$1(this, "space", space);
  $560639d49e3c9a19$var$info.call(this, property, attribute);
  while (++index < $560639d49e3c9a19$var$checksLength) {
    check = $560639d49e3c9a19$var$checks[index];
    $560639d49e3c9a19$var$mark$1(this, check, (mask & $560639d49e3c9a19$var$types[check]) === $560639d49e3c9a19$var$types[check]);
  }
}
function $560639d49e3c9a19$var$mark$1(values, key, value) {
  if (value)
    values[key] = value;
}
var $560639d49e3c9a19$var$create_1 = $560639d49e3c9a19$var$create;
function $560639d49e3c9a19$var$create(definition) {
  var space = definition.space;
  var mustUseProperty = definition.mustUseProperty || [];
  var attributes = definition.attributes || {};
  var props = definition.properties;
  var transform = definition.transform;
  var property = {};
  var normal = {};
  var prop;
  var info;
  for (prop in props) {
    info = new $560639d49e3c9a19$var$definedInfo(prop, transform(attributes, prop), props[prop], space);
    if (mustUseProperty.indexOf(prop) !== -1)
      info.mustUseProperty = true;
    property[prop] = info;
    normal[$560639d49e3c9a19$var$normalize_1(prop)] = prop;
    normal[$560639d49e3c9a19$var$normalize_1(info.attribute)] = prop;
  }
  return new $560639d49e3c9a19$var$schema$1(property, normal, space);
}
var $560639d49e3c9a19$var$xlink = $560639d49e3c9a19$var$create_1({
  space: "xlink",
  transform: $560639d49e3c9a19$var$xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function $560639d49e3c9a19$var$xlinkTransform(_, prop) {
  return "xlink:" + prop.slice(5).toLowerCase();
}
var $560639d49e3c9a19$var$xml = $560639d49e3c9a19$var$create_1({
  space: "xml",
  transform: $560639d49e3c9a19$var$xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function $560639d49e3c9a19$var$xmlTransform(_, prop) {
  return "xml:" + prop.slice(3).toLowerCase();
}
var $560639d49e3c9a19$var$caseSensitiveTransform_1 = $560639d49e3c9a19$var$caseSensitiveTransform;
function $560639d49e3c9a19$var$caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
var $560639d49e3c9a19$var$caseInsensitiveTransform_1 = $560639d49e3c9a19$var$caseInsensitiveTransform;
function $560639d49e3c9a19$var$caseInsensitiveTransform(attributes, property) {
  return $560639d49e3c9a19$var$caseSensitiveTransform_1(attributes, property.toLowerCase());
}
var $560639d49e3c9a19$var$xmlns = $560639d49e3c9a19$var$create_1({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: $560639d49e3c9a19$var$caseInsensitiveTransform_1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
var $560639d49e3c9a19$var$booleanish$1 = $560639d49e3c9a19$var$types.booleanish;
var $560639d49e3c9a19$var$number$2 = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated$2 = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$aria = $560639d49e3c9a19$var$create_1({
  transform: $560639d49e3c9a19$var$ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: $560639d49e3c9a19$var$booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: $560639d49e3c9a19$var$booleanish$1,
    ariaChecked: $560639d49e3c9a19$var$booleanish$1,
    ariaColCount: $560639d49e3c9a19$var$number$2,
    ariaColIndex: $560639d49e3c9a19$var$number$2,
    ariaColSpan: $560639d49e3c9a19$var$number$2,
    ariaControls: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaCurrent: null,
    ariaDescribedBy: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaDetails: null,
    ariaDisabled: $560639d49e3c9a19$var$booleanish$1,
    ariaDropEffect: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaErrorMessage: null,
    ariaExpanded: $560639d49e3c9a19$var$booleanish$1,
    ariaFlowTo: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaGrabbed: $560639d49e3c9a19$var$booleanish$1,
    ariaHasPopup: null,
    ariaHidden: $560639d49e3c9a19$var$booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaLevel: $560639d49e3c9a19$var$number$2,
    ariaLive: null,
    ariaModal: $560639d49e3c9a19$var$booleanish$1,
    ariaMultiLine: $560639d49e3c9a19$var$booleanish$1,
    ariaMultiSelectable: $560639d49e3c9a19$var$booleanish$1,
    ariaOrientation: null,
    ariaOwns: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaPlaceholder: null,
    ariaPosInSet: $560639d49e3c9a19$var$number$2,
    ariaPressed: $560639d49e3c9a19$var$booleanish$1,
    ariaReadOnly: $560639d49e3c9a19$var$booleanish$1,
    ariaRelevant: null,
    ariaRequired: $560639d49e3c9a19$var$booleanish$1,
    ariaRoleDescription: $560639d49e3c9a19$var$spaceSeparated$2,
    ariaRowCount: $560639d49e3c9a19$var$number$2,
    ariaRowIndex: $560639d49e3c9a19$var$number$2,
    ariaRowSpan: $560639d49e3c9a19$var$number$2,
    ariaSelected: $560639d49e3c9a19$var$booleanish$1,
    ariaSetSize: $560639d49e3c9a19$var$number$2,
    ariaSort: null,
    ariaValueMax: $560639d49e3c9a19$var$number$2,
    ariaValueMin: $560639d49e3c9a19$var$number$2,
    ariaValueNow: $560639d49e3c9a19$var$number$2,
    ariaValueText: null,
    role: null
  }
});
function $560639d49e3c9a19$var$ariaTransform(_, prop) {
  return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
}
var $560639d49e3c9a19$var$boolean$1 = $560639d49e3c9a19$var$types.boolean;
var $560639d49e3c9a19$var$overloadedBoolean = $560639d49e3c9a19$var$types.overloadedBoolean;
var $560639d49e3c9a19$var$booleanish = $560639d49e3c9a19$var$types.booleanish;
var $560639d49e3c9a19$var$number$1 = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated$1 = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$commaSeparated$1 = $560639d49e3c9a19$var$types.commaSeparated;
var $560639d49e3c9a19$var$html$2 = $560639d49e3c9a19$var$create_1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: $560639d49e3c9a19$var$caseInsensitiveTransform_1,
  mustUseProperty: [
    "checked",
    "multiple",
    "muted",
    "selected"
  ],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: $560639d49e3c9a19$var$commaSeparated$1,
    acceptCharset: $560639d49e3c9a19$var$spaceSeparated$1,
    accessKey: $560639d49e3c9a19$var$spaceSeparated$1,
    action: null,
    allow: null,
    allowFullScreen: $560639d49e3c9a19$var$boolean$1,
    allowPaymentRequest: $560639d49e3c9a19$var$boolean$1,
    allowUserMedia: $560639d49e3c9a19$var$boolean$1,
    alt: null,
    as: null,
    async: $560639d49e3c9a19$var$boolean$1,
    autoCapitalize: null,
    autoComplete: $560639d49e3c9a19$var$spaceSeparated$1,
    autoFocus: $560639d49e3c9a19$var$boolean$1,
    autoPlay: $560639d49e3c9a19$var$boolean$1,
    capture: $560639d49e3c9a19$var$boolean$1,
    charSet: null,
    checked: $560639d49e3c9a19$var$boolean$1,
    cite: null,
    className: $560639d49e3c9a19$var$spaceSeparated$1,
    cols: $560639d49e3c9a19$var$number$1,
    colSpan: null,
    content: null,
    contentEditable: $560639d49e3c9a19$var$booleanish,
    controls: $560639d49e3c9a19$var$boolean$1,
    controlsList: $560639d49e3c9a19$var$spaceSeparated$1,
    coords: $560639d49e3c9a19$var$number$1 | $560639d49e3c9a19$var$commaSeparated$1,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: $560639d49e3c9a19$var$boolean$1,
    defer: $560639d49e3c9a19$var$boolean$1,
    dir: null,
    dirName: null,
    disabled: $560639d49e3c9a19$var$boolean$1,
    download: $560639d49e3c9a19$var$overloadedBoolean,
    draggable: $560639d49e3c9a19$var$booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: $560639d49e3c9a19$var$boolean$1,
    formTarget: null,
    headers: $560639d49e3c9a19$var$spaceSeparated$1,
    height: $560639d49e3c9a19$var$number$1,
    hidden: $560639d49e3c9a19$var$boolean$1,
    high: $560639d49e3c9a19$var$number$1,
    href: null,
    hrefLang: null,
    htmlFor: $560639d49e3c9a19$var$spaceSeparated$1,
    httpEquiv: $560639d49e3c9a19$var$spaceSeparated$1,
    id: null,
    imageSizes: null,
    imageSrcSet: $560639d49e3c9a19$var$commaSeparated$1,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: $560639d49e3c9a19$var$boolean$1,
    itemId: null,
    itemProp: $560639d49e3c9a19$var$spaceSeparated$1,
    itemRef: $560639d49e3c9a19$var$spaceSeparated$1,
    itemScope: $560639d49e3c9a19$var$boolean$1,
    itemType: $560639d49e3c9a19$var$spaceSeparated$1,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loop: $560639d49e3c9a19$var$boolean$1,
    low: $560639d49e3c9a19$var$number$1,
    manifest: null,
    max: null,
    maxLength: $560639d49e3c9a19$var$number$1,
    media: null,
    method: null,
    min: null,
    minLength: $560639d49e3c9a19$var$number$1,
    multiple: $560639d49e3c9a19$var$boolean$1,
    muted: $560639d49e3c9a19$var$boolean$1,
    name: null,
    nonce: null,
    noModule: $560639d49e3c9a19$var$boolean$1,
    noValidate: $560639d49e3c9a19$var$boolean$1,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: $560639d49e3c9a19$var$boolean$1,
    optimum: $560639d49e3c9a19$var$number$1,
    pattern: null,
    ping: $560639d49e3c9a19$var$spaceSeparated$1,
    placeholder: null,
    playsInline: $560639d49e3c9a19$var$boolean$1,
    poster: null,
    preload: null,
    readOnly: $560639d49e3c9a19$var$boolean$1,
    referrerPolicy: null,
    rel: $560639d49e3c9a19$var$spaceSeparated$1,
    required: $560639d49e3c9a19$var$boolean$1,
    reversed: $560639d49e3c9a19$var$boolean$1,
    rows: $560639d49e3c9a19$var$number$1,
    rowSpan: $560639d49e3c9a19$var$number$1,
    sandbox: $560639d49e3c9a19$var$spaceSeparated$1,
    scope: null,
    scoped: $560639d49e3c9a19$var$boolean$1,
    seamless: $560639d49e3c9a19$var$boolean$1,
    selected: $560639d49e3c9a19$var$boolean$1,
    shape: null,
    size: $560639d49e3c9a19$var$number$1,
    sizes: null,
    slot: null,
    span: $560639d49e3c9a19$var$number$1,
    spellCheck: $560639d49e3c9a19$var$booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: $560639d49e3c9a19$var$commaSeparated$1,
    start: $560639d49e3c9a19$var$number$1,
    step: null,
    style: null,
    tabIndex: $560639d49e3c9a19$var$number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: $560639d49e3c9a19$var$boolean$1,
    useMap: null,
    value: $560639d49e3c9a19$var$booleanish,
    width: $560639d49e3c9a19$var$number$1,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    aLink: null,
    archive: $560639d49e3c9a19$var$spaceSeparated$1,
    axis: null,
    background: null,
    bgColor: null,
    border: $560639d49e3c9a19$var$number$1,
    borderColor: null,
    bottomMargin: $560639d49e3c9a19$var$number$1,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: $560639d49e3c9a19$var$boolean$1,
    declare: $560639d49e3c9a19$var$boolean$1,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: $560639d49e3c9a19$var$number$1,
    leftMargin: $560639d49e3c9a19$var$number$1,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: $560639d49e3c9a19$var$number$1,
    marginWidth: $560639d49e3c9a19$var$number$1,
    noResize: $560639d49e3c9a19$var$boolean$1,
    noHref: $560639d49e3c9a19$var$boolean$1,
    noShade: $560639d49e3c9a19$var$boolean$1,
    noWrap: $560639d49e3c9a19$var$boolean$1,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: $560639d49e3c9a19$var$number$1,
    rules: null,
    scheme: null,
    scrolling: $560639d49e3c9a19$var$booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: $560639d49e3c9a19$var$number$1,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: $560639d49e3c9a19$var$number$1,
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: $560639d49e3c9a19$var$boolean$1,
    disableRemotePlayback: $560639d49e3c9a19$var$boolean$1,
    prefix: null,
    property: null,
    results: $560639d49e3c9a19$var$number$1,
    security: null,
    unselectable: null
  }
});
var $560639d49e3c9a19$var$html_1 = $560639d49e3c9a19$var$merge_1([
  $560639d49e3c9a19$var$xml,
  $560639d49e3c9a19$var$xlink,
  $560639d49e3c9a19$var$xmlns,
  $560639d49e3c9a19$var$aria,
  $560639d49e3c9a19$var$html$2
]);
var $560639d49e3c9a19$var$boolean = $560639d49e3c9a19$var$types.boolean;
var $560639d49e3c9a19$var$number = $560639d49e3c9a19$var$types.number;
var $560639d49e3c9a19$var$spaceSeparated = $560639d49e3c9a19$var$types.spaceSeparated;
var $560639d49e3c9a19$var$commaSeparated = $560639d49e3c9a19$var$types.commaSeparated;
var $560639d49e3c9a19$var$commaOrSpaceSeparated = $560639d49e3c9a19$var$types.commaOrSpaceSeparated;
var $560639d49e3c9a19$var$svg = $560639d49e3c9a19$var$create_1({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: $560639d49e3c9a19$var$caseSensitiveTransform_1,
  properties: {
    about: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    accentHeight: $560639d49e3c9a19$var$number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: $560639d49e3c9a19$var$number,
    amplitude: $560639d49e3c9a19$var$number,
    arabicForm: null,
    ascent: $560639d49e3c9a19$var$number,
    attributeName: null,
    attributeType: null,
    azimuth: $560639d49e3c9a19$var$number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: $560639d49e3c9a19$var$number,
    by: null,
    calcMode: null,
    capHeight: $560639d49e3c9a19$var$number,
    className: $560639d49e3c9a19$var$spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: $560639d49e3c9a19$var$number,
    diffuseConstant: $560639d49e3c9a19$var$number,
    direction: null,
    display: null,
    dur: null,
    divisor: $560639d49e3c9a19$var$number,
    dominantBaseline: null,
    download: $560639d49e3c9a19$var$boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: $560639d49e3c9a19$var$number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: $560639d49e3c9a19$var$number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: $560639d49e3c9a19$var$number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: $560639d49e3c9a19$var$commaSeparated,
    g2: $560639d49e3c9a19$var$commaSeparated,
    glyphName: $560639d49e3c9a19$var$commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: $560639d49e3c9a19$var$number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: $560639d49e3c9a19$var$number,
    horizOriginX: $560639d49e3c9a19$var$number,
    horizOriginY: $560639d49e3c9a19$var$number,
    id: null,
    ideographic: $560639d49e3c9a19$var$number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: $560639d49e3c9a19$var$number,
    k: $560639d49e3c9a19$var$number,
    k1: $560639d49e3c9a19$var$number,
    k2: $560639d49e3c9a19$var$number,
    k3: $560639d49e3c9a19$var$number,
    k4: $560639d49e3c9a19$var$number,
    kernelMatrix: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: $560639d49e3c9a19$var$number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: $560639d49e3c9a19$var$number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: $560639d49e3c9a19$var$number,
    overlineThickness: $560639d49e3c9a19$var$number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: $560639d49e3c9a19$var$number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: $560639d49e3c9a19$var$spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: $560639d49e3c9a19$var$number,
    pointsAtY: $560639d49e3c9a19$var$number,
    pointsAtZ: $560639d49e3c9a19$var$number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    rev: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    requiredFeatures: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    requiredFonts: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    requiredFormats: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: $560639d49e3c9a19$var$number,
    specularExponent: $560639d49e3c9a19$var$number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: $560639d49e3c9a19$var$number,
    strikethroughThickness: $560639d49e3c9a19$var$number,
    string: null,
    stroke: null,
    strokeDashArray: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: $560639d49e3c9a19$var$number,
    strokeOpacity: $560639d49e3c9a19$var$number,
    strokeWidth: null,
    style: null,
    surfaceScale: $560639d49e3c9a19$var$number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    tabIndex: $560639d49e3c9a19$var$number,
    tableValues: null,
    target: null,
    targetX: $560639d49e3c9a19$var$number,
    targetY: $560639d49e3c9a19$var$number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: $560639d49e3c9a19$var$commaOrSpaceSeparated,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: $560639d49e3c9a19$var$number,
    underlineThickness: $560639d49e3c9a19$var$number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: $560639d49e3c9a19$var$number,
    values: null,
    vAlphabetic: $560639d49e3c9a19$var$number,
    vMathematical: $560639d49e3c9a19$var$number,
    vectorEffect: null,
    vHanging: $560639d49e3c9a19$var$number,
    vIdeographic: $560639d49e3c9a19$var$number,
    version: null,
    vertAdvY: $560639d49e3c9a19$var$number,
    vertOriginX: $560639d49e3c9a19$var$number,
    vertOriginY: $560639d49e3c9a19$var$number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: $560639d49e3c9a19$var$number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var $560639d49e3c9a19$var$svg_1 = $560639d49e3c9a19$var$merge_1([
  $560639d49e3c9a19$var$xml,
  $560639d49e3c9a19$var$xlink,
  $560639d49e3c9a19$var$xmlns,
  $560639d49e3c9a19$var$aria,
  $560639d49e3c9a19$var$svg
]);
var $560639d49e3c9a19$var$index$2 = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "menuitem",
  "meta",
  "nextid",
  "param",
  "source",
  "track",
  "wbr"
];
var $560639d49e3c9a19$var$htmlVoidElements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": $560639d49e3c9a19$var$index$2
});
var $560639d49e3c9a19$var$unistUtilIs = $560639d49e3c9a19$var$is;
function $560639d49e3c9a19$var$is(test, node, index, parent, context) {
  var hasParent = parent !== null && parent !== void 0;
  var hasIndex = index !== null && index !== void 0;
  var check = $560639d49e3c9a19$var$convert(test);
  if (hasIndex && (typeof index !== "number" || index < 0 || index === Infinity))
    throw new Error("Expected positive finite index or child node");
  if (hasParent && (!$560639d49e3c9a19$var$is(null, parent) || !parent.children))
    throw new Error("Expected parent node");
  if (!node || !node.type || typeof node.type !== "string")
    return false;
  if (hasParent !== hasIndex)
    throw new Error("Expected both parent and index");
  return Boolean(check.call(context, node, index, parent));
}
function $560639d49e3c9a19$var$convert(test) {
  if (typeof test === "string")
    return $560639d49e3c9a19$var$typeFactory(test);
  if (test === null || test === void 0)
    return $560639d49e3c9a19$var$ok;
  if (typeof test === "object")
    return ("length" in test ? $560639d49e3c9a19$var$anyFactory : $560639d49e3c9a19$var$matchesFactory)(test);
  if (typeof test === "function")
    return test;
  throw new Error("Expected function, string, or object as test");
}
function $560639d49e3c9a19$var$convertAll(tests) {
  var results = [];
  var length = tests.length;
  var index = -1;
  while (++index < length)
    results[index] = $560639d49e3c9a19$var$convert(tests[index]);
  return results;
}
function $560639d49e3c9a19$var$matchesFactory(test) {
  return matches;
  function matches(node) {
    var key;
    for (key in test) {
      if (node[key] !== test[key])
        return false;
    }
    return true;
  }
}
function $560639d49e3c9a19$var$anyFactory(tests) {
  var checks = $560639d49e3c9a19$var$convertAll(tests);
  var length = checks.length;
  return matches;
  function matches() {
    var index = -1;
    while (++index < length) {
      if (checks[index].apply(this, arguments))
        return true;
    }
    return false;
  }
}
function $560639d49e3c9a19$var$typeFactory(test) {
  return type;
  function type(node) {
    return Boolean(node && node.type === test);
  }
}
function $560639d49e3c9a19$var$ok() {
  return true;
}
var $560639d49e3c9a19$var$hastUtilIsElement = $560639d49e3c9a19$var$isElement;
function $560639d49e3c9a19$var$isElement(node, tagNames) {
  var name;
  if (!(tagNames === null || tagNames === void 0 || typeof tagNames === "string" || typeof tagNames === "object" && tagNames.length !== 0))
    throw new Error("Expected `string` or `Array.<string>` for `tagNames`, not `" + tagNames + "`");
  if (!node || typeof node !== "object" || node.type !== "element" || typeof node.tagName !== "string")
    return false;
  if (tagNames === null || tagNames === void 0)
    return true;
  name = node.tagName;
  if (typeof tagNames === "string")
    return name === tagNames;
  return tagNames.indexOf(name) !== -1;
}
var $560639d49e3c9a19$var$hastUtilWhitespace = $560639d49e3c9a19$var$interElementWhiteSpace;
var $560639d49e3c9a19$var$re = /[ \t\n\f\r]/g;
function $560639d49e3c9a19$var$interElementWhiteSpace(node) {
  var value;
  if (node && typeof node === "object" && node.type === "text")
    value = node.value || "";
  else if (typeof node === "string")
    value = node;
  else
    return false;
  return value.replace($560639d49e3c9a19$var$re, "") === "";
}
var $560639d49e3c9a19$var$before$1 = $560639d49e3c9a19$var$siblings(-1);
var $560639d49e3c9a19$var$after$2 = $560639d49e3c9a19$var$siblings(1);
function $560639d49e3c9a19$var$siblings(increment) {
  return sibling;
  function sibling(parent, index, includeWhiteSpace) {
    var siblings = parent && parent.children;
    var next;
    index += increment;
    next = siblings && siblings[index];
    if (!includeWhiteSpace)
      while (next && $560639d49e3c9a19$var$hastUtilWhitespace(next)) {
        index += increment;
        next = siblings[index];
      }
    return next;
  }
}
var $560639d49e3c9a19$var$siblings_1 = {
  before: $560639d49e3c9a19$var$before$1,
  after: $560639d49e3c9a19$var$after$2
};
var $560639d49e3c9a19$var$after$1 = $560639d49e3c9a19$var$siblings_1.after;
var $560639d49e3c9a19$var$first_1 = $560639d49e3c9a19$var$first;
function $560639d49e3c9a19$var$first(parent, includeWhiteSpace) {
  return $560639d49e3c9a19$var$after$1(parent, -1, includeWhiteSpace);
}
var $560639d49e3c9a19$var$place_1 = $560639d49e3c9a19$var$place;
function $560639d49e3c9a19$var$place(parent, child) {
  return parent && parent.children && parent.children.indexOf(child);
}
var $560639d49e3c9a19$var$whiteSpaceLeft_1 = $560639d49e3c9a19$var$whiteSpaceLeft;
function $560639d49e3c9a19$var$whiteSpaceLeft(node) {
  return $560639d49e3c9a19$var$unistUtilIs("text", node) && $560639d49e3c9a19$var$hastUtilWhitespace(node.value.charAt(0));
}
var $560639d49e3c9a19$var$omission_1 = $560639d49e3c9a19$var$omission$1;
var $560639d49e3c9a19$var$own$5 = {}.hasOwnProperty;
function $560639d49e3c9a19$var$omission$1(handlers) {
  return omit;
  function omit(node, index, parent) {
    var name = node.tagName;
    var fn = $560639d49e3c9a19$var$own$5.call(handlers, name) ? handlers[name] : false;
    return fn ? fn(node, index, parent) : false;
  }
}
var $560639d49e3c9a19$var$after = $560639d49e3c9a19$var$siblings_1.after;
var $560639d49e3c9a19$var$optionGroup = "optgroup";
var $560639d49e3c9a19$var$options = [
  "option"
].concat($560639d49e3c9a19$var$optionGroup);
var $560639d49e3c9a19$var$dataListItem = [
  "dt",
  "dd"
];
var $560639d49e3c9a19$var$listItem = "li";
var $560639d49e3c9a19$var$menuContent = [
  "menuitem",
  "hr",
  "menu"
];
var $560639d49e3c9a19$var$ruby = [
  "rp",
  "rt"
];
var $560639d49e3c9a19$var$tableContainer = [
  "tbody",
  "tfoot"
];
var $560639d49e3c9a19$var$tableRow$1 = "tr";
var $560639d49e3c9a19$var$tableCell = [
  "td",
  "th"
];
var $560639d49e3c9a19$var$confusingParagraphParent = [
  "a",
  "audio",
  "del",
  "ins",
  "map",
  "noscript",
  "video"
];
var $560639d49e3c9a19$var$clearParagraphSibling = [
  "address",
  "article",
  "aside",
  "blockquote",
  "details",
  "div",
  "dl",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "main",
  "menu",
  "nav",
  "ol",
  "p",
  "pre",
  "section",
  "table",
  "ul"
];
var $560639d49e3c9a19$var$closing$1 = $560639d49e3c9a19$var$omission_1({
  html: $560639d49e3c9a19$var$html$1,
  head: $560639d49e3c9a19$var$headOrColgroupOrCaption,
  body: $560639d49e3c9a19$var$body$1,
  p: $560639d49e3c9a19$var$p,
  li: $560639d49e3c9a19$var$li,
  dt: $560639d49e3c9a19$var$dt,
  dd: $560639d49e3c9a19$var$dd,
  rt: $560639d49e3c9a19$var$rubyElement,
  rp: $560639d49e3c9a19$var$rubyElement,
  optgroup: $560639d49e3c9a19$var$optgroup,
  option: $560639d49e3c9a19$var$option,
  menuitem: $560639d49e3c9a19$var$menuitem,
  colgroup: $560639d49e3c9a19$var$headOrColgroupOrCaption,
  caption: $560639d49e3c9a19$var$headOrColgroupOrCaption,
  thead: $560639d49e3c9a19$var$thead,
  tbody: $560639d49e3c9a19$var$tbody$1,
  tfoot: $560639d49e3c9a19$var$tfoot,
  tr: $560639d49e3c9a19$var$tr,
  td: $560639d49e3c9a19$var$cells,
  th: $560639d49e3c9a19$var$cells
});
function $560639d49e3c9a19$var$headOrColgroupOrCaption(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index, true);
  return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next) && !$560639d49e3c9a19$var$whiteSpaceLeft_1(next);
}
function $560639d49e3c9a19$var$html$1(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next);
}
function $560639d49e3c9a19$var$body$1(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || !$560639d49e3c9a19$var$unistUtilIs("comment", next);
}
function $560639d49e3c9a19$var$p(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return next ? $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$clearParagraphSibling) : !parent || !$560639d49e3c9a19$var$hastUtilIsElement(parent, $560639d49e3c9a19$var$confusingParagraphParent);
}
function $560639d49e3c9a19$var$li(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$listItem);
}
function $560639d49e3c9a19$var$dt(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return next && $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$dataListItem);
}
function $560639d49e3c9a19$var$dd(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$dataListItem);
}
function $560639d49e3c9a19$var$rubyElement(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$ruby);
}
function $560639d49e3c9a19$var$optgroup(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$optionGroup);
}
function $560639d49e3c9a19$var$option(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$options);
}
function $560639d49e3c9a19$var$menuitem(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$menuContent);
}
function $560639d49e3c9a19$var$thead(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return next && $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableContainer);
}
function $560639d49e3c9a19$var$tbody$1(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableContainer);
}
function $560639d49e3c9a19$var$tfoot(node, index, parent) {
  return !$560639d49e3c9a19$var$after(parent, index);
}
function $560639d49e3c9a19$var$tr(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableRow$1);
}
function $560639d49e3c9a19$var$cells(node, index, parent) {
  var next = $560639d49e3c9a19$var$after(parent, index);
  return !next || $560639d49e3c9a19$var$hastUtilIsElement(next, $560639d49e3c9a19$var$tableCell);
}
var $560639d49e3c9a19$var$before = $560639d49e3c9a19$var$siblings_1.before;
var $560639d49e3c9a19$var$own$4 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$uniqueHeadMetadata = [
  "title",
  "base"
];
var $560639d49e3c9a19$var$meta = [
  "meta",
  "link",
  "script",
  "style",
  "template"
];
var $560639d49e3c9a19$var$tableContainers = [
  "thead",
  "tbody"
];
var $560639d49e3c9a19$var$tableRow = "tr";
var $560639d49e3c9a19$var$opening$1 = $560639d49e3c9a19$var$omission_1({
  html: $560639d49e3c9a19$var$html,
  head: $560639d49e3c9a19$var$head,
  body: $560639d49e3c9a19$var$body,
  colgroup: $560639d49e3c9a19$var$colgroup,
  tbody: $560639d49e3c9a19$var$tbody
});
function $560639d49e3c9a19$var$html(node) {
  var head = $560639d49e3c9a19$var$first_1(node);
  return !head || !$560639d49e3c9a19$var$unistUtilIs("comment", head);
}
function $560639d49e3c9a19$var$head(node) {
  var children = node.children;
  var length = children.length;
  var map = {};
  var index = -1;
  var child;
  var name;
  while (++index < length) {
    child = children[index];
    name = child.tagName;
    if ($560639d49e3c9a19$var$hastUtilIsElement(child, $560639d49e3c9a19$var$uniqueHeadMetadata)) {
      if ($560639d49e3c9a19$var$own$4.call(map, name))
        return false;
      map[name] = true;
    }
  }
  return Boolean(length);
}
function $560639d49e3c9a19$var$body(node) {
  var head = $560639d49e3c9a19$var$first_1(node, true);
  return !head || !$560639d49e3c9a19$var$unistUtilIs("comment", head) && !$560639d49e3c9a19$var$whiteSpaceLeft_1(head) && !$560639d49e3c9a19$var$hastUtilIsElement(head, $560639d49e3c9a19$var$meta);
}
function $560639d49e3c9a19$var$colgroup(node, index, parent) {
  var prev = $560639d49e3c9a19$var$before(parent, index);
  var head = $560639d49e3c9a19$var$first_1(node, true);
  if ($560639d49e3c9a19$var$hastUtilIsElement(prev, "colgroup") && $560639d49e3c9a19$var$closing$1(prev, $560639d49e3c9a19$var$place_1(parent, prev), parent))
    return false;
  return head && $560639d49e3c9a19$var$hastUtilIsElement(head, "col");
}
function $560639d49e3c9a19$var$tbody(node, index, parent) {
  var prev = $560639d49e3c9a19$var$before(parent, index);
  var head = $560639d49e3c9a19$var$first_1(node);
  if ($560639d49e3c9a19$var$hastUtilIsElement(prev, $560639d49e3c9a19$var$tableContainers) && $560639d49e3c9a19$var$closing$1(prev, $560639d49e3c9a19$var$place_1(parent, prev), parent))
    return false;
  return head && $560639d49e3c9a19$var$hastUtilIsElement(head, $560639d49e3c9a19$var$tableRow);
}
var $560639d49e3c9a19$var$opening = $560639d49e3c9a19$var$opening$1;
var $560639d49e3c9a19$var$closing = $560639d49e3c9a19$var$closing$1;
var $560639d49e3c9a19$var$omission = {
  opening: $560639d49e3c9a19$var$opening,
  closing: $560639d49e3c9a19$var$closing
};
var $560639d49e3c9a19$var$index$1 = [
  "script",
  "style",
  "pre",
  "textarea"
];
var $560639d49e3c9a19$var$htmlWhitespaceSensitiveTagNames = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": $560639d49e3c9a19$var$index$1
});
var $560639d49e3c9a19$var$sensitive = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$htmlWhitespaceSensitiveTagNames);
var $560639d49e3c9a19$var$all_1 = $560639d49e3c9a19$var$all$1;
function $560639d49e3c9a19$var$all$1(ctx, parent) {
  var children = parent && parent.children;
  var length = children && children.length;
  var index = -1;
  var results = [];
  let printWidthOffset = 0;
  let innerTextLength = 0;
  while (++index < length) {
    innerTextLength = $560639d49e3c9a19$var$getInnerTextLength(children[index]);
    results[index] = $560639d49e3c9a19$var$one_1(ctx, children[index], index, parent, printWidthOffset, innerTextLength);
    printWidthOffset = results[index].replace(/\n+/g, "").length;
  }
  return results.join("");
}
function $560639d49e3c9a19$var$getInnerTextLength(node) {
  if ($560639d49e3c9a19$var$sensitive.indexOf(node.tagName) !== -1)
    return 0;
  if (!node.children || !node.children.length)
    return 0;
  var child = node.children[0];
  if (child.type === "text" || child.type === "comment")
    return child.value.split("\n")[0].length;
  return 0;
}
var $560639d49e3c9a19$var$text_1 = $560639d49e3c9a19$var$text;
function $560639d49e3c9a19$var$text(ctx, node, index, parent) {
  var value = node.value;
  return value;
}
var $560639d49e3c9a19$var$data = "data";
var $560639d49e3c9a19$var$find_1 = $560639d49e3c9a19$var$find;
var $560639d49e3c9a19$var$valid = /^data[-\w.:]+$/i;
var $560639d49e3c9a19$var$dash = /-[a-z]/g;
var $560639d49e3c9a19$var$cap$1 = /[A-Z]/g;
function $560639d49e3c9a19$var$find(schema, value) {
  var normal = $560639d49e3c9a19$var$normalize_1(value);
  var prop = value;
  var Type = $560639d49e3c9a19$var$info;
  if (normal in schema.normal)
    return schema.property[schema.normal[normal]];
  if (normal.length > 4 && normal.slice(0, 4) === $560639d49e3c9a19$var$data && $560639d49e3c9a19$var$valid.test(value)) {
    if (value.charAt(4) === "-")
      prop = $560639d49e3c9a19$var$datasetToProperty(value);
    else
      value = $560639d49e3c9a19$var$datasetToAttribute(value);
    Type = $560639d49e3c9a19$var$definedInfo;
  }
  return new Type(prop, value);
}
function $560639d49e3c9a19$var$datasetToProperty(attribute) {
  var value = attribute.slice(5).replace($560639d49e3c9a19$var$dash, $560639d49e3c9a19$var$camelcase);
  return $560639d49e3c9a19$var$data + value.charAt(0).toUpperCase() + value.slice(1);
}
function $560639d49e3c9a19$var$datasetToAttribute(property) {
  var value = property.slice(4);
  if ($560639d49e3c9a19$var$dash.test(value))
    return property;
  value = value.replace($560639d49e3c9a19$var$cap$1, $560639d49e3c9a19$var$kebab);
  if (value.charAt(0) !== "-")
    value = "-" + value;
  return $560639d49e3c9a19$var$data + value;
}
function $560639d49e3c9a19$var$kebab($0) {
  return "-" + $0.toLowerCase();
}
function $560639d49e3c9a19$var$camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var $560639d49e3c9a19$var$parse_1 = $560639d49e3c9a19$var$parse$2;
var $560639d49e3c9a19$var$stringify_1 = $560639d49e3c9a19$var$stringify$2;
var $560639d49e3c9a19$var$comma = ",";
var $560639d49e3c9a19$var$space$2 = " ";
var $560639d49e3c9a19$var$empty$1 = "";
function $560639d49e3c9a19$var$parse$2(value) {
  var values = [];
  var input = String(value || $560639d49e3c9a19$var$empty$1);
  var index = input.indexOf($560639d49e3c9a19$var$comma);
  var lastIndex = 0;
  var end = false;
  var val;
  while (!end) {
    if (index === -1) {
      index = input.length;
      end = true;
    }
    val = input.slice(lastIndex, index).trim();
    if (val || !end)
      values.push(val);
    lastIndex = index + 1;
    index = input.indexOf($560639d49e3c9a19$var$comma, lastIndex);
  }
  return values;
}
function $560639d49e3c9a19$var$stringify$2(values, options) {
  var settings = options || {};
  var left = settings.padLeft === false ? $560639d49e3c9a19$var$empty$1 : $560639d49e3c9a19$var$space$2;
  var right = settings.padRight ? $560639d49e3c9a19$var$space$2 : $560639d49e3c9a19$var$empty$1;
  if (values[values.length - 1] === $560639d49e3c9a19$var$empty$1)
    values = values.concat($560639d49e3c9a19$var$empty$1);
  return values.join(right + $560639d49e3c9a19$var$comma + left).trim();
}
var $560639d49e3c9a19$var$commaSeparatedTokens = {
  parse: $560639d49e3c9a19$var$parse_1,
  stringify: $560639d49e3c9a19$var$stringify_1
};
var $560639d49e3c9a19$var$nbsp = " ";
var $560639d49e3c9a19$var$iexcl = "¡";
var $560639d49e3c9a19$var$cent = "¢";
var $560639d49e3c9a19$var$pound = "£";
var $560639d49e3c9a19$var$curren = "¤";
var $560639d49e3c9a19$var$yen = "¥";
var $560639d49e3c9a19$var$brvbar = "¦";
var $560639d49e3c9a19$var$sect = "§";
var $560639d49e3c9a19$var$uml = "¨";
var $560639d49e3c9a19$var$copy = "©";
var $560639d49e3c9a19$var$ordf = "ª";
var $560639d49e3c9a19$var$laquo = "«";
var $560639d49e3c9a19$var$not = "¬";
var $560639d49e3c9a19$var$shy = "­";
var $560639d49e3c9a19$var$reg = "®";
var $560639d49e3c9a19$var$macr = "¯";
var $560639d49e3c9a19$var$deg = "°";
var $560639d49e3c9a19$var$plusmn = "±";
var $560639d49e3c9a19$var$sup2 = "²";
var $560639d49e3c9a19$var$sup3 = "³";
var $560639d49e3c9a19$var$acute = "´";
var $560639d49e3c9a19$var$micro = "µ";
var $560639d49e3c9a19$var$para = "¶";
var $560639d49e3c9a19$var$middot = "·";
var $560639d49e3c9a19$var$cedil = "¸";
var $560639d49e3c9a19$var$sup1 = "¹";
var $560639d49e3c9a19$var$ordm = "º";
var $560639d49e3c9a19$var$raquo = "»";
var $560639d49e3c9a19$var$frac14 = "¼";
var $560639d49e3c9a19$var$frac12 = "½";
var $560639d49e3c9a19$var$frac34 = "¾";
var $560639d49e3c9a19$var$iquest = "¿";
var $560639d49e3c9a19$var$Agrave = "À";
var $560639d49e3c9a19$var$Aacute = "Á";
var $560639d49e3c9a19$var$Acirc = "Â";
var $560639d49e3c9a19$var$Atilde = "Ã";
var $560639d49e3c9a19$var$Auml = "Ä";
var $560639d49e3c9a19$var$Aring = "Å";
var $560639d49e3c9a19$var$AElig = "Æ";
var $560639d49e3c9a19$var$Ccedil = "Ç";
var $560639d49e3c9a19$var$Egrave = "È";
var $560639d49e3c9a19$var$Eacute = "É";
var $560639d49e3c9a19$var$Ecirc = "Ê";
var $560639d49e3c9a19$var$Euml = "Ë";
var $560639d49e3c9a19$var$Igrave = "Ì";
var $560639d49e3c9a19$var$Iacute = "Í";
var $560639d49e3c9a19$var$Icirc = "Î";
var $560639d49e3c9a19$var$Iuml = "Ï";
var $560639d49e3c9a19$var$ETH = "Ð";
var $560639d49e3c9a19$var$Ntilde = "Ñ";
var $560639d49e3c9a19$var$Ograve = "Ò";
var $560639d49e3c9a19$var$Oacute = "Ó";
var $560639d49e3c9a19$var$Ocirc = "Ô";
var $560639d49e3c9a19$var$Otilde = "Õ";
var $560639d49e3c9a19$var$Ouml = "Ö";
var $560639d49e3c9a19$var$times = "×";
var $560639d49e3c9a19$var$Oslash = "Ø";
var $560639d49e3c9a19$var$Ugrave = "Ù";
var $560639d49e3c9a19$var$Uacute = "Ú";
var $560639d49e3c9a19$var$Ucirc = "Û";
var $560639d49e3c9a19$var$Uuml = "Ü";
var $560639d49e3c9a19$var$Yacute = "Ý";
var $560639d49e3c9a19$var$THORN = "Þ";
var $560639d49e3c9a19$var$szlig = "ß";
var $560639d49e3c9a19$var$agrave = "à";
var $560639d49e3c9a19$var$aacute = "á";
var $560639d49e3c9a19$var$acirc = "â";
var $560639d49e3c9a19$var$atilde = "ã";
var $560639d49e3c9a19$var$auml = "ä";
var $560639d49e3c9a19$var$aring = "å";
var $560639d49e3c9a19$var$aelig = "æ";
var $560639d49e3c9a19$var$ccedil = "ç";
var $560639d49e3c9a19$var$egrave = "è";
var $560639d49e3c9a19$var$eacute = "é";
var $560639d49e3c9a19$var$ecirc = "ê";
var $560639d49e3c9a19$var$euml = "ë";
var $560639d49e3c9a19$var$igrave = "ì";
var $560639d49e3c9a19$var$iacute = "í";
var $560639d49e3c9a19$var$icirc = "î";
var $560639d49e3c9a19$var$iuml = "ï";
var $560639d49e3c9a19$var$eth = "ð";
var $560639d49e3c9a19$var$ntilde = "ñ";
var $560639d49e3c9a19$var$ograve = "ò";
var $560639d49e3c9a19$var$oacute = "ó";
var $560639d49e3c9a19$var$ocirc = "ô";
var $560639d49e3c9a19$var$otilde = "õ";
var $560639d49e3c9a19$var$ouml = "ö";
var $560639d49e3c9a19$var$divide = "÷";
var $560639d49e3c9a19$var$oslash = "ø";
var $560639d49e3c9a19$var$ugrave = "ù";
var $560639d49e3c9a19$var$uacute = "ú";
var $560639d49e3c9a19$var$ucirc = "û";
var $560639d49e3c9a19$var$uuml = "ü";
var $560639d49e3c9a19$var$yacute = "ý";
var $560639d49e3c9a19$var$thorn = "þ";
var $560639d49e3c9a19$var$yuml = "ÿ";
var $560639d49e3c9a19$var$fnof = "ƒ";
var $560639d49e3c9a19$var$Alpha = "Α";
var $560639d49e3c9a19$var$Beta = "Β";
var $560639d49e3c9a19$var$Gamma = "Γ";
var $560639d49e3c9a19$var$Delta = "Δ";
var $560639d49e3c9a19$var$Epsilon = "Ε";
var $560639d49e3c9a19$var$Zeta = "Ζ";
var $560639d49e3c9a19$var$Eta = "Η";
var $560639d49e3c9a19$var$Theta = "Θ";
var $560639d49e3c9a19$var$Iota = "Ι";
var $560639d49e3c9a19$var$Kappa = "Κ";
var $560639d49e3c9a19$var$Lambda = "Λ";
var $560639d49e3c9a19$var$Mu = "Μ";
var $560639d49e3c9a19$var$Nu = "Ν";
var $560639d49e3c9a19$var$Xi = "Ξ";
var $560639d49e3c9a19$var$Omicron = "Ο";
var $560639d49e3c9a19$var$Pi = "Π";
var $560639d49e3c9a19$var$Rho = "Ρ";
var $560639d49e3c9a19$var$Sigma = "Σ";
var $560639d49e3c9a19$var$Tau = "Τ";
var $560639d49e3c9a19$var$Upsilon = "Υ";
var $560639d49e3c9a19$var$Phi = "Φ";
var $560639d49e3c9a19$var$Chi = "Χ";
var $560639d49e3c9a19$var$Psi = "Ψ";
var $560639d49e3c9a19$var$Omega = "Ω";
var $560639d49e3c9a19$var$alpha = "α";
var $560639d49e3c9a19$var$beta = "β";
var $560639d49e3c9a19$var$gamma = "γ";
var $560639d49e3c9a19$var$delta = "δ";
var $560639d49e3c9a19$var$epsilon = "ε";
var $560639d49e3c9a19$var$zeta = "ζ";
var $560639d49e3c9a19$var$eta = "η";
var $560639d49e3c9a19$var$theta = "θ";
var $560639d49e3c9a19$var$iota = "ι";
var $560639d49e3c9a19$var$kappa = "κ";
var $560639d49e3c9a19$var$lambda = "λ";
var $560639d49e3c9a19$var$mu = "μ";
var $560639d49e3c9a19$var$nu = "ν";
var $560639d49e3c9a19$var$xi = "ξ";
var $560639d49e3c9a19$var$omicron = "ο";
var $560639d49e3c9a19$var$pi = "π";
var $560639d49e3c9a19$var$rho = "ρ";
var $560639d49e3c9a19$var$sigmaf = "ς";
var $560639d49e3c9a19$var$sigma = "σ";
var $560639d49e3c9a19$var$tau = "τ";
var $560639d49e3c9a19$var$upsilon = "υ";
var $560639d49e3c9a19$var$phi = "φ";
var $560639d49e3c9a19$var$chi = "χ";
var $560639d49e3c9a19$var$psi = "ψ";
var $560639d49e3c9a19$var$omega = "ω";
var $560639d49e3c9a19$var$thetasym = "ϑ";
var $560639d49e3c9a19$var$upsih = "ϒ";
var $560639d49e3c9a19$var$piv = "ϖ";
var $560639d49e3c9a19$var$bull = "•";
var $560639d49e3c9a19$var$hellip = "…";
var $560639d49e3c9a19$var$prime = "′";
var $560639d49e3c9a19$var$Prime = "″";
var $560639d49e3c9a19$var$oline = "‾";
var $560639d49e3c9a19$var$frasl = "⁄";
var $560639d49e3c9a19$var$weierp = "℘";
var $560639d49e3c9a19$var$image = "ℑ";
var $560639d49e3c9a19$var$real = "ℜ";
var $560639d49e3c9a19$var$trade = "™";
var $560639d49e3c9a19$var$alefsym = "ℵ";
var $560639d49e3c9a19$var$larr = "←";
var $560639d49e3c9a19$var$uarr = "↑";
var $560639d49e3c9a19$var$rarr = "→";
var $560639d49e3c9a19$var$darr = "↓";
var $560639d49e3c9a19$var$harr = "↔";
var $560639d49e3c9a19$var$crarr = "↵";
var $560639d49e3c9a19$var$lArr = "⇐";
var $560639d49e3c9a19$var$uArr = "⇑";
var $560639d49e3c9a19$var$rArr = "⇒";
var $560639d49e3c9a19$var$dArr = "⇓";
var $560639d49e3c9a19$var$hArr = "⇔";
var $560639d49e3c9a19$var$forall = "∀";
var $560639d49e3c9a19$var$part = "∂";
var $560639d49e3c9a19$var$exist = "∃";
var $560639d49e3c9a19$var$empty = "∅";
var $560639d49e3c9a19$var$nabla = "∇";
var $560639d49e3c9a19$var$isin = "∈";
var $560639d49e3c9a19$var$notin = "∉";
var $560639d49e3c9a19$var$ni = "∋";
var $560639d49e3c9a19$var$prod = "∏";
var $560639d49e3c9a19$var$sum = "∑";
var $560639d49e3c9a19$var$minus = "−";
var $560639d49e3c9a19$var$lowast = "∗";
var $560639d49e3c9a19$var$radic = "√";
var $560639d49e3c9a19$var$prop = "∝";
var $560639d49e3c9a19$var$infin = "∞";
var $560639d49e3c9a19$var$ang = "∠";
var $560639d49e3c9a19$var$and = "∧";
var $560639d49e3c9a19$var$or = "∨";
var $560639d49e3c9a19$var$cap = "∩";
var $560639d49e3c9a19$var$cup = "∪";
var $560639d49e3c9a19$var$int = "∫";
var $560639d49e3c9a19$var$there4 = "∴";
var $560639d49e3c9a19$var$sim = "∼";
var $560639d49e3c9a19$var$cong = "≅";
var $560639d49e3c9a19$var$asymp = "≈";
var $560639d49e3c9a19$var$ne = "≠";
var $560639d49e3c9a19$var$equiv = "≡";
var $560639d49e3c9a19$var$le = "≤";
var $560639d49e3c9a19$var$ge = "≥";
var $560639d49e3c9a19$var$sub = "⊂";
var $560639d49e3c9a19$var$sup = "⊃";
var $560639d49e3c9a19$var$nsub = "⊄";
var $560639d49e3c9a19$var$sube = "⊆";
var $560639d49e3c9a19$var$supe = "⊇";
var $560639d49e3c9a19$var$oplus = "⊕";
var $560639d49e3c9a19$var$otimes = "⊗";
var $560639d49e3c9a19$var$perp = "⊥";
var $560639d49e3c9a19$var$sdot = "⋅";
var $560639d49e3c9a19$var$lceil = "⌈";
var $560639d49e3c9a19$var$rceil = "⌉";
var $560639d49e3c9a19$var$lfloor = "⌊";
var $560639d49e3c9a19$var$rfloor = "⌋";
var $560639d49e3c9a19$var$lang = "〈";
var $560639d49e3c9a19$var$rang = "〉";
var $560639d49e3c9a19$var$loz = "◊";
var $560639d49e3c9a19$var$spades = "♠";
var $560639d49e3c9a19$var$clubs = "♣";
var $560639d49e3c9a19$var$hearts = "♥";
var $560639d49e3c9a19$var$diams = "♦";
var $560639d49e3c9a19$var$quot = '"';
var $560639d49e3c9a19$var$amp = "&";
var $560639d49e3c9a19$var$lt = "<";
var $560639d49e3c9a19$var$gt = ">";
var $560639d49e3c9a19$var$OElig = "Œ";
var $560639d49e3c9a19$var$oelig = "œ";
var $560639d49e3c9a19$var$Scaron = "Š";
var $560639d49e3c9a19$var$scaron = "š";
var $560639d49e3c9a19$var$Yuml = "Ÿ";
var $560639d49e3c9a19$var$circ = "ˆ";
var $560639d49e3c9a19$var$tilde = "˜";
var $560639d49e3c9a19$var$ensp = " ";
var $560639d49e3c9a19$var$emsp = " ";
var $560639d49e3c9a19$var$thinsp = " ";
var $560639d49e3c9a19$var$zwnj = "‌";
var $560639d49e3c9a19$var$zwj = "‍";
var $560639d49e3c9a19$var$lrm = "‎";
var $560639d49e3c9a19$var$rlm = "‏";
var $560639d49e3c9a19$var$ndash = "–";
var $560639d49e3c9a19$var$mdash = "—";
var $560639d49e3c9a19$var$lsquo = "‘";
var $560639d49e3c9a19$var$rsquo = "’";
var $560639d49e3c9a19$var$sbquo = "‚";
var $560639d49e3c9a19$var$ldquo = "“";
var $560639d49e3c9a19$var$rdquo = "”";
var $560639d49e3c9a19$var$bdquo = "„";
var $560639d49e3c9a19$var$dagger = "†";
var $560639d49e3c9a19$var$Dagger = "‡";
var $560639d49e3c9a19$var$permil = "‰";
var $560639d49e3c9a19$var$lsaquo = "‹";
var $560639d49e3c9a19$var$rsaquo = "›";
var $560639d49e3c9a19$var$euro = "€";
var $560639d49e3c9a19$var$index = {
  nbsp: $560639d49e3c9a19$var$nbsp,
  iexcl: $560639d49e3c9a19$var$iexcl,
  cent: $560639d49e3c9a19$var$cent,
  pound: $560639d49e3c9a19$var$pound,
  curren: $560639d49e3c9a19$var$curren,
  yen: $560639d49e3c9a19$var$yen,
  brvbar: $560639d49e3c9a19$var$brvbar,
  sect: $560639d49e3c9a19$var$sect,
  uml: $560639d49e3c9a19$var$uml,
  copy: $560639d49e3c9a19$var$copy,
  ordf: $560639d49e3c9a19$var$ordf,
  laquo: $560639d49e3c9a19$var$laquo,
  not: $560639d49e3c9a19$var$not,
  shy: $560639d49e3c9a19$var$shy,
  reg: $560639d49e3c9a19$var$reg,
  macr: $560639d49e3c9a19$var$macr,
  deg: $560639d49e3c9a19$var$deg,
  plusmn: $560639d49e3c9a19$var$plusmn,
  sup2: $560639d49e3c9a19$var$sup2,
  sup3: $560639d49e3c9a19$var$sup3,
  acute: $560639d49e3c9a19$var$acute,
  micro: $560639d49e3c9a19$var$micro,
  para: $560639d49e3c9a19$var$para,
  middot: $560639d49e3c9a19$var$middot,
  cedil: $560639d49e3c9a19$var$cedil,
  sup1: $560639d49e3c9a19$var$sup1,
  ordm: $560639d49e3c9a19$var$ordm,
  raquo: $560639d49e3c9a19$var$raquo,
  frac14: $560639d49e3c9a19$var$frac14,
  frac12: $560639d49e3c9a19$var$frac12,
  frac34: $560639d49e3c9a19$var$frac34,
  iquest: $560639d49e3c9a19$var$iquest,
  Agrave: $560639d49e3c9a19$var$Agrave,
  Aacute: $560639d49e3c9a19$var$Aacute,
  Acirc: $560639d49e3c9a19$var$Acirc,
  Atilde: $560639d49e3c9a19$var$Atilde,
  Auml: $560639d49e3c9a19$var$Auml,
  Aring: $560639d49e3c9a19$var$Aring,
  AElig: $560639d49e3c9a19$var$AElig,
  Ccedil: $560639d49e3c9a19$var$Ccedil,
  Egrave: $560639d49e3c9a19$var$Egrave,
  Eacute: $560639d49e3c9a19$var$Eacute,
  Ecirc: $560639d49e3c9a19$var$Ecirc,
  Euml: $560639d49e3c9a19$var$Euml,
  Igrave: $560639d49e3c9a19$var$Igrave,
  Iacute: $560639d49e3c9a19$var$Iacute,
  Icirc: $560639d49e3c9a19$var$Icirc,
  Iuml: $560639d49e3c9a19$var$Iuml,
  ETH: $560639d49e3c9a19$var$ETH,
  Ntilde: $560639d49e3c9a19$var$Ntilde,
  Ograve: $560639d49e3c9a19$var$Ograve,
  Oacute: $560639d49e3c9a19$var$Oacute,
  Ocirc: $560639d49e3c9a19$var$Ocirc,
  Otilde: $560639d49e3c9a19$var$Otilde,
  Ouml: $560639d49e3c9a19$var$Ouml,
  times: $560639d49e3c9a19$var$times,
  Oslash: $560639d49e3c9a19$var$Oslash,
  Ugrave: $560639d49e3c9a19$var$Ugrave,
  Uacute: $560639d49e3c9a19$var$Uacute,
  Ucirc: $560639d49e3c9a19$var$Ucirc,
  Uuml: $560639d49e3c9a19$var$Uuml,
  Yacute: $560639d49e3c9a19$var$Yacute,
  THORN: $560639d49e3c9a19$var$THORN,
  szlig: $560639d49e3c9a19$var$szlig,
  agrave: $560639d49e3c9a19$var$agrave,
  aacute: $560639d49e3c9a19$var$aacute,
  acirc: $560639d49e3c9a19$var$acirc,
  atilde: $560639d49e3c9a19$var$atilde,
  auml: $560639d49e3c9a19$var$auml,
  aring: $560639d49e3c9a19$var$aring,
  aelig: $560639d49e3c9a19$var$aelig,
  ccedil: $560639d49e3c9a19$var$ccedil,
  egrave: $560639d49e3c9a19$var$egrave,
  eacute: $560639d49e3c9a19$var$eacute,
  ecirc: $560639d49e3c9a19$var$ecirc,
  euml: $560639d49e3c9a19$var$euml,
  igrave: $560639d49e3c9a19$var$igrave,
  iacute: $560639d49e3c9a19$var$iacute,
  icirc: $560639d49e3c9a19$var$icirc,
  iuml: $560639d49e3c9a19$var$iuml,
  eth: $560639d49e3c9a19$var$eth,
  ntilde: $560639d49e3c9a19$var$ntilde,
  ograve: $560639d49e3c9a19$var$ograve,
  oacute: $560639d49e3c9a19$var$oacute,
  ocirc: $560639d49e3c9a19$var$ocirc,
  otilde: $560639d49e3c9a19$var$otilde,
  ouml: $560639d49e3c9a19$var$ouml,
  divide: $560639d49e3c9a19$var$divide,
  oslash: $560639d49e3c9a19$var$oslash,
  ugrave: $560639d49e3c9a19$var$ugrave,
  uacute: $560639d49e3c9a19$var$uacute,
  ucirc: $560639d49e3c9a19$var$ucirc,
  uuml: $560639d49e3c9a19$var$uuml,
  yacute: $560639d49e3c9a19$var$yacute,
  thorn: $560639d49e3c9a19$var$thorn,
  yuml: $560639d49e3c9a19$var$yuml,
  fnof: $560639d49e3c9a19$var$fnof,
  Alpha: $560639d49e3c9a19$var$Alpha,
  Beta: $560639d49e3c9a19$var$Beta,
  Gamma: $560639d49e3c9a19$var$Gamma,
  Delta: $560639d49e3c9a19$var$Delta,
  Epsilon: $560639d49e3c9a19$var$Epsilon,
  Zeta: $560639d49e3c9a19$var$Zeta,
  Eta: $560639d49e3c9a19$var$Eta,
  Theta: $560639d49e3c9a19$var$Theta,
  Iota: $560639d49e3c9a19$var$Iota,
  Kappa: $560639d49e3c9a19$var$Kappa,
  Lambda: $560639d49e3c9a19$var$Lambda,
  Mu: $560639d49e3c9a19$var$Mu,
  Nu: $560639d49e3c9a19$var$Nu,
  Xi: $560639d49e3c9a19$var$Xi,
  Omicron: $560639d49e3c9a19$var$Omicron,
  Pi: $560639d49e3c9a19$var$Pi,
  Rho: $560639d49e3c9a19$var$Rho,
  Sigma: $560639d49e3c9a19$var$Sigma,
  Tau: $560639d49e3c9a19$var$Tau,
  Upsilon: $560639d49e3c9a19$var$Upsilon,
  Phi: $560639d49e3c9a19$var$Phi,
  Chi: $560639d49e3c9a19$var$Chi,
  Psi: $560639d49e3c9a19$var$Psi,
  Omega: $560639d49e3c9a19$var$Omega,
  alpha: $560639d49e3c9a19$var$alpha,
  beta: $560639d49e3c9a19$var$beta,
  gamma: $560639d49e3c9a19$var$gamma,
  delta: $560639d49e3c9a19$var$delta,
  epsilon: $560639d49e3c9a19$var$epsilon,
  zeta: $560639d49e3c9a19$var$zeta,
  eta: $560639d49e3c9a19$var$eta,
  theta: $560639d49e3c9a19$var$theta,
  iota: $560639d49e3c9a19$var$iota,
  kappa: $560639d49e3c9a19$var$kappa,
  lambda: $560639d49e3c9a19$var$lambda,
  mu: $560639d49e3c9a19$var$mu,
  nu: $560639d49e3c9a19$var$nu,
  xi: $560639d49e3c9a19$var$xi,
  omicron: $560639d49e3c9a19$var$omicron,
  pi: $560639d49e3c9a19$var$pi,
  rho: $560639d49e3c9a19$var$rho,
  sigmaf: $560639d49e3c9a19$var$sigmaf,
  sigma: $560639d49e3c9a19$var$sigma,
  tau: $560639d49e3c9a19$var$tau,
  upsilon: $560639d49e3c9a19$var$upsilon,
  phi: $560639d49e3c9a19$var$phi,
  chi: $560639d49e3c9a19$var$chi,
  psi: $560639d49e3c9a19$var$psi,
  omega: $560639d49e3c9a19$var$omega,
  thetasym: $560639d49e3c9a19$var$thetasym,
  upsih: $560639d49e3c9a19$var$upsih,
  piv: $560639d49e3c9a19$var$piv,
  bull: $560639d49e3c9a19$var$bull,
  hellip: $560639d49e3c9a19$var$hellip,
  prime: $560639d49e3c9a19$var$prime,
  Prime: $560639d49e3c9a19$var$Prime,
  oline: $560639d49e3c9a19$var$oline,
  frasl: $560639d49e3c9a19$var$frasl,
  weierp: $560639d49e3c9a19$var$weierp,
  image: $560639d49e3c9a19$var$image,
  real: $560639d49e3c9a19$var$real,
  trade: $560639d49e3c9a19$var$trade,
  alefsym: $560639d49e3c9a19$var$alefsym,
  larr: $560639d49e3c9a19$var$larr,
  uarr: $560639d49e3c9a19$var$uarr,
  rarr: $560639d49e3c9a19$var$rarr,
  darr: $560639d49e3c9a19$var$darr,
  harr: $560639d49e3c9a19$var$harr,
  crarr: $560639d49e3c9a19$var$crarr,
  lArr: $560639d49e3c9a19$var$lArr,
  uArr: $560639d49e3c9a19$var$uArr,
  rArr: $560639d49e3c9a19$var$rArr,
  dArr: $560639d49e3c9a19$var$dArr,
  hArr: $560639d49e3c9a19$var$hArr,
  forall: $560639d49e3c9a19$var$forall,
  part: $560639d49e3c9a19$var$part,
  exist: $560639d49e3c9a19$var$exist,
  empty: $560639d49e3c9a19$var$empty,
  nabla: $560639d49e3c9a19$var$nabla,
  isin: $560639d49e3c9a19$var$isin,
  notin: $560639d49e3c9a19$var$notin,
  ni: $560639d49e3c9a19$var$ni,
  prod: $560639d49e3c9a19$var$prod,
  sum: $560639d49e3c9a19$var$sum,
  minus: $560639d49e3c9a19$var$minus,
  lowast: $560639d49e3c9a19$var$lowast,
  radic: $560639d49e3c9a19$var$radic,
  prop: $560639d49e3c9a19$var$prop,
  infin: $560639d49e3c9a19$var$infin,
  ang: $560639d49e3c9a19$var$ang,
  and: $560639d49e3c9a19$var$and,
  or: $560639d49e3c9a19$var$or,
  cap: $560639d49e3c9a19$var$cap,
  cup: $560639d49e3c9a19$var$cup,
  int: $560639d49e3c9a19$var$int,
  there4: $560639d49e3c9a19$var$there4,
  sim: $560639d49e3c9a19$var$sim,
  cong: $560639d49e3c9a19$var$cong,
  asymp: $560639d49e3c9a19$var$asymp,
  ne: $560639d49e3c9a19$var$ne,
  equiv: $560639d49e3c9a19$var$equiv,
  le: $560639d49e3c9a19$var$le,
  ge: $560639d49e3c9a19$var$ge,
  sub: $560639d49e3c9a19$var$sub,
  sup: $560639d49e3c9a19$var$sup,
  nsub: $560639d49e3c9a19$var$nsub,
  sube: $560639d49e3c9a19$var$sube,
  supe: $560639d49e3c9a19$var$supe,
  oplus: $560639d49e3c9a19$var$oplus,
  otimes: $560639d49e3c9a19$var$otimes,
  perp: $560639d49e3c9a19$var$perp,
  sdot: $560639d49e3c9a19$var$sdot,
  lceil: $560639d49e3c9a19$var$lceil,
  rceil: $560639d49e3c9a19$var$rceil,
  lfloor: $560639d49e3c9a19$var$lfloor,
  rfloor: $560639d49e3c9a19$var$rfloor,
  lang: $560639d49e3c9a19$var$lang,
  rang: $560639d49e3c9a19$var$rang,
  loz: $560639d49e3c9a19$var$loz,
  spades: $560639d49e3c9a19$var$spades,
  clubs: $560639d49e3c9a19$var$clubs,
  hearts: $560639d49e3c9a19$var$hearts,
  diams: $560639d49e3c9a19$var$diams,
  quot: $560639d49e3c9a19$var$quot,
  amp: $560639d49e3c9a19$var$amp,
  lt: $560639d49e3c9a19$var$lt,
  gt: $560639d49e3c9a19$var$gt,
  OElig: $560639d49e3c9a19$var$OElig,
  oelig: $560639d49e3c9a19$var$oelig,
  Scaron: $560639d49e3c9a19$var$Scaron,
  scaron: $560639d49e3c9a19$var$scaron,
  Yuml: $560639d49e3c9a19$var$Yuml,
  circ: $560639d49e3c9a19$var$circ,
  tilde: $560639d49e3c9a19$var$tilde,
  ensp: $560639d49e3c9a19$var$ensp,
  emsp: $560639d49e3c9a19$var$emsp,
  thinsp: $560639d49e3c9a19$var$thinsp,
  zwnj: $560639d49e3c9a19$var$zwnj,
  zwj: $560639d49e3c9a19$var$zwj,
  lrm: $560639d49e3c9a19$var$lrm,
  rlm: $560639d49e3c9a19$var$rlm,
  ndash: $560639d49e3c9a19$var$ndash,
  mdash: $560639d49e3c9a19$var$mdash,
  lsquo: $560639d49e3c9a19$var$lsquo,
  rsquo: $560639d49e3c9a19$var$rsquo,
  sbquo: $560639d49e3c9a19$var$sbquo,
  ldquo: $560639d49e3c9a19$var$ldquo,
  rdquo: $560639d49e3c9a19$var$rdquo,
  bdquo: $560639d49e3c9a19$var$bdquo,
  dagger: $560639d49e3c9a19$var$dagger,
  Dagger: $560639d49e3c9a19$var$Dagger,
  permil: $560639d49e3c9a19$var$permil,
  lsaquo: $560639d49e3c9a19$var$lsaquo,
  rsaquo: $560639d49e3c9a19$var$rsaquo,
  euro: $560639d49e3c9a19$var$euro
};
var $560639d49e3c9a19$var$characterEntitiesHtml4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  nbsp: $560639d49e3c9a19$var$nbsp,
  iexcl: $560639d49e3c9a19$var$iexcl,
  cent: $560639d49e3c9a19$var$cent,
  pound: $560639d49e3c9a19$var$pound,
  curren: $560639d49e3c9a19$var$curren,
  yen: $560639d49e3c9a19$var$yen,
  brvbar: $560639d49e3c9a19$var$brvbar,
  sect: $560639d49e3c9a19$var$sect,
  uml: $560639d49e3c9a19$var$uml,
  copy: $560639d49e3c9a19$var$copy,
  ordf: $560639d49e3c9a19$var$ordf,
  laquo: $560639d49e3c9a19$var$laquo,
  not: $560639d49e3c9a19$var$not,
  shy: $560639d49e3c9a19$var$shy,
  reg: $560639d49e3c9a19$var$reg,
  macr: $560639d49e3c9a19$var$macr,
  deg: $560639d49e3c9a19$var$deg,
  plusmn: $560639d49e3c9a19$var$plusmn,
  sup2: $560639d49e3c9a19$var$sup2,
  sup3: $560639d49e3c9a19$var$sup3,
  acute: $560639d49e3c9a19$var$acute,
  micro: $560639d49e3c9a19$var$micro,
  para: $560639d49e3c9a19$var$para,
  middot: $560639d49e3c9a19$var$middot,
  cedil: $560639d49e3c9a19$var$cedil,
  sup1: $560639d49e3c9a19$var$sup1,
  ordm: $560639d49e3c9a19$var$ordm,
  raquo: $560639d49e3c9a19$var$raquo,
  frac14: $560639d49e3c9a19$var$frac14,
  frac12: $560639d49e3c9a19$var$frac12,
  frac34: $560639d49e3c9a19$var$frac34,
  iquest: $560639d49e3c9a19$var$iquest,
  Agrave: $560639d49e3c9a19$var$Agrave,
  Aacute: $560639d49e3c9a19$var$Aacute,
  Acirc: $560639d49e3c9a19$var$Acirc,
  Atilde: $560639d49e3c9a19$var$Atilde,
  Auml: $560639d49e3c9a19$var$Auml,
  Aring: $560639d49e3c9a19$var$Aring,
  AElig: $560639d49e3c9a19$var$AElig,
  Ccedil: $560639d49e3c9a19$var$Ccedil,
  Egrave: $560639d49e3c9a19$var$Egrave,
  Eacute: $560639d49e3c9a19$var$Eacute,
  Ecirc: $560639d49e3c9a19$var$Ecirc,
  Euml: $560639d49e3c9a19$var$Euml,
  Igrave: $560639d49e3c9a19$var$Igrave,
  Iacute: $560639d49e3c9a19$var$Iacute,
  Icirc: $560639d49e3c9a19$var$Icirc,
  Iuml: $560639d49e3c9a19$var$Iuml,
  ETH: $560639d49e3c9a19$var$ETH,
  Ntilde: $560639d49e3c9a19$var$Ntilde,
  Ograve: $560639d49e3c9a19$var$Ograve,
  Oacute: $560639d49e3c9a19$var$Oacute,
  Ocirc: $560639d49e3c9a19$var$Ocirc,
  Otilde: $560639d49e3c9a19$var$Otilde,
  Ouml: $560639d49e3c9a19$var$Ouml,
  times: $560639d49e3c9a19$var$times,
  Oslash: $560639d49e3c9a19$var$Oslash,
  Ugrave: $560639d49e3c9a19$var$Ugrave,
  Uacute: $560639d49e3c9a19$var$Uacute,
  Ucirc: $560639d49e3c9a19$var$Ucirc,
  Uuml: $560639d49e3c9a19$var$Uuml,
  Yacute: $560639d49e3c9a19$var$Yacute,
  THORN: $560639d49e3c9a19$var$THORN,
  szlig: $560639d49e3c9a19$var$szlig,
  agrave: $560639d49e3c9a19$var$agrave,
  aacute: $560639d49e3c9a19$var$aacute,
  acirc: $560639d49e3c9a19$var$acirc,
  atilde: $560639d49e3c9a19$var$atilde,
  auml: $560639d49e3c9a19$var$auml,
  aring: $560639d49e3c9a19$var$aring,
  aelig: $560639d49e3c9a19$var$aelig,
  ccedil: $560639d49e3c9a19$var$ccedil,
  egrave: $560639d49e3c9a19$var$egrave,
  eacute: $560639d49e3c9a19$var$eacute,
  ecirc: $560639d49e3c9a19$var$ecirc,
  euml: $560639d49e3c9a19$var$euml,
  igrave: $560639d49e3c9a19$var$igrave,
  iacute: $560639d49e3c9a19$var$iacute,
  icirc: $560639d49e3c9a19$var$icirc,
  iuml: $560639d49e3c9a19$var$iuml,
  eth: $560639d49e3c9a19$var$eth,
  ntilde: $560639d49e3c9a19$var$ntilde,
  ograve: $560639d49e3c9a19$var$ograve,
  oacute: $560639d49e3c9a19$var$oacute,
  ocirc: $560639d49e3c9a19$var$ocirc,
  otilde: $560639d49e3c9a19$var$otilde,
  ouml: $560639d49e3c9a19$var$ouml,
  divide: $560639d49e3c9a19$var$divide,
  oslash: $560639d49e3c9a19$var$oslash,
  ugrave: $560639d49e3c9a19$var$ugrave,
  uacute: $560639d49e3c9a19$var$uacute,
  ucirc: $560639d49e3c9a19$var$ucirc,
  uuml: $560639d49e3c9a19$var$uuml,
  yacute: $560639d49e3c9a19$var$yacute,
  thorn: $560639d49e3c9a19$var$thorn,
  yuml: $560639d49e3c9a19$var$yuml,
  fnof: $560639d49e3c9a19$var$fnof,
  Alpha: $560639d49e3c9a19$var$Alpha,
  Beta: $560639d49e3c9a19$var$Beta,
  Gamma: $560639d49e3c9a19$var$Gamma,
  Delta: $560639d49e3c9a19$var$Delta,
  Epsilon: $560639d49e3c9a19$var$Epsilon,
  Zeta: $560639d49e3c9a19$var$Zeta,
  Eta: $560639d49e3c9a19$var$Eta,
  Theta: $560639d49e3c9a19$var$Theta,
  Iota: $560639d49e3c9a19$var$Iota,
  Kappa: $560639d49e3c9a19$var$Kappa,
  Lambda: $560639d49e3c9a19$var$Lambda,
  Mu: $560639d49e3c9a19$var$Mu,
  Nu: $560639d49e3c9a19$var$Nu,
  Xi: $560639d49e3c9a19$var$Xi,
  Omicron: $560639d49e3c9a19$var$Omicron,
  Pi: $560639d49e3c9a19$var$Pi,
  Rho: $560639d49e3c9a19$var$Rho,
  Sigma: $560639d49e3c9a19$var$Sigma,
  Tau: $560639d49e3c9a19$var$Tau,
  Upsilon: $560639d49e3c9a19$var$Upsilon,
  Phi: $560639d49e3c9a19$var$Phi,
  Chi: $560639d49e3c9a19$var$Chi,
  Psi: $560639d49e3c9a19$var$Psi,
  Omega: $560639d49e3c9a19$var$Omega,
  alpha: $560639d49e3c9a19$var$alpha,
  beta: $560639d49e3c9a19$var$beta,
  gamma: $560639d49e3c9a19$var$gamma,
  delta: $560639d49e3c9a19$var$delta,
  epsilon: $560639d49e3c9a19$var$epsilon,
  zeta: $560639d49e3c9a19$var$zeta,
  eta: $560639d49e3c9a19$var$eta,
  theta: $560639d49e3c9a19$var$theta,
  iota: $560639d49e3c9a19$var$iota,
  kappa: $560639d49e3c9a19$var$kappa,
  lambda: $560639d49e3c9a19$var$lambda,
  mu: $560639d49e3c9a19$var$mu,
  nu: $560639d49e3c9a19$var$nu,
  xi: $560639d49e3c9a19$var$xi,
  omicron: $560639d49e3c9a19$var$omicron,
  pi: $560639d49e3c9a19$var$pi,
  rho: $560639d49e3c9a19$var$rho,
  sigmaf: $560639d49e3c9a19$var$sigmaf,
  sigma: $560639d49e3c9a19$var$sigma,
  tau: $560639d49e3c9a19$var$tau,
  upsilon: $560639d49e3c9a19$var$upsilon,
  phi: $560639d49e3c9a19$var$phi,
  chi: $560639d49e3c9a19$var$chi,
  psi: $560639d49e3c9a19$var$psi,
  omega: $560639d49e3c9a19$var$omega,
  thetasym: $560639d49e3c9a19$var$thetasym,
  upsih: $560639d49e3c9a19$var$upsih,
  piv: $560639d49e3c9a19$var$piv,
  bull: $560639d49e3c9a19$var$bull,
  hellip: $560639d49e3c9a19$var$hellip,
  prime: $560639d49e3c9a19$var$prime,
  Prime: $560639d49e3c9a19$var$Prime,
  oline: $560639d49e3c9a19$var$oline,
  frasl: $560639d49e3c9a19$var$frasl,
  weierp: $560639d49e3c9a19$var$weierp,
  image: $560639d49e3c9a19$var$image,
  real: $560639d49e3c9a19$var$real,
  trade: $560639d49e3c9a19$var$trade,
  alefsym: $560639d49e3c9a19$var$alefsym,
  larr: $560639d49e3c9a19$var$larr,
  uarr: $560639d49e3c9a19$var$uarr,
  rarr: $560639d49e3c9a19$var$rarr,
  darr: $560639d49e3c9a19$var$darr,
  harr: $560639d49e3c9a19$var$harr,
  crarr: $560639d49e3c9a19$var$crarr,
  lArr: $560639d49e3c9a19$var$lArr,
  uArr: $560639d49e3c9a19$var$uArr,
  rArr: $560639d49e3c9a19$var$rArr,
  dArr: $560639d49e3c9a19$var$dArr,
  hArr: $560639d49e3c9a19$var$hArr,
  forall: $560639d49e3c9a19$var$forall,
  part: $560639d49e3c9a19$var$part,
  exist: $560639d49e3c9a19$var$exist,
  empty: $560639d49e3c9a19$var$empty,
  nabla: $560639d49e3c9a19$var$nabla,
  isin: $560639d49e3c9a19$var$isin,
  notin: $560639d49e3c9a19$var$notin,
  ni: $560639d49e3c9a19$var$ni,
  prod: $560639d49e3c9a19$var$prod,
  sum: $560639d49e3c9a19$var$sum,
  minus: $560639d49e3c9a19$var$minus,
  lowast: $560639d49e3c9a19$var$lowast,
  radic: $560639d49e3c9a19$var$radic,
  prop: $560639d49e3c9a19$var$prop,
  infin: $560639d49e3c9a19$var$infin,
  ang: $560639d49e3c9a19$var$ang,
  and: $560639d49e3c9a19$var$and,
  or: $560639d49e3c9a19$var$or,
  cap: $560639d49e3c9a19$var$cap,
  cup: $560639d49e3c9a19$var$cup,
  int: $560639d49e3c9a19$var$int,
  there4: $560639d49e3c9a19$var$there4,
  sim: $560639d49e3c9a19$var$sim,
  cong: $560639d49e3c9a19$var$cong,
  asymp: $560639d49e3c9a19$var$asymp,
  ne: $560639d49e3c9a19$var$ne,
  equiv: $560639d49e3c9a19$var$equiv,
  le: $560639d49e3c9a19$var$le,
  ge: $560639d49e3c9a19$var$ge,
  sub: $560639d49e3c9a19$var$sub,
  sup: $560639d49e3c9a19$var$sup,
  nsub: $560639d49e3c9a19$var$nsub,
  sube: $560639d49e3c9a19$var$sube,
  supe: $560639d49e3c9a19$var$supe,
  oplus: $560639d49e3c9a19$var$oplus,
  otimes: $560639d49e3c9a19$var$otimes,
  perp: $560639d49e3c9a19$var$perp,
  sdot: $560639d49e3c9a19$var$sdot,
  lceil: $560639d49e3c9a19$var$lceil,
  rceil: $560639d49e3c9a19$var$rceil,
  lfloor: $560639d49e3c9a19$var$lfloor,
  rfloor: $560639d49e3c9a19$var$rfloor,
  lang: $560639d49e3c9a19$var$lang,
  rang: $560639d49e3c9a19$var$rang,
  loz: $560639d49e3c9a19$var$loz,
  spades: $560639d49e3c9a19$var$spades,
  clubs: $560639d49e3c9a19$var$clubs,
  hearts: $560639d49e3c9a19$var$hearts,
  diams: $560639d49e3c9a19$var$diams,
  quot: $560639d49e3c9a19$var$quot,
  amp: $560639d49e3c9a19$var$amp,
  lt: $560639d49e3c9a19$var$lt,
  gt: $560639d49e3c9a19$var$gt,
  OElig: $560639d49e3c9a19$var$OElig,
  oelig: $560639d49e3c9a19$var$oelig,
  Scaron: $560639d49e3c9a19$var$Scaron,
  scaron: $560639d49e3c9a19$var$scaron,
  Yuml: $560639d49e3c9a19$var$Yuml,
  circ: $560639d49e3c9a19$var$circ,
  tilde: $560639d49e3c9a19$var$tilde,
  ensp: $560639d49e3c9a19$var$ensp,
  emsp: $560639d49e3c9a19$var$emsp,
  thinsp: $560639d49e3c9a19$var$thinsp,
  zwnj: $560639d49e3c9a19$var$zwnj,
  zwj: $560639d49e3c9a19$var$zwj,
  lrm: $560639d49e3c9a19$var$lrm,
  rlm: $560639d49e3c9a19$var$rlm,
  ndash: $560639d49e3c9a19$var$ndash,
  mdash: $560639d49e3c9a19$var$mdash,
  lsquo: $560639d49e3c9a19$var$lsquo,
  rsquo: $560639d49e3c9a19$var$rsquo,
  sbquo: $560639d49e3c9a19$var$sbquo,
  ldquo: $560639d49e3c9a19$var$ldquo,
  rdquo: $560639d49e3c9a19$var$rdquo,
  bdquo: $560639d49e3c9a19$var$bdquo,
  dagger: $560639d49e3c9a19$var$dagger,
  Dagger: $560639d49e3c9a19$var$Dagger,
  permil: $560639d49e3c9a19$var$permil,
  lsaquo: $560639d49e3c9a19$var$lsaquo,
  rsaquo: $560639d49e3c9a19$var$rsaquo,
  euro: $560639d49e3c9a19$var$euro,
  "default": $560639d49e3c9a19$var$index
});
var $560639d49e3c9a19$var$dangerous$1 = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
];
var $560639d49e3c9a19$var$dangerous$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  "default": $560639d49e3c9a19$var$dangerous$1
});
var $560639d49e3c9a19$var$entities = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$characterEntitiesHtml4);
var $560639d49e3c9a19$var$dangerous = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$dangerous$2);
var $560639d49e3c9a19$var$decimal = $560639d49e3c9a19$var$isDecimal;
var $560639d49e3c9a19$var$stringifyEntities = $560639d49e3c9a19$var$encode;
$560639d49e3c9a19$var$encode.escape = $560639d49e3c9a19$var$escape;
var $560639d49e3c9a19$var$own$3 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$escapes = [
  '"',
  "'",
  "<",
  ">",
  "&",
  "`"
];
var $560639d49e3c9a19$var$characters = $560639d49e3c9a19$var$construct();
var $560639d49e3c9a19$var$defaultEscapes = $560639d49e3c9a19$var$toExpression($560639d49e3c9a19$var$escapes);
var $560639d49e3c9a19$var$surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
var $560639d49e3c9a19$var$bmp = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
function $560639d49e3c9a19$var$encode(value, options) {
  var settings = options || {};
  var subset = settings.subset;
  var set = subset ? $560639d49e3c9a19$var$toExpression(subset) : $560639d49e3c9a19$var$defaultEscapes;
  var escapeOnly = settings.escapeOnly;
  var omit = settings.omitOptionalSemicolons;
  value = value.replace(set, replace);
  if (subset || escapeOnly)
    return value;
  return value.replace($560639d49e3c9a19$var$surrogatePair, replaceSurrogatePair).replace($560639d49e3c9a19$var$bmp, replace);
  function replaceSurrogatePair(pair, pos, val) {
    return $560639d49e3c9a19$var$toHexReference((pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536, val.charAt(pos + 2), omit);
  }
  function replace(char, pos, val) {
    return $560639d49e3c9a19$var$one$1(char, val.charAt(pos + 1), settings);
  }
}
function $560639d49e3c9a19$var$escape(value) {
  return $560639d49e3c9a19$var$encode(value, {
    escapeOnly: true,
    useNamedReferences: true
  });
}
function $560639d49e3c9a19$var$one$1(char, next, options) {
  var shortest = options.useShortestReferences;
  var omit = options.omitOptionalSemicolons;
  var named;
  var code;
  var numeric;
  var decimal;
  if ((shortest || options.useNamedReferences) && $560639d49e3c9a19$var$own$3.call($560639d49e3c9a19$var$characters, char))
    named = $560639d49e3c9a19$var$toNamed($560639d49e3c9a19$var$characters[char], next, omit, options.attribute);
  if (shortest || !named) {
    code = char.charCodeAt(0);
    numeric = $560639d49e3c9a19$var$toHexReference(code, next, omit);
    if (shortest) {
      decimal = $560639d49e3c9a19$var$toDecimalReference(code, next, omit);
      if (decimal.length < numeric.length)
        numeric = decimal;
    }
  }
  if (named && (!shortest || named.length < numeric.length))
    return named;
  return numeric;
}
function $560639d49e3c9a19$var$toNamed(name, next, omit, attribute) {
  var value = "&" + name;
  if (omit && $560639d49e3c9a19$var$own$3.call($560639d49e3c9a19$var$legacy, name) && $560639d49e3c9a19$var$dangerous.indexOf(name) === -1 && (!attribute || next && next !== "=" && !$560639d49e3c9a19$var$isAlphanumerical(next)))
    return value;
  return value + ";";
}
function $560639d49e3c9a19$var$toHexReference(code, next, omit) {
  var value = "&#x" + code.toString(16).toUpperCase();
  return omit && next && !$560639d49e3c9a19$var$isHexadecimal(next) ? value : value + ";";
}
function $560639d49e3c9a19$var$toDecimalReference(code, next, omit) {
  var value = "&#" + String(code);
  return omit && next && !$560639d49e3c9a19$var$decimal(next) ? value : value + ";";
}
function $560639d49e3c9a19$var$toExpression(characters) {
  return new RegExp("[" + characters.join("") + "]", "g");
}
function $560639d49e3c9a19$var$construct() {
  var chars = {};
  var name;
  for (name in $560639d49e3c9a19$var$entities)
    chars[$560639d49e3c9a19$var$entities[name]] = name;
  return chars;
}
var $560639d49e3c9a19$var$NULL = "\0";
var $560639d49e3c9a19$var$AMP = "&";
var $560639d49e3c9a19$var$SP = " ";
var $560639d49e3c9a19$var$TB = "	";
var $560639d49e3c9a19$var$GR = "`";
var $560639d49e3c9a19$var$DQ$1 = '"';
var $560639d49e3c9a19$var$SQ$1 = "'";
var $560639d49e3c9a19$var$EQ = "=";
var $560639d49e3c9a19$var$LT = "<";
var $560639d49e3c9a19$var$GT = ">";
var $560639d49e3c9a19$var$SO = "/";
var $560639d49e3c9a19$var$LF = "\n";
var $560639d49e3c9a19$var$CR = "\r";
var $560639d49e3c9a19$var$FF = "\f";
var $560639d49e3c9a19$var$whitespace = [
  $560639d49e3c9a19$var$SP,
  $560639d49e3c9a19$var$TB,
  $560639d49e3c9a19$var$LF,
  $560639d49e3c9a19$var$CR,
  $560639d49e3c9a19$var$FF
];
var $560639d49e3c9a19$var$name = $560639d49e3c9a19$var$whitespace.concat($560639d49e3c9a19$var$AMP, $560639d49e3c9a19$var$SO, $560639d49e3c9a19$var$GT, $560639d49e3c9a19$var$EQ);
var $560639d49e3c9a19$var$unquoted$1 = $560639d49e3c9a19$var$whitespace.concat($560639d49e3c9a19$var$AMP, $560639d49e3c9a19$var$GT);
var $560639d49e3c9a19$var$unquotedSafe = $560639d49e3c9a19$var$unquoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT, $560639d49e3c9a19$var$EQ, $560639d49e3c9a19$var$GR);
var $560639d49e3c9a19$var$singleQuoted$1 = [
  $560639d49e3c9a19$var$AMP,
  $560639d49e3c9a19$var$SQ$1
];
var $560639d49e3c9a19$var$doubleQuoted$1 = [
  $560639d49e3c9a19$var$AMP,
  $560639d49e3c9a19$var$DQ$1
];
var $560639d49e3c9a19$var$constants = {
  name: [
    [
      $560639d49e3c9a19$var$name,
      $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
    ],
    [
      $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT),
      $560639d49e3c9a19$var$name.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$LT, $560639d49e3c9a19$var$GR)
    ]
  ],
  unquoted: [
    [
      $560639d49e3c9a19$var$unquoted$1,
      $560639d49e3c9a19$var$unquotedSafe
    ],
    [
      $560639d49e3c9a19$var$unquotedSafe,
      $560639d49e3c9a19$var$unquotedSafe
    ]
  ],
  single: [
    [
      $560639d49e3c9a19$var$singleQuoted$1,
      $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$GR)
    ],
    [
      $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$NULL),
      $560639d49e3c9a19$var$singleQuoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$DQ$1, $560639d49e3c9a19$var$GR)
    ]
  ],
  double: [
    [
      $560639d49e3c9a19$var$doubleQuoted$1,
      $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
    ],
    [
      $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$NULL),
      $560639d49e3c9a19$var$doubleQuoted$1.concat($560639d49e3c9a19$var$NULL, $560639d49e3c9a19$var$SQ$1, $560639d49e3c9a19$var$GR)
    ]
  ]
};
var $560639d49e3c9a19$var$spaces = $560639d49e3c9a19$var$spaceSeparatedTokens.stringify;
var $560639d49e3c9a19$var$commas = $560639d49e3c9a19$var$commaSeparatedTokens.stringify;
var $560639d49e3c9a19$var$element_1 = $560639d49e3c9a19$var$element;
var $560639d49e3c9a19$var$emptyString = "";
var $560639d49e3c9a19$var$space$1 = " ";
var $560639d49e3c9a19$var$quotationMark = '"';
var $560639d49e3c9a19$var$apostrophe$1 = "'";
var $560639d49e3c9a19$var$equalsTo = "=";
var $560639d49e3c9a19$var$lessThan$1 = "<";
var $560639d49e3c9a19$var$greaterThan = ">";
var $560639d49e3c9a19$var$slash$1 = "/";
var $560639d49e3c9a19$var$newLine = "\n";
function $560639d49e3c9a19$var$element(ctx, node, index, parent, printWidthOffset, innerTextLength) {
  var parentSchema = ctx.schema;
  var name = node.tagName;
  var value = "";
  var selfClosing;
  var close;
  var omit;
  var root = node;
  var content;
  var attrs;
  var indentLevel = $560639d49e3c9a19$var$getNodeData(node, "indentLevel", 0);
  var printContext = {
    offset: printWidthOffset,
    wrapAttributes: false,
    indentLevel
  };
  var isVoid = ctx.voids.indexOf(name) !== -1;
  var ignoreAttrCollapsing = $560639d49e3c9a19$var$getNodeData(node, "ignore", false) || $560639d49e3c9a19$var$getNodeData(node, "preserveAttrWrapping", false);
  if (parentSchema.space === "html" && name === "svg")
    ctx.schema = $560639d49e3c9a19$var$svg_1;
  if (ctx.schema.space === "svg") {
    omit = false;
    close = true;
    selfClosing = ctx.closeEmpty;
  } else {
    omit = ctx.omit;
    close = ctx.close;
    selfClosing = isVoid;
  }
  if (selfClosing === false)
    selfClosing = $560639d49e3c9a19$var$getNodeData(node, "selfClosing", false);
  printContext.offset += $560639d49e3c9a19$var$lessThan$1.length;
  printContext.offset += node.tagName.length;
  if (selfClosing && !isVoid)
    printContext.offset += $560639d49e3c9a19$var$slash$1.length;
  printContext.offset += $560639d49e3c9a19$var$greaterThan.length;
  const propertyCount = Object.keys(node.properties).length;
  if (propertyCount > 1 && ctx.wrapAttributes)
    printContext.wrapAttributes = true;
  if (propertyCount)
    printContext.offset += propertyCount * $560639d49e3c9a19$var$space$1.length;
  printContext.offset += innerTextLength;
  attrs = $560639d49e3c9a19$var$attributes(ctx, node.properties, printContext, ignoreAttrCollapsing);
  const shouldCollapse = ignoreAttrCollapsing === false && printContext.wrapAttributes;
  content = $560639d49e3c9a19$var$all_1(ctx, root);
  selfClosing = content ? false : selfClosing;
  if (attrs || !omit || !omit.opening(node, index, parent)) {
    value = $560639d49e3c9a19$var$lessThan$1 + name;
    if (attrs) {
      if (shouldCollapse)
        value += attrs;
      else
        value += $560639d49e3c9a19$var$space$1 + attrs;
    }
    let selfClosed = false;
    if (selfClosing && close) {
      if ((!ctx.tightClose || attrs.charAt(attrs.length - 1) === $560639d49e3c9a19$var$slash$1) && !shouldCollapse)
        value += $560639d49e3c9a19$var$space$1;
      if (shouldCollapse)
        value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
      selfClosed = true;
      value += $560639d49e3c9a19$var$slash$1;
    } else if (selfClosing && !isVoid) {
      if (shouldCollapse)
        value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
      selfClosed = true;
      value += $560639d49e3c9a19$var$slash$1;
    }
    if (shouldCollapse && !selfClosed)
      value += $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel);
    value += $560639d49e3c9a19$var$greaterThan;
  }
  value += content;
  if (!selfClosing && (!omit || !omit.closing(node, index, parent)))
    value += $560639d49e3c9a19$var$lessThan$1 + $560639d49e3c9a19$var$slash$1 + name + $560639d49e3c9a19$var$greaterThan;
  ctx.schema = parentSchema;
  return value;
}
function $560639d49e3c9a19$var$attributes(ctx, props, printContext, ignoreIndent) {
  var values = [];
  var key;
  var value;
  var result;
  var length;
  var index;
  var last;
  for (key in props) {
    value = props[key];
    if (value == null)
      continue;
    result = $560639d49e3c9a19$var$attribute$1(ctx, key, value);
    printContext.offset += result.length;
    if (ignoreIndent === false && printContext.offset > ctx.printWidth)
      printContext.wrapAttributes = true;
    if (result)
      values.push(result);
  }
  length = values.length;
  index = -1;
  while (++index < length) {
    result = values[index];
    last = null;
    if (last !== $560639d49e3c9a19$var$quotationMark && last !== $560639d49e3c9a19$var$apostrophe$1) {
      if (printContext.wrapAttributes)
        values[index] = $560639d49e3c9a19$var$newLine + $560639d49e3c9a19$var$repeatString(ctx.tabWidth, printContext.indentLevel + 1) + result;
      else if (index !== length - 1)
        values[index] = result + $560639d49e3c9a19$var$space$1;
      else
        values[index] = result;
    }
  }
  return values.join($560639d49e3c9a19$var$emptyString);
}
function $560639d49e3c9a19$var$attribute$1(ctx, key, value) {
  var schema = ctx.schema;
  var info = $560639d49e3c9a19$var$find_1(schema, key);
  var name = info.attribute;
  if (value == null || typeof value === "number" && isNaN(value) || value === false && info.boolean)
    return $560639d49e3c9a19$var$emptyString;
  name = $560639d49e3c9a19$var$attributeName$1(ctx, name);
  if (value === true && info.boolean || value === true && info.overloadedBoolean)
    return name;
  return name + $560639d49e3c9a19$var$attributeValue$1(ctx, key, value, info);
}
function $560639d49e3c9a19$var$attributeName$1(ctx, name) {
  var valid = ctx.schema.space === "html" ? ctx.valid : 1;
  var subset = $560639d49e3c9a19$var$constants.name[valid][ctx.safe];
  return $560639d49e3c9a19$var$stringifyEntities(name, $560639d49e3c9a19$var$immutable(ctx.entities, {
    subset
  }));
}
function $560639d49e3c9a19$var$attributeValue$1(ctx, key, value, info) {
  var quote = ctx.quote;
  if (typeof value === "object" && "length" in value)
    value = (info.commaSeparated ? $560639d49e3c9a19$var$commas : $560639d49e3c9a19$var$spaces)(value, {
      padLeft: !ctx.tightLists
    });
  value = String(value);
  if (value === "")
    return value;
  else
    value = $560639d49e3c9a19$var$equalsTo + quote + value + quote;
  return value;
}
function $560639d49e3c9a19$var$getNodeData(node, key, defaultValue) {
  let data = node.data || {};
  return data[key] || defaultValue;
}
var $560639d49e3c9a19$var$doctype_1 = $560639d49e3c9a19$var$doctype;
function $560639d49e3c9a19$var$doctype(ctx, node) {
  var sep = ctx.tightDoctype ? "" : " ";
  var name = node.name;
  var pub = node.public;
  var sys = node.system;
  var val = [
    "<!doctype"
  ];
  if (name) {
    val.push(sep, name);
    if (pub != null)
      val.push(" public", sep, $560639d49e3c9a19$var$smart(pub));
    else if (sys != null)
      val.push(" system");
    if (sys != null)
      val.push(sep, $560639d49e3c9a19$var$smart(sys));
  }
  return val.join("") + ">";
}
function $560639d49e3c9a19$var$smart(value) {
  var quote = value.indexOf('"') === -1 ? '"' : "'";
  return quote + value + quote;
}
var $560639d49e3c9a19$var$comment_1 = $560639d49e3c9a19$var$comment;
function $560639d49e3c9a19$var$comment(ctx, node) {
  return "<!--" + node.value + "-->";
}
var $560639d49e3c9a19$var$raw_1 = $560639d49e3c9a19$var$raw;
function $560639d49e3c9a19$var$raw(ctx, node) {
  return node.value;
}
var $560639d49e3c9a19$var$one_1 = $560639d49e3c9a19$var$one;
var $560639d49e3c9a19$var$own$2 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$handlers = {};
$560639d49e3c9a19$var$handlers.root = $560639d49e3c9a19$var$all_1;
$560639d49e3c9a19$var$handlers.text = $560639d49e3c9a19$var$text_1;
$560639d49e3c9a19$var$handlers.element = $560639d49e3c9a19$var$element_1;
$560639d49e3c9a19$var$handlers.doctype = $560639d49e3c9a19$var$doctype_1;
$560639d49e3c9a19$var$handlers.comment = $560639d49e3c9a19$var$comment_1;
$560639d49e3c9a19$var$handlers.raw = $560639d49e3c9a19$var$raw_1;
function $560639d49e3c9a19$var$one(ctx, node, index, parent, printWidthOffset, innerTextLength) {
  var type = node && node.type;
  if (!type)
    throw new Error("Expected node, not `" + node + "`");
  if (!$560639d49e3c9a19$var$own$2.call($560639d49e3c9a19$var$handlers, type))
    throw new Error("Cannot compile unknown node `" + type + "`");
  return $560639d49e3c9a19$var$handlers[type](ctx, node, index, parent, printWidthOffset, innerTextLength);
}
var $560639d49e3c9a19$var$voids = $560639d49e3c9a19$var$getCjsExportFromNamespace($560639d49e3c9a19$var$htmlVoidElements);
var $560639d49e3c9a19$var$lib$1 = $560639d49e3c9a19$var$toHTML;
var $560639d49e3c9a19$var$DQ = '"';
var $560639d49e3c9a19$var$SQ = "'";
function $560639d49e3c9a19$var$toHTML(node, options) {
  var settings = options || {};
  var quote = settings.singleQuote ? $560639d49e3c9a19$var$SQ : $560639d49e3c9a19$var$DQ;
  var printWidth = settings.printWidth === void 0 ? 80 : settings.printWidth;
  var useTabs = settings.useTabs;
  var tabWidth = settings.tabWidth || 2;
  var wrapAttributes = settings.wrapAttributes;
  if (useTabs)
    tabWidth = "	";
  else if (typeof tabWidth === "number")
    tabWidth = $560639d49e3c9a19$var$repeatString(" ", tabWidth);
  return $560639d49e3c9a19$var$one_1({
    valid: settings.allowParseErrors ? 0 : 1,
    safe: settings.allowDangerousCharacters ? 0 : 1,
    schema: settings.space === "svg" ? $560639d49e3c9a19$var$svg_1 : $560639d49e3c9a19$var$html_1,
    omit: settings.omitOptionalTags && $560639d49e3c9a19$var$omission,
    quote,
    printWidth,
    tabWidth,
    wrapAttributes,
    tightDoctype: Boolean(settings.tightDoctype),
    tightLists: settings.tightCommaSeparatedLists,
    voids: settings.voids || $560639d49e3c9a19$var$voids.concat(),
    entities: settings.entities || {},
    close: settings.closeSelfClosing,
    tightClose: settings.tightSelfClosing,
    closeEmpty: settings.closeEmptyElements
  }, node);
}
var $560639d49e3c9a19$var$prettyhtmlHastToHtml = $560639d49e3c9a19$var$lib$1;
const $560639d49e3c9a19$var$void_els = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
const $560639d49e3c9a19$var$RE_SVELTE_TAG = /^<svelte:([a-z]*)[\s\S]*(?:(?:svelte:[a-z]*)|(?:\/))>$/;
const $560639d49e3c9a19$var$RE_SVELTE_TAG_START = /(^\s*)<([\\/\s])*svelte:/;
function $560639d49e3c9a19$var$parse_svelte_tag(eat, value, silent) {
  const is_svelte_tag = $560639d49e3c9a19$var$RE_SVELTE_TAG_START.exec(value);
  if (is_svelte_tag) {
    if (silent)
      return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    let current_tag = "";
    let in_tag_name = false;
    while (cbPos > -1) {
      if (!trimmed_value[pos])
        break;
      if (trimmed_value[pos].match(/</)) {
        cbPos++;
        current_tag = "";
        in_tag_name = true;
      }
      if (in_tag_name && trimmed_value[pos].match(/\s/))
        in_tag_name = false;
      if (in_tag_name && !trimmed_value[pos].match(/</))
        current_tag += trimmed_value[pos];
      const is_void = $560639d49e3c9a19$var$void_els.includes(current_tag);
      if (is_void && trimmed_value[pos].match(/>/) || (trimmed_value[pos - 1] + trimmed_value[pos]).match(/\/>/))
        cbPos--;
      if ((trimmed_value[pos - 1] + trimmed_value[pos]).match(/<\//)) {
        let inner_indent = 0;
        while (inner_indent > -1)
          if (trimmed_value[pos].match(/>/)) {
            pos++;
            inner_indent -= 1;
            cbPos -= 2;
          } else
            pos++;
      }
      pos++;
    }
    const match = $560639d49e3c9a19$var$RE_SVELTE_TAG.exec(trimmed_value.substring(0, pos).trim());
    if (!match)
      return;
    return eat(is_svelte_tag[1] + match[0])({
      type: "svelteTag",
      value: match[0],
      name: match[1]
    });
  }
}
const $560639d49e3c9a19$var$RE_SVELTE_BLOCK_START = /(^\s*){[#:/@]/;
const $560639d49e3c9a19$var$RE_SVELTE_BLOCK = /^{[#:/@](else if|[a-z]+).*}$/;
function $560639d49e3c9a19$var$parse_svelte_block(eat, value, silent) {
  const is_svelte_block = $560639d49e3c9a19$var$RE_SVELTE_BLOCK_START.exec(value);
  if (is_svelte_block) {
    if (silent)
      return true;
    const trimmed_value = value.trim();
    let cbPos = 0;
    let pos = 1;
    while (cbPos > -1) {
      if (trimmed_value[pos].match(/{/))
        cbPos++;
      if (trimmed_value[pos].match(/}/))
        cbPos--;
      pos++;
    }
    const match = $560639d49e3c9a19$var$RE_SVELTE_BLOCK.exec(trimmed_value.substring(0, pos));
    if (!match)
      return;
    return eat(is_svelte_block[1] + match[0])({
      type: "svelteBlock",
      value: `${is_svelte_block[1]}${match[0]}`,
      name: match[1]
    });
  }
}
const $560639d49e3c9a19$var$dotAllPolyfill = "[\0-￿]";
const $560639d49e3c9a19$var$attributeName = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
const $560639d49e3c9a19$var$unquoted = "[^\"'=<>`\\u0000-\\u0020]+";
const $560639d49e3c9a19$var$singleQuoted = "'[^']*'";
const $560639d49e3c9a19$var$doubleQuoted = '"[^"]*"';
const $560639d49e3c9a19$var$jsProps = "{.*}".replace(".", $560639d49e3c9a19$var$dotAllPolyfill);
const $560639d49e3c9a19$var$attributeValue = "(?:" + $560639d49e3c9a19$var$unquoted + "|" + $560639d49e3c9a19$var$singleQuoted + "|" + $560639d49e3c9a19$var$doubleQuoted + "|" + $560639d49e3c9a19$var$jsProps + ")";
const $560639d49e3c9a19$var$attribute = "(?:\\s+" + $560639d49e3c9a19$var$attributeName + "(?:\\s*=\\s*" + $560639d49e3c9a19$var$attributeValue + ")?)";
const $560639d49e3c9a19$var$openTag = "<[A-Za-z]*[A-Za-z0-9\\.\\-]*" + $560639d49e3c9a19$var$attribute + "*\\s*\\/?>";
const $560639d49e3c9a19$var$closeTag = "<\\/[A-Za-z][A-Za-z0-9\\.\\-]*\\s*>";
const $560639d49e3c9a19$var$openCloseTag = new RegExp("^(?:" + $560639d49e3c9a19$var$openTag + "|" + $560639d49e3c9a19$var$closeTag + ")");
const $560639d49e3c9a19$var$tab = "	";
const $560639d49e3c9a19$var$space = " ";
const $560639d49e3c9a19$var$lineFeed = "\n";
const $560639d49e3c9a19$var$lessThan = "<";
const $560639d49e3c9a19$var$rawOpenExpression = /^<(script|pre|style)(?=(\s|>|$))/i;
const $560639d49e3c9a19$var$rawCloseExpression = /<\/(script|pre|style)>/i;
const $560639d49e3c9a19$var$commentOpenExpression = /^<!--/;
const $560639d49e3c9a19$var$commentCloseExpression = /-->/;
const $560639d49e3c9a19$var$instructionOpenExpression = /^<\?/;
const $560639d49e3c9a19$var$instructionCloseExpression = /\?>/;
const $560639d49e3c9a19$var$directiveOpenExpression = /^<![A-Za-z]/;
const $560639d49e3c9a19$var$directiveCloseExpression = />/;
const $560639d49e3c9a19$var$cdataOpenExpression = /^<!\[CDATA\[/;
const $560639d49e3c9a19$var$cdataCloseExpression = /\]\]>/;
const $560639d49e3c9a19$var$elementCloseExpression = /^$/;
const $560639d49e3c9a19$var$otherElementOpenExpression = new RegExp($560639d49e3c9a19$var$openCloseTag.source + "\\s*$");
const $560639d49e3c9a19$var$fragmentOpenExpression = /^<>/;
function $560639d49e3c9a19$var$blockHtml(eat, value, silent) {
  const blocks = "[a-z\\.]*(\\.){0,1}[a-z][a-z0-9\\.]*";
  const elementOpenExpression = new RegExp("^</?(" + blocks + ")(?=(\\s|/?>|$))", "i");
  const length = value.length;
  let index = 0;
  let next;
  let line;
  let offset;
  let character;
  let sequence;
  const sequences = [
    [
      $560639d49e3c9a19$var$rawOpenExpression,
      $560639d49e3c9a19$var$rawCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$commentOpenExpression,
      $560639d49e3c9a19$var$commentCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$instructionOpenExpression,
      $560639d49e3c9a19$var$instructionCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$directiveOpenExpression,
      $560639d49e3c9a19$var$directiveCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$cdataOpenExpression,
      $560639d49e3c9a19$var$cdataCloseExpression,
      true
    ],
    [
      elementOpenExpression,
      $560639d49e3c9a19$var$elementCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$fragmentOpenExpression,
      $560639d49e3c9a19$var$elementCloseExpression,
      true
    ],
    [
      $560639d49e3c9a19$var$otherElementOpenExpression,
      $560639d49e3c9a19$var$elementCloseExpression,
      false
    ]
  ];
  while (index < length) {
    character = value.charAt(index);
    if (character !== $560639d49e3c9a19$var$tab && character !== $560639d49e3c9a19$var$space)
      break;
    index++;
  }
  if (value.charAt(index) !== $560639d49e3c9a19$var$lessThan)
    return;
  next = value.indexOf($560639d49e3c9a19$var$lineFeed, index + 1);
  next = next === -1 ? length : next;
  line = value.slice(index, next);
  offset = -1;
  const count = sequences.length;
  while (++offset < count)
    if (sequences[offset][0].test(line)) {
      sequence = sequences[offset];
      break;
    }
  if (!sequence)
    return;
  if (silent)
    return sequence[2];
  index = next;
  if (!sequence[1].test(line))
    while (index < length) {
      next = value.indexOf($560639d49e3c9a19$var$lineFeed, index + 1);
      next = next === -1 ? length : next;
      line = value.slice(index + 1, next);
      if (sequence[1].test(line)) {
        if (line)
          index = next;
        break;
      }
      index = next;
    }
  const subvalue = value.slice(0, index);
  return eat(subvalue)({
    type: "html",
    value: subvalue
  });
}
function $560639d49e3c9a19$var$mdsvex_parser() {
  const Parser = this.Parser;
  const block_tokenizers = Parser.prototype.blockTokenizers;
  const methods = Parser.prototype.blockMethods;
  block_tokenizers.svelteBlock = $560639d49e3c9a19$var$parse_svelte_block;
  block_tokenizers.svelteTag = $560639d49e3c9a19$var$parse_svelte_tag;
  block_tokenizers.html = $560639d49e3c9a19$var$blockHtml;
  block_tokenizers.indentedCode = $560639d49e3c9a19$var$indentedCode;
  methods.splice(methods.indexOf("html"), 0, "svelteBlock");
  methods.splice(methods.indexOf("html"), 0, "svelteTag");
}
function $560639d49e3c9a19$var$indentedCode() {
  return true;
}
var $560639d49e3c9a19$var$unified_1 = $560639d49e3c9a19$var$unified().freeze();
var $560639d49e3c9a19$var$slice = [].slice;
var $560639d49e3c9a19$var$own$1 = {}.hasOwnProperty;
var $560639d49e3c9a19$var$pipeline = $560639d49e3c9a19$var$trough_1().use($560639d49e3c9a19$var$pipelineParse).use($560639d49e3c9a19$var$pipelineRun).use($560639d49e3c9a19$var$pipelineStringify);
function $560639d49e3c9a19$var$pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}
function $560639d49e3c9a19$var$pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err)
      next(err);
    else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function $560639d49e3c9a19$var$pipelineStringify(p, ctx) {
  ctx.file.contents = p.stringify(ctx.tree, ctx.file);
}
function $560639d49e3c9a19$var$unified() {
  var attachers = [];
  var transformers = $560639d49e3c9a19$var$trough_1();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process1;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = $560639d49e3c9a19$var$unified();
    var length = attachers.length;
    var index = -1;
    while (++index < length)
      destination.use.apply(null, attachers[index]);
    destination.data($560639d49e3c9a19$var$extend$2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;
    if (frozen)
      return processor;
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;
      if (options === false)
        continue;
      if (options === true)
        values[1] = void 0;
      transformer = plugin.apply(processor, values.slice(1));
      if (typeof transformer === "function")
        transformers.use(transformer);
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        $560639d49e3c9a19$var$assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return $560639d49e3c9a19$var$own$1.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      $560639d49e3c9a19$var$assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    $560639d49e3c9a19$var$assertUnfrozen("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function")
      addPlugin.apply(null, arguments);
    else if (typeof value === "object") {
      if ("length" in value)
        addList(value);
      else
        addPreset(value);
    } else
      throw new Error("Expected usable value, not `" + value + "`");
    if (settings)
      namespace.settings = $560639d49e3c9a19$var$extend$2(namespace.settings || {}, settings);
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings)
        settings = $560639d49e3c9a19$var$extend$2(settings || {}, result.settings);
    }
    function add(value2) {
      if (typeof value2 === "function")
        addPlugin(value2);
      else if (typeof value2 === "object") {
        if ("length" in value2)
          addPlugin.apply(null, value2);
        else
          addPreset(value2);
      } else
        throw new Error("Expected usable value, not `" + value2 + "`");
    }
    function addList(plugins) {
      var length;
      var index;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index = -1;
        while (++index < length)
          add(plugins[index]);
      } else
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
    }
    function addPlugin(plugin, value2) {
      var entry = find(plugin);
      if (entry) {
        if ($560639d49e3c9a19$var$isPlainObj(entry[1]) && $560639d49e3c9a19$var$isPlainObj(value2))
          value2 = $560639d49e3c9a19$var$extend$2(entry[1], value2);
        entry[1] = value2;
      } else
        attachers.push($560639d49e3c9a19$var$slice.call(arguments));
    }
  }
  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;
    while (++index < length) {
      entry = attachers[index];
      if (entry[0] === plugin)
        return entry;
    }
  }
  function parse(doc) {
    var file = $560639d49e3c9a19$var$vfile(doc);
    var Parser;
    freeze();
    Parser = processor.Parser;
    $560639d49e3c9a19$var$assertParser("parse", Parser);
    if ($560639d49e3c9a19$var$newable(Parser, "parse"))
      return new Parser(String(file), file).parse();
    return Parser(String(file), file);
  }
  function run(node, file, cb) {
    $560639d49e3c9a19$var$assertNode(node);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node, $560639d49e3c9a19$var$vfile(file), done);
      function done(err, tree, file2) {
        tree = tree || node;
        if (err)
          reject(err);
        else if (resolve)
          resolve(tree);
        else
          cb(null, tree, file2);
      }
    }
  }
  function runSync(node, file) {
    var complete = false;
    var result;
    run(node, file, done);
    $560639d49e3c9a19$var$assertDone("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      $560639d49e3c9a19$var$bail_1(err);
      result = tree;
    }
  }
  function stringify(node, doc) {
    var file = $560639d49e3c9a19$var$vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    $560639d49e3c9a19$var$assertCompiler("stringify", Compiler);
    $560639d49e3c9a19$var$assertNode(node);
    if ($560639d49e3c9a19$var$newable(Compiler, "compile"))
      return new Compiler(node, file).compile();
    return Compiler(node, file);
  }
  function process1(doc, cb) {
    freeze();
    $560639d49e3c9a19$var$assertParser("process", processor.Parser);
    $560639d49e3c9a19$var$assertCompiler("process", processor.Compiler);
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      var file = $560639d49e3c9a19$var$vfile(doc);
      $560639d49e3c9a19$var$pipeline.run(processor, {
        file
      }, done);
      function done(err) {
        if (err)
          reject(err);
        else if (resolve)
          resolve(file);
        else
          cb(null, file);
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    $560639d49e3c9a19$var$assertParser("processSync", processor.Parser);
    $560639d49e3c9a19$var$assertCompiler("processSync", processor.Compiler);
    file = $560639d49e3c9a19$var$vfile(doc);
    process1(file, done);
    $560639d49e3c9a19$var$assertDone("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      $560639d49e3c9a19$var$bail_1(err);
    }
  }
}
function $560639d49e3c9a19$var$newable(value, name) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  ($560639d49e3c9a19$var$keys(value.prototype) || name in value.prototype);
}
function $560639d49e3c9a19$var$keys(value) {
  var key;
  for (key in value)
    return true;
  return false;
}
function $560639d49e3c9a19$var$assertParser(name, Parser) {
  if (typeof Parser !== "function")
    throw new Error("Cannot `" + name + "` without `Parser`");
}
function $560639d49e3c9a19$var$assertCompiler(name, Compiler) {
  if (typeof Compiler !== "function")
    throw new Error("Cannot `" + name + "` without `Compiler`");
}
function $560639d49e3c9a19$var$assertUnfrozen(name, frozen) {
  if (frozen)
    throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
function $560639d49e3c9a19$var$assertNode(node) {
  if (!node || typeof node.type !== "string")
    throw new Error("Expected node, got `" + node + "`");
}
function $560639d49e3c9a19$var$assertDone(name, asyncName, complete) {
  if (!complete)
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $560639d49e3c9a19$var$nlcstToString_1 = $560639d49e3c9a19$var$nlcstToString;
function $560639d49e3c9a19$var$nlcstToString(node, separator) {
  var sep = separator || "";
  var values;
  var length;
  var children;
  if (!node || !("length" in node) && !node.type)
    throw new Error("Expected node, not `" + node + "`");
  if (typeof node.value === "string")
    return node.value;
  children = "length" in node ? node : node.children;
  length = children.length;
  if (length === 1 && "value" in children[0])
    return children[0].value;
  values = [];
  while (length--)
    values[length] = $560639d49e3c9a19$var$nlcstToString(children[length], sep);
  return values.join(sep);
}
var $560639d49e3c9a19$var$tokenizer = $560639d49e3c9a19$var$tokenizerFactory;
function $560639d49e3c9a19$var$tokenizerFactory(childType, expression) {
  return tokenizer;
  function tokenizer(node) {
    var children = [];
    var tokens = node.children;
    var type = node.type;
    var length = tokens.length;
    var index = -1;
    var lastIndex = length - 1;
    var start = 0;
    var first;
    var last;
    var parent;
    while (++index < length)
      if (index === lastIndex || tokens[index].type === childType && expression.test($560639d49e3c9a19$var$nlcstToString_1(tokens[index]))) {
        first = tokens[start];
        last = tokens[index];
        parent = {
          type,
          children: tokens.slice(start, index + 1)
        };
        if (first.position && last.position)
          parent.position = {
            start: first.position.start,
            end: last.position.end
          };
        children.push(parent);
        start = index + 1;
      }
    return children;
  }
}
var $560639d49e3c9a19$var$parser = $560639d49e3c9a19$var$parserFactory;
function $560639d49e3c9a19$var$parserFactory(options) {
  var type = options.type;
  var tokenizerProperty = options.tokenizer;
  var delimiter = options.delimiter;
  var tokenize = delimiter && $560639d49e3c9a19$var$tokenizer(options.delimiterType, delimiter);
  return parser;
  function parser(value) {
    var children = this[tokenizerProperty](value);
    return {
      type,
      children: tokenize ? tokenize(children) : children
    };
  }
}
var $560639d49e3c9a19$var$expressions = {
  affixSymbol: /^([\)\]\}\u0F3B\u0F3D\u169C\u2046\u207E\u208E\u2309\u230B\u232A\u2769\u276B\u276D\u276F\u2771\u2773\u2775\u27C6\u27E7\u27E9\u27EB\u27ED\u27EF\u2984\u2986\u2988\u298A\u298C\u298E\u2990\u2992\u2994\u2996\u2998\u29D9\u29DB\u29FD\u2E23\u2E25\u2E27\u2E29\u3009\u300B\u300D\u300F\u3011\u3015\u3017\u3019\u301B\u301E\u301F\uFD3E\uFE18\uFE36\uFE38\uFE3A\uFE3C\uFE3E\uFE40\uFE42\uFE44\uFE48\uFE5A\uFE5C\uFE5E\uFF09\uFF3D\uFF5D\uFF60\uFF63]|["'\xBB\u2019\u201D\u203A\u2E03\u2E05\u2E0A\u2E0D\u2E1D\u2E21]|[!\.\?\u2026\u203D])\1*$/,
  newLine: /^[ \t]*((\r?\n|\r)[\t ]*)+$/,
  newLineMulti: /^[ \t]*((\r?\n|\r)[\t ]*){2,}$/,
  terminalMarker: /^((?:[!\.\?\u2026\u203D])+)$/,
  wordSymbolInner: /^((?:[&'\x2D\.:=\?@\xAD\xB7\u2010\u2011\u2019\u2027])|(?:_)+)$/,
  numerical: /^(?:[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D58-\u0D5E\u0D66-\u0D78\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDCFB-\uDCFF\uDD16-\uDD1B\uDDBC\uDDBD\uDDC0-\uDDCF\uDDD2-\uDDFF\uDE40-\uDE48\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDCFA-\uDCFF\uDD30-\uDD39\uDE60-\uDE7E\uDF1D-\uDF26\uDF51-\uDF54]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDC50-\uDC59\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9\uDF30-\uDF3B]|\uD806[\uDCE0-\uDCF2]|\uD807[\uDC50-\uDC6C\uDD50-\uDD59\uDDA0-\uDDA9\uDFC0-\uDFD4]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD81B[\uDE80-\uDE96]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDFCE-\uDFFF]|\uD838[\uDD40-\uDD49\uDEF0-\uDEF9]|\uD83A[\uDCC7-\uDCCF\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D]|\uD83C[\uDD00-\uDD0C])+$/,
  digitStart: /^\d/,
  lowerInitial: /^(?:[a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0560-\u0588\u10D0-\u10FA\u10FD-\u10FF\u13F8-\u13FD\u1C80-\u1C88\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7AF\uA7B5\uA7B7\uA7B9\uA7BB\uA7BD\uA7BF\uA7C3\uA7FA\uAB30-\uAB5A\uAB60-\uAB67\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A]|\uD801[\uDC28-\uDC4F\uDCD8-\uDCFB]|\uD803[\uDCC0-\uDCF2]|\uD806[\uDCC0-\uDCDF]|\uD81B[\uDE60-\uDE7F]|\uD835[\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]|\uD83A[\uDD22-\uDD43])/,
  surrogates: /[\uD800-\uDFFF]/,
  punctuation: /[!"'-\),-\/:;\?\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u201F\u2022-\u2027\u2032-\u203A\u203C-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDFFF]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,
  word: /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u052F\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05EF-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u07FD\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D3-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09F4-\u09F9\u09FC\u09FE\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BF2\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C7E\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D63\u0D66-\u0D78\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u17F0-\u17F9\u180B-\u180D\u1810-\u1819\u1820-\u1878\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CD0-\u1CD2\u1CD4-\u1CFA\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u20D0-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BA\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA672\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA827\uA830-\uA835\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE38-\uDE3A\uDE3F-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE6\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD27\uDD30-\uDD39\uDE60-\uDE7E\uDF00-\uDF27\uDF30-\uDF54\uDFE0-\uDFF6]|\uD804[\uDC00-\uDC46\uDC52-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD44-\uDD46\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDC9-\uDDCC\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3B-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC5E\uDC5F\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF1D-\uDF2B\uDF30-\uDF3B]|\uD806[\uDC00-\uDC3A\uDCA0-\uDCF2\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD7\uDDDA-\uDDE1\uDDE3\uDDE4\uDE00-\uDE3E\uDE47\uDE50-\uDE99\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD8E\uDD90\uDD91\uDD93-\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF6\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF4F-\uDF87\uDF8F-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD00-\uDD2C\uDD30-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCD6\uDD00-\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/,
  whiteSpace: /[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
};
var $560639d49e3c9a19$var$arrayIterate = $560639d49e3c9a19$var$iterate;
var $560639d49e3c9a19$var$own = {}.hasOwnProperty;
function $560639d49e3c9a19$var$iterate(values, callback, context) {
  var index = -1;
  var result;
  if (!values)
    throw new Error("Iterate requires that |this| not be " + values);
  if (!$560639d49e3c9a19$var$own.call(values, "length"))
    throw new Error("Iterate requires that |this| has a `length`");
  if (typeof callback !== "function")
    throw new Error("`callback` must be a function");
  while (++index < values.length) {
    if (!(index in values))
      continue;
    result = callback.call(context, values[index], index, values);
    if (typeof result === "number") {
      if (result < 0)
        index = 0;
      index = result - 1;
    }
  }
}
var $560639d49e3c9a19$var$unistUtilModifyChildren = $560639d49e3c9a19$var$modifierFactory;
function $560639d49e3c9a19$var$modifierFactory(callback) {
  return $560639d49e3c9a19$var$iteratorFactory($560639d49e3c9a19$var$wrapperFactory(callback));
}
function $560639d49e3c9a19$var$iteratorFactory(callback) {
  return iterator;
  function iterator(parent) {
    var children = parent && parent.children;
    if (!children)
      throw new Error("Missing children in `parent` for `modifier`");
    return $560639d49e3c9a19$var$arrayIterate(children, callback, parent);
  }
}
function $560639d49e3c9a19$var$wrapperFactory(callback) {
  return wrapper;
  function wrapper(value, index) {
    return callback(value, index, this);
  }
}
var $560639d49e3c9a19$var$mergeInitialWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialWordSymbol);
function $560639d49e3c9a19$var$mergeInitialWordSymbol(child, index, parent) {
  var children;
  var next;
  if (child.type !== "SymbolNode" && child.type !== "PunctuationNode" || $560639d49e3c9a19$var$nlcstToString_1(child) !== "&")
    return;
  children = parent.children;
  next = children[index + 1];
  if (index !== 0 && children[index - 1].type === "WordNode" || !(next && next.type === "WordNode"))
    return;
  children.splice(index, 1);
  next.children.unshift(child);
  if (next.position && child.position)
    next.position.start = child.position.start;
  return index - 1;
}
var $560639d49e3c9a19$var$mergeFinalWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeFinalWordSymbol$1);
function $560639d49e3c9a19$var$mergeFinalWordSymbol$1(child, index, parent) {
  var children;
  var prev;
  var next;
  if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $560639d49e3c9a19$var$nlcstToString_1(child) === "-") {
    children = parent.children;
    prev = children[index - 1];
    next = children[index + 1];
    if ((!next || next.type !== "WordNode") && prev && prev.type === "WordNode") {
      children.splice(index, 1);
      prev.children.push(child);
      if (prev.position && child.position)
        prev.position.end = child.position.end;
      return index;
    }
  }
}
var $560639d49e3c9a19$var$mergeInnerWordSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInnerWordSymbol);
var $560639d49e3c9a19$var$wordSymbolInner = $560639d49e3c9a19$var$expressions.wordSymbolInner;
function $560639d49e3c9a19$var$mergeInnerWordSymbol(child, index, parent) {
  var siblings;
  var sibling;
  var prev;
  var last;
  var position;
  var tokens;
  var queue;
  if (index !== 0 && (child.type === "SymbolNode" || child.type === "PunctuationNode")) {
    siblings = parent.children;
    prev = siblings[index - 1];
    if (prev && prev.type === "WordNode") {
      position = index - 1;
      tokens = [];
      queue = [];
      while (siblings[++position]) {
        sibling = siblings[position];
        if (sibling.type === "WordNode") {
          tokens = tokens.concat(queue, sibling.children);
          queue = [];
        } else if ((sibling.type === "SymbolNode" || sibling.type === "PunctuationNode") && $560639d49e3c9a19$var$wordSymbolInner.test($560639d49e3c9a19$var$nlcstToString_1(sibling)))
          queue.push(sibling);
        else
          break;
      }
      if (tokens.length !== 0) {
        if (queue.length !== 0)
          position -= queue.length;
        siblings.splice(index, position - index);
        prev.children = prev.children.concat(tokens);
        last = tokens[tokens.length - 1];
        if (prev.position && last.position)
          prev.position.end = last.position.end;
        return index;
      }
    }
  }
}
var $560639d49e3c9a19$var$mergeInnerWordSlash_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInnerWordSlash);
var $560639d49e3c9a19$var$slash = "/";
function $560639d49e3c9a19$var$mergeInnerWordSlash(child, index, parent) {
  var siblings = parent.children;
  var prev;
  var next;
  var prevValue;
  var nextValue;
  var queue;
  var tail;
  var count;
  prev = siblings[index - 1];
  next = siblings[index + 1];
  if (prev && prev.type === "WordNode" && (child.type === "SymbolNode" || child.type === "PunctuationNode") && $560639d49e3c9a19$var$nlcstToString_1(child) === $560639d49e3c9a19$var$slash) {
    prevValue = $560639d49e3c9a19$var$nlcstToString_1(prev);
    tail = child;
    queue = [
      child
    ];
    count = 1;
    if (next && next.type === "WordNode") {
      nextValue = $560639d49e3c9a19$var$nlcstToString_1(next);
      tail = next;
      queue = queue.concat(next.children);
      count++;
    }
    if (prevValue.length < 3 && (!nextValue || nextValue.length < 3)) {
      prev.children = prev.children.concat(queue);
      siblings.splice(index, count);
      if (prev.position && tail.position)
        prev.position.end = tail.position.end;
      return index;
    }
  }
}
var $560639d49e3c9a19$var$mergeInitialisms_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialisms);
var $560639d49e3c9a19$var$numerical = $560639d49e3c9a19$var$expressions.numerical;
function $560639d49e3c9a19$var$mergeInitialisms(child, index, parent) {
  var siblings;
  var prev;
  var children;
  var length;
  var position;
  var otherChild;
  var isAllDigits;
  var value;
  if (index !== 0 && $560639d49e3c9a19$var$nlcstToString_1(child) === ".") {
    siblings = parent.children;
    prev = siblings[index - 1];
    children = prev.children;
    length = children && children.length;
    if (prev.type === "WordNode" && length !== 1 && length % 2 !== 0) {
      position = length;
      isAllDigits = true;
      while (children[--position]) {
        otherChild = children[position];
        value = $560639d49e3c9a19$var$nlcstToString_1(otherChild);
        if (position % 2 === 0) {
          if (value.length > 1)
            return;
          if (!$560639d49e3c9a19$var$numerical.test(value))
            isAllDigits = false;
        } else if (value !== ".") {
          if (position < length - 2)
            break;
          else
            return;
        }
      }
      if (!isAllDigits) {
        siblings.splice(index, 1);
        children.push(child);
        if (prev.position && child.position)
          prev.position.end = child.position.end;
        return index;
      }
    }
  }
}
var $560639d49e3c9a19$var$mergeWords = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeFinalWordSymbol);
function $560639d49e3c9a19$var$mergeFinalWordSymbol(child, index, parent) {
  var siblings = parent.children;
  var next;
  if (child.type === "WordNode") {
    next = siblings[index + 1];
    if (next && next.type === "WordNode") {
      siblings.splice(index + 1, 1);
      child.children = child.children.concat(next.children);
      if (next.position && child.position)
        child.position.end = next.position.end;
      return index;
    }
  }
}
var $560639d49e3c9a19$var$unistUtilVisitChildren = $560639d49e3c9a19$var$visitChildren;
function $560639d49e3c9a19$var$visitChildren(callback) {
  return visitor;
  function visitor(parent) {
    var index = -1;
    var children = parent && parent.children;
    if (!children)
      throw new Error("Missing children in `parent` for `visitor`");
    while (++index in children)
      callback(children[index], index, parent);
  }
}
var $560639d49e3c9a19$var$patchPosition_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$patchPosition);
function $560639d49e3c9a19$var$patchPosition(child, index, node) {
  var siblings = node.children;
  if (!child.position)
    return;
  if (index === 0 && (!node.position || /* istanbul ignore next */
  !node.position.start)) {
    $560639d49e3c9a19$var$patch(node);
    node.position.start = child.position.start;
  }
  if (index === siblings.length - 1 && (!node.position || !node.position.end)) {
    $560639d49e3c9a19$var$patch(node);
    node.position.end = child.position.end;
  }
}
function $560639d49e3c9a19$var$patch(node) {
  if (!node.position)
    node.position = {};
}
var $560639d49e3c9a19$var$mergeNonWordSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeNonWordSentences);
function $560639d49e3c9a19$var$mergeNonWordSentences(child, index, parent) {
  var children = child.children;
  var position = -1;
  var prev;
  var next;
  while (children[++position]) {
    if (children[position].type === "WordNode")
      return;
  }
  prev = parent.children[index - 1];
  if (prev) {
    prev.children = prev.children.concat(children);
    parent.children.splice(index, 1);
    if (prev.position && child.position)
      prev.position.end = child.position.end;
    return index;
  }
  next = parent.children[index + 1];
  if (next) {
    next.children = children.concat(next.children);
    if (next.position && child.position)
      next.position.start = child.position.start;
    parent.children.splice(index, 1);
  }
}
var $560639d49e3c9a19$var$mergeAffixSymbol_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeAffixSymbol);
var $560639d49e3c9a19$var$affixSymbol = $560639d49e3c9a19$var$expressions.affixSymbol;
function $560639d49e3c9a19$var$mergeAffixSymbol(child, index, parent) {
  var children = child.children;
  var first;
  var second;
  var prev;
  if (children && children.length !== 0 && index !== 0) {
    first = children[0];
    second = children[1];
    prev = parent.children[index - 1];
    if ((first.type === "SymbolNode" || first.type === "PunctuationNode") && $560639d49e3c9a19$var$affixSymbol.test($560639d49e3c9a19$var$nlcstToString_1(first))) {
      prev.children.push(children.shift());
      if (first.position && prev.position)
        prev.position.end = first.position.end;
      if (second && second.position && child.position)
        child.position.start = second.position.start;
      return index - 1;
    }
  }
}
var $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences);
var $560639d49e3c9a19$var$lowerInitial = $560639d49e3c9a19$var$expressions.lowerInitial;
function $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences(child, index, parent) {
  var children = child.children;
  var position;
  var node;
  var siblings;
  var prev;
  if (children && children.length !== 0 && index !== 0) {
    position = -1;
    while (children[++position]) {
      node = children[position];
      if (node.type === "WordNode") {
        if (!$560639d49e3c9a19$var$lowerInitial.test($560639d49e3c9a19$var$nlcstToString_1(node)))
          return;
        siblings = parent.children;
        prev = siblings[index - 1];
        prev.children = prev.children.concat(children);
        siblings.splice(index, 1);
        if (prev.position && child.position)
          prev.position.end = child.position.end;
        return index;
      }
      if (node.type === "SymbolNode" || node.type === "PunctuationNode")
        return;
    }
  }
}
var $560639d49e3c9a19$var$mergeInitialDigitSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeInitialDigitSentences);
var $560639d49e3c9a19$var$digit = $560639d49e3c9a19$var$expressions.digitStart;
function $560639d49e3c9a19$var$mergeInitialDigitSentences(child, index, parent) {
  var children = child.children;
  var siblings = parent.children;
  var prev = siblings[index - 1];
  var head = children[0];
  if (prev && head && head.type === "WordNode" && $560639d49e3c9a19$var$digit.test($560639d49e3c9a19$var$nlcstToString_1(head))) {
    prev.children = prev.children.concat(children);
    siblings.splice(index, 1);
    if (prev.position && child.position)
      prev.position.end = child.position.end;
    return index;
  }
}
var $560639d49e3c9a19$var$mergePrefixExceptions_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergePrefixExceptions);
var $560639d49e3c9a19$var$abbreviationPrefix = new RegExp("^([0-9]{1,3}|[a-z]|al|ca|cap|cca|cent|cf|cit|con|cp|cwt|ead|etc|ff|fl|ibid|id|nem|op|pro|seq|sic|stat|tem|viz)$");
function $560639d49e3c9a19$var$mergePrefixExceptions(child, index, parent) {
  var children = child.children;
  var period;
  var node;
  var next;
  if (children && children.length > 1) {
    period = children[children.length - 1];
    if (period && $560639d49e3c9a19$var$nlcstToString_1(period) === ".") {
      node = children[children.length - 2];
      if (node && node.type === "WordNode" && $560639d49e3c9a19$var$abbreviationPrefix.test($560639d49e3c9a19$var$nlcstToString_1(node).toLowerCase())) {
        node.children.push(period);
        children.pop();
        if (period.position && node.position)
          node.position.end = period.position.end;
        next = parent.children[index + 1];
        if (next) {
          child.children = children.concat(next.children);
          parent.children.splice(index + 1, 1);
          if (next.position && child.position)
            child.position.end = next.position.end;
          return index - 1;
        }
      }
    }
  }
}
var $560639d49e3c9a19$var$mergeAffixExceptions_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$mergeAffixExceptions);
function $560639d49e3c9a19$var$mergeAffixExceptions(child, index, parent) {
  var children = child.children;
  var node;
  var position;
  var value;
  var previousChild;
  if (!children || children.length === 0 || index === 0)
    return;
  position = -1;
  while (children[++position]) {
    node = children[position];
    if (node.type === "WordNode")
      return;
    if (node.type === "SymbolNode" || node.type === "PunctuationNode") {
      value = $560639d49e3c9a19$var$nlcstToString_1(node);
      if (value !== "," && value !== ";")
        return;
      previousChild = parent.children[index - 1];
      previousChild.children = previousChild.children.concat(children);
      if (previousChild.position && child.position)
        previousChild.position.end = child.position.end;
      parent.children.splice(index, 1);
      return index;
    }
  }
}
var $560639d49e3c9a19$var$mergeRemainingFullStops_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$mergeRemainingFullStops);
var $560639d49e3c9a19$var$terminalMarker = $560639d49e3c9a19$var$expressions.terminalMarker;
function $560639d49e3c9a19$var$mergeRemainingFullStops(child) {
  var children = child.children;
  var position = children.length;
  var hasFoundDelimiter = false;
  var grandchild;
  var prev;
  var next;
  var nextNext;
  while (children[--position]) {
    grandchild = children[position];
    if (grandchild.type !== "SymbolNode" && grandchild.type !== "PunctuationNode") {
      if (grandchild.type === "WordNode")
        hasFoundDelimiter = true;
      continue;
    }
    if (!$560639d49e3c9a19$var$terminalMarker.test($560639d49e3c9a19$var$nlcstToString_1(grandchild)))
      continue;
    if (!hasFoundDelimiter) {
      hasFoundDelimiter = true;
      continue;
    }
    if ($560639d49e3c9a19$var$nlcstToString_1(grandchild) !== ".")
      continue;
    prev = children[position - 1];
    next = children[position + 1];
    if (prev && prev.type === "WordNode") {
      nextNext = children[position + 2];
      if (next && nextNext && next.type === "WhiteSpaceNode" && $560639d49e3c9a19$var$nlcstToString_1(nextNext) === ".")
        continue;
      children.splice(position, 1);
      prev.children.push(grandchild);
      if (grandchild.position && prev.position)
        prev.position.end = grandchild.position.end;
      position--;
    } else if (next && next.type === "WordNode") {
      children.splice(position, 1);
      next.children.unshift(grandchild);
      if (grandchild.position && next.position)
        next.position.start = grandchild.position.start;
    }
  }
}
var $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1 = $560639d49e3c9a19$var$unistUtilVisitChildren($560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings);
function $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings(child, index, parent) {
  var children = child.children;
  var next;
  if (children && children.length !== 0 && children[0].type === "WhiteSpaceNode") {
    parent.children.splice(index, 0, children.shift());
    next = children[0];
    if (next && next.position && child.position)
      child.position.start = next.position.start;
  }
}
var $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings);
function $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings(child, index, parent) {
  var children = child.children;
  var prev;
  if (children && children.length !== 0 && children[children.length - 1].type === "WhiteSpaceNode") {
    parent.children.splice(index + 1, 0, child.children.pop());
    prev = children[children.length - 1];
    if (prev && prev.position && child.position)
      child.position.end = prev.position.end;
    return index;
  }
}
var $560639d49e3c9a19$var$breakImplicitSentences_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$breakImplicitSentences);
var $560639d49e3c9a19$var$multiNewLine = $560639d49e3c9a19$var$expressions.newLineMulti;
function $560639d49e3c9a19$var$breakImplicitSentences(child, index, parent) {
  var children;
  var position;
  var length;
  var tail;
  var head;
  var end;
  var insertion;
  var node;
  if (child.type !== "SentenceNode")
    return;
  children = child.children;
  length = children.length - 1;
  position = 0;
  while (++position < length) {
    node = children[position];
    if (node.type !== "WhiteSpaceNode" || !$560639d49e3c9a19$var$multiNewLine.test($560639d49e3c9a19$var$nlcstToString_1(node)))
      continue;
    child.children = children.slice(0, position);
    insertion = {
      type: "SentenceNode",
      children: children.slice(position + 1)
    };
    tail = children[position - 1];
    head = children[position + 1];
    parent.children.splice(index + 1, 0, node, insertion);
    if (child.position && tail.position && head.position) {
      end = child.position.end;
      child.position.end = tail.position.end;
      insertion.position = {
        start: head.position.start,
        end
      };
    }
    return index + 1;
  }
}
var $560639d49e3c9a19$var$removeEmptyNodes_1 = $560639d49e3c9a19$var$unistUtilModifyChildren($560639d49e3c9a19$var$removeEmptyNodes);
function $560639d49e3c9a19$var$removeEmptyNodes(child, index, parent) {
  if ("children" in child && child.children.length === 0) {
    parent.children.splice(index, 1);
    return index;
  }
}
var $560639d49e3c9a19$var$lib = $560639d49e3c9a19$var$ParseLatin;
function $560639d49e3c9a19$var$ParseLatin(doc, file) {
  var value = file || doc;
  if (!(this instanceof $560639d49e3c9a19$var$ParseLatin))
    return new $560639d49e3c9a19$var$ParseLatin(doc, file);
  this.doc = value ? String(value) : null;
}
var $560639d49e3c9a19$var$proto = $560639d49e3c9a19$var$ParseLatin.prototype;
$560639d49e3c9a19$var$proto.position = true;
$560639d49e3c9a19$var$proto.tokenizeSymbol = $560639d49e3c9a19$var$createTextFactory("Symbol");
$560639d49e3c9a19$var$proto.tokenizeWhiteSpace = $560639d49e3c9a19$var$createTextFactory("WhiteSpace");
$560639d49e3c9a19$var$proto.tokenizePunctuation = $560639d49e3c9a19$var$createTextFactory("Punctuation");
$560639d49e3c9a19$var$proto.tokenizeSource = $560639d49e3c9a19$var$createTextFactory("Source");
$560639d49e3c9a19$var$proto.tokenizeText = $560639d49e3c9a19$var$createTextFactory("Text");
$560639d49e3c9a19$var$proto.run = $560639d49e3c9a19$var$run;
$560639d49e3c9a19$var$proto.use = $560639d49e3c9a19$var$useFactory(function(context, key, plugins) {
  context[key] = context[key].concat(plugins);
});
$560639d49e3c9a19$var$proto.useFirst = $560639d49e3c9a19$var$useFactory(function(context, key, plugins) {
  context[key] = plugins.concat(context[key]);
});
$560639d49e3c9a19$var$proto.parse = function(value) {
  return this.tokenizeRoot(value || this.doc);
};
$560639d49e3c9a19$var$proto.tokenize = function(value) {
  return $560639d49e3c9a19$var$tokenize(this, value);
};
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeWord", function(value, eat) {
  var add = (eat || $560639d49e3c9a19$var$noopEat)("");
  var parent = {
    type: "WordNode",
    children: []
  };
  this.tokenizeText(value, eat, parent);
  return add(parent);
});
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeSentence", $560639d49e3c9a19$var$parser({
  type: "SentenceNode",
  tokenizer: "tokenize"
}));
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeParagraph", $560639d49e3c9a19$var$parser({
  type: "ParagraphNode",
  delimiter: $560639d49e3c9a19$var$expressions.terminalMarker,
  delimiterType: "PunctuationNode",
  tokenizer: "tokenizeSentence"
}));
$560639d49e3c9a19$var$pluggable($560639d49e3c9a19$var$ParseLatin, "tokenizeRoot", $560639d49e3c9a19$var$parser({
  type: "RootNode",
  delimiter: $560639d49e3c9a19$var$expressions.newLine,
  delimiterType: "WhiteSpaceNode",
  tokenizer: "tokenizeParagraph"
}));
$560639d49e3c9a19$var$proto.use("tokenizeSentence", [
  $560639d49e3c9a19$var$mergeInitialWordSymbol_1,
  $560639d49e3c9a19$var$mergeFinalWordSymbol_1,
  $560639d49e3c9a19$var$mergeInnerWordSymbol_1,
  $560639d49e3c9a19$var$mergeInnerWordSlash_1,
  $560639d49e3c9a19$var$mergeInitialisms_1,
  $560639d49e3c9a19$var$mergeWords,
  $560639d49e3c9a19$var$patchPosition_1
]);
$560639d49e3c9a19$var$proto.use("tokenizeParagraph", [
  $560639d49e3c9a19$var$mergeNonWordSentences_1,
  $560639d49e3c9a19$var$mergeAffixSymbol_1,
  $560639d49e3c9a19$var$mergeInitialLowerCaseLetterSentences_1,
  $560639d49e3c9a19$var$mergeInitialDigitSentences_1,
  $560639d49e3c9a19$var$mergePrefixExceptions_1,
  $560639d49e3c9a19$var$mergeAffixExceptions_1,
  $560639d49e3c9a19$var$mergeRemainingFullStops_1,
  $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1,
  $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1,
  $560639d49e3c9a19$var$breakImplicitSentences_1,
  $560639d49e3c9a19$var$removeEmptyNodes_1,
  $560639d49e3c9a19$var$patchPosition_1
]);
$560639d49e3c9a19$var$proto.use("tokenizeRoot", [
  $560639d49e3c9a19$var$makeInitialWhiteSpaceSiblings_1,
  $560639d49e3c9a19$var$makeFinalWhiteSpaceSiblings_1,
  $560639d49e3c9a19$var$removeEmptyNodes_1,
  $560639d49e3c9a19$var$patchPosition_1
]);
function $560639d49e3c9a19$var$createTextFactory(type) {
  type += "Node";
  return createText;
  function createText(value, eat, parent) {
    if (value === null || value === void 0)
      value = "";
    return (eat || $560639d49e3c9a19$var$noopEat)(value)({
      type,
      value: String(value)
    }, parent);
  }
}
function $560639d49e3c9a19$var$run(key, nodes) {
  var wareKey = key + "Plugins";
  var plugins = this[wareKey];
  var index = -1;
  if (plugins)
    while (plugins[++index])
      plugins[index](nodes);
  return nodes;
}
function $560639d49e3c9a19$var$pluggable(Constructor, key, callback) {
  Constructor.prototype[key] = function() {
    return this.run(key, callback.apply(this, arguments));
  };
}
function $560639d49e3c9a19$var$useFactory(callback) {
  return use;
  function use(key, plugins) {
    var self2 = this;
    var wareKey;
    if (!(key in self2))
      throw new Error("Illegal Invocation: Unsupported `key` for `use(key, plugins)`. Make sure `key` is a supported function");
    if (!plugins)
      return;
    wareKey = key + "Plugins";
    if (typeof plugins === "function")
      plugins = [
        plugins
      ];
    else
      plugins = plugins.concat();
    if (!self2[wareKey])
      self2[wareKey] = [];
    callback(self2, wareKey, plugins);
  }
}
var $560639d49e3c9a19$var$wordRe = $560639d49e3c9a19$var$expressions.word;
var $560639d49e3c9a19$var$surrogatesRe = $560639d49e3c9a19$var$expressions.surrogates;
var $560639d49e3c9a19$var$punctuationRe = $560639d49e3c9a19$var$expressions.punctuation;
var $560639d49e3c9a19$var$whiteSpaceRe = $560639d49e3c9a19$var$expressions.whiteSpace;
function $560639d49e3c9a19$var$tokenize(parser, value) {
  var tokens;
  var offset;
  var line;
  var column;
  var index;
  var length;
  var character;
  var queue;
  var prev;
  var left;
  var right;
  var eater;
  if (value === null || value === void 0)
    value = "";
  else if (value instanceof String)
    value = value.toString();
  if (typeof value !== "string") {
    if ("length" in value && (!value[0] || value[0].type))
      return value;
    throw new Error("Illegal invocation: '" + value + "' is not a valid argument for 'ParseLatin'");
  }
  tokens = [];
  if (!value)
    return tokens;
  index = 0;
  offset = 0;
  line = 1;
  column = 1;
  eater = parser.position ? eat : noPositionEat;
  length = value.length;
  prev = "";
  queue = "";
  while (index < length) {
    character = value.charAt(index);
    if ($560639d49e3c9a19$var$whiteSpaceRe.test(character))
      right = "WhiteSpace";
    else if ($560639d49e3c9a19$var$punctuationRe.test(character))
      right = "Punctuation";
    else if ($560639d49e3c9a19$var$wordRe.test(character))
      right = "Word";
    else
      right = "Symbol";
    tick();
    prev = character;
    character = "";
    left = right;
    right = null;
    index++;
  }
  tick();
  return tokens;
  function tick() {
    if (left === right && (left === "Word" || left === "WhiteSpace" || character === prev || $560639d49e3c9a19$var$surrogatesRe.test(character)))
      queue += character;
    else {
      if (queue)
        parser["tokenize" + left](queue, eater);
      queue = character;
    }
  }
  function eat(subvalue) {
    var pos = position();
    update(subvalue);
    return apply;
    function apply() {
      return pos(add.apply(null, arguments));
    }
  }
  function noPositionEat() {
    return apply;
    function apply() {
      return add.apply(null, arguments);
    }
  }
  function add(node, parent) {
    if (parent)
      parent.children.push(node);
    else
      tokens.push(node);
    return node;
  }
  function position() {
    var before = now();
    function patch(node) {
      node.position = new Position(before);
      return node;
    }
    return patch;
  }
  function update(subvalue) {
    var subvalueLength = subvalue.length;
    var character2 = -1;
    var lastIndex = -1;
    offset += subvalueLength;
    while (++character2 < subvalueLength)
      if (subvalue.charAt(character2) === "\n") {
        lastIndex = character2;
        line++;
      }
    if (lastIndex === -1)
      column += subvalueLength;
    else
      column = subvalueLength - lastIndex;
  }
  function Position(start) {
    this.start = start;
    this.end = now();
  }
  function now() {
    return {
      line,
      column,
      offset
    };
  }
}
function $560639d49e3c9a19$var$noopAdd(node, parent) {
  if (parent)
    parent.children.push(node);
  return node;
}
function $560639d49e3c9a19$var$noopEat() {
  return $560639d49e3c9a19$var$noopAdd;
}
var $560639d49e3c9a19$var$parseLatin = $560639d49e3c9a19$var$lib;
var $560639d49e3c9a19$var$retextLatin = $560639d49e3c9a19$var$parse$1;
$560639d49e3c9a19$var$parse$1.Parser = $560639d49e3c9a19$var$parseLatin;
function $560639d49e3c9a19$var$parse$1() {
  this.Parser = $560639d49e3c9a19$var$unherit_1($560639d49e3c9a19$var$parseLatin);
}
var $560639d49e3c9a19$var$retextStringify = $560639d49e3c9a19$var$stringify$1;
function $560639d49e3c9a19$var$stringify$1() {
  this.Compiler = $560639d49e3c9a19$var$compiler;
}
function $560639d49e3c9a19$var$compiler(tree) {
  return $560639d49e3c9a19$var$nlcstToString_1(tree);
}
var $560639d49e3c9a19$var$retext = $560639d49e3c9a19$var$unified_1().use($560639d49e3c9a19$var$retextLatin).use($560639d49e3c9a19$var$retextStringify).freeze();
var $560639d49e3c9a19$var$retextSmartypants = $560639d49e3c9a19$var$smartypants;
var $560639d49e3c9a19$var$punctuation = "PunctuationNode";
var $560639d49e3c9a19$var$symbol = "SymbolNode";
var $560639d49e3c9a19$var$word = "WordNode";
var $560639d49e3c9a19$var$whiteSpace = "WhiteSpaceNode";
var $560639d49e3c9a19$var$decadeExpression = /^\d\ds$/;
var $560639d49e3c9a19$var$threeFullStopsExpression = /^\.{3,}$/;
var $560639d49e3c9a19$var$fullStopsExpression = /^\.+$/;
var $560639d49e3c9a19$var$threeDashes = "---";
var $560639d49e3c9a19$var$twoDashes = "--";
var $560639d49e3c9a19$var$emDash = "—";
var $560639d49e3c9a19$var$enDash = "–";
var $560639d49e3c9a19$var$ellipsis = "…";
var $560639d49e3c9a19$var$twoBackticks = "``";
var $560639d49e3c9a19$var$backtick = "`";
var $560639d49e3c9a19$var$twoSingleQuotes = "''";
var $560639d49e3c9a19$var$singleQuote = "'";
var $560639d49e3c9a19$var$apostrophe = "’";
var $560639d49e3c9a19$var$doubleQuote = '"';
var $560639d49e3c9a19$var$openingDoubleQuote = "“";
var $560639d49e3c9a19$var$closingDoubleQuote = "”";
var $560639d49e3c9a19$var$openingSingleQuote = "‘";
var $560639d49e3c9a19$var$closingSingleQuote = "’";
var $560639d49e3c9a19$var$closingQuotes = {};
var $560639d49e3c9a19$var$openingQuotes = {};
$560639d49e3c9a19$var$openingQuotes[$560639d49e3c9a19$var$doubleQuote] = $560639d49e3c9a19$var$openingDoubleQuote;
$560639d49e3c9a19$var$closingQuotes[$560639d49e3c9a19$var$doubleQuote] = $560639d49e3c9a19$var$closingDoubleQuote;
$560639d49e3c9a19$var$openingQuotes[$560639d49e3c9a19$var$singleQuote] = $560639d49e3c9a19$var$openingSingleQuote;
$560639d49e3c9a19$var$closingQuotes[$560639d49e3c9a19$var$singleQuote] = $560639d49e3c9a19$var$closingSingleQuote;
var $560639d49e3c9a19$var$educators = {};
$560639d49e3c9a19$var$educators.dashes = {
  true: $560639d49e3c9a19$var$dashes,
  oldschool: $560639d49e3c9a19$var$oldschool,
  inverted: $560639d49e3c9a19$var$inverted
};
$560639d49e3c9a19$var$educators.backticks = {
  true: $560639d49e3c9a19$var$backticks,
  all: $560639d49e3c9a19$var$all
};
$560639d49e3c9a19$var$educators.ellipses = {
  true: $560639d49e3c9a19$var$ellipses
};
$560639d49e3c9a19$var$educators.quotes = {
  true: $560639d49e3c9a19$var$quotes
};
function $560639d49e3c9a19$var$smartypants(options) {
  var methods = [];
  var quotes;
  var ellipses;
  var backticks;
  var dashes;
  if (!options)
    options = {};
  if ("quotes" in options) {
    quotes = options.quotes;
    if (quotes !== Boolean(quotes))
      throw new TypeError("Illegal invocation: `" + quotes + "` is not a valid value for `quotes` in `smartypants`");
  } else
    quotes = true;
  if ("ellipses" in options) {
    ellipses = options.ellipses;
    if (ellipses !== Boolean(ellipses))
      throw new TypeError("Illegal invocation: `" + ellipses + "` is not a valid value for `ellipses` in `smartypants`");
  } else
    ellipses = true;
  if ("backticks" in options) {
    backticks = options.backticks;
    if (backticks !== Boolean(backticks) && backticks !== "all")
      throw new TypeError("Illegal invocation: `" + backticks + "` is not a valid value for `backticks` in `smartypants`");
    if (backticks === "all" && quotes === true)
      throw new TypeError("Illegal invocation: `backticks: " + backticks + "` is not a valid value when `quotes: " + quotes + "` in `smartypants`");
  } else
    backticks = true;
  if ("dashes" in options) {
    dashes = options.dashes;
    if (dashes !== Boolean(dashes) && dashes !== "oldschool" && dashes !== "inverted")
      throw new TypeError("Illegal invocation: `" + dashes + "` is not a valid value for `dahes` in `smartypants`");
  } else
    dashes = true;
  if (quotes !== false)
    methods.push($560639d49e3c9a19$var$educators.quotes[quotes]);
  if (ellipses !== false)
    methods.push($560639d49e3c9a19$var$educators.ellipses[ellipses]);
  if (backticks !== false)
    methods.push($560639d49e3c9a19$var$educators.backticks[backticks]);
  if (dashes !== false)
    methods.push($560639d49e3c9a19$var$educators.dashes[dashes]);
  return $560639d49e3c9a19$var$transformFactory(methods);
}
function $560639d49e3c9a19$var$transformFactory(methods) {
  var length = methods.length;
  return transformer;
  function transformer(tree) {
    $560639d49e3c9a19$var$unistUtilVisit(tree, visitor);
  }
  function visitor(node, position, parent) {
    var index = -1;
    if (node.type === $560639d49e3c9a19$var$punctuation || node.type === $560639d49e3c9a19$var$symbol)
      while (++index < length)
        methods[index](node, position, parent);
  }
}
function $560639d49e3c9a19$var$oldschool(node) {
  if (node.value === $560639d49e3c9a19$var$threeDashes)
    node.value = $560639d49e3c9a19$var$emDash;
  else if (node.value === $560639d49e3c9a19$var$twoDashes)
    node.value = $560639d49e3c9a19$var$enDash;
}
function $560639d49e3c9a19$var$dashes(node) {
  if (node.value === $560639d49e3c9a19$var$twoDashes)
    node.value = $560639d49e3c9a19$var$emDash;
}
function $560639d49e3c9a19$var$inverted(node) {
  if (node.value === $560639d49e3c9a19$var$threeDashes)
    node.value = $560639d49e3c9a19$var$enDash;
  else if (node.value === $560639d49e3c9a19$var$twoDashes)
    node.value = $560639d49e3c9a19$var$emDash;
}
function $560639d49e3c9a19$var$backticks(node) {
  if (node.value === $560639d49e3c9a19$var$twoBackticks)
    node.value = $560639d49e3c9a19$var$openingDoubleQuote;
  else if (node.value === $560639d49e3c9a19$var$twoSingleQuotes)
    node.value = $560639d49e3c9a19$var$closingDoubleQuote;
}
function $560639d49e3c9a19$var$all(node) {
  $560639d49e3c9a19$var$backticks(node);
  if (node.value === $560639d49e3c9a19$var$backtick)
    node.value = $560639d49e3c9a19$var$openingSingleQuote;
  else if (node.value === $560639d49e3c9a19$var$singleQuote)
    node.value = $560639d49e3c9a19$var$closingSingleQuote;
}
function $560639d49e3c9a19$var$ellipses(node, index, parent) {
  var value = node.value;
  var siblings = parent.children;
  var position;
  var nodes;
  var sibling;
  var type;
  var count;
  var queue;
  if ($560639d49e3c9a19$var$threeFullStopsExpression.test(node.value)) {
    node.value = $560639d49e3c9a19$var$ellipsis;
    return;
  }
  if (!$560639d49e3c9a19$var$fullStopsExpression.test(value))
    return;
  nodes = [];
  position = index;
  count = 1;
  while (--position > 0) {
    sibling = siblings[position];
    if (sibling.type !== $560639d49e3c9a19$var$whiteSpace)
      break;
    queue = sibling;
    sibling = siblings[--position];
    type = sibling && sibling.type;
    if (sibling && (type === $560639d49e3c9a19$var$punctuation || type === $560639d49e3c9a19$var$symbol) && $560639d49e3c9a19$var$fullStopsExpression.test(sibling.value)) {
      nodes.push(queue, sibling);
      count++;
      continue;
    }
    break;
  }
  if (count < 3)
    return;
  siblings.splice(index - nodes.length, nodes.length);
  node.value = $560639d49e3c9a19$var$ellipsis;
}
function $560639d49e3c9a19$var$quotes(node, index, parent) {
  var siblings = parent.children;
  var value = node.value;
  var next;
  var nextNext;
  var prev;
  var nextValue;
  if (value !== $560639d49e3c9a19$var$doubleQuote && value !== $560639d49e3c9a19$var$singleQuote)
    return;
  prev = siblings[index - 1];
  next = siblings[index + 1];
  nextNext = siblings[index + 2];
  nextValue = next && $560639d49e3c9a19$var$nlcstToString_1(next);
  if (next && nextNext && (next.type === $560639d49e3c9a19$var$punctuation || next.type === $560639d49e3c9a19$var$symbol) && nextNext.type !== $560639d49e3c9a19$var$word)
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
  else if (nextNext && (nextValue === $560639d49e3c9a19$var$doubleQuote || nextValue === $560639d49e3c9a19$var$singleQuote) && nextNext.type === $560639d49e3c9a19$var$word) {
    node.value = $560639d49e3c9a19$var$openingQuotes[value];
    next.value = $560639d49e3c9a19$var$openingQuotes[nextValue];
  } else if (next && $560639d49e3c9a19$var$decadeExpression.test(nextValue))
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
  else if (prev && next && (prev.type === $560639d49e3c9a19$var$whiteSpace || prev.type === $560639d49e3c9a19$var$punctuation || prev.type === $560639d49e3c9a19$var$symbol) && next.type === $560639d49e3c9a19$var$word)
    node.value = $560639d49e3c9a19$var$openingQuotes[value];
  else if (prev && prev.type !== $560639d49e3c9a19$var$whiteSpace && prev.type !== $560639d49e3c9a19$var$symbol && prev.type !== $560639d49e3c9a19$var$punctuation)
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
  else if (!next || next.type === $560639d49e3c9a19$var$whiteSpace || (value === $560639d49e3c9a19$var$singleQuote || value === $560639d49e3c9a19$var$apostrophe) && nextValue === "s")
    node.value = $560639d49e3c9a19$var$closingQuotes[value];
  else
    node.value = $560639d49e3c9a19$var$openingQuotes[value];
}
function $560639d49e3c9a19$var$isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function $560639d49e3c9a19$var$isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function $560639d49e3c9a19$var$toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if ($560639d49e3c9a19$var$isNothing(sequence))
    return [];
  return [
    sequence
  ];
}
function $560639d49e3c9a19$var$extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function $560639d49e3c9a19$var$repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1)
    result += string;
  return result;
}
function $560639d49e3c9a19$var$isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var $560639d49e3c9a19$var$isNothing_1 = $560639d49e3c9a19$var$isNothing;
var $560639d49e3c9a19$var$isObject_1 = $560639d49e3c9a19$var$isObject;
var $560639d49e3c9a19$var$toArray_1 = $560639d49e3c9a19$var$toArray;
var $560639d49e3c9a19$var$repeat_1 = $560639d49e3c9a19$var$repeat;
var $560639d49e3c9a19$var$isNegativeZero_1 = $560639d49e3c9a19$var$isNegativeZero;
var $560639d49e3c9a19$var$extend_1 = $560639d49e3c9a19$var$extend;
var $560639d49e3c9a19$var$common = {
  isNothing: $560639d49e3c9a19$var$isNothing_1,
  isObject: $560639d49e3c9a19$var$isObject_1,
  toArray: $560639d49e3c9a19$var$toArray_1,
  repeat: $560639d49e3c9a19$var$repeat_1,
  isNegativeZero: $560639d49e3c9a19$var$isNegativeZero_1,
  extend: $560639d49e3c9a19$var$extend_1
};
function $560639d49e3c9a19$var$YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor);
  else
    this.stack = new Error().stack || "";
}
$560639d49e3c9a19$var$YAMLException$1.prototype = Object.create(Error.prototype);
$560639d49e3c9a19$var$YAMLException$1.prototype.constructor = $560639d49e3c9a19$var$YAMLException$1;
$560639d49e3c9a19$var$YAMLException$1.prototype.toString = function toString(compact) {
  var result = this.name + ": ";
  result += this.reason || "(unknown reason)";
  if (!compact && this.mark)
    result += " " + this.mark.toString();
  return result;
};
var $560639d49e3c9a19$var$exception = $560639d49e3c9a19$var$YAMLException$1;
function $560639d49e3c9a19$var$Mark(name, buffer, position, line, column) {
  this.name = name;
  this.buffer = buffer;
  this.position = position;
  this.line = line;
  this.column = column;
}
$560639d49e3c9a19$var$Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;
  if (!this.buffer)
    return null;
  indent = indent || 4;
  maxLength = maxLength || 75;
  head = "";
  start = this.position;
  while (start > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > maxLength / 2 - 1) {
      head = " ... ";
      start += 5;
      break;
    }
  }
  tail = "";
  end = this.position;
  while (end < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > maxLength / 2 - 1) {
      tail = " ... ";
      end -= 5;
      break;
    }
  }
  snippet = this.buffer.slice(start, end);
  return $560639d49e3c9a19$var$common.repeat(" ", indent) + head + snippet + tail + "\n" + $560639d49e3c9a19$var$common.repeat(" ", indent + this.position - start + head.length) + "^";
};
$560639d49e3c9a19$var$Mark.prototype.toString = function toString2(compact) {
  var snippet, where = "";
  if (this.name)
    where += 'in "' + this.name + '" ';
  where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
  if (!compact) {
    snippet = this.getSnippet();
    if (snippet)
      where += ":\n" + snippet;
  }
  return where;
};
var $560639d49e3c9a19$var$mark = $560639d49e3c9a19$var$Mark;
var $560639d49e3c9a19$var$TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
];
var $560639d49e3c9a19$var$YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function $560639d49e3c9a19$var$compileStyleAliases(map) {
  var result = {};
  if (map !== null)
    Object.keys(map).forEach(function(style) {
      map[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  return result;
}
function $560639d49e3c9a19$var$Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if ($560639d49e3c9a19$var$TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1)
      throw new $560639d49e3c9a19$var$exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
  });
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.styleAliases = $560639d49e3c9a19$var$compileStyleAliases(options["styleAliases"] || null);
  if ($560639d49e3c9a19$var$YAML_NODE_KINDS.indexOf(this.kind) === -1)
    throw new $560639d49e3c9a19$var$exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
}
var $560639d49e3c9a19$var$type = $560639d49e3c9a19$var$Type$1;
function $560639d49e3c9a19$var$compileList(schema, name, result) {
  var exclude = [];
  schema.include.forEach(function(includedSchema) {
    result = $560639d49e3c9a19$var$compileList(includedSchema, name, result);
  });
  schema[name].forEach(function(currentType) {
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind)
        exclude.push(previousIndex);
    });
    result.push(currentType);
  });
  return result.filter(function(type, index) {
    return exclude.indexOf(index) === -1;
  });
}
function $560639d49e3c9a19$var$compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, index, length;
  function collectType(type) {
    result[type.kind][type.tag] = result["fallback"][type.tag] = type;
  }
  for (index = 0, length = arguments.length; index < length; index += 1)
    arguments[index].forEach(collectType);
  return result;
}
function $560639d49e3c9a19$var$Schema$1(definition) {
  this.include = definition.include || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];
  this.implicit.forEach(function(type) {
    if (type.loadKind && type.loadKind !== "scalar")
      throw new $560639d49e3c9a19$var$exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  });
  this.compiledImplicit = $560639d49e3c9a19$var$compileList(this, "implicit", []);
  this.compiledExplicit = $560639d49e3c9a19$var$compileList(this, "explicit", []);
  this.compiledTypeMap = $560639d49e3c9a19$var$compileMap(this.compiledImplicit, this.compiledExplicit);
}
$560639d49e3c9a19$var$Schema$1.DEFAULT = null;
$560639d49e3c9a19$var$Schema$1.create = function createSchema() {
  var schemas, types;
  switch (arguments.length) {
    case 1:
      schemas = $560639d49e3c9a19$var$Schema$1.DEFAULT;
      types = arguments[0];
      break;
    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;
    default:
      throw new $560639d49e3c9a19$var$exception("Wrong number of arguments for Schema.create function");
  }
  schemas = $560639d49e3c9a19$var$common.toArray(schemas);
  types = $560639d49e3c9a19$var$common.toArray(types);
  if (!schemas.every(function(schema) {
    return schema instanceof $560639d49e3c9a19$var$Schema$1;
  }))
    throw new $560639d49e3c9a19$var$exception("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!types.every(function(type$1) {
    return type$1 instanceof $560639d49e3c9a19$var$type;
  }))
    throw new $560639d49e3c9a19$var$exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new $560639d49e3c9a19$var$Schema$1({
    include: schemas,
    explicit: types
  });
};
var $560639d49e3c9a19$var$schema = $560639d49e3c9a19$var$Schema$1;
var $560639d49e3c9a19$var$str = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var $560639d49e3c9a19$var$seq = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var $560639d49e3c9a19$var$map = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var $560639d49e3c9a19$var$failsafe = new $560639d49e3c9a19$var$schema({
  explicit: [
    $560639d49e3c9a19$var$str,
    $560639d49e3c9a19$var$seq,
    $560639d49e3c9a19$var$map
  ]
});
function $560639d49e3c9a19$var$resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function $560639d49e3c9a19$var$constructYamlNull() {
  return null;
}
function $560639d49e3c9a19$var$isNull(object) {
  return object === null;
}
var $560639d49e3c9a19$var$_null = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlNull,
  construct: $560639d49e3c9a19$var$constructYamlNull,
  predicate: $560639d49e3c9a19$var$isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
});
function $560639d49e3c9a19$var$resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function $560639d49e3c9a19$var$constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function $560639d49e3c9a19$var$isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var $560639d49e3c9a19$var$bool = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlBoolean,
  construct: $560639d49e3c9a19$var$constructYamlBoolean,
  predicate: $560639d49e3c9a19$var$isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function $560639d49e3c9a19$var$isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
function $560639d49e3c9a19$var$isOctCode(c) {
  return 48 <= c && c <= 55;
}
function $560639d49e3c9a19$var$isDecCode(c) {
  return 48 <= c && c <= 57;
}
function $560639d49e3c9a19$var$resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+")
    ch = data[++index];
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!$560639d49e3c9a19$var$isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (!$560639d49e3c9a19$var$isOctCode(data.charCodeAt(index)))
        return false;
      hasDigits = true;
    }
    return hasDigits && ch !== "_";
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (ch === ":")
      break;
    if (!$560639d49e3c9a19$var$isDecCode(data.charCodeAt(index)))
      return false;
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  if (ch !== ":")
    return true;
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function $560639d49e3c9a19$var$constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];
  if (value.indexOf("_") !== -1)
    value = value.replace(/_/g, "");
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(":") !== -1) {
    value.split(":").forEach(function(v) {
      digits.unshift(parseInt(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseInt(value, 10);
}
function $560639d49e3c9a19$var$isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !$560639d49e3c9a19$var$common.isNegativeZero(object);
}
var $560639d49e3c9a19$var$int_1 = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlInteger,
  construct: $560639d49e3c9a19$var$constructYamlInteger,
  predicate: $560639d49e3c9a19$var$isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [
      2,
      "bin"
    ],
    octal: [
      8,
      "oct"
    ],
    decimal: [
      10,
      "dec"
    ],
    hexadecimal: [
      16,
      "hex"
    ]
  }
});
var $560639d49e3c9a19$var$YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function $560639d49e3c9a19$var$resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!$560639d49e3c9a19$var$YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_")
    return false;
  return true;
}
function $560639d49e3c9a19$var$constructYamlFloat(data) {
  var value, sign, base, digits;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  digits = [];
  if ("+-".indexOf(value[0]) >= 0)
    value = value.slice(1);
  if (value === ".inf")
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  else if (value === ".nan")
    return NaN;
  else if (value.indexOf(":") >= 0) {
    value.split(":").forEach(function(v) {
      digits.unshift(parseFloat(v, 10));
    });
    value = 0;
    base = 1;
    digits.forEach(function(d) {
      value += d * base;
      base *= 60;
    });
    return sign * value;
  }
  return sign * parseFloat(value, 10);
}
var $560639d49e3c9a19$var$SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function $560639d49e3c9a19$var$representYamlFloat(object, style) {
  var res;
  if (isNaN(object))
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === object)
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if ($560639d49e3c9a19$var$common.isNegativeZero(object))
    return "-0.0";
  res = object.toString(10);
  return $560639d49e3c9a19$var$SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function $560639d49e3c9a19$var$isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || $560639d49e3c9a19$var$common.isNegativeZero(object));
}
var $560639d49e3c9a19$var$float_1 = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlFloat,
  construct: $560639d49e3c9a19$var$constructYamlFloat,
  predicate: $560639d49e3c9a19$var$isFloat,
  represent: $560639d49e3c9a19$var$representYamlFloat,
  defaultStyle: "lowercase"
});
var $560639d49e3c9a19$var$json = new $560639d49e3c9a19$var$schema({
  include: [
    $560639d49e3c9a19$var$failsafe
  ],
  implicit: [
    $560639d49e3c9a19$var$_null,
    $560639d49e3c9a19$var$bool,
    $560639d49e3c9a19$var$int_1,
    $560639d49e3c9a19$var$float_1
  ]
});
var $560639d49e3c9a19$var$core = new $560639d49e3c9a19$var$schema({
  include: [
    $560639d49e3c9a19$var$json
  ]
});
var $560639d49e3c9a19$var$YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
var $560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function $560639d49e3c9a19$var$resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if ($560639d49e3c9a19$var$YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if ($560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function $560639d49e3c9a19$var$constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = $560639d49e3c9a19$var$YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = $560639d49e3c9a19$var$YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4])
    return new Date(Date.UTC(year, month, day));
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3)
      fraction += "0";
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function $560639d49e3c9a19$var$representYamlTimestamp(object) {
  return object.toISOString();
}
var $560639d49e3c9a19$var$timestamp = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlTimestamp,
  construct: $560639d49e3c9a19$var$constructYamlTimestamp,
  instanceOf: Date,
  represent: $560639d49e3c9a19$var$representYamlTimestamp
});
function $560639d49e3c9a19$var$resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var $560639d49e3c9a19$var$merge = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlMerge
});
var $560639d49e3c9a19$var$NodeBuffer;
try {
  var $560639d49e3c9a19$var$_require$1 = $560639d49e3c9a19$var$commonjsRequire;
  $560639d49e3c9a19$var$NodeBuffer = $560639d49e3c9a19$var$_require$1("buffer").Buffer;
} catch (__) {
}
var $560639d49e3c9a19$var$BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function $560639d49e3c9a19$var$resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map = $560639d49e3c9a19$var$BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function $560639d49e3c9a19$var$constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = $560639d49e3c9a19$var$BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12)
    result.push(bits >> 4 & 255);
  if ($560639d49e3c9a19$var$NodeBuffer)
    return $560639d49e3c9a19$var$NodeBuffer.from ? $560639d49e3c9a19$var$NodeBuffer.from(result) : new $560639d49e3c9a19$var$NodeBuffer(result);
  return result;
}
function $560639d49e3c9a19$var$representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map = $560639d49e3c9a19$var$BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map[bits >> 18 & 63];
    result += map[bits >> 12 & 63];
    result += map[bits >> 6 & 63];
    result += map[bits & 63];
  } else if (tail === 2) {
    result += map[bits >> 10 & 63];
    result += map[bits >> 4 & 63];
    result += map[bits << 2 & 63];
    result += map[64];
  } else if (tail === 1) {
    result += map[bits >> 2 & 63];
    result += map[bits << 4 & 63];
    result += map[64];
    result += map[64];
  }
  return result;
}
function $560639d49e3c9a19$var$isBinary(object) {
  return $560639d49e3c9a19$var$NodeBuffer && $560639d49e3c9a19$var$NodeBuffer.isBuffer(object);
}
var $560639d49e3c9a19$var$binary = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveYamlBinary,
  construct: $560639d49e3c9a19$var$constructYamlBinary,
  predicate: $560639d49e3c9a19$var$isBinary,
  represent: $560639d49e3c9a19$var$representYamlBinary
});
var $560639d49e3c9a19$var$_hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$_toString$2 = Object.prototype.toString;
function $560639d49e3c9a19$var$resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if ($560639d49e3c9a19$var$_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair)
      if ($560639d49e3c9a19$var$_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function $560639d49e3c9a19$var$constructYamlOmap(data) {
  return data !== null ? data : [];
}
var $560639d49e3c9a19$var$omap = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: $560639d49e3c9a19$var$resolveYamlOmap,
  construct: $560639d49e3c9a19$var$constructYamlOmap
});
var $560639d49e3c9a19$var$_toString$1 = Object.prototype.toString;
function $560639d49e3c9a19$var$resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if ($560639d49e3c9a19$var$_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [
      keys[0],
      pair[keys[0]]
    ];
  }
  return true;
}
function $560639d49e3c9a19$var$constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [
      keys[0],
      pair[keys[0]]
    ];
  }
  return result;
}
var $560639d49e3c9a19$var$pairs = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: $560639d49e3c9a19$var$resolveYamlPairs,
  construct: $560639d49e3c9a19$var$constructYamlPairs
});
var $560639d49e3c9a19$var$_hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function $560639d49e3c9a19$var$resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object)
    if ($560639d49e3c9a19$var$_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  return true;
}
function $560639d49e3c9a19$var$constructYamlSet(data) {
  return data !== null ? data : {};
}
var $560639d49e3c9a19$var$set = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: $560639d49e3c9a19$var$resolveYamlSet,
  construct: $560639d49e3c9a19$var$constructYamlSet
});
var $560639d49e3c9a19$var$default_safe = new $560639d49e3c9a19$var$schema({
  include: [
    $560639d49e3c9a19$var$core
  ],
  implicit: [
    $560639d49e3c9a19$var$timestamp,
    $560639d49e3c9a19$var$merge
  ],
  explicit: [
    $560639d49e3c9a19$var$binary,
    $560639d49e3c9a19$var$omap,
    $560639d49e3c9a19$var$pairs,
    $560639d49e3c9a19$var$set
  ]
});
function $560639d49e3c9a19$var$resolveJavascriptUndefined() {
  return true;
}
function $560639d49e3c9a19$var$constructJavascriptUndefined() {
  return void 0;
}
function $560639d49e3c9a19$var$representJavascriptUndefined() {
  return "";
}
function $560639d49e3c9a19$var$isUndefined(object) {
  return typeof object === "undefined";
}
var $560639d49e3c9a19$var$_undefined = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveJavascriptUndefined,
  construct: $560639d49e3c9a19$var$constructJavascriptUndefined,
  predicate: $560639d49e3c9a19$var$isUndefined,
  represent: $560639d49e3c9a19$var$representJavascriptUndefined
});
function $560639d49e3c9a19$var$resolveJavascriptRegExp(data) {
  if (data === null)
    return false;
  if (data.length === 0)
    return false;
  var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  if (regexp[0] === "/") {
    if (tail)
      modifiers = tail[1];
    if (modifiers.length > 3)
      return false;
    if (regexp[regexp.length - modifiers.length - 1] !== "/")
      return false;
  }
  return true;
}
function $560639d49e3c9a19$var$constructJavascriptRegExp(data) {
  var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
  if (regexp[0] === "/") {
    if (tail)
      modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }
  return new RegExp(regexp, modifiers);
}
function $560639d49e3c9a19$var$representJavascriptRegExp(object) {
  var result = "/" + object.source + "/";
  if (object.global)
    result += "g";
  if (object.multiline)
    result += "m";
  if (object.ignoreCase)
    result += "i";
  return result;
}
function $560639d49e3c9a19$var$isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var $560639d49e3c9a19$var$regexp = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveJavascriptRegExp,
  construct: $560639d49e3c9a19$var$constructJavascriptRegExp,
  predicate: $560639d49e3c9a19$var$isRegExp,
  represent: $560639d49e3c9a19$var$representJavascriptRegExp
});
var $560639d49e3c9a19$var$esprima;
try {
  var $560639d49e3c9a19$var$_require = $560639d49e3c9a19$var$commonjsRequire;
  $560639d49e3c9a19$var$esprima = $560639d49e3c9a19$var$_require("esprima");
} catch (_) {
  if (typeof window !== "undefined")
    $560639d49e3c9a19$var$esprima = window.esprima;
}
function $560639d49e3c9a19$var$resolveJavascriptFunction(data) {
  if (data === null)
    return false;
  try {
    var source = "(" + data + ")", ast = $560639d49e3c9a19$var$esprima.parse(source, {
      range: true
    });
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
      return false;
    return true;
  } catch (err) {
    return false;
  }
}
function $560639d49e3c9a19$var$constructJavascriptFunction(data) {
  var source = "(" + data + ")", ast = $560639d49e3c9a19$var$esprima.parse(source, {
    range: true
  }), params = [], body;
  if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  ast.body[0].expression.params.forEach(function(param) {
    params.push(param.name);
  });
  body = ast.body[0].expression.body.range;
  if (ast.body[0].expression.body.type === "BlockStatement")
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  return new Function(params, "return " + source.slice(body[0], body[1]));
}
function $560639d49e3c9a19$var$representJavascriptFunction(object) {
  return object.toString();
}
function $560639d49e3c9a19$var$isFunction(object) {
  return Object.prototype.toString.call(object) === "[object Function]";
}
var $560639d49e3c9a19$var$_function = new $560639d49e3c9a19$var$type("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: $560639d49e3c9a19$var$resolveJavascriptFunction,
  construct: $560639d49e3c9a19$var$constructJavascriptFunction,
  predicate: $560639d49e3c9a19$var$isFunction,
  represent: $560639d49e3c9a19$var$representJavascriptFunction
});
var $560639d49e3c9a19$var$default_full = $560639d49e3c9a19$var$schema.DEFAULT = new $560639d49e3c9a19$var$schema({
  include: [
    $560639d49e3c9a19$var$default_safe
  ],
  explicit: [
    $560639d49e3c9a19$var$_undefined,
    $560639d49e3c9a19$var$regexp,
    $560639d49e3c9a19$var$_function
  ]
});
var $560639d49e3c9a19$var$_hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$CONTEXT_FLOW_IN = 1;
var $560639d49e3c9a19$var$CONTEXT_FLOW_OUT = 2;
var $560639d49e3c9a19$var$CONTEXT_BLOCK_IN = 3;
var $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT = 4;
var $560639d49e3c9a19$var$CHOMPING_CLIP = 1;
var $560639d49e3c9a19$var$CHOMPING_STRIP = 2;
var $560639d49e3c9a19$var$CHOMPING_KEEP = 3;
var $560639d49e3c9a19$var$PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var $560639d49e3c9a19$var$PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var $560639d49e3c9a19$var$PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var $560639d49e3c9a19$var$PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var $560639d49e3c9a19$var$PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function $560639d49e3c9a19$var$_class(obj) {
  return Object.prototype.toString.call(obj);
}
function $560639d49e3c9a19$var$is_EOL(c) {
  return c === 10 || c === 13;
}
function $560639d49e3c9a19$var$is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
function $560639d49e3c9a19$var$is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function $560639d49e3c9a19$var$is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function $560639d49e3c9a19$var$fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57)
    return c - 48;
  lc = c | 32;
  if (97 <= lc && lc <= 102)
    return lc - 97 + 10;
  return -1;
}
function $560639d49e3c9a19$var$escapedHexLen(c) {
  if (c === 120)
    return 2;
  if (c === 117)
    return 4;
  if (c === 85)
    return 8;
  return 0;
}
function $560639d49e3c9a19$var$fromDecimalCode(c) {
  if (48 <= c && c <= 57)
    return c - 48;
  return -1;
}
function $560639d49e3c9a19$var$simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "" : c === 95 ? " " : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function $560639d49e3c9a19$var$charFromCodepoint(c) {
  if (c <= 65535)
    return String.fromCharCode(c);
  return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
}
var $560639d49e3c9a19$var$simpleEscapeCheck = new Array(256);
var $560639d49e3c9a19$var$simpleEscapeMap = new Array(256);
for (var $560639d49e3c9a19$var$i = 0; $560639d49e3c9a19$var$i < 256; $560639d49e3c9a19$var$i++) {
  $560639d49e3c9a19$var$simpleEscapeCheck[$560639d49e3c9a19$var$i] = $560639d49e3c9a19$var$simpleEscapeSequence($560639d49e3c9a19$var$i) ? 1 : 0;
  $560639d49e3c9a19$var$simpleEscapeMap[$560639d49e3c9a19$var$i] = $560639d49e3c9a19$var$simpleEscapeSequence($560639d49e3c9a19$var$i);
}
function $560639d49e3c9a19$var$State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || $560639d49e3c9a19$var$default_full;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.documents = [];
}
function $560639d49e3c9a19$var$generateError(state, message) {
  return new $560639d49e3c9a19$var$exception(message, new $560639d49e3c9a19$var$mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function $560639d49e3c9a19$var$throwError(state, message) {
  throw $560639d49e3c9a19$var$generateError(state, message);
}
function $560639d49e3c9a19$var$throwWarning(state, message) {
  if (state.onWarning)
    state.onWarning.call(null, $560639d49e3c9a19$var$generateError(state, message));
}
var $560639d49e3c9a19$var$directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null)
      $560639d49e3c9a19$var$throwError(state, "duplication of %YAML directive");
    if (args.length !== 1)
      $560639d49e3c9a19$var$throwError(state, "YAML directive accepts exactly one argument");
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null)
      $560639d49e3c9a19$var$throwError(state, "ill-formed argument of the YAML directive");
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1)
      $560639d49e3c9a19$var$throwError(state, "unacceptable YAML version of the document");
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2)
      $560639d49e3c9a19$var$throwWarning(state, "unsupported YAML version of the document");
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2)
      $560639d49e3c9a19$var$throwError(state, "TAG directive accepts exactly two arguments");
    handle = args[0];
    prefix = args[1];
    if (!$560639d49e3c9a19$var$PATTERN_TAG_HANDLE.test(handle))
      $560639d49e3c9a19$var$throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.tagMap, handle))
      $560639d49e3c9a19$var$throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    if (!$560639d49e3c9a19$var$PATTERN_TAG_URI.test(prefix))
      $560639d49e3c9a19$var$throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    state.tagMap[handle] = prefix;
  }
};
function $560639d49e3c9a19$var$captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson)
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111))
          $560639d49e3c9a19$var$throwError(state, "expected valid JSON character");
      }
    else if ($560639d49e3c9a19$var$PATTERN_NON_PRINTABLE.test(_result))
      $560639d49e3c9a19$var$throwError(state, "the stream contains non-printable characters");
    state.result += _result;
  }
}
function $560639d49e3c9a19$var$mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!$560639d49e3c9a19$var$common.isObject(source))
    $560639d49e3c9a19$var$throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!$560639d49e3c9a19$var$_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index]))
        $560639d49e3c9a19$var$throwError(state, "nested arrays are not supported inside keys");
      if (typeof keyNode === "object" && $560639d49e3c9a19$var$_class(keyNode[index]) === "[object Object]")
        keyNode[index] = "[object Object]";
    }
  }
  if (typeof keyNode === "object" && $560639d49e3c9a19$var$_class(keyNode) === "[object Object]")
    keyNode = "[object Object]";
  keyNode = String(keyNode);
  if (_result === null)
    _result = {};
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode))
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1)
        $560639d49e3c9a19$var$mergeMappings(state, _result, valueNode[index], overridableKeys);
    else
      $560639d49e3c9a19$var$mergeMappings(state, _result, valueNode, overridableKeys);
  } else {
    if (!state.json && !$560639d49e3c9a19$var$_hasOwnProperty$1.call(overridableKeys, keyNode) && $560639d49e3c9a19$var$_hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      $560639d49e3c9a19$var$throwError(state, "duplicated mapping key");
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return _result;
}
function $560639d49e3c9a19$var$readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10)
    state.position++;
  else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10)
      state.position++;
  } else
    $560639d49e3c9a19$var$throwError(state, "a line break is expected");
  state.line += 1;
  state.lineStart = state.position;
}
function $560639d49e3c9a19$var$skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while ($560639d49e3c9a19$var$is_WHITE_SPACE(ch))
      ch = state.input.charCodeAt(++state.position);
    if (allowComments && ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (ch !== 10 && ch !== 13 && ch !== 0);
    if ($560639d49e3c9a19$var$is_EOL(ch)) {
      $560639d49e3c9a19$var$readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else
      break;
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent)
    $560639d49e3c9a19$var$throwWarning(state, "deficient indentation");
  return lineBreaks;
}
function $560639d49e3c9a19$var$testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || $560639d49e3c9a19$var$is_WS_OR_EOL(ch))
      return true;
  }
  return false;
}
function $560639d49e3c9a19$var$writeFoldedLines(state, count) {
  if (count === 1)
    state.result += " ";
  else if (count > 1)
    state.result += $560639d49e3c9a19$var$common.repeat("\n", count - 1);
}
function $560639d49e3c9a19$var$readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if ($560639d49e3c9a19$var$is_WS_OR_EOL(ch) || $560639d49e3c9a19$var$is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96)
    return false;
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if ($560639d49e3c9a19$var$is_WS_OR_EOL(following) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(following))
      return false;
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if ($560639d49e3c9a19$var$is_WS_OR_EOL(following) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(following))
        break;
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if ($560639d49e3c9a19$var$is_WS_OR_EOL(preceding))
        break;
    } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state) || withinFlowCollection && $560639d49e3c9a19$var$is_FLOW_INDICATOR(ch))
      break;
    else if ($560639d49e3c9a19$var$is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      $560639d49e3c9a19$var$skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, false);
      $560639d49e3c9a19$var$writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!$560639d49e3c9a19$var$is_WHITE_SPACE(ch))
      captureEnd = state.position + 1;
    ch = state.input.charCodeAt(++state.position);
  }
  $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, false);
  if (state.result)
    return true;
  state.kind = _kind;
  state.result = _result;
  return false;
}
function $560639d49e3c9a19$var$readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39)
    return false;
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else
        return true;
    } else if ($560639d49e3c9a19$var$is_EOL(ch)) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, true);
      $560639d49e3c9a19$var$writeFoldedLines(state, $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state))
      $560639d49e3c9a19$var$throwError(state, "unexpected end of the document within a single quoted scalar");
    else {
      state.position++;
      captureEnd = state.position;
    }
  }
  $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function $560639d49e3c9a19$var$readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34)
    return false;
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if ($560639d49e3c9a19$var$is_EOL(ch))
        $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent);
      else if (ch < 256 && $560639d49e3c9a19$var$simpleEscapeCheck[ch]) {
        state.result += $560639d49e3c9a19$var$simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = $560639d49e3c9a19$var$escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = $560639d49e3c9a19$var$fromHexCode(ch)) >= 0)
            hexResult = (hexResult << 4) + tmp;
          else
            $560639d49e3c9a19$var$throwError(state, "expected hexadecimal character");
        }
        state.result += $560639d49e3c9a19$var$charFromCodepoint(hexResult);
        state.position++;
      } else
        $560639d49e3c9a19$var$throwError(state, "unknown escape sequence");
      captureStart = captureEnd = state.position;
    } else if ($560639d49e3c9a19$var$is_EOL(ch)) {
      $560639d49e3c9a19$var$captureSegment(state, captureStart, captureEnd, true);
      $560639d49e3c9a19$var$writeFoldedLines(state, $560639d49e3c9a19$var$skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state))
      $560639d49e3c9a19$var$throwError(state, "unexpected end of the document within a double quoted scalar");
    else {
      state.position++;
      captureEnd = state.position;
    }
  }
  $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function $560639d49e3c9a19$var$readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else
    return false;
  if (state.anchor !== null)
    state.anchorMap[state.anchor] = _result;
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext)
      $560639d49e3c9a19$var$throwError(state, "missed comma between flow collection entries");
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if ($560639d49e3c9a19$var$is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
      $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping)
      $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    else if (isPair)
      _result.push($560639d49e3c9a19$var$storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    else
      _result.push(keyNode);
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else
      readNext = false;
  }
  $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a flow collection");
}
function $560639d49e3c9a19$var$readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = $560639d49e3c9a19$var$CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124)
    folding = false;
  else if (ch === 62)
    folding = true;
  else
    return false;
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if ($560639d49e3c9a19$var$CHOMPING_CLIP === chomping)
        chomping = ch === 43 ? $560639d49e3c9a19$var$CHOMPING_KEEP : $560639d49e3c9a19$var$CHOMPING_STRIP;
      else
        $560639d49e3c9a19$var$throwError(state, "repeat of a chomping mode identifier");
    } else if ((tmp = $560639d49e3c9a19$var$fromDecimalCode(ch)) >= 0) {
      if (tmp === 0)
        $560639d49e3c9a19$var$throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else
        $560639d49e3c9a19$var$throwError(state, "repeat of an indentation width identifier");
    } else
      break;
  }
  if ($560639d49e3c9a19$var$is_WHITE_SPACE(ch)) {
    do
      ch = state.input.charCodeAt(++state.position);
    while ($560639d49e3c9a19$var$is_WHITE_SPACE(ch));
    if (ch === 35)
      do
        ch = state.input.charCodeAt(++state.position);
      while (!$560639d49e3c9a19$var$is_EOL(ch) && ch !== 0);
  }
  while (ch !== 0) {
    $560639d49e3c9a19$var$readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent)
      textIndent = state.lineIndent;
    if ($560639d49e3c9a19$var$is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === $560639d49e3c9a19$var$CHOMPING_KEEP)
        state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      else if (chomping === $560639d49e3c9a19$var$CHOMPING_CLIP) {
        if (didReadContent)
          state.result += "\n";
      }
      break;
    }
    if (folding) {
      if ($560639d49e3c9a19$var$is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += $560639d49e3c9a19$var$common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent)
          state.result += " ";
      } else
        state.result += $560639d49e3c9a19$var$common.repeat("\n", emptyLines);
    } else
      state.result += $560639d49e3c9a19$var$common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!$560639d49e3c9a19$var$is_EOL(ch) && ch !== 0)
      ch = state.input.charCodeAt(++state.position);
    $560639d49e3c9a19$var$captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function $560639d49e3c9a19$var$readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.anchor !== null)
    state.anchorMap[state.anchor] = _result;
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 45)
      break;
    following = state.input.charCodeAt(state.position + 1);
    if (!$560639d49e3c9a19$var$is_WS_OR_EOL(following))
      break;
    detected = true;
    state.position++;
    if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    $560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0)
      $560639d49e3c9a19$var$throwError(state, "bad indentation of a sequence entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function $560639d49e3c9a19$var$readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.anchor !== null)
    state.anchorMap[state.anchor] = _result;
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    _pos = state.position;
    if ((ch === 63 || ch === 58) && $560639d49e3c9a19$var$is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else
        $560639d49e3c9a19$var$throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      state.position += 1;
      ch = following;
    } else if ($560639d49e3c9a19$var$composeNode(state, flowIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while ($560639d49e3c9a19$var$is_WHITE_SPACE(ch))
          ch = state.input.charCodeAt(++state.position);
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!$560639d49e3c9a19$var$is_WS_OR_EOL(ch))
            $560639d49e3c9a19$var$throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          if (atExplicitKey) {
            $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected)
          $560639d49e3c9a19$var$throwError(state, "can not read an implicit mapping pair; a colon is missed");
        else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected)
        $560639d49e3c9a19$var$throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    } else
      break;
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if ($560639d49e3c9a19$var$composeNode(state, nodeIndent, $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey)
          keyNode = state.result;
        else
          valueNode = state.result;
      }
      if (!atExplicitKey) {
        $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }
      $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0)
      $560639d49e3c9a19$var$throwError(state, "bad indentation of a mapping entry");
    else if (state.lineIndent < nodeIndent)
      break;
  }
  if (atExplicitKey)
    $560639d49e3c9a19$var$storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function $560639d49e3c9a19$var$readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null)
    $560639d49e3c9a19$var$throwError(state, "duplication of a tag property");
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else
    tagHandle = "!";
  _position = state.position;
  if (isVerbatim) {
    do
      ch = state.input.charCodeAt(++state.position);
    while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else
      $560639d49e3c9a19$var$throwError(state, "unexpected end of the stream within a verbatim tag");
  } else {
    while (ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!$560639d49e3c9a19$var$PATTERN_TAG_HANDLE.test(tagHandle))
            $560639d49e3c9a19$var$throwError(state, "named tag handle cannot contain such characters");
          isNamed = true;
          _position = state.position + 1;
        } else
          $560639d49e3c9a19$var$throwError(state, "tag suffix cannot contain exclamation marks");
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if ($560639d49e3c9a19$var$PATTERN_FLOW_INDICATORS.test(tagName))
      $560639d49e3c9a19$var$throwError(state, "tag suffix cannot contain flow indicator characters");
  }
  if (tagName && !$560639d49e3c9a19$var$PATTERN_TAG_URI.test(tagName))
    $560639d49e3c9a19$var$throwError(state, "tag name cannot contain such characters: " + tagName);
  if (isVerbatim)
    state.tag = tagName;
  else if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.tagMap, tagHandle))
    state.tag = state.tagMap[tagHandle] + tagName;
  else if (tagHandle === "!")
    state.tag = "!" + tagName;
  else if (tagHandle === "!!")
    state.tag = "tag:yaml.org,2002:" + tagName;
  else
    $560639d49e3c9a19$var$throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  return true;
}
function $560639d49e3c9a19$var$readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null)
    $560639d49e3c9a19$var$throwError(state, "duplication of an anchor property");
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch) && !$560639d49e3c9a19$var$is_FLOW_INDICATOR(ch))
    ch = state.input.charCodeAt(++state.position);
  if (state.position === _position)
    $560639d49e3c9a19$var$throwError(state, "name of an anchor node must contain at least one character");
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function $560639d49e3c9a19$var$readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch) && !$560639d49e3c9a19$var$is_FLOW_INDICATOR(ch))
    ch = state.input.charCodeAt(++state.position);
  if (state.position === _position)
    $560639d49e3c9a19$var$throwError(state, "name of an alias node must contain at least one character");
  alias = state.input.slice(_position, state.position);
  if (!state.anchorMap.hasOwnProperty(alias))
    $560639d49e3c9a19$var$throwError(state, 'unidentified alias "' + alias + '"');
  state.result = state.anchorMap[alias];
  $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
  return true;
}
function $560639d49e3c9a19$var$composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
  if (state.listener !== null)
    state.listener("open", state);
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT === nodeContext || $560639d49e3c9a19$var$CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent)
        indentStatus = 1;
      else if (state.lineIndent === parentIndent)
        indentStatus = 0;
      else if (state.lineIndent < parentIndent)
        indentStatus = -1;
    }
  }
  if (indentStatus === 1) {
    while ($560639d49e3c9a19$var$readTagProperty(state) || $560639d49e3c9a19$var$readAnchorProperty(state))
      if ($560639d49e3c9a19$var$skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent)
          indentStatus = 1;
        else if (state.lineIndent === parentIndent)
          indentStatus = 0;
        else if (state.lineIndent < parentIndent)
          indentStatus = -1;
      } else
        allowBlockCollections = false;
  }
  if (allowBlockCollections)
    allowBlockCollections = atNewLine || allowCompact;
  if (indentStatus === 1 || $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT === nodeContext) {
    if ($560639d49e3c9a19$var$CONTEXT_FLOW_IN === nodeContext || $560639d49e3c9a19$var$CONTEXT_FLOW_OUT === nodeContext)
      flowIndent = parentIndent;
    else
      flowIndent = parentIndent + 1;
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && ($560639d49e3c9a19$var$readBlockSequence(state, blockIndent) || $560639d49e3c9a19$var$readBlockMapping(state, blockIndent, flowIndent)) || $560639d49e3c9a19$var$readFlowCollection(state, flowIndent))
        hasContent = true;
      else {
        if (allowBlockScalars && $560639d49e3c9a19$var$readBlockScalar(state, flowIndent) || $560639d49e3c9a19$var$readSingleQuotedScalar(state, flowIndent) || $560639d49e3c9a19$var$readDoubleQuotedScalar(state, flowIndent))
          hasContent = true;
        else if ($560639d49e3c9a19$var$readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null)
            $560639d49e3c9a19$var$throwError(state, "alias node should not have any properties");
        } else if ($560639d49e3c9a19$var$readPlainScalar(state, flowIndent, $560639d49e3c9a19$var$CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null)
            state.tag = "?";
        }
        if (state.anchor !== null)
          state.anchorMap[state.anchor] = state.result;
      }
    } else if (indentStatus === 0)
      hasContent = allowBlockCollections && $560639d49e3c9a19$var$readBlockSequence(state, blockIndent);
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      if (state.result !== null && state.kind !== "scalar")
        $560639d49e3c9a19$var$throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) {
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null)
            state.anchorMap[state.anchor] = state.result;
          break;
        }
      }
    } else if ($560639d49e3c9a19$var$_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type.kind !== state.kind)
        $560639d49e3c9a19$var$throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      if (!type.resolve(state.result))
        $560639d49e3c9a19$var$throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
      else {
        state.result = type.construct(state.result);
        if (state.anchor !== null)
          state.anchorMap[state.anchor] = state.result;
      }
    } else
      $560639d49e3c9a19$var$throwError(state, "unknown tag !<" + state.tag + ">");
  }
  if (state.listener !== null)
    state.listener("close", state);
  return state.tag !== null || state.anchor !== null || hasContent;
}
function $560639d49e3c9a19$var$readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37)
      break;
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch))
      ch = state.input.charCodeAt(++state.position);
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1)
      $560639d49e3c9a19$var$throwError(state, "directive name must not be less than one character in length");
    while (ch !== 0) {
      while ($560639d49e3c9a19$var$is_WHITE_SPACE(ch))
        ch = state.input.charCodeAt(++state.position);
      if (ch === 35) {
        do
          ch = state.input.charCodeAt(++state.position);
        while (ch !== 0 && !$560639d49e3c9a19$var$is_EOL(ch));
        break;
      }
      if ($560639d49e3c9a19$var$is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !$560639d49e3c9a19$var$is_WS_OR_EOL(ch))
        ch = state.input.charCodeAt(++state.position);
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      $560639d49e3c9a19$var$readLineBreak(state);
    if ($560639d49e3c9a19$var$_hasOwnProperty$1.call($560639d49e3c9a19$var$directiveHandlers, directiveName))
      $560639d49e3c9a19$var$directiveHandlers[directiveName](state, directiveName, directiveArgs);
    else
      $560639d49e3c9a19$var$throwWarning(state, 'unknown document directive "' + directiveName + '"');
  }
  $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
  } else if (hasDirectives)
    $560639d49e3c9a19$var$throwError(state, "directives end mark is expected");
  $560639d49e3c9a19$var$composeNode(state, state.lineIndent - 1, $560639d49e3c9a19$var$CONTEXT_BLOCK_OUT, false, true);
  $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && $560639d49e3c9a19$var$PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position)))
    $560639d49e3c9a19$var$throwWarning(state, "non-ASCII line breaks are interpreted as content");
  state.documents.push(state.result);
  if (state.position === state.lineStart && $560639d49e3c9a19$var$testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      $560639d49e3c9a19$var$skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1)
    $560639d49e3c9a19$var$throwError(state, "end of the stream or a document separator is expected");
  else
    return;
}
function $560639d49e3c9a19$var$loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13)
      input += "\n";
    if (input.charCodeAt(0) === 65279)
      input = input.slice(1);
  }
  var state = new $560639d49e3c9a19$var$State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    $560639d49e3c9a19$var$throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1)
    $560639d49e3c9a19$var$readDocument(state);
  return state.documents;
}
function $560639d49e3c9a19$var$loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = $560639d49e3c9a19$var$loadDocuments(input, options);
  if (typeof iterator !== "function")
    return documents;
  for (var index = 0, length = documents.length; index < length; index += 1)
    iterator(documents[index]);
}
function $560639d49e3c9a19$var$load$1(input, options) {
  var documents = $560639d49e3c9a19$var$loadDocuments(input, options);
  if (documents.length === 0)
    return void 0;
  else if (documents.length === 1)
    return documents[0];
  throw new $560639d49e3c9a19$var$exception("expected a single document in the stream, but found more");
}
function $560639d49e3c9a19$var$safeLoadAll$1(input, iterator, options) {
  if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  return $560639d49e3c9a19$var$loadAll$1(input, iterator, $560639d49e3c9a19$var$common.extend({
    schema: $560639d49e3c9a19$var$default_safe
  }, options));
}
function $560639d49e3c9a19$var$safeLoad$1(input, options) {
  return $560639d49e3c9a19$var$load$1(input, $560639d49e3c9a19$var$common.extend({
    schema: $560639d49e3c9a19$var$default_safe
  }, options));
}
var $560639d49e3c9a19$var$loadAll_1 = $560639d49e3c9a19$var$loadAll$1;
var $560639d49e3c9a19$var$load_1 = $560639d49e3c9a19$var$load$1;
var $560639d49e3c9a19$var$safeLoadAll_1 = $560639d49e3c9a19$var$safeLoadAll$1;
var $560639d49e3c9a19$var$safeLoad_1 = $560639d49e3c9a19$var$safeLoad$1;
var $560639d49e3c9a19$var$loader = {
  loadAll: $560639d49e3c9a19$var$loadAll_1,
  load: $560639d49e3c9a19$var$load_1,
  safeLoadAll: $560639d49e3c9a19$var$safeLoadAll_1,
  safeLoad: $560639d49e3c9a19$var$safeLoad_1
};
var $560639d49e3c9a19$var$_toString = Object.prototype.toString;
var $560639d49e3c9a19$var$_hasOwnProperty = Object.prototype.hasOwnProperty;
var $560639d49e3c9a19$var$CHAR_TAB = 9;
var $560639d49e3c9a19$var$CHAR_LINE_FEED = 10;
var $560639d49e3c9a19$var$CHAR_CARRIAGE_RETURN = 13;
var $560639d49e3c9a19$var$CHAR_SPACE = 32;
var $560639d49e3c9a19$var$CHAR_EXCLAMATION = 33;
var $560639d49e3c9a19$var$CHAR_DOUBLE_QUOTE = 34;
var $560639d49e3c9a19$var$CHAR_SHARP = 35;
var $560639d49e3c9a19$var$CHAR_PERCENT = 37;
var $560639d49e3c9a19$var$CHAR_AMPERSAND = 38;
var $560639d49e3c9a19$var$CHAR_SINGLE_QUOTE = 39;
var $560639d49e3c9a19$var$CHAR_ASTERISK = 42;
var $560639d49e3c9a19$var$CHAR_COMMA = 44;
var $560639d49e3c9a19$var$CHAR_MINUS = 45;
var $560639d49e3c9a19$var$CHAR_COLON = 58;
var $560639d49e3c9a19$var$CHAR_EQUALS = 61;
var $560639d49e3c9a19$var$CHAR_GREATER_THAN = 62;
var $560639d49e3c9a19$var$CHAR_QUESTION = 63;
var $560639d49e3c9a19$var$CHAR_COMMERCIAL_AT = 64;
var $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET = 91;
var $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET = 93;
var $560639d49e3c9a19$var$CHAR_GRAVE_ACCENT = 96;
var $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET = 123;
var $560639d49e3c9a19$var$CHAR_VERTICAL_LINE = 124;
var $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET = 125;
var $560639d49e3c9a19$var$ESCAPE_SEQUENCES = {};
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[0] = "\\0";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[7] = "\\a";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[8] = "\\b";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[9] = "\\t";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[10] = "\\n";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[11] = "\\v";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[12] = "\\f";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[13] = "\\r";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[27] = "\\e";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[34] = '\\"';
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[92] = "\\\\";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[133] = "\\N";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[160] = "\\_";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[8232] = "\\L";
$560639d49e3c9a19$var$ESCAPE_SEQUENCES[8233] = "\\P";
var $560639d49e3c9a19$var$DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function $560639d49e3c9a19$var$compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;
  if (map === null)
    return {};
  result = {};
  keys = Object.keys(map);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);
    if (tag.slice(0, 2) === "!!")
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    type = schema.compiledTypeMap["fallback"][tag];
    if (type && $560639d49e3c9a19$var$_hasOwnProperty.call(type.styleAliases, style))
      style = type.styleAliases[style];
    result[tag] = style;
  }
  return result;
}
function $560639d49e3c9a19$var$encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else
    throw new $560639d49e3c9a19$var$exception("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + handle + $560639d49e3c9a19$var$common.repeat("0", length - string.length) + string;
}
function $560639d49e3c9a19$var$State(options) {
  this.schema = options["schema"] || $560639d49e3c9a19$var$default_full;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = $560639d49e3c9a19$var$common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = $560639d49e3c9a19$var$compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function $560639d49e3c9a19$var$indentString(string, spaces) {
  var ind = $560639d49e3c9a19$var$common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function $560639d49e3c9a19$var$generateNextLine(state, level) {
  return "\n" + $560639d49e3c9a19$var$common.repeat(" ", state.indent * level);
}
function $560639d49e3c9a19$var$testImplicitResolving(state, str) {
  var index, length, type;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];
    if (type.resolve(str))
      return true;
  }
  return false;
}
function $560639d49e3c9a19$var$isWhitespace(c) {
  return c === $560639d49e3c9a19$var$CHAR_SPACE || c === $560639d49e3c9a19$var$CHAR_TAB;
}
function $560639d49e3c9a19$var$isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
}
function $560639d49e3c9a19$var$isNsChar(c) {
  return $560639d49e3c9a19$var$isPrintable(c) && !$560639d49e3c9a19$var$isWhitespace(c) && c !== 65279 && c !== $560639d49e3c9a19$var$CHAR_CARRIAGE_RETURN && c !== $560639d49e3c9a19$var$CHAR_LINE_FEED;
}
function $560639d49e3c9a19$var$isPlainSafe(c, prev) {
  return $560639d49e3c9a19$var$isPrintable(c) && c !== 65279 && c !== $560639d49e3c9a19$var$CHAR_COMMA && c !== $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_COLON && (c !== $560639d49e3c9a19$var$CHAR_SHARP || prev && $560639d49e3c9a19$var$isNsChar(prev));
}
function $560639d49e3c9a19$var$isPlainSafeFirst(c) {
  return $560639d49e3c9a19$var$isPrintable(c) && c !== 65279 && !$560639d49e3c9a19$var$isWhitespace(c) && c !== $560639d49e3c9a19$var$CHAR_MINUS && c !== $560639d49e3c9a19$var$CHAR_QUESTION && c !== $560639d49e3c9a19$var$CHAR_COLON && c !== $560639d49e3c9a19$var$CHAR_COMMA && c !== $560639d49e3c9a19$var$CHAR_LEFT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_SQUARE_BRACKET && c !== $560639d49e3c9a19$var$CHAR_LEFT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_RIGHT_CURLY_BRACKET && c !== $560639d49e3c9a19$var$CHAR_SHARP && c !== $560639d49e3c9a19$var$CHAR_AMPERSAND && c !== $560639d49e3c9a19$var$CHAR_ASTERISK && c !== $560639d49e3c9a19$var$CHAR_EXCLAMATION && c !== $560639d49e3c9a19$var$CHAR_VERTICAL_LINE && c !== $560639d49e3c9a19$var$CHAR_EQUALS && c !== $560639d49e3c9a19$var$CHAR_GREATER_THAN && c !== $560639d49e3c9a19$var$CHAR_SINGLE_QUOTE && c !== $560639d49e3c9a19$var$CHAR_DOUBLE_QUOTE && c !== $560639d49e3c9a19$var$CHAR_PERCENT && c !== $560639d49e3c9a19$var$CHAR_COMMERCIAL_AT && c !== $560639d49e3c9a19$var$CHAR_GRAVE_ACCENT;
}
function $560639d49e3c9a19$var$needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var $560639d49e3c9a19$var$STYLE_PLAIN = 1, $560639d49e3c9a19$var$STYLE_SINGLE = 2, $560639d49e3c9a19$var$STYLE_LITERAL = 3, $560639d49e3c9a19$var$STYLE_FOLDED = 4, $560639d49e3c9a19$var$STYLE_DOUBLE = 5;
function $560639d49e3c9a19$var$chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char, prev_char;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = $560639d49e3c9a19$var$isPlainSafeFirst(string.charCodeAt(0)) && !$560639d49e3c9a19$var$isWhitespace(string.charCodeAt(string.length - 1));
  if (singleLineOnly)
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!$560639d49e3c9a19$var$isPrintable(char))
        return $560639d49e3c9a19$var$STYLE_DOUBLE;
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && $560639d49e3c9a19$var$isPlainSafe(char, prev_char);
    }
  else {
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === $560639d49e3c9a19$var$CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!$560639d49e3c9a19$var$isPrintable(char))
        return $560639d49e3c9a19$var$STYLE_DOUBLE;
      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
      plain = plain && $560639d49e3c9a19$var$isPlainSafe(char, prev_char);
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
  }
  if (!hasLineBreak && !hasFoldableLine)
    return plain && !testAmbiguousType(string) ? $560639d49e3c9a19$var$STYLE_PLAIN : $560639d49e3c9a19$var$STYLE_SINGLE;
  if (indentPerLevel > 9 && $560639d49e3c9a19$var$needIndentIndicator(string))
    return $560639d49e3c9a19$var$STYLE_DOUBLE;
  return hasFoldableLine ? $560639d49e3c9a19$var$STYLE_FOLDED : $560639d49e3c9a19$var$STYLE_LITERAL;
}
function $560639d49e3c9a19$var$writeScalar(state, string, level, iskey) {
  state.dump = function() {
    if (string.length === 0)
      return "''";
    if (!state.noCompatMode && $560639d49e3c9a19$var$DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1)
      return "'" + string + "'";
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return $560639d49e3c9a19$var$testImplicitResolving(state, string2);
    }
    switch ($560639d49e3c9a19$var$chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case $560639d49e3c9a19$var$STYLE_PLAIN:
        return string;
      case $560639d49e3c9a19$var$STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case $560639d49e3c9a19$var$STYLE_LITERAL:
        return "|" + $560639d49e3c9a19$var$blockHeader(string, state.indent) + $560639d49e3c9a19$var$dropEndingNewline($560639d49e3c9a19$var$indentString(string, indent));
      case $560639d49e3c9a19$var$STYLE_FOLDED:
        return ">" + $560639d49e3c9a19$var$blockHeader(string, state.indent) + $560639d49e3c9a19$var$dropEndingNewline($560639d49e3c9a19$var$indentString($560639d49e3c9a19$var$foldString(string, lineWidth), indent));
      case $560639d49e3c9a19$var$STYLE_DOUBLE:
        return '"' + $560639d49e3c9a19$var$escapeString(string) + '"';
      default:
        throw new $560639d49e3c9a19$var$exception("impossible error: invalid scalar style");
    }
  }();
}
function $560639d49e3c9a19$var$blockHeader(string, indentPerLevel) {
  var indentIndicator = $560639d49e3c9a19$var$needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function $560639d49e3c9a19$var$dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function $560639d49e3c9a19$var$foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return $560639d49e3c9a19$var$foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + $560639d49e3c9a19$var$foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function $560639d49e3c9a19$var$foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start)
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  else
    result += line.slice(start);
  return result.slice(1);
}
function $560639d49e3c9a19$var$escapeString(string) {
  var result = "";
  var char, nextChar;
  var escapeSeq;
  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    if (char >= 55296 && char <= 56319) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 56320 && nextChar <= 57343) {
        result += $560639d49e3c9a19$var$encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
        i++;
        continue;
      }
    }
    escapeSeq = $560639d49e3c9a19$var$ESCAPE_SEQUENCES[char];
    result += !escapeSeq && $560639d49e3c9a19$var$isPrintable(char) ? string[i] : escapeSeq || $560639d49e3c9a19$var$encodeHex(char);
  }
  return result;
}
function $560639d49e3c9a19$var$writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    if ($560639d49e3c9a19$var$writeNode(state, level, object[index], false, false)) {
      if (index !== 0)
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function $560639d49e3c9a19$var$writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length;
  for (index = 0, length = object.length; index < length; index += 1)
    if ($560639d49e3c9a19$var$writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0)
        _result += $560639d49e3c9a19$var$generateNextLine(state, level);
      if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0))
        _result += "-";
      else
        _result += "- ";
      _result += state.dump;
    }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function $560639d49e3c9a19$var$writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (index !== 0)
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (!$560639d49e3c9a19$var$writeNode(state, level, objectKey, false, false))
      continue;
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!$560639d49e3c9a19$var$writeNode(state, level, objectValue, false, false))
      continue;
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function $560639d49e3c9a19$var$writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true)
    objectKeyList.sort();
  else if (typeof state.sortKeys === "function")
    objectKeyList.sort(state.sortKeys);
  else if (state.sortKeys)
    throw new $560639d49e3c9a19$var$exception("sortKeys must be a boolean or a function");
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || index !== 0)
      pairBuffer += $560639d49e3c9a19$var$generateNextLine(state, level);
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (!$560639d49e3c9a19$var$writeNode(state, level + 1, objectKey, true, true, true))
      continue;
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0))
        pairBuffer += "?";
      else
        pairBuffer += "? ";
    }
    pairBuffer += state.dump;
    if (explicitPair)
      pairBuffer += $560639d49e3c9a19$var$generateNextLine(state, level);
    if (!$560639d49e3c9a19$var$writeNode(state, level + 1, objectValue, true, explicitPair))
      continue;
    if (state.dump && $560639d49e3c9a19$var$CHAR_LINE_FEED === state.dump.charCodeAt(0))
      pairBuffer += ":";
    else
      pairBuffer += ": ";
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function $560639d49e3c9a19$var$detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];
    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
      state.tag = explicit ? type.tag : "?";
      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;
        if ($560639d49e3c9a19$var$_toString.call(type.represent) === "[object Function]")
          _result = type.represent(object, style);
        else if ($560639d49e3c9a19$var$_hasOwnProperty.call(type.represent, style))
          _result = type.represent[style](object, style);
        else
          throw new $560639d49e3c9a19$var$exception("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function $560639d49e3c9a19$var$writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;
  if (!$560639d49e3c9a19$var$detectType(state, object, false))
    $560639d49e3c9a19$var$detectType(state, object, true);
  var type = $560639d49e3c9a19$var$_toString.call(state.dump);
  if (block)
    block = state.flowLevel < 0 || state.flowLevel > level;
  var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0)
    compact = false;
  if (duplicate && state.usedDuplicates[duplicateIndex])
    state.dump = "*ref_" + duplicateIndex;
  else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex])
      state.usedDuplicates[duplicateIndex] = true;
    if (type === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        $560639d49e3c9a19$var$writeBlockMapping(state, level, state.dump, compact);
        if (duplicate)
          state.dump = "&ref_" + duplicateIndex + state.dump;
      } else {
        $560639d49e3c9a19$var$writeFlowMapping(state, level, state.dump);
        if (duplicate)
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
      }
    } else if (type === "[object Array]") {
      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
      if (block && state.dump.length !== 0) {
        $560639d49e3c9a19$var$writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate)
          state.dump = "&ref_" + duplicateIndex + state.dump;
      } else {
        $560639d49e3c9a19$var$writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate)
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
      }
    } else if (type === "[object String]") {
      if (state.tag !== "?")
        $560639d49e3c9a19$var$writeScalar(state, state.dump, level, iskey);
    } else {
      if (state.skipInvalid)
        return false;
      throw new $560639d49e3c9a19$var$exception("unacceptable kind of an object to dump " + type);
    }
    if (state.tag !== null && state.tag !== "?")
      state.dump = "!<" + state.tag + "> " + state.dump;
  }
  return true;
}
function $560639d49e3c9a19$var$getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  $560639d49e3c9a19$var$inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1)
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  state.usedDuplicates = new Array(length);
}
function $560639d49e3c9a19$var$inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1)
        duplicatesIndexes.push(index);
    } else {
      objects.push(object);
      if (Array.isArray(object))
        for (index = 0, length = object.length; index < length; index += 1)
          $560639d49e3c9a19$var$inspectNode(object[index], objects, duplicatesIndexes);
      else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1)
          $560639d49e3c9a19$var$inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
      }
    }
  }
}
function $560639d49e3c9a19$var$dump$1(input, options) {
  options = options || {};
  var state = new $560639d49e3c9a19$var$State(options);
  if (!state.noRefs)
    $560639d49e3c9a19$var$getDuplicateReferences(input, state);
  if ($560639d49e3c9a19$var$writeNode(state, 0, input, true, true))
    return state.dump + "\n";
  return "";
}
function $560639d49e3c9a19$var$safeDump$1(input, options) {
  return $560639d49e3c9a19$var$dump$1(input, $560639d49e3c9a19$var$common.extend({
    schema: $560639d49e3c9a19$var$default_safe
  }, options));
}
var $560639d49e3c9a19$var$dump_1 = $560639d49e3c9a19$var$dump$1;
var $560639d49e3c9a19$var$safeDump_1 = $560639d49e3c9a19$var$safeDump$1;
var $560639d49e3c9a19$var$dumper = {
  dump: $560639d49e3c9a19$var$dump_1,
  safeDump: $560639d49e3c9a19$var$safeDump_1
};
function $560639d49e3c9a19$var$deprecated(name) {
  return function() {
    throw new Error("Function " + name + " is deprecated and cannot be used.");
  };
}
var $560639d49e3c9a19$var$Type = $560639d49e3c9a19$var$type;
var $560639d49e3c9a19$var$Schema = $560639d49e3c9a19$var$schema;
var $560639d49e3c9a19$var$FAILSAFE_SCHEMA = $560639d49e3c9a19$var$failsafe;
var $560639d49e3c9a19$var$JSON_SCHEMA = $560639d49e3c9a19$var$json;
var $560639d49e3c9a19$var$CORE_SCHEMA = $560639d49e3c9a19$var$core;
var $560639d49e3c9a19$var$DEFAULT_SAFE_SCHEMA = $560639d49e3c9a19$var$default_safe;
var $560639d49e3c9a19$var$DEFAULT_FULL_SCHEMA = $560639d49e3c9a19$var$default_full;
var $560639d49e3c9a19$var$load = $560639d49e3c9a19$var$loader.load;
var $560639d49e3c9a19$var$loadAll = $560639d49e3c9a19$var$loader.loadAll;
var $560639d49e3c9a19$var$safeLoad = $560639d49e3c9a19$var$loader.safeLoad;
var $560639d49e3c9a19$var$safeLoadAll = $560639d49e3c9a19$var$loader.safeLoadAll;
var $560639d49e3c9a19$var$dump = $560639d49e3c9a19$var$dumper.dump;
var $560639d49e3c9a19$var$safeDump = $560639d49e3c9a19$var$dumper.safeDump;
var $560639d49e3c9a19$var$YAMLException = $560639d49e3c9a19$var$exception;
var $560639d49e3c9a19$var$MINIMAL_SCHEMA = $560639d49e3c9a19$var$failsafe;
var $560639d49e3c9a19$var$SAFE_SCHEMA = $560639d49e3c9a19$var$default_safe;
var $560639d49e3c9a19$var$DEFAULT_SCHEMA = $560639d49e3c9a19$var$default_full;
var $560639d49e3c9a19$var$scan = $560639d49e3c9a19$var$deprecated("scan");
var $560639d49e3c9a19$var$parse = $560639d49e3c9a19$var$deprecated("parse");
var $560639d49e3c9a19$var$compose = $560639d49e3c9a19$var$deprecated("compose");
var $560639d49e3c9a19$var$addConstructor = $560639d49e3c9a19$var$deprecated("addConstructor");
var $560639d49e3c9a19$var$jsYaml$1 = {
  Type: $560639d49e3c9a19$var$Type,
  Schema: $560639d49e3c9a19$var$Schema,
  FAILSAFE_SCHEMA: $560639d49e3c9a19$var$FAILSAFE_SCHEMA,
  JSON_SCHEMA: $560639d49e3c9a19$var$JSON_SCHEMA,
  CORE_SCHEMA: $560639d49e3c9a19$var$CORE_SCHEMA,
  DEFAULT_SAFE_SCHEMA: $560639d49e3c9a19$var$DEFAULT_SAFE_SCHEMA,
  DEFAULT_FULL_SCHEMA: $560639d49e3c9a19$var$DEFAULT_FULL_SCHEMA,
  load: $560639d49e3c9a19$var$load,
  loadAll: $560639d49e3c9a19$var$loadAll,
  safeLoad: $560639d49e3c9a19$var$safeLoad,
  safeLoadAll: $560639d49e3c9a19$var$safeLoadAll,
  dump: $560639d49e3c9a19$var$dump,
  safeDump: $560639d49e3c9a19$var$safeDump,
  YAMLException: $560639d49e3c9a19$var$YAMLException,
  MINIMAL_SCHEMA: $560639d49e3c9a19$var$MINIMAL_SCHEMA,
  SAFE_SCHEMA: $560639d49e3c9a19$var$SAFE_SCHEMA,
  DEFAULT_SCHEMA: $560639d49e3c9a19$var$DEFAULT_SCHEMA,
  scan: $560639d49e3c9a19$var$scan,
  parse: $560639d49e3c9a19$var$parse,
  compose: $560639d49e3c9a19$var$compose,
  addConstructor: $560639d49e3c9a19$var$addConstructor
};
var $560639d49e3c9a19$var$jsYaml = $560639d49e3c9a19$var$jsYaml$1;
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var $560639d49e3c9a19$var$matchHtmlRegExp = /["'&<>]/;
var $560639d49e3c9a19$var$escapeHtml_1 = $560639d49e3c9a19$var$escapeHtml;
function $560639d49e3c9a19$var$escapeHtml(string) {
  var str = "" + string;
  var match = $560639d49e3c9a19$var$matchHtmlRegExp.exec(str);
  if (!match)
    return str;
  var escape;
  var html = "";
  var index = 0;
  var lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#39;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index)
      html += str.substring(lastIndex, index);
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
function $560639d49e3c9a19$var$_optionalChain(ops) {
  let lastAccessLHS = void 0;
  let value = ops[0];
  let i = 1;
  while (i < ops.length) {
    const op = ops[i];
    const fn = ops[i + 1];
    i += 2;
    if ((op === "optionalAccess" || op === "optionalCall") && value == null)
      return void 0;
    if (op === "access" || op === "optionalAccess") {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === "call" || op === "optionalCall") {
      value = fn((...args) => value.call(lastAccessLHS, ...args));
      lastAccessLHS = void 0;
    }
  }
  return value;
}
const $560639d49e3c9a19$var$newline = "\n";
function $560639d49e3c9a19$var$default_frontmatter(value, messages) {
  try {
    return $560639d49e3c9a19$var$jsYaml.safeLoad(value);
  } catch (e) {
    messages.push(new $560639d49e3c9a19$var$vfileMessage("YAML failed to parse"));
  }
}
function $560639d49e3c9a19$var$parse_frontmatter({ parse, type }) {
  const transformer = (tree, vFile) => {
    $560639d49e3c9a19$var$unistUtilVisit(tree, type, (node) => {
      const data = parse(node.value, vFile.messages);
      if (data)
        vFile.data.fm = data;
    });
  };
  return transformer;
}
const $560639d49e3c9a19$var$entites = [
  [
    /</g,
    "&lt;"
  ],
  [
    />/g,
    "&gt;"
  ],
  [
    /{/g,
    "&#123;"
  ],
  [
    /}/g,
    "&#125;"
  ]
];
function $560639d49e3c9a19$var$escape_code({ blocks }) {
  return function(tree) {
    if (!blocks)
      $560639d49e3c9a19$var$unistUtilVisit(tree, "code", escape);
    $560639d49e3c9a19$var$unistUtilVisit(tree, "inlineCode", escape);
    function escape(node) {
      for (let i = 0; i < $560639d49e3c9a19$var$entites.length; i += 1)
        node.value = node.value.replace($560639d49e3c9a19$var$entites[i][0], $560639d49e3c9a19$var$entites[i][1]);
    }
  };
}
function $560639d49e3c9a19$var$smartypants_transformer(options = {}) {
  const processor = $560639d49e3c9a19$var$retext().use($560639d49e3c9a19$var$retextSmartypants, options);
  return function(tree) {
    $560639d49e3c9a19$var$unistUtilVisit(tree, "text", (node) => {
      node.value = String(processor.processSync(node.value));
    });
  };
}
const $560639d49e3c9a19$var$attrs = `(?:\\s{0,1}[a-zA-z]+=(?:"){0,1}[a-zA-Z0-9]+(?:"){0,1})*`;
const $560639d49e3c9a19$var$context = `(?:\\s{0,1}context)=(?:"){0,1}module(?:"){0,1}`;
const $560639d49e3c9a19$var$RE_BLANK = /^\n+$|^\s+$/;
const $560639d49e3c9a19$var$RE_SCRIPT = new RegExp(`^(<script` + $560639d49e3c9a19$var$attrs + `>)`);
const $560639d49e3c9a19$var$RE_MODULE_SCRIPT = new RegExp(`^(<script` + $560639d49e3c9a19$var$attrs + $560639d49e3c9a19$var$context + $560639d49e3c9a19$var$attrs + `>)`);
function $560639d49e3c9a19$var$extract_parts(nodes) {
  const parts = {
    special: [],
    html: [],
    instance: [],
    module: [],
    css: []
  };
  children:
    for (let i = 0; i < nodes.length; i += 1) {
      const empty_node = nodes[i].type === "text" && $560639d49e3c9a19$var$RE_BLANK.exec(nodes[i].value);
      if (empty_node || !nodes[i].value) {
        if (!parts.html.length || !($560639d49e3c9a19$var$RE_BLANK.exec(nodes[i].value) && $560639d49e3c9a19$var$RE_BLANK.exec(parts.html[parts.html.length - 1].value)))
          parts.html.push(nodes[i]);
        continue children;
      }
      let result;
      try {
        result = (0, $49260c17099cae5e$exports.parse)(nodes[i].value);
      } catch (e) {
        parts.html.push(nodes[i]);
        continue children;
      }
      if (!result.html || !result.html.children)
        return parts;
      const _parts = result.html.children.map((v) => {
        if (v.type === "Options" || v.type === "Head" || v.type === "Window" || v.type === "Body")
          return [
            "special",
            v.start,
            v.end
          ];
        else
          return [
            "html",
            v.start,
            v.end
          ];
      });
      results:
        for (const key in result) {
          if (key === "html" || !result[key])
            continue results;
          _parts.push([
            key,
            result[key].start,
            result[key].end
          ]);
        }
      const sorted = _parts.sort((a, b) => a[1] - b[1]);
      sorted.forEach((next) => {
        parts[next[0]].push({
          type: "raw",
          value: nodes[i].value.substring(next[1], next[2])
        });
      });
    }
  return parts;
}
function $560639d49e3c9a19$var$map_layout_to_path(filename, layout_map) {
  const match = Object.keys(layout_map).find((l) => new RegExp(`\\${$4S4dR$sep}${l}\\${$4S4dR$sep}`).test($4S4dR$normalize(filename).replace(process.cwd(), "")));
  if (match)
    return layout_map[match];
  else
    return layout_map["_"] ? layout_map["_"] : void 0;
}
function $560639d49e3c9a19$var$generate_layout_import(layout) {
  if (!layout)
    return false;
  return `import Layout_MDSVEX_DEFAULT${layout.components.length ? `, * as Components` : ""} from '${layout.path}';`;
}
function $560639d49e3c9a19$var$generate_layout({ frontmatter_layout, layout_options, layout_mode, filename }) {
  let selected_layout;
  const error = {
    reason: ""
  };
  if (!layout_options || frontmatter_layout === false)
    return [
      false,
      false,
      false
    ];
  else if (layout_mode === "single") {
    selected_layout = layout_options.__mdsvex_default;
    if (frontmatter_layout)
      error.reason = `You attempted to apply a named layout in the front-matter of "${filename}", but did not provide any named layouts as options to the preprocessor. `;
  } else if (frontmatter_layout) {
    selected_layout = layout_options[frontmatter_layout];
    if (!selected_layout)
      error.reason = `Could not find a layout with the name "${frontmatter_layout}" and no fall back layout ("_") was provided.`;
  } else
    selected_layout = $560639d49e3c9a19$var$map_layout_to_path(filename, layout_options);
  return [
    $560639d49e3c9a19$var$generate_layout_import(selected_layout),
    selected_layout !== void 0 && selected_layout.components.length > 0 && selected_layout.components,
    error.reason ? error : false
  ];
}
function $560639d49e3c9a19$var$transform_hast({ layout, layout_mode }) {
  return function transformer(tree, vFile) {
    $560639d49e3c9a19$var$unistUtilVisit(tree, "element", (node) => {
      if (node.tagName === "a" && node.properties && typeof node.properties.href === "string")
        node.properties.href = node.properties.href.replace(/%7B/g, "{").replace(/%7D/g, "}");
      if (node.tagName === "img" && node.properties && typeof node.properties.src === "string")
        node.properties.src = node.properties.src.replace(/%7B/g, "{").replace(/%7D/g, "}");
    });
    if (!layout && !vFile.data.fm)
      return tree;
    $560639d49e3c9a19$var$unistUtilVisit(tree, "root", (node) => {
      const { special, html, instance, module: _module, css } = $560639d49e3c9a19$var$extract_parts(node.children);
      const { fm: metadata } = vFile.data;
      const stringified = metadata && JSON.stringify(metadata).replace(/<(\/?script|\/?style)/g, '<"+"$1');
      const fm = metadata && `export const metadata = ${stringified};${$560639d49e3c9a19$var$newline}	const { ${Object.keys(metadata).join(", ")} } = metadata;`;
      const frontmatter_layout = metadata && metadata.layout;
      const [import_script, components, error] = $560639d49e3c9a19$var$generate_layout({
        frontmatter_layout,
        layout_options: layout,
        layout_mode,
        //@ts-ignore
        filename: vFile.filename
      });
      if (error)
        vFile.messages.push(new $560639d49e3c9a19$var$vfileMessage(error.reason));
      if (components)
        for (let i = 0; i < components.length; i++)
          $560639d49e3c9a19$var$unistUtilVisit(tree, "element", (node2) => {
            if (node2.tagName === components[i])
              node2.tagName = `Components.${components[i]}`;
          });
      if (import_script && !instance[0])
        instance.push({
          type: "raw",
          value: `${$560639d49e3c9a19$var$newline}<script>${$560639d49e3c9a19$var$newline}	${import_script}${$560639d49e3c9a19$var$newline}<\/script>${$560639d49e3c9a19$var$newline}`
        });
      else if (import_script)
        instance[0].value = instance[0].value.replace($560639d49e3c9a19$var$RE_SCRIPT, `$1${$560639d49e3c9a19$var$newline}	${import_script}`);
      if (!_module[0] && fm)
        _module.push({
          type: "raw",
          value: `<script context="module">${$560639d49e3c9a19$var$newline}	${fm}${$560639d49e3c9a19$var$newline}<\/script>`
        });
      else if (fm)
        _module[0].value = _module[0].value.replace($560639d49e3c9a19$var$RE_MODULE_SCRIPT, `$1${$560639d49e3c9a19$var$newline}	${fm}`);
      node.children = [
        //@ts-ignore
        ..._module,
        //@ts-ignore
        {
          type: "raw",
          value: _module[0] ? $560639d49e3c9a19$var$newline : ""
        },
        //@ts-ignore
        ...instance,
        //@ts-ignore
        {
          type: "raw",
          value: instance[0] ? $560639d49e3c9a19$var$newline : ""
        },
        //@ts-ignore
        ...css,
        //@ts-ignore
        {
          type: "raw",
          value: css[0] ? $560639d49e3c9a19$var$newline : ""
        },
        //@ts-ignore
        ...special,
        //@ts-ignore
        {
          type: "raw",
          value: special[0] ? $560639d49e3c9a19$var$newline : ""
        },
        {
          //@ts-ignore
          type: "raw",
          value: import_script ? `<Layout_MDSVEX_DEFAULT {...$$props}${fm ? " {...metadata}" : ""}>` : ""
        },
        //@ts-ignore
        {
          type: "raw",
          value: $560639d49e3c9a19$var$newline
        },
        //@ts-ignore
        ...html,
        //@ts-ignore
        {
          type: "raw",
          value: $560639d49e3c9a19$var$newline
        },
        //@ts-ignore
        {
          type: "raw",
          value: import_script ? "</Layout_MDSVEX_DEFAULT>" : ""
        }
      ];
    });
  };
}
const $560639d49e3c9a19$var$langs = {};
let $560639d49e3c9a19$var$Prism;
const $560639d49e3c9a19$var$make_path = (base_path, id) => base_path.replace("{id}", id);
function $560639d49e3c9a19$var$get_lang_info(name, lang_meta, base_path) {
  const _lang_meta = {
    name,
    path: `prismjs/${$560639d49e3c9a19$var$make_path(base_path, name)}`,
    deps: /* @__PURE__ */ new Set()
  };
  const aliases = /* @__PURE__ */ new Set();
  if (lang_meta.require) {
    if (Array.isArray(lang_meta.require))
      lang_meta.require.forEach((id) => _lang_meta.deps.add(id));
    else
      _lang_meta.deps.add(lang_meta.require);
  }
  if (lang_meta.peerDependencies) {
    if (Array.isArray(lang_meta.peerDependencies))
      lang_meta.peerDependencies.forEach((id) => _lang_meta.deps.add(id));
    else
      _lang_meta.deps.add(lang_meta.peerDependencies);
  }
  if (lang_meta.alias) {
    if (Array.isArray(lang_meta.alias))
      lang_meta.alias.forEach((id) => aliases.add(id));
    else
      aliases.add(lang_meta.alias);
  }
  return [
    {
      ..._lang_meta,
      aliases
    },
    aliases
  ];
}
function $560639d49e3c9a19$var$load_language_metadata() {
  if (!process.browser) {
    const { meta, ...languages } = parcelRequire("4bc8D").languages;
    for (const lang in languages) {
      const [lang_info, aliases] = $560639d49e3c9a19$var$get_lang_info(lang, languages[lang], meta.path);
      $560639d49e3c9a19$var$langs[lang] = lang_info;
      aliases.forEach((_n) => {
        $560639d49e3c9a19$var$langs[_n] = $560639d49e3c9a19$var$langs[lang];
      });
    }
    const svelte_meta = {
      name: "svelte",
      aliases: /* @__PURE__ */ new Set([
        "sv"
      ]),
      path: "prism-svelte",
      deps: /* @__PURE__ */ new Set([
        "javscript",
        "css"
      ])
    };
    $560639d49e3c9a19$var$langs.svelte = svelte_meta;
    $560639d49e3c9a19$var$langs.sv = svelte_meta;
  }
}
function $560639d49e3c9a19$var$load_language(lang) {
  if (!process.browser) {
    if (!$560639d49e3c9a19$var$langs[lang])
      return;
    $560639d49e3c9a19$var$langs[lang].deps.forEach((name) => $560639d49e3c9a19$var$load_language(name));
    require($560639d49e3c9a19$var$langs[lang].path);
  }
}
function $560639d49e3c9a19$var$highlight_blocks({ highlighter: highlight_fn, alias } = {}) {
  if (highlight_fn && !process.browser) {
    $560639d49e3c9a19$var$load_language_metadata();
    if (alias)
      for (const lang in alias)
        $560639d49e3c9a19$var$langs[lang] = $560639d49e3c9a19$var$langs[alias[lang]];
  }
  return async function(tree) {
    if (highlight_fn) {
      const nodes = [];
      $560639d49e3c9a19$var$unistUtilVisit(tree, "code", (node) => {
        nodes.push(node);
      });
      await Promise.all(nodes.map(async (node) => {
        node.type = "html";
        node.value = await highlight_fn(node.value, node.lang, node.meta);
      }));
    }
  };
}
const $560639d49e3c9a19$export$92ff52ce4f9996ed = (str) => str.replace(
  /[{}`]/g,
  //@ts-ignore
  (c) => ({
    "{": "&#123;",
    "}": "&#125;",
    "`": "&#96;"
  })[c]
).replace(/\\([trn])/g, "&#92;$1");
const $560639d49e3c9a19$var$code_highlight = (code, lang) => {
  const normalised_lang = $560639d49e3c9a19$var$_optionalChain([
    lang,
    "optionalAccess",
    (_) => _.toLowerCase,
    "call",
    (_2) => _2()
  ]);
  if (!process.browser) {
    let _lang = !!normalised_lang && $560639d49e3c9a19$var$langs[normalised_lang];
    if (!$560639d49e3c9a19$var$Prism)
      $560639d49e3c9a19$var$Prism = parcelRequire("4wAom");
    if (_lang && !$560639d49e3c9a19$var$Prism.languages[_lang.name])
      $560639d49e3c9a19$var$load_language(_lang.name);
    if (!_lang && normalised_lang && $560639d49e3c9a19$var$Prism.languages[normalised_lang]) {
      $560639d49e3c9a19$var$langs[normalised_lang] = {
        name: lang
      };
      _lang = $560639d49e3c9a19$var$langs[normalised_lang];
    }
    const highlighted = $560639d49e3c9a19$export$92ff52ce4f9996ed(_lang ? $560639d49e3c9a19$var$Prism.highlight(code, $560639d49e3c9a19$var$Prism.languages[_lang.name], _lang.name) : $560639d49e3c9a19$var$escapeHtml_1(code));
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  } else {
    const highlighted = $560639d49e3c9a19$export$92ff52ce4f9996ed($560639d49e3c9a19$var$escapeHtml_1(code));
    return `<pre class="language-${normalised_lang}">{@html \`<code class="language-${normalised_lang}">${highlighted}</code>\`}</pre>`;
  }
};
function $560639d49e3c9a19$var$stringify(options = {}) {
  this.Compiler = compiler;
  function compiler(tree) {
    return $560639d49e3c9a19$var$prettyhtmlHastToHtml(tree, options);
  }
}
const $560639d49e3c9a19$var$apply_plugins = (plugins, parser) => {
  plugins.forEach((plugin) => {
    if (Array.isArray(plugin)) {
      if (plugin[1] && plugin[1])
        parser.use(plugin[0], plugin[1]);
      else
        parser.use(plugin[0]);
    } else
      parser.use(plugin);
  });
  return parser;
};
function $560639d49e3c9a19$var$transform({ remarkPlugins = [], rehypePlugins = [], frontmatter, smartypants, layout, layout_mode, highlight } = {
  layout_mode: "single"
}) {
  const fm_opts = frontmatter ? frontmatter : {
    parse: $560639d49e3c9a19$var$default_frontmatter,
    type: "yaml",
    marker: "-"
  };
  const toMDAST = $560639d49e3c9a19$var$unified_1$1().use($560639d49e3c9a19$var$remarkParse).use($560639d49e3c9a19$var$mdsvex_parser).use($560639d49e3c9a19$var$remarkExternalLinks, {
    target: false,
    rel: [
      "nofollow"
    ]
  }).use($560639d49e3c9a19$var$escape_code, {
    blocks: !!highlight
  }).use($560639d49e3c9a19$var$remarkFrontmatter, [
    {
      type: fm_opts.type,
      marker: fm_opts.marker
    }
  ]).use($560639d49e3c9a19$var$parse_frontmatter, {
    parse: fm_opts.parse,
    type: fm_opts.type
  });
  if (smartypants)
    toMDAST.use($560639d49e3c9a19$var$smartypants_transformer, typeof smartypants === "boolean" ? {} : smartypants);
  $560639d49e3c9a19$var$apply_plugins(remarkPlugins, toMDAST).use($560639d49e3c9a19$var$highlight_blocks, highlight || {});
  const toHAST = toMDAST.use($560639d49e3c9a19$var$remarkRehype, {
    // @ts-ignore
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  }).use($560639d49e3c9a19$var$transform_hast, {
    layout,
    layout_mode
  });
  $560639d49e3c9a19$var$apply_plugins(rehypePlugins, toHAST);
  const processor = toHAST.use($560639d49e3c9a19$var$stringify, {
    allowDangerousHtml: true,
    allowDangerousCharacters: true
  });
  return processor;
}
const $560639d49e3c9a19$var$defaults = {
  remarkPlugins: [],
  rehypePlugins: [],
  smartypants: true,
  extension: ".svx",
  highlight: {
    highlighter: $560639d49e3c9a19$var$code_highlight
  }
};
function $560639d49e3c9a19$var$to_posix(_path) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(_path);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(_path);
  if (isExtendedLengthPath || hasNonAscii)
    return _path;
  return _path.replace(/\\/g, "/");
}
function $560639d49e3c9a19$var$resolve_layout(layout_path) {
  try {
    return $560639d49e3c9a19$var$to_posix((void 0)(layout_path));
  } catch (e) {
    try {
      const _path = (0, $4S4dR$join)(process.cwd(), layout_path);
      return $560639d49e3c9a19$var$to_posix((void 0)(_path));
    } catch (e2) {
      throw new Error(`The layout path you provided couldn't be found at either ${layout_path} or ${$4S4dR$join(process.cwd(), layout_path)}. Please double-check it and try again.`);
    }
  }
}
function $560639d49e3c9a19$var$process_layouts(layouts) {
  const _layouts = layouts;
  for (const key in _layouts) {
    const layout = fs.readFileSync(_layouts[key].path, {
      encoding: "utf8"
    });
    let ast;
    try {
      ast = (0, $49260c17099cae5e$exports.parse)(layout);
    } catch (e) {
      throw new Error(e.toString() + `
	at ${_layouts[key].path}`);
    }
    if (ast.module) {
      const component_exports = ast.module.content.body.filter((node) => node.type === "ExportNamedDeclaration");
      if (component_exports.length) {
        _layouts[key].components = [];
        for (let i = 0; i < component_exports.length; i++) {
          if (component_exports[i].specifiers && component_exports[i].specifiers.length)
            for (let j = 0; j < component_exports[i].specifiers.length; j++)
              _layouts[key].components.push(component_exports[i].specifiers[j].exported.name);
          else if (component_exports[i].declaration.declarations) {
            const declarations = component_exports[i].declaration.declarations;
            for (let j = 0; j < declarations.length; j++)
              _layouts[key].components.push(declarations[j].id.name);
          } else if (component_exports[i].declaration)
            _layouts[key].components.push(
              //@ts-ignore
              component_exports[i].declaration.id.name
            );
        }
      }
    }
  }
  return _layouts;
}
const $560639d49e3c9a19$export$d61cf7a1924293cc = (options = $560639d49e3c9a19$var$defaults) => {
  const { remarkPlugins = [], rehypePlugins = [], smartypants = true, extension = ".svx", extensions, layout = false, highlight = {
    highlighter: $560639d49e3c9a19$var$code_highlight
  }, frontmatter } = options;
  if (options.layouts)
    throw new Error(`mdsvex: "layouts" is not a valid option. Did you mean "layout"?`);
  const unknown_opts = [];
  const known_opts = [
    "filename",
    "remarkPlugins",
    "rehypePlugins",
    "smartypants",
    "extension",
    "extensions",
    "layout",
    "highlight",
    "frontmatter"
  ];
  for (const opt in options)
    if (!known_opts.includes(opt))
      unknown_opts.push(opt);
  if (unknown_opts.length)
    console.warn(`mdsvex: Received unknown options: ${unknown_opts.join(", ")}. Valid options are: ${known_opts.join(", ")}.`);
  let _layout = {};
  let layout_mode = "single";
  if (typeof layout === "string")
    _layout.__mdsvex_default = {
      path: $560639d49e3c9a19$var$resolve_layout(layout),
      components: []
    };
  else if (typeof layout === "object") {
    layout_mode = "named";
    for (const name in layout)
      _layout[name] = {
        path: $560639d49e3c9a19$var$resolve_layout(layout[name]),
        components: []
      };
  }
  if (highlight && highlight.highlighter === void 0)
    highlight.highlighter = $560639d49e3c9a19$var$code_highlight;
  _layout = $560639d49e3c9a19$var$process_layouts(_layout);
  const parser = $560639d49e3c9a19$var$transform({
    remarkPlugins,
    rehypePlugins,
    smartypants,
    layout: _layout,
    layout_mode,
    highlight,
    frontmatter
  });
  return {
    markup: async ({ content, filename }) => {
      const extensionsParts = (extensions || [
        extension
      ]).map((ext) => ext.split(".").pop());
      if (!extensionsParts.includes(filename.split(".").pop()))
        return;
      const parsed = await parser.process({
        contents: content,
        filename
      });
      return {
        code: parsed.contents,
        data: parsed.data,
        map: ""
      };
    }
  };
};
var $365749e2073871b1$exports = {};
var $bc540824f1c98218$exports = {};
var $4wAom = parcelRequire("4wAom");
var $34b7c77508ea8b01$exports = {};
$34b7c77508ea8b01$exports = {
  // Case insensitive
  // If you are changing this, update the inlined version in api/status/[...route]/extractQueries.server.js
  supportedLangs: [
    "JavaScript",
    "HTML",
    "CSS",
    "SQL",
    "Python",
    "TypeScript",
    "Java",
    "Bash",
    "CSharp",
    "C++",
    "PHP",
    "C",
    "PowerShell",
    "Go",
    "Rust",
    "Kotlin",
    "Dart",
    "Ruby",
    "R",
    "MATLAB",
    "DAX",
    "JSON",
    "YAML",
    "Markdown",
    "Code",
    "Svelte",
    "Shell"
  ].map((r) => r.toLowerCase())
};
var $bc540824f1c98218$require$supportedLangs = $34b7c77508ea8b01$exports.supportedLangs;
const $bc540824f1c98218$var$getPrismLangs = function() {
  let prismLangs = /* @__PURE__ */ new Set();
  $bc540824f1c98218$require$supportedLangs.forEach((supportedLanguage) => {
    prismLangs.add(supportedLanguage);
    if (supportedLanguage in $4wAom.languages) {
      const languageComponent = $4wAom.languages[supportedLanguage];
      if (languageComponent.alias) {
        if (Array.isArray(languageComponent.alias))
          languageComponent.alias.forEach((a) => prismLangs.add(a));
        else
          prismLangs.add(languageComponent.alias);
      }
    }
  });
  return prismLangs;
};
$bc540824f1c98218$exports = $bc540824f1c98218$var$getPrismLangs;
function $365749e2073871b1$var$highlighter(code, lang, meta) {
  code = code.replace(/'/g, "&apos;");
  code = code.replace(/"/g, "&quot;");
  code = code.replace(/{/g, "&lbrace;").replace(/}/g, "&rbrace;");
  if (lang?.toLowerCase() === "sql" && meta || !$bc540824f1c98218$exports().has(lang?.toLowerCase() ?? "")) {
    const queryId = lang?.toLowerCase() === "sql" && meta ? meta : lang;
    return `
        {#if ${queryId} }
            <QueryViewer
                queryID = "${queryId ?? "untitled"}"
                queryResult = {${queryId ?? "untitled"}}
            /> 
        {/if}
        `;
  }
  return `<CodeBlock source="${code}" copyToClipboard=true />`;
}
$365749e2073871b1$exports = {
  highlighter: $365749e2073871b1$var$highlighter
};
var $3fd82c6737eb24ad$require$highlighter = $365749e2073871b1$exports.highlighter;
var $7d9f7d1f69c18b39$exports = {};
const $7d9f7d1f69c18b39$var$addScriptTags = {
  markup({ content, filename }) {
    if (filename.endsWith(".md")) {
      if (!content.match(/\<script(.*)\>/))
        return {
          code: '<script context="module"> <\/script><script> <\/script>' + content
        };
      if (!content.match(/\<script(.*)context\=\"module\"(.*)\>/))
        return {
          code: '<script context="module"> <\/script>' + content
        };
      if (!content.match(/\<script\>/))
        return {
          code: "<script> <\/script>" + content
        };
    }
  }
};
$7d9f7d1f69c18b39$exports = $7d9f7d1f69c18b39$var$addScriptTags;
var $bb8aaf4d81463a1b$exports = {};
var $8f0b7f8489fbb30d$exports = {};
var $0515c28000a54e5a$exports = {};
(function($) {
  function safeAdd(x, y) {
    var lsw = (x & 65535) + (y & 65535);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  function binlMD5(x, len) {
    x[len >> 5] |= 128 << len % 32;
    x[(len + 64 >>> 9 << 4) + 14] = len;
    var i;
    var olda;
    var oldb;
    var oldc;
    var oldd;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    for (i = 0; i < x.length; i += 16) {
      olda = a;
      oldb = b;
      oldc = c;
      oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return [
      a,
      b,
      c,
      d
    ];
  }
  function binl2rstr(input) {
    var i;
    var output = "";
    var length32 = input.length * 32;
    for (i = 0; i < length32; i += 8)
      output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
    return output;
  }
  function rstr2binl(input) {
    var i;
    var output = [];
    output[(input.length >> 2) - 1] = void 0;
    for (i = 0; i < output.length; i += 1)
      output[i] = 0;
    var length8 = input.length * 8;
    for (i = 0; i < length8; i += 8)
      output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
    return output;
  }
  function rstrMD5(s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
  }
  function rstrHMACMD5(key, data) {
    var i;
    var bkey = rstr2binl(key);
    var ipad = [];
    var opad = [];
    var hash;
    ipad[15] = opad[15] = void 0;
    if (bkey.length > 16)
      bkey = binlMD5(bkey, key.length * 8);
    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 909522486;
      opad[i] = bkey[i] ^ 1549556828;
    }
    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
    return binl2rstr(binlMD5(opad.concat(hash), 640));
  }
  function rstr2hex(input) {
    var hexTab = "0123456789abcdef";
    var output = "";
    var x;
    var i;
    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i);
      output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
    }
    return output;
  }
  function str2rstrUTF8(input) {
    return unescape(encodeURIComponent(input));
  }
  function rawMD5(s) {
    return rstrMD5(str2rstrUTF8(s));
  }
  function hexMD5(s) {
    return rstr2hex(rawMD5(s));
  }
  function rawHMACMD5(k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
  }
  function hexHMACMD5(k, d) {
    return rstr2hex(rawHMACMD5(k, d));
  }
  function md5(string, key, raw) {
    if (!key) {
      if (!raw)
        return hexMD5(string);
      return rawMD5(string);
    }
    if (!raw)
      return hexHMACMD5(key, string);
    return rawHMACMD5(key, string);
  }
  if (typeof define === "function" && define.amd)
    define(function() {
      return md5;
    });
  else if ($0515c28000a54e5a$exports)
    $0515c28000a54e5a$exports = md5;
  else
    $.md5 = md5;
})($0515c28000a54e5a$exports);
$8f0b7f8489fbb30d$exports = {
  /**
  * Generates a unique (but consistent) hash for a route
  * @param {string} filename
  * @example /src/pages/+page.md /src/pages/my-route/+page.md
  * @returns string
  */
  getRouteHash: (filename) => {
    const isIndex = filename.split("/src/pages")[1] === "/+page.md";
    if (isIndex)
      return $0515c28000a54e5a$exports("/");
    let route = filename.split("/src/pages")?.[1].replace(".md", "").replace(/\/\+page/g, "");
    if (!route)
      throw new Error(`Failed to generate route hash for ${filename} (${JSON.stringify({
        isIndex
      })})`);
    return $0515c28000a54e5a$exports(route);
  }
};
var $bb8aaf4d81463a1b$require$getRouteHash = $8f0b7f8489fbb30d$exports.getRouteHash;
var $3bc517d55346f2bb$exports = {};
var $7f6f6807a3a8644e$exports = {};
var $df3ba5e804f3b490$exports = {};
$df3ba5e804f3b490$exports = $df3ba5e804f3b490$var$bail;
function $df3ba5e804f3b490$var$bail(err) {
  if (err)
    throw err;
}
var $9POxA = parcelRequire("9POxA");
var $5f4474664cf1d724$exports = {};
var $5f4474664cf1d724$var$hasOwn = Object.prototype.hasOwnProperty;
var $5f4474664cf1d724$var$toStr = Object.prototype.toString;
var $5f4474664cf1d724$var$defineProperty = Object.defineProperty;
var $5f4474664cf1d724$var$gOPD = Object.getOwnPropertyDescriptor;
var $5f4474664cf1d724$var$isArray = function isArray2(arr) {
  if (typeof Array.isArray === "function")
    return Array.isArray(arr);
  return $5f4474664cf1d724$var$toStr.call(arr) === "[object Array]";
};
var $5f4474664cf1d724$var$isPlainObject = function isPlainObject2(obj) {
  if (!obj || $5f4474664cf1d724$var$toStr.call(obj) !== "[object Object]")
    return false;
  var hasOwnConstructor = $5f4474664cf1d724$var$hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && $5f4474664cf1d724$var$hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf)
    return false;
  var key;
  for (key in obj)
    ;
  return typeof key === "undefined" || $5f4474664cf1d724$var$hasOwn.call(obj, key);
};
var $5f4474664cf1d724$var$setProperty = function setProperty2(target, options) {
  if ($5f4474664cf1d724$var$defineProperty && options.name === "__proto__")
    $5f4474664cf1d724$var$defineProperty(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  else
    target[options.name] = options.newValue;
};
var $5f4474664cf1d724$var$getProperty = function getProperty2(obj, name) {
  if (name === "__proto__") {
    if (!$5f4474664cf1d724$var$hasOwn.call(obj, name))
      return void 0;
    else if ($5f4474664cf1d724$var$gOPD)
      return $5f4474664cf1d724$var$gOPD(obj, name).value;
  }
  return obj[name];
};
$5f4474664cf1d724$exports = function extend2() {
  var options, name, src, copy, copyIsArray, clone;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function")
    target = {};
  for (; i < length; ++i) {
    options = arguments[i];
    if (options != null)
      for (name in options) {
        src = $5f4474664cf1d724$var$getProperty(target, name);
        copy = $5f4474664cf1d724$var$getProperty(options, name);
        if (target !== copy) {
          if (deep && copy && ($5f4474664cf1d724$var$isPlainObject(copy) || (copyIsArray = $5f4474664cf1d724$var$isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && $5f4474664cf1d724$var$isArray(src) ? src : [];
            } else
              clone = src && $5f4474664cf1d724$var$isPlainObject(src) ? src : {};
            $5f4474664cf1d724$var$setProperty(target, {
              name,
              newValue: extend2(deep, clone, copy)
            });
          } else if (typeof copy !== "undefined")
            $5f4474664cf1d724$var$setProperty(target, {
              name,
              newValue: copy
            });
        }
      }
  }
  return target;
};
var $b2243982bfcc40b1$exports = {};
$b2243982bfcc40b1$exports = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
var $d42d0c51804cd466$exports = {};
var $31c5a40faaf91428$exports = {};
var $31c5a40faaf91428$var$slice = [].slice;
$31c5a40faaf91428$exports = $31c5a40faaf91428$var$wrap;
function $31c5a40faaf91428$var$wrap(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = $31c5a40faaf91428$var$slice.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result;
    if (callback2)
      params.push(done);
    try {
      result = fn.apply(null, params);
    } catch (error) {
      if (callback2 && invoked)
        throw error;
      return done(error);
    }
    if (!callback2) {
      if (result && typeof result.then === "function")
        result.then(then, done);
      else if (result instanceof Error)
        done(result);
      else
        then(result);
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value) {
    done(null, value);
  }
}
$d42d0c51804cd466$exports = $d42d0c51804cd466$var$trough;
$d42d0c51804cd466$var$trough.wrap = $31c5a40faaf91428$exports;
var $d42d0c51804cd466$var$slice = [].slice;
function $d42d0c51804cd466$var$trough() {
  var fns = [];
  var middleware = {};
  middleware.run = run;
  middleware.use = use;
  return middleware;
  function run() {
    var index = -1;
    var input = $d42d0c51804cd466$var$slice.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function")
      throw new Error("Expected function as last argument, not " + done);
    next.apply(null, [
      null
    ].concat(input));
    function next(err) {
      var fn = fns[++index];
      var params = $d42d0c51804cd466$var$slice.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length)
        if (values[pos] === null || values[pos] === void 0)
          values[pos] = input[pos];
      input = values;
      if (fn)
        $31c5a40faaf91428$exports(fn, next).apply(null, input);
      else
        done.apply(null, [
          null
        ].concat(input));
    }
  }
  function use(fn) {
    if (typeof fn !== "function")
      throw new Error("Expected `fn` to be a function, not " + fn);
    fns.push(fn);
    return middleware;
  }
}
var $10b7bc44255075d9$exports = {};
$10b7bc44255075d9$exports = parcelRequire("i3bOO");
$7f6f6807a3a8644e$exports = $7f6f6807a3a8644e$var$unified().freeze();
var $7f6f6807a3a8644e$var$slice = [].slice;
var $7f6f6807a3a8644e$var$own = {}.hasOwnProperty;
var $7f6f6807a3a8644e$var$pipeline = $d42d0c51804cd466$exports().use($7f6f6807a3a8644e$var$pipelineParse).use($7f6f6807a3a8644e$var$pipelineRun).use($7f6f6807a3a8644e$var$pipelineStringify);
function $7f6f6807a3a8644e$var$pipelineParse(p, ctx) {
  ctx.tree = p.parse(ctx.file);
}
function $7f6f6807a3a8644e$var$pipelineRun(p, ctx, next) {
  p.run(ctx.tree, ctx.file, done);
  function done(err, tree, file) {
    if (err)
      next(err);
    else {
      ctx.tree = tree;
      ctx.file = file;
      next();
    }
  }
}
function $7f6f6807a3a8644e$var$pipelineStringify(p, ctx) {
  var result = p.stringify(ctx.tree, ctx.file);
  var file = ctx.file;
  if (result === void 0 || result === null)
    ;
  else if (typeof result === "string" || $9POxA(result))
    file.contents = result;
  else
    file.result = result;
}
function $7f6f6807a3a8644e$var$unified() {
  var attachers = [];
  var transformers = $d42d0c51804cd466$exports();
  var namespace = {};
  var frozen = false;
  var freezeIndex = -1;
  processor.data = data;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse;
  processor.stringify = stringify;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = $7f6f6807a3a8644e$var$unified();
    var length = attachers.length;
    var index = -1;
    while (++index < length)
      destination.use.apply(null, attachers[index]);
    destination.data($5f4474664cf1d724$exports(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var plugin;
    var options;
    var transformer;
    if (frozen)
      return processor;
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      plugin = values[0];
      options = values[1];
      transformer = null;
      if (options === false)
        continue;
      if (options === true)
        values[1] = void 0;
      transformer = plugin.apply(processor, values.slice(1));
      if (typeof transformer === "function")
        transformers.use(transformer);
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        $7f6f6807a3a8644e$var$assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return $7f6f6807a3a8644e$var$own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      $7f6f6807a3a8644e$var$assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function use(value) {
    var settings;
    $7f6f6807a3a8644e$var$assertUnfrozen("use", frozen);
    if (value === null || value === void 0)
      ;
    else if (typeof value === "function")
      addPlugin.apply(null, arguments);
    else if (typeof value === "object") {
      if ("length" in value)
        addList(value);
      else
        addPreset(value);
    } else
      throw new Error("Expected usable value, not `" + value + "`");
    if (settings)
      namespace.settings = $5f4474664cf1d724$exports(namespace.settings || {}, settings);
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings)
        settings = $5f4474664cf1d724$exports(settings || {}, result.settings);
    }
    function add(value2) {
      if (typeof value2 === "function")
        addPlugin(value2);
      else if (typeof value2 === "object") {
        if ("length" in value2)
          addPlugin.apply(null, value2);
        else
          addPreset(value2);
      } else
        throw new Error("Expected usable value, not `" + value2 + "`");
    }
    function addList(plugins) {
      var length;
      var index;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        length = plugins.length;
        index = -1;
        while (++index < length)
          add(plugins[index]);
      } else
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
    }
    function addPlugin(plugin, value2) {
      var entry = find(plugin);
      if (entry) {
        if ($b2243982bfcc40b1$exports(entry[1]) && $b2243982bfcc40b1$exports(value2))
          value2 = $5f4474664cf1d724$exports(entry[1], value2);
        entry[1] = value2;
      } else
        attachers.push($7f6f6807a3a8644e$var$slice.call(arguments));
    }
  }
  function find(plugin) {
    var length = attachers.length;
    var index = -1;
    var entry;
    while (++index < length) {
      entry = attachers[index];
      if (entry[0] === plugin)
        return entry;
    }
  }
  function parse(doc) {
    var file = $10b7bc44255075d9$exports(doc);
    var Parser;
    freeze();
    Parser = processor.Parser;
    $7f6f6807a3a8644e$var$assertParser("parse", Parser);
    if ($7f6f6807a3a8644e$var$newable(Parser, "parse"))
      return new Parser(String(file), file).parse();
    return Parser(String(file), file);
  }
  function run(node, file, cb) {
    $7f6f6807a3a8644e$var$assertNode(node);
    freeze();
    if (!cb && typeof file === "function") {
      cb = file;
      file = null;
    }
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      transformers.run(node, $10b7bc44255075d9$exports(file), done);
      function done(err, tree, file2) {
        tree = tree || node;
        if (err)
          reject(err);
        else if (resolve)
          resolve(tree);
        else
          cb(null, tree, file2);
      }
    }
  }
  function runSync(node, file) {
    var complete = false;
    var result;
    run(node, file, done);
    $7f6f6807a3a8644e$var$assertDone("runSync", "run", complete);
    return result;
    function done(err, tree) {
      complete = true;
      $df3ba5e804f3b490$exports(err);
      result = tree;
    }
  }
  function stringify(node, doc) {
    var file = $10b7bc44255075d9$exports(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    $7f6f6807a3a8644e$var$assertCompiler("stringify", Compiler);
    $7f6f6807a3a8644e$var$assertNode(node);
    if ($7f6f6807a3a8644e$var$newable(Compiler, "compile"))
      return new Compiler(node, file).compile();
    return Compiler(node, file);
  }
  function process2(doc, cb) {
    freeze();
    $7f6f6807a3a8644e$var$assertParser("process", processor.Parser);
    $7f6f6807a3a8644e$var$assertCompiler("process", processor.Compiler);
    if (!cb)
      return new Promise(executor);
    executor(null, cb);
    function executor(resolve, reject) {
      var file = $10b7bc44255075d9$exports(doc);
      $7f6f6807a3a8644e$var$pipeline.run(processor, {
        file
      }, done);
      function done(err) {
        if (err)
          reject(err);
        else if (resolve)
          resolve(file);
        else
          cb(null, file);
      }
    }
  }
  function processSync(doc) {
    var complete = false;
    var file;
    freeze();
    $7f6f6807a3a8644e$var$assertParser("processSync", processor.Parser);
    $7f6f6807a3a8644e$var$assertCompiler("processSync", processor.Compiler);
    file = $10b7bc44255075d9$exports(doc);
    process2(file, done);
    $7f6f6807a3a8644e$var$assertDone("processSync", "process", complete);
    return file;
    function done(err) {
      complete = true;
      $df3ba5e804f3b490$exports(err);
    }
  }
}
function $7f6f6807a3a8644e$var$newable(value, name) {
  return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  ($7f6f6807a3a8644e$var$keys(value.prototype) || name in value.prototype);
}
function $7f6f6807a3a8644e$var$keys(value) {
  var key;
  for (key in value)
    return true;
  return false;
}
function $7f6f6807a3a8644e$var$assertParser(name, Parser) {
  if (typeof Parser !== "function")
    throw new Error("Cannot `" + name + "` without `Parser`");
}
function $7f6f6807a3a8644e$var$assertCompiler(name, Compiler) {
  if (typeof Compiler !== "function")
    throw new Error("Cannot `" + name + "` without `Compiler`");
}
function $7f6f6807a3a8644e$var$assertUnfrozen(name, frozen) {
  if (frozen)
    throw new Error("Cannot invoke `" + name + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
}
function $7f6f6807a3a8644e$var$assertNode(node) {
  if (!node || typeof node.type !== "string")
    throw new Error("Expected node, got `" + node + "`");
}
function $7f6f6807a3a8644e$var$assertDone(name, asyncName, complete) {
  if (!complete)
    throw new Error("`" + name + "` finished async. Use `" + asyncName + "` instead");
}
var $4ecf9a54af9f01ab$exports = {};
var $16758458ef599f83$exports = {};
var $gqx3p = parcelRequire("gqx3p");
var $73e3fac3938c8b64$exports = {};
try {
  var $73e3fac3938c8b64$var$util = $73e3fac3938c8b64$import$c048c975dde88ad4;
  if (typeof $73e3fac3938c8b64$var$util.inherits !== "function")
    throw "";
  $73e3fac3938c8b64$exports = $73e3fac3938c8b64$var$util.inherits;
} catch (e) {
  $73e3fac3938c8b64$exports = parcelRequire("cSDDS");
}
$16758458ef599f83$exports = $16758458ef599f83$var$unherit;
function $16758458ef599f83$var$unherit(Super) {
  var result;
  var key;
  var value;
  $73e3fac3938c8b64$exports(Of, Super);
  $73e3fac3938c8b64$exports(From, Of);
  result = Of.prototype;
  for (key in result) {
    value = result[key];
    if (value && typeof value === "object")
      result[key] = "concat" in value ? value.concat() : $gqx3p(value);
  }
  return Of;
  function From(parameters) {
    return Super.apply(this, parameters);
  }
  function Of() {
    if (!(this instanceof Of))
      return new From(arguments);
    return Super.apply(this, arguments);
  }
}
var $gqx3p = parcelRequire("gqx3p");
var $ed2921c87997049c$exports = {};
var $gqx3p = parcelRequire("gqx3p");
var $aec8e6fcf2d07ca0$exports = {};
$aec8e6fcf2d07ca0$exports = $aec8e6fcf2d07ca0$var$factory;
function $aec8e6fcf2d07ca0$var$factory(key, state, ctx) {
  return enter;
  function enter() {
    var context = ctx || this;
    var current = context[key];
    context[key] = !state;
    return exit;
    function exit() {
      context[key] = current;
    }
  }
}
var $cd6373c8f2c4afd5$exports = {};
$cd6373c8f2c4afd5$exports = $cd6373c8f2c4afd5$var$factory;
function $cd6373c8f2c4afd5$var$factory(file) {
  var value = String(file);
  var indices = [];
  var search = /\r?\n|\r/g;
  while (search.exec(value))
    indices.push(search.lastIndex);
  indices.push(value.length + 1);
  return {
    toPoint: offsetToPoint,
    toPosition: offsetToPoint,
    toOffset: pointToOffset
  };
  function offsetToPoint(offset) {
    var index = -1;
    if (offset > -1 && offset < indices[indices.length - 1])
      while (++index < indices.length) {
        if (indices[index] > offset)
          return {
            line: index + 1,
            column: offset - (indices[index - 1] || 0) + 1,
            offset
          };
      }
    return {};
  }
  function pointToOffset(point) {
    var line = point && point.line;
    var column = point && point.column;
    var offset;
    if (!isNaN(line) && !isNaN(column) && line - 1 in indices)
      offset = (indices[line - 2] || 0) + column - 1 || 0;
    return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
  }
}
var $2a69ad6a0b7ae99b$exports = {};
$2a69ad6a0b7ae99b$exports = $2a69ad6a0b7ae99b$var$factory;
var $2a69ad6a0b7ae99b$var$backslash = "\\";
function $2a69ad6a0b7ae99b$var$factory(ctx, key) {
  return unescape2;
  function unescape2(value) {
    var previous = 0;
    var index = value.indexOf($2a69ad6a0b7ae99b$var$backslash);
    var escape = ctx[key];
    var queue = [];
    var character;
    while (index !== -1) {
      queue.push(value.slice(previous, index));
      previous = index + 1;
      character = value.charAt(previous);
      if (!character || escape.indexOf(character) === -1)
        queue.push($2a69ad6a0b7ae99b$var$backslash);
      index = value.indexOf($2a69ad6a0b7ae99b$var$backslash, previous + 1);
    }
    queue.push(value.slice(previous));
    return queue.join("");
  }
}
var $d2ac610520580292$exports = {};
var $gqx3p = parcelRequire("gqx3p");
var $3qZkh = parcelRequire("3qZkh");
$d2ac610520580292$exports = $d2ac610520580292$var$factory;
function $d2ac610520580292$var$factory(ctx) {
  decoder.raw = decodeRaw;
  return decoder;
  function normalize(position) {
    var offsets = ctx.offset;
    var line = position.line;
    var result = [];
    while (++line) {
      if (!(line in offsets))
        break;
      result.push((offsets[line] || 0) + 1);
    }
    return {
      start: position,
      indent: result
    };
  }
  function decoder(value, position, handler) {
    $3qZkh(value, {
      position: normalize(position),
      warning: handleWarning,
      text: handler,
      reference: handler,
      textContext: ctx,
      referenceContext: ctx
    });
  }
  function decodeRaw(value, position, options) {
    return $3qZkh(value, $gqx3p(options, {
      position: normalize(position),
      warning: handleWarning
    }));
  }
  function handleWarning(reason, position, code) {
    if (code !== 3)
      ctx.file.message(reason, position);
  }
}
var $a79271e383b04b47$exports = {};
$a79271e383b04b47$exports = $a79271e383b04b47$var$factory;
function $a79271e383b04b47$var$factory(type) {
  return tokenize;
  function tokenize(value, location) {
    var self2 = this;
    var offset = self2.offset;
    var tokens = [];
    var methods = self2[type + "Methods"];
    var tokenizers = self2[type + "Tokenizers"];
    var line = location.line;
    var column = location.column;
    var index;
    var length;
    var method;
    var name;
    var matched;
    var valueLength;
    if (!value)
      return tokens;
    eat.now = now;
    eat.file = self2.file;
    updatePosition("");
    while (value) {
      index = -1;
      length = methods.length;
      matched = false;
      while (++index < length) {
        name = methods[index];
        method = tokenizers[name];
        if (method && /* istanbul ignore next */
        (!method.onlyAtStart || self2.atStart) && /* istanbul ignore next */
        (!method.notInList || !self2.inList) && /* istanbul ignore next */
        (!method.notInBlock || !self2.inBlock) && (!method.notInLink || !self2.inLink)) {
          valueLength = value.length;
          method.apply(self2, [
            eat,
            value
          ]);
          matched = valueLength !== value.length;
          if (matched)
            break;
        }
      }
      if (!matched)
        self2.file.fail(new Error("Infinite loop"), eat.now());
    }
    self2.eof = now();
    return tokens;
    function updatePosition(subvalue) {
      var lastIndex = -1;
      var index2 = subvalue.indexOf("\n");
      while (index2 !== -1) {
        line++;
        lastIndex = index2;
        index2 = subvalue.indexOf("\n", index2 + 1);
      }
      if (lastIndex === -1)
        column += subvalue.length;
      else
        column = subvalue.length - lastIndex;
      if (line in offset) {
        if (lastIndex !== -1)
          column += offset[line];
        else if (column <= offset[line])
          column = offset[line] + 1;
      }
    }
    function getOffset() {
      var indentation = [];
      var pos = line + 1;
      return function() {
        var last = line + 1;
        while (pos < last) {
          indentation.push((offset[pos] || 0) + 1);
          pos++;
        }
        return indentation;
      };
    }
    function now() {
      var pos = {
        line,
        column
      };
      pos.offset = self2.toOffset(pos);
      return pos;
    }
    function Position(start) {
      this.start = start;
      this.end = now();
    }
    function validateEat(subvalue) {
      if (value.slice(0, subvalue.length) !== subvalue)
        self2.file.fail(new Error("Incorrectly eaten value: please report this warning on https://git.io/vg5Ft"), now());
    }
    function position() {
      var before = now();
      return update;
      function update(node, indent) {
        var previous = node.position;
        var start = previous ? previous.start : before;
        var combined = [];
        var n = previous && previous.end.line;
        var l = before.line;
        node.position = new Position(start);
        if (previous && indent && previous.indent) {
          combined = previous.indent;
          if (n < l) {
            while (++n < l)
              combined.push((offset[n] || 0) + 1);
            combined.push(before.column);
          }
          indent = combined.concat(indent);
        }
        node.position.indent = indent || [];
        return node;
      }
    }
    function add(node, parent) {
      var children = parent ? parent.children : tokens;
      var previous = children[children.length - 1];
      var fn;
      if (previous && node.type === previous.type && (node.type === "text" || node.type === "blockquote") && $a79271e383b04b47$var$mergeable(previous) && $a79271e383b04b47$var$mergeable(node)) {
        fn = node.type === "text" ? $a79271e383b04b47$var$mergeText : $a79271e383b04b47$var$mergeBlockquote;
        node = fn.call(self2, previous, node);
      }
      if (node !== previous)
        children.push(node);
      if (self2.atStart && tokens.length !== 0)
        self2.exitStart();
      return node;
    }
    function eat(subvalue) {
      var indent = getOffset();
      var pos = position();
      var current = now();
      validateEat(subvalue);
      apply.reset = reset;
      reset.test = test;
      apply.test = test;
      value = value.slice(subvalue.length);
      updatePosition(subvalue);
      indent = indent();
      return apply;
      function apply(node, parent) {
        return pos(add(pos(node), parent), indent);
      }
      function reset() {
        var node = apply.apply(null, arguments);
        line = current.line;
        column = current.column;
        value = subvalue + value;
        return node;
      }
      function test() {
        var result = pos({});
        line = current.line;
        column = current.column;
        value = subvalue + value;
        return result.position;
      }
    }
  }
}
function $a79271e383b04b47$var$mergeable(node) {
  var start;
  var end;
  if (node.type !== "text" || !node.position)
    return true;
  start = node.position.start;
  end = node.position.end;
  return start.line !== end.line || end.column - start.column === node.value.length;
}
function $a79271e383b04b47$var$mergeText(previous, node) {
  previous.value += node.value;
  return previous;
}
function $a79271e383b04b47$var$mergeBlockquote(previous, node) {
  if (this.options.commonmark || this.options.gfm)
    return node;
  previous.children = previous.children.concat(node.children);
  return previous;
}
$ed2921c87997049c$exports = $ed2921c87997049c$var$Parser;
function $ed2921c87997049c$var$Parser(doc, file) {
  this.file = file;
  this.offset = {};
  this.options = $gqx3p(this.options);
  this.setOptions({});
  this.inList = false;
  this.inBlock = false;
  this.inLink = false;
  this.atStart = true;
  this.toOffset = $cd6373c8f2c4afd5$exports(file).toOffset;
  this.unescape = $2a69ad6a0b7ae99b$exports(this, "escape");
  this.decode = $d2ac610520580292$exports(this);
}
var $ed2921c87997049c$var$proto = $ed2921c87997049c$var$Parser.prototype;
$ed2921c87997049c$var$proto.setOptions = parcelRequire("fh61I");
$ed2921c87997049c$var$proto.parse = parcelRequire("jPzk9");
$ed2921c87997049c$var$proto.options = parcelRequire("c0y3C");
$ed2921c87997049c$var$proto.exitStart = $aec8e6fcf2d07ca0$exports("atStart", true);
$ed2921c87997049c$var$proto.enterList = $aec8e6fcf2d07ca0$exports("inList", false);
$ed2921c87997049c$var$proto.enterLink = $aec8e6fcf2d07ca0$exports("inLink", false);
$ed2921c87997049c$var$proto.enterBlock = $aec8e6fcf2d07ca0$exports("inBlock", false);
$ed2921c87997049c$var$proto.interruptParagraph = [
  [
    "thematicBreak"
  ],
  [
    "list"
  ],
  [
    "atxHeading"
  ],
  [
    "fencedCode"
  ],
  [
    "blockquote"
  ],
  [
    "html"
  ],
  [
    "setextHeading",
    {
      commonmark: false
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$ed2921c87997049c$var$proto.interruptList = [
  [
    "atxHeading",
    {
      pedantic: false
    }
  ],
  [
    "fencedCode",
    {
      pedantic: false
    }
  ],
  [
    "thematicBreak",
    {
      pedantic: false
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$ed2921c87997049c$var$proto.interruptBlockquote = [
  [
    "indentedCode",
    {
      commonmark: true
    }
  ],
  [
    "fencedCode",
    {
      commonmark: true
    }
  ],
  [
    "atxHeading",
    {
      commonmark: true
    }
  ],
  [
    "setextHeading",
    {
      commonmark: true
    }
  ],
  [
    "thematicBreak",
    {
      commonmark: true
    }
  ],
  [
    "html",
    {
      commonmark: true
    }
  ],
  [
    "list",
    {
      commonmark: true
    }
  ],
  [
    "definition",
    {
      commonmark: false
    }
  ]
];
$ed2921c87997049c$var$proto.blockTokenizers = {
  blankLine: parcelRequire("6MCKT"),
  indentedCode: parcelRequire("eRBEg"),
  fencedCode: parcelRequire("1dZOZ"),
  blockquote: parcelRequire("1lYit"),
  atxHeading: parcelRequire("dbuo7"),
  thematicBreak: parcelRequire("etWp6"),
  list: parcelRequire("2nv9J"),
  setextHeading: parcelRequire("igoS1"),
  html: parcelRequire("5mJ60"),
  definition: parcelRequire("iUyeb"),
  table: parcelRequire("jvhub"),
  paragraph: parcelRequire("fkexf")
};
$ed2921c87997049c$var$proto.inlineTokenizers = {
  escape: parcelRequire("jGxnv"),
  autoLink: parcelRequire("aoJGq"),
  url: parcelRequire("9HIzs"),
  email: parcelRequire("dps5A"),
  html: parcelRequire("6NCFJ"),
  link: parcelRequire("8jyKl"),
  reference: parcelRequire("4wSVw"),
  strong: parcelRequire("icpkQ"),
  emphasis: parcelRequire("3P2AS"),
  deletion: parcelRequire("jUYRO"),
  code: parcelRequire("ahmx7"),
  break: parcelRequire("9AmxP"),
  text: parcelRequire("I2hrQ")
};
$ed2921c87997049c$var$proto.blockMethods = $ed2921c87997049c$var$keys($ed2921c87997049c$var$proto.blockTokenizers);
$ed2921c87997049c$var$proto.inlineMethods = $ed2921c87997049c$var$keys($ed2921c87997049c$var$proto.inlineTokenizers);
$ed2921c87997049c$var$proto.tokenizeBlock = $a79271e383b04b47$exports("block");
$ed2921c87997049c$var$proto.tokenizeInline = $a79271e383b04b47$exports("inline");
$ed2921c87997049c$var$proto.tokenizeFactory = $a79271e383b04b47$exports;
function $ed2921c87997049c$var$keys(value) {
  var result = [];
  var key;
  for (key in value)
    result.push(key);
  return result;
}
$4ecf9a54af9f01ab$exports = $4ecf9a54af9f01ab$var$parse;
$4ecf9a54af9f01ab$var$parse.Parser = $ed2921c87997049c$exports;
function $4ecf9a54af9f01ab$var$parse(options) {
  var settings = this.data("settings");
  var Local = $16758458ef599f83$exports($ed2921c87997049c$exports);
  Local.prototype.options = $gqx3p(Local.prototype.options, settings, options);
  this.Parser = Local;
}
var $5cnuX = parcelRequire("5cnuX");
var $ljm8s = parcelRequire("ljm8s");
var $3bc517d55346f2bb$require$parseFrontmatter = $ljm8s.parseFrontmatter;
var $1b8cd49791e763b0$exports = {};
var $2WRWK = parcelRequire("2WRWK");
var $4210d187e864d94b$exports = {};
var $e15a6bce02e95efb$exports = {};
$e15a6bce02e95efb$exports = (flag, argv = process.argv) => {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
const { env: $4210d187e864d94b$var$env } = process;
let $4210d187e864d94b$var$forceColor;
if ($e15a6bce02e95efb$exports("no-color") || $e15a6bce02e95efb$exports("no-colors") || $e15a6bce02e95efb$exports("color=false") || $e15a6bce02e95efb$exports("color=never"))
  $4210d187e864d94b$var$forceColor = 0;
else if ($e15a6bce02e95efb$exports("color") || $e15a6bce02e95efb$exports("colors") || $e15a6bce02e95efb$exports("color=true") || $e15a6bce02e95efb$exports("color=always"))
  $4210d187e864d94b$var$forceColor = 1;
if ("FORCE_COLOR" in $4210d187e864d94b$var$env) {
  if ($4210d187e864d94b$var$env.FORCE_COLOR === "true")
    $4210d187e864d94b$var$forceColor = 1;
  else if ($4210d187e864d94b$var$env.FORCE_COLOR === "false")
    $4210d187e864d94b$var$forceColor = 0;
  else
    $4210d187e864d94b$var$forceColor = $4210d187e864d94b$var$env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt($4210d187e864d94b$var$env.FORCE_COLOR, 10), 3);
}
function $4210d187e864d94b$var$translateLevel(level) {
  if (level === 0)
    return false;
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function $4210d187e864d94b$var$supportsColor(haveStream, streamIsTTY) {
  if ($4210d187e864d94b$var$forceColor === 0)
    return 0;
  if ($e15a6bce02e95efb$exports("color=16m") || $e15a6bce02e95efb$exports("color=full") || $e15a6bce02e95efb$exports("color=truecolor"))
    return 3;
  if ($e15a6bce02e95efb$exports("color=256"))
    return 2;
  if (haveStream && !streamIsTTY && $4210d187e864d94b$var$forceColor === void 0)
    return 0;
  const min = $4210d187e864d94b$var$forceColor || 0;
  if ($4210d187e864d94b$var$env.TERM === "dumb")
    return min;
  if (process.platform === "win32") {
    const osRelease = release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586)
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    return 1;
  }
  if ("CI" in $4210d187e864d94b$var$env) {
    if ([
      "TRAVIS",
      "CIRCLECI",
      "APPVEYOR",
      "GITLAB_CI",
      "GITHUB_ACTIONS",
      "BUILDKITE"
    ].some((sign) => sign in $4210d187e864d94b$var$env) || $4210d187e864d94b$var$env.CI_NAME === "codeship")
      return 1;
    return min;
  }
  if ("TEAMCITY_VERSION" in $4210d187e864d94b$var$env)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test($4210d187e864d94b$var$env.TEAMCITY_VERSION) ? 1 : 0;
  if ($4210d187e864d94b$var$env.COLORTERM === "truecolor")
    return 3;
  if ("TERM_PROGRAM" in $4210d187e864d94b$var$env) {
    const version = parseInt(($4210d187e864d94b$var$env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch ($4210d187e864d94b$var$env.TERM_PROGRAM) {
      case "iTerm.app":
        return version >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test($4210d187e864d94b$var$env.TERM))
    return 2;
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test($4210d187e864d94b$var$env.TERM))
    return 1;
  if ("COLORTERM" in $4210d187e864d94b$var$env)
    return 1;
  return min;
}
function $4210d187e864d94b$var$getSupportLevel(stream) {
  const level = $4210d187e864d94b$var$supportsColor(stream, stream && stream.isTTY);
  return $4210d187e864d94b$var$translateLevel(level);
}
$4210d187e864d94b$exports = {
  supportsColor: $4210d187e864d94b$var$getSupportLevel,
  stdout: $4210d187e864d94b$var$translateLevel($4210d187e864d94b$var$supportsColor(true, isatty(1))),
  stderr: $4210d187e864d94b$var$translateLevel($4210d187e864d94b$var$supportsColor(true, isatty(2)))
};
var $1b8cd49791e763b0$require$stdoutColor = $4210d187e864d94b$exports.stdout;
var $1b8cd49791e763b0$require$stderrColor = $4210d187e864d94b$exports.stderr;
var $a8b17ba7c3520953$exports = {};
const $a8b17ba7c3520953$var$stringReplaceAll = (string, substring, replacer) => {
  let index = string.indexOf(substring);
  if (index === -1)
    return string;
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
const $a8b17ba7c3520953$var$stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.substr(endIndex);
  return returnValue;
};
$a8b17ba7c3520953$exports = {
  stringReplaceAll: $a8b17ba7c3520953$var$stringReplaceAll,
  stringEncaseCRLFWithFirstIndex: $a8b17ba7c3520953$var$stringEncaseCRLFWithFirstIndex
};
var $1b8cd49791e763b0$require$stringReplaceAll = $a8b17ba7c3520953$exports.stringReplaceAll;
var $1b8cd49791e763b0$require$stringEncaseCRLFWithFirstIndex = $a8b17ba7c3520953$exports.stringEncaseCRLFWithFirstIndex;
const { isArray: $1b8cd49791e763b0$var$isArray } = Array;
const $1b8cd49791e763b0$var$levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
const $1b8cd49791e763b0$var$styles = /* @__PURE__ */ Object.create(null);
const $1b8cd49791e763b0$var$applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const colorLevel = $1b8cd49791e763b0$require$stdoutColor ? $1b8cd49791e763b0$require$stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
class $1b8cd49791e763b0$var$ChalkClass {
  constructor(options) {
    return $1b8cd49791e763b0$var$chalkFactory(options);
  }
}
const $1b8cd49791e763b0$var$chalkFactory = (options) => {
  const chalk = {};
  $1b8cd49791e763b0$var$applyOptions(chalk, options);
  chalk.template = (...arguments_) => $1b8cd49791e763b0$var$chalkTag(chalk.template, ...arguments_);
  Object.setPrototypeOf(chalk, $1b8cd49791e763b0$var$Chalk.prototype);
  Object.setPrototypeOf(chalk.template, chalk);
  chalk.template.constructor = () => {
    throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
  };
  chalk.template.Instance = $1b8cd49791e763b0$var$ChalkClass;
  return chalk.template;
};
function $1b8cd49791e763b0$var$Chalk(options) {
  return $1b8cd49791e763b0$var$chalkFactory(options);
}
for (const [styleName, style] of Object.entries($2WRWK))
  $1b8cd49791e763b0$var$styles[styleName] = {
    get() {
      const builder = $1b8cd49791e763b0$var$createBuilder(this, $1b8cd49791e763b0$var$createStyler(style.open, style.close, this._styler), this._isEmpty);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
$1b8cd49791e763b0$var$styles.visible = {
  get() {
    const builder = $1b8cd49791e763b0$var$createBuilder(this, this._styler, true);
    Object.defineProperty(this, "visible", {
      value: builder
    });
    return builder;
  }
};
const $1b8cd49791e763b0$var$usedModels = [
  "rgb",
  "hex",
  "keyword",
  "hsl",
  "hsv",
  "hwb",
  "ansi",
  "ansi256"
];
for (const model of $1b8cd49791e763b0$var$usedModels)
  $1b8cd49791e763b0$var$styles[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = $1b8cd49791e763b0$var$createStyler($2WRWK.color[$1b8cd49791e763b0$var$levelMapping[level]][model](...arguments_), $2WRWK.color.close, this._styler);
        return $1b8cd49791e763b0$var$createBuilder(this, styler, this._isEmpty);
      };
    }
  };
for (const model of $1b8cd49791e763b0$var$usedModels) {
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  $1b8cd49791e763b0$var$styles[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = $1b8cd49791e763b0$var$createStyler($2WRWK.bgColor[$1b8cd49791e763b0$var$levelMapping[level]][model](...arguments_), $2WRWK.bgColor.close, this._styler);
        return $1b8cd49791e763b0$var$createBuilder(this, styler, this._isEmpty);
      };
    }
  };
}
const $1b8cd49791e763b0$var$proto = Object.defineProperties(() => {
}, {
  ...$1b8cd49791e763b0$var$styles,
  level: {
    enumerable: true,
    get() {
      return this._generator.level;
    },
    set(level) {
      this._generator.level = level;
    }
  }
});
const $1b8cd49791e763b0$var$createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
const $1b8cd49791e763b0$var$createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => {
    if ($1b8cd49791e763b0$var$isArray(arguments_[0]) && $1b8cd49791e763b0$var$isArray(arguments_[0].raw))
      return $1b8cd49791e763b0$var$applyStyle(builder, $1b8cd49791e763b0$var$chalkTag(builder, ...arguments_));
    return $1b8cd49791e763b0$var$applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  };
  Object.setPrototypeOf(builder, $1b8cd49791e763b0$var$proto);
  builder._generator = self2;
  builder._styler = _styler;
  builder._isEmpty = _isEmpty;
  return builder;
};
const $1b8cd49791e763b0$var$applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string)
    return self2._isEmpty ? "" : string;
  let styler = self2._styler;
  if (styler === void 0)
    return string;
  const { openAll, closeAll } = styler;
  if (string.indexOf("\x1B") !== -1)
    while (styler !== void 0) {
      string = $1b8cd49791e763b0$require$stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1)
    string = $1b8cd49791e763b0$require$stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  return openAll + string + closeAll;
};
let $1b8cd49791e763b0$var$template;
const $1b8cd49791e763b0$var$chalkTag = (chalk, ...strings) => {
  const [firstString] = strings;
  if (!$1b8cd49791e763b0$var$isArray(firstString) || !$1b8cd49791e763b0$var$isArray(firstString.raw))
    return strings.join(" ");
  const arguments_ = strings.slice(1);
  const parts = [
    firstString.raw[0]
  ];
  for (let i = 1; i < firstString.length; i++)
    parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
  if ($1b8cd49791e763b0$var$template === void 0)
    $1b8cd49791e763b0$var$template = parcelRequire("gn0Qn");
  return $1b8cd49791e763b0$var$template(chalk, parts.join(""));
};
Object.defineProperties($1b8cd49791e763b0$var$Chalk.prototype, $1b8cd49791e763b0$var$styles);
const $1b8cd49791e763b0$var$chalk = $1b8cd49791e763b0$var$Chalk();
$1b8cd49791e763b0$var$chalk.supportsColor = $1b8cd49791e763b0$require$stdoutColor;
$1b8cd49791e763b0$var$chalk.stderr = $1b8cd49791e763b0$var$Chalk({
  level: $1b8cd49791e763b0$require$stderrColor ? $1b8cd49791e763b0$require$stderrColor.level : 0
});
$1b8cd49791e763b0$var$chalk.stderr.supportsColor = $1b8cd49791e763b0$require$stderrColor;
$1b8cd49791e763b0$exports = $1b8cd49791e763b0$var$chalk;
const $3bc517d55346f2bb$var$warnedExternalQueries = {};
const $3bc517d55346f2bb$var$readFileToQuery = (externalQuery, id) => {
  try {
    const content = readFileSync(`./queries/${externalQuery}`).toString().trim();
    return {
      id: id.toLowerCase(),
      compiledQueryString: content,
      inputQueryString: content,
      compiled: false,
      inline: false
    };
  } catch {
    console.warn(`Failed to load sql file ${externalQuery}`);
  }
};
const $3bc517d55346f2bb$var$ignoreIndentedCode = function() {
  const Parser = this.Parser;
  const block_tokenizers = Parser.prototype.blockTokenizers;
  block_tokenizers.indentedCode = () => true;
};
const $3bc517d55346f2bb$var$extractExternalQueries = (content, filename) => {
  const frontmatter = $3bc517d55346f2bb$require$parseFrontmatter(content);
  if (!frontmatter)
    return [];
  if (!frontmatter.queries)
    return [];
  if (!Array.isArray(frontmatter.queries)) {
    console.warn(`Malformed frontmatter found in ${filename}. Unable to extract external queries.`);
    return [];
  }
  const validateExternalQuery = (externalQuery) => {
    if (!externalQuery.endsWith(".sql")) {
      if (!$3bc517d55346f2bb$var$warnedExternalQueries[externalQuery]) {
        $3bc517d55346f2bb$var$warnedExternalQueries[externalQuery] = true;
        console.warn($1b8cd49791e763b0$exports.bold.red(`! ${externalQuery}`) + $1b8cd49791e763b0$exports.gray(" does not appear to be a .sql file, and will not be loaded"));
      }
      return false;
    }
    return true;
  };
  return frontmatter.queries.map((externalQuery) => {
    if (typeof externalQuery === "string") {
      if (!validateExternalQuery(externalQuery))
        return false;
      const id = externalQuery.split(".sql")[0].replace("/", "_").replace("\\", "_");
      return $3bc517d55346f2bb$var$readFileToQuery(externalQuery, id);
    } else if (typeof externalQuery === "object") {
      const usedKey = Object.keys(externalQuery)?.[0] ?? "";
      const value = externalQuery[usedKey];
      if (Object.keys(externalQuery).length > 1)
        console.warn(`ExternalQuery object has more than one key, this may lead to unintended behavior. Only ${usedKey}: ${value} will be imported.`);
      if (!validateExternalQuery(value))
        return false;
      return $3bc517d55346f2bb$var$readFileToQuery(value, usedKey);
    }
  }).filter(Boolean);
};
const $3bc517d55346f2bb$var$extractInlineQueries = (content) => {
  let queries = [];
  let tree = $7f6f6807a3a8644e$exports().use($4ecf9a54af9f01ab$exports).use($3bc517d55346f2bb$var$ignoreIndentedCode).parse(content);
  const prismLangs = $bc540824f1c98218$exports();
  $5cnuX(tree, "code", function(node) {
    let id = node.lang ?? "untitled";
    if (id.toLowerCase() === "sql" && node.meta)
      id = node.meta;
    if (!prismLangs.has(id.toLowerCase()) && id.toLowerCase() !== "plaintext") {
      let compiledQueryString = node.value.trim();
      let inputQueryString = compiledQueryString;
      let compiled = false;
      queries.push({
        id,
        compiledQueryString,
        inputQueryString,
        compiled,
        inline: true
      });
    }
  });
  return queries;
};
const $3bc517d55346f2bb$var$strictBuild = process.env.VITE_BUILD_STRICT === "true";
const $3bc517d55346f2bb$var$circularRefErrorMsg = "Compiler error: circular reference";
const $3bc517d55346f2bb$var$extractQueries = (content) => {
  const queries = [];
  queries.push(...$3bc517d55346f2bb$var$extractExternalQueries(content));
  queries.push(...$3bc517d55346f2bb$var$extractInlineQueries(content));
  const maxIterations = 15;
  const queryIds = new Set(queries.map((d) => d.id));
  const interpolated_variables = /* @__PURE__ */ new Set();
  for (let i = 0; i <= maxIterations; i++)
    queries.forEach((query) => {
      const startTemplateInterpolation = /[^\\](\$\{)/g;
      const validTemplateInterpolation = /[^\\]\$\{((?:.|\s)+?)\}/g;
      const hasTemplates = startTemplateInterpolation.exec(query.inputQueryString);
      const hasValidTemplates = validTemplateInterpolation.exec(query.inputQueryString);
      if (hasTemplates?.length !== hasValidTemplates?.length) {
        if (query.inputQueryString.includes("${}"))
          query.compileError = "Query contains an empty template literal (${})";
        else
          query.compileError = "Query contains invalid template literal (unmatched ${ and }";
        return;
      }
      const references = query.compiledQueryString.match(/\${.*?\}/gi);
      if (references && references.some((d) => !interpolated_variables.has(d)))
        references.forEach((reference) => {
          try {
            const referencedQueryID = reference.replace("${", "").replace("}", "").trim();
            if (!queryIds.has(referencedQueryID))
              interpolated_variables.add(reference);
            else if (i >= maxIterations)
              throw new Error($3bc517d55346f2bb$var$circularRefErrorMsg);
            else {
              const referencedQuery = queries.find((d) => d.id === referencedQueryID);
              if (!query.inline && referencedQuery.inline)
                throw new Error(`Cannot reference inline query from SQL File. (Referenced ${referencedQueryID})`);
              const queryString = `(${referencedQuery.compiledQueryString})`;
              query.compiledQueryString = query.compiledQueryString.replace(reference, queryString);
              query.compiled = true;
            }
          } catch (_e) {
            const e = _e.message === void 0 || _e.message === null ? Error($3bc517d55346f2bb$var$circularRefErrorMsg) : _e;
            query.compileError = e.message;
            query.compiledQueryString = e.message;
            if ($3bc517d55346f2bb$var$strictBuild)
              throw new Error(e.message);
          }
        });
    });
  return queries;
};
const $3bc517d55346f2bb$var$getQueryIds = (content) => {
  return $3bc517d55346f2bb$var$extractQueries(content).map((q) => q.id);
};
$3bc517d55346f2bb$exports = {
  extractQueries: $3bc517d55346f2bb$var$extractQueries,
  getQueryIds: $3bc517d55346f2bb$var$getQueryIds
};
var $bb8aaf4d81463a1b$require$extractQueries = $3bc517d55346f2bb$exports.extractQueries;
var $bb8aaf4d81463a1b$require$highlighter = $365749e2073871b1$exports.highlighter;
var $5xH1P = parcelRequire("5xH1P");
var $bb8aaf4d81463a1b$require$containsFrontmatter = $5xH1P.containsFrontmatter;
const $bb8aaf4d81463a1b$var$createDefaultProps = function(filename, componentDevelopmentMode, duckdbQueries = {}) {
  const routeH = $bb8aaf4d81463a1b$require$getRouteHash(filename);
  let queryDeclarations = "";
  if (Object.keys(duckdbQueries).length > 0) {
    const IS_VALID_QUERY = /^([a-zA-Z_$][a-zA-Z0-9d_$]*)$/;
    const validIds = Object.keys(duckdbQueries).filter((query) => IS_VALID_QUERY.test(query) && !duckdbQueries[query].compileError);
    const IS_REACTIVE_QUERY = /\${.*?}/s;
    const reactiveIds = validIds.filter((id) => IS_REACTIVE_QUERY.test(duckdbQueries[id].compiledQueryString));
    const IS_INPUT_QUERY = /\${\s*inputs\s*\..*?}/s;
    const input_ids = reactiveIds.filter((id) => IS_INPUT_QUERY.test(duckdbQueries[id].compiledQueryString));
    const errQueries = Object.values(duckdbQueries).filter((q) => q.compileError).map((q) => `const ${q.id} = QueryStore.create(\`${q.compiledQueryString.replaceAll("$", "\\$")}\`, undefined, "${q.id}", { initialError: new Error(\`${q.compileError.replaceAll("$", "\\$")}\`)})`);
    const queryStoreDeclarations = validIds.map((id) => {
      return `
				$: _${id}_query_text = \`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;
				$: _${id}_has_unresolved = __checkForUnsetInputs\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`;

				if (import.meta?.hot) {
					undefined.on("evidence:queryChange", ({queryId, content}) => {
						let errors = []
						if (!queryId) errors.push("Malformed event: Missing queryId")
						if (!content) errors.push("Malformed event: Missing content")
						if (errors.length) {
							console.warn("Failed to update query on serverside change!", errors.join("\\n"))
							return
						}

						if (queryId === "${id}") {
							_${id}_query_text = content
						}
						
					})
				}

				// Initial Query
				let _${id}_initial_query;
				$: if(!_${id}_initial_query) _${id}_initial_query = _${id}_query_text;
				onMount(() => _${id}_initial_query = _${id}_query_text);
		
				// Current Query
				$: _${id}_current_query = _${id}_query_text;
				
				// Query has changed
				$: _${id}_changed = browser ? _${id}_current_query !== _${id}_initial_query : false;
				
				// Actual Query Execution
				let _${id};

				const _${id}_reactivity_manager = () => {
					const update = () => {
						let initialData, initialError;

						try {
							if (_${id}_changed || __has_hmr_run) {
								// Query changed after page load, we have no prerendered results
								initialData = undefined
								initialError = undefined
							} else if (data.${id}) {
								// Data is coming from SSR
								if (data.${id} instanceof Error) {
									throw data.${id}
								} else {
									initialData = data.${id}
								}
							} else {
								// We are currently prerendering
								initialData = profile(__db.query, _${id}_query_text, { query_name: '${id}' })
							}
						} catch (e) {
							if (!browser) {
								// If building in strict mode; we should fail, this query broke
								if ("true") throw e;
							}
							initialData = []
							initialError = e
						}

						const query_store = QueryStore.create(
							_${id}_query_text,
							queryFunc,
							'${id}',
							{
								scoreNotifier,
								initialData,
								initialError,
								noResolve: _${id}_has_unresolved
							}
						);
						
						let fetch_maybepromise = undefined
						if (!query_store.loaded) {
							fetch_maybepromise = query_store.fetch();
						}


						if (_${id}) {
							// Query has already been created
							// Fetch the data and then replace
							
							if (fetch_maybepromise instanceof Promise) {
								fetch_maybepromise.then(() => (_${id} = query_store));
							} else {
								_${id} = query_store;
							}
						} else {
							_${id} = query_store;
						}
					};
		
					update();
		
					return debounce(update, 500);
				}
		
				let _${id}_debounced_updater;
				// make sure svelte knows debounced updater is dependent on query text
				$: if (typeof _${id}_debounced_updater === 'undefined') {
                    _${id}_query_text;
                    _${id}_debounced_updater = _${id}_reactivity_manager();
                };
				// rerun if query text changes
				$: _${id}_query_text, _${id}_debounced_updater();
				// rerun if data changes during dev mode, likely source HMR
				$: if (dev) data, _${id}_debounced_updater();
			`;
    });
    const input_query_stores = `
		if (!browser) {
			onDestroy(inputs_store.subscribe((inputs) => {
				${input_ids.map((id) => `
				${id} = get(QueryStore.create(
						\`${duckdbQueries[id].compiledQueryString.replaceAll("`", "\\`")}\`,
						queryFunc,
						'${id}',
						{}
					));
				`).join("\n")}
			}));
		}
		`;
    const all_query_stores = validIds.map((id) => `$: ${id} = $_${id};`);
    queryDeclarations += `
		${errQueries.join("\n")}
		${queryStoreDeclarations.join("\n")}
		${input_query_stores}
		${all_query_stores.join("\n")}
		`;
  }
  let defaultProps = `
        import { page } from '$app/stores';
        import { pageHasQueries, routeHash, toasts } from '@evidence-dev/component-utilities/stores';
        import { setContext, getContext, beforeUpdate, onDestroy, onMount } from 'svelte';
		import { writable, get } from 'svelte/store';
        
        // Functions
        import { fmt } from '@evidence-dev/component-utilities/formatting';

		import { CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY, INPUTS_CONTEXT_KEY } from '@evidence-dev/component-utilities/globalContexts';		
        
        let props;
        export { props as data }; // little hack to make the data name not overlap
        let { data = {}, customFormattingSettings, __db, inputs } = props;
        $: ({ data = {}, customFormattingSettings, __db } = props);

        $routeHash = '${routeH}';

		${""}
		let inputs_store = writable(inputs);
		setContext(INPUTS_CONTEXT_KEY, inputs_store);
		onDestroy(inputs_store.subscribe((value) => inputs = value));

        $: pageHasQueries.set(Object.keys(data).length > 0);

        setContext(CUSTOM_FORMATTING_SETTINGS_CONTEXT_KEY, {
            getCustomFormats: () => {
                return customFormattingSettings.customFormats || [];
            }
        });

		import { browser, dev } from "$app/environment";
		import { profile } from '@evidence-dev/component-utilities/profile';
		import debounce from 'debounce';
		import { QueryStore } from '@evidence-dev/query-store';
		import { setQueryFunction } from '@evidence-dev/component-utilities/buildQuery';

		const queryFunc = (query, query_name) => profile(__db.query, query, { query_name });
		setQueryFunction(queryFunc);

		const scoreNotifier = !dev? () => {} : (info) => {
			toasts.add({
				id: Math.random(),
				title: info.id,
				message: \`Results estimated to use \${
					Intl.NumberFormat().format(info.score / (1024 * 1024))
				}mb of memory, performance may be impacted\`,
				status: 'warning'
			}, 5000);
		};

		let __has_hmr_run = false
	    if (import.meta?.hot) {
	        undefined.on("vite:afterUpdate", () => {
				__has_hmr_run = true
				QueryStore.emptyCache() // All bets are off
			})
	    }
		
		let params = $page.params;
		$: params = $page.params;

		function __checkForUnsetInputs(strings, ...args) {
			if (args.some(a => a?.__unset)) {
				return true
			} else {
				return false
			}
		}
		

        ${queryDeclarations}
    `;
  return defaultProps;
};
const $bb8aaf4d81463a1b$var$processQueries = (componentDevelopmentMode) => {
  const dynamicQueries = {};
  return {
    markup({ content, filename }) {
      if (filename.endsWith(".md")) {
        let fileQueries = $bb8aaf4d81463a1b$require$extractQueries(content);
        dynamicQueries[$bb8aaf4d81463a1b$require$getRouteHash(filename)] = fileQueries.reduce((acc, q) => {
          acc[q.id] = q;
          return acc;
        }, {});
        const externalQueryViews = "\n\n\n" + fileQueries.filter((q) => !q.inline).map((q) => {
          return $bb8aaf4d81463a1b$require$highlighter(q.compiledQueryString, q.id.toLowerCase());
        }).join("\n");
        const frontmatter = $bb8aaf4d81463a1b$require$containsFrontmatter(content);
        if (frontmatter) {
          const contentWithoutFrontmatter = content.substring(frontmatter.length + 6);
          const output = `---
${frontmatter}
---` + externalQueryViews + contentWithoutFrontmatter;
          return {
            code: output
          };
        }
        return {
          code: externalQueryViews + content
        };
      }
    },
    script({ content, filename, attributes }) {
      if (filename.endsWith(".md")) {
        if (attributes.context != "module") {
          const duckdbQueries = dynamicQueries[$bb8aaf4d81463a1b$require$getRouteHash(filename)];
          return {
            code: $bb8aaf4d81463a1b$var$createDefaultProps(filename, componentDevelopmentMode, duckdbQueries) + content
          };
        }
      }
    }
  };
};
$bb8aaf4d81463a1b$exports = $bb8aaf4d81463a1b$var$processQueries;
var $283f418c0f57366a$exports = {};
var $eb0fced0eff13ef9$exports = {};
$parcel$export($eb0fced0eff13ef9$exports, "matches", () => $3c8bc001a91ed78a$export$de994efd351b291c);
$parcel$export($eb0fced0eff13ef9$exports, "select", () => $3c8bc001a91ed78a$export$2e6c959c16ff56b8);
$parcel$export($eb0fced0eff13ef9$exports, "selectAll", () => $3c8bc001a91ed78a$export$90aca4adda6ff0f5);
class $aeb03138839d5479$export$19342e026b58ebb7 {
  /**
  * @constructor
  * @param {Properties} property
  * @param {Normal} normal
  * @param {string} [space]
  */
  constructor(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space)
      this.space = space;
  }
}
$aeb03138839d5479$export$19342e026b58ebb7.prototype.property = {};
$aeb03138839d5479$export$19342e026b58ebb7.prototype.normal = {};
$aeb03138839d5479$export$19342e026b58ebb7.prototype.space = null;
function $ee955db8a177ae50$export$4950aa0f605343fb(definitions, space) {
  const property = {};
  const normal = {};
  let index = -1;
  while (++index < definitions.length) {
    Object.assign(property, definitions[index].property);
    Object.assign(normal, definitions[index].normal);
  }
  return new $aeb03138839d5479$export$19342e026b58ebb7(property, normal, space);
}
function $c0cbded1258b50dd$export$a3295358bff77e(value) {
  return value.toLowerCase();
}
class $88a04fe869d4ccb4$export$c4868e4a24d48fad {
  /**
  * @constructor
  * @param {string} property
  * @param {string} attribute
  */
  constructor(property, attribute) {
    this.property = property;
    this.attribute = attribute;
  }
}
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.space = null;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.boolean = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.booleanish = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.overloadedBoolean = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.number = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.commaSeparated = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.spaceSeparated = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.commaOrSpaceSeparated = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.mustUseProperty = false;
$88a04fe869d4ccb4$export$c4868e4a24d48fad.prototype.defined = false;
var $76a3ad9a7c278548$exports = {};
$parcel$export($76a3ad9a7c278548$exports, "boolean", () => $76a3ad9a7c278548$export$4a21f16c33752377);
$parcel$export($76a3ad9a7c278548$exports, "booleanish", () => $76a3ad9a7c278548$export$55e9e1fbc638dc8f);
$parcel$export($76a3ad9a7c278548$exports, "overloadedBoolean", () => $76a3ad9a7c278548$export$242ac3d3042558aa);
$parcel$export($76a3ad9a7c278548$exports, "number", () => $76a3ad9a7c278548$export$98e628dec113755e);
$parcel$export($76a3ad9a7c278548$exports, "spaceSeparated", () => $76a3ad9a7c278548$export$ab8645c862eb5a3e);
$parcel$export($76a3ad9a7c278548$exports, "commaSeparated", () => $76a3ad9a7c278548$export$9c8d678629b3d3);
$parcel$export($76a3ad9a7c278548$exports, "commaOrSpaceSeparated", () => $76a3ad9a7c278548$export$2ad25cfebf36cacd);
let $76a3ad9a7c278548$var$powers = 0;
const $76a3ad9a7c278548$export$4a21f16c33752377 = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$55e9e1fbc638dc8f = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$242ac3d3042558aa = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$98e628dec113755e = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$ab8645c862eb5a3e = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$9c8d678629b3d3 = $76a3ad9a7c278548$var$increment();
const $76a3ad9a7c278548$export$2ad25cfebf36cacd = $76a3ad9a7c278548$var$increment();
function $76a3ad9a7c278548$var$increment() {
  return 2 ** ++$76a3ad9a7c278548$var$powers;
}
const $5e28067120a690f2$var$checks = Object.keys($76a3ad9a7c278548$exports);
class $5e28067120a690f2$export$ea6b9f0064e88c9b extends $88a04fe869d4ccb4$export$c4868e4a24d48fad {
  /**
  * @constructor
  * @param {string} property
  * @param {string} attribute
  * @param {number|null} [mask]
  * @param {string} [space]
  */
  constructor(property, attribute, mask, space) {
    let index = -1;
    super(property, attribute);
    $5e28067120a690f2$var$mark(this, "space", space);
    if (typeof mask === "number")
      while (++index < $5e28067120a690f2$var$checks.length) {
        const check = $5e28067120a690f2$var$checks[index];
        $5e28067120a690f2$var$mark(this, $5e28067120a690f2$var$checks[index], (mask & $76a3ad9a7c278548$exports[check]) === $76a3ad9a7c278548$exports[check]);
      }
  }
}
$5e28067120a690f2$export$ea6b9f0064e88c9b.prototype.defined = true;
function $5e28067120a690f2$var$mark(values, key, value) {
  if (value)
    values[key] = value;
}
const $9066aadbbde7f399$var$own = {}.hasOwnProperty;
function $9066aadbbde7f399$export$185802fd694ee1f5(definition) {
  const property = {};
  const normal = {};
  let prop;
  for (prop in definition.properties)
    if ($9066aadbbde7f399$var$own.call(definition.properties, prop)) {
      const value = definition.properties[prop];
      const info = new $5e28067120a690f2$export$ea6b9f0064e88c9b(prop, definition.transform(definition.attributes || {}, prop), value, definition.space);
      if (definition.mustUseProperty && definition.mustUseProperty.includes(prop))
        info.mustUseProperty = true;
      property[prop] = info;
      normal[$c0cbded1258b50dd$export$a3295358bff77e(prop)] = prop;
      normal[$c0cbded1258b50dd$export$a3295358bff77e(info.attribute)] = prop;
    }
  return new $aeb03138839d5479$export$19342e026b58ebb7(property, normal, definition.space);
}
const $7c7bbc4118f11718$export$2bd1230ec7600845 = $9066aadbbde7f399$export$185802fd694ee1f5({
  space: "xlink",
  transform(_, prop) {
    return "xlink:" + prop.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
const $60f5eef93a090a30$export$f2913fe8983302e = $9066aadbbde7f399$export$185802fd694ee1f5({
  space: "xml",
  transform(_, prop) {
    return "xml:" + prop.slice(3).toLowerCase();
  },
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function $83bf63b3108058a6$export$5b10b3bc32d7efbc(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute;
}
function $5bd3b09f6716dfcb$export$32b9e4cec9c208e1(attributes, property) {
  return $83bf63b3108058a6$export$5b10b3bc32d7efbc(attributes, property.toLowerCase());
}
const $324f866611dd1b2b$export$e20c24a128671213 = $9066aadbbde7f399$export$185802fd694ee1f5({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: $5bd3b09f6716dfcb$export$32b9e4cec9c208e1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
const $daa3ec292e672965$export$4d2d26490572750a = $9066aadbbde7f399$export$185802fd694ee1f5({
  transform(_, prop) {
    return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaAutoComplete: null,
    ariaBusy: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaChecked: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaColCount: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaColIndex: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaColSpan: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaControls: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaCurrent: null,
    ariaDescribedBy: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaDetails: null,
    ariaDisabled: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaDropEffect: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaErrorMessage: null,
    ariaExpanded: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaFlowTo: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaGrabbed: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaHasPopup: null,
    ariaHidden: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaLevel: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaLive: null,
    ariaModal: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaMultiLine: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaMultiSelectable: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaOrientation: null,
    ariaOwns: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaPlaceholder: null,
    ariaPosInSet: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaPressed: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaReadOnly: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaRelevant: null,
    ariaRequired: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaRoleDescription: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    ariaRowCount: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaRowIndex: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaRowSpan: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaSelected: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    ariaSetSize: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaSort: null,
    ariaValueMax: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaValueMin: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaValueNow: $76a3ad9a7c278548$export$98e628dec113755e,
    ariaValueText: null,
    role: null
  }
});
const $577b1e32f9e70a13$export$c0bb0b647f701bb5 = $9066aadbbde7f399$export$185802fd694ee1f5({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: $5bd3b09f6716dfcb$export$32b9e4cec9c208e1,
  mustUseProperty: [
    "checked",
    "multiple",
    "muted",
    "selected"
  ],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: $76a3ad9a7c278548$export$9c8d678629b3d3,
    acceptCharset: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    accessKey: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    action: null,
    allow: null,
    allowFullScreen: $76a3ad9a7c278548$export$4a21f16c33752377,
    allowPaymentRequest: $76a3ad9a7c278548$export$4a21f16c33752377,
    allowUserMedia: $76a3ad9a7c278548$export$4a21f16c33752377,
    alt: null,
    as: null,
    async: $76a3ad9a7c278548$export$4a21f16c33752377,
    autoCapitalize: null,
    autoComplete: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    autoFocus: $76a3ad9a7c278548$export$4a21f16c33752377,
    autoPlay: $76a3ad9a7c278548$export$4a21f16c33752377,
    blocking: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    capture: $76a3ad9a7c278548$export$4a21f16c33752377,
    charSet: null,
    checked: $76a3ad9a7c278548$export$4a21f16c33752377,
    cite: null,
    className: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    cols: $76a3ad9a7c278548$export$98e628dec113755e,
    colSpan: null,
    content: null,
    contentEditable: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    controls: $76a3ad9a7c278548$export$4a21f16c33752377,
    controlsList: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    coords: $76a3ad9a7c278548$export$98e628dec113755e | $76a3ad9a7c278548$export$9c8d678629b3d3,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: $76a3ad9a7c278548$export$4a21f16c33752377,
    defer: $76a3ad9a7c278548$export$4a21f16c33752377,
    dir: null,
    dirName: null,
    disabled: $76a3ad9a7c278548$export$4a21f16c33752377,
    download: $76a3ad9a7c278548$export$242ac3d3042558aa,
    draggable: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: $76a3ad9a7c278548$export$4a21f16c33752377,
    formTarget: null,
    headers: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    height: $76a3ad9a7c278548$export$98e628dec113755e,
    hidden: $76a3ad9a7c278548$export$4a21f16c33752377,
    high: $76a3ad9a7c278548$export$98e628dec113755e,
    href: null,
    hrefLang: null,
    htmlFor: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    httpEquiv: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: $76a3ad9a7c278548$export$4a21f16c33752377,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: $76a3ad9a7c278548$export$4a21f16c33752377,
    itemId: null,
    itemProp: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    itemRef: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    itemScope: $76a3ad9a7c278548$export$4a21f16c33752377,
    itemType: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: $76a3ad9a7c278548$export$4a21f16c33752377,
    low: $76a3ad9a7c278548$export$98e628dec113755e,
    manifest: null,
    max: null,
    maxLength: $76a3ad9a7c278548$export$98e628dec113755e,
    media: null,
    method: null,
    min: null,
    minLength: $76a3ad9a7c278548$export$98e628dec113755e,
    multiple: $76a3ad9a7c278548$export$4a21f16c33752377,
    muted: $76a3ad9a7c278548$export$4a21f16c33752377,
    name: null,
    nonce: null,
    noModule: $76a3ad9a7c278548$export$4a21f16c33752377,
    noValidate: $76a3ad9a7c278548$export$4a21f16c33752377,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: $76a3ad9a7c278548$export$4a21f16c33752377,
    optimum: $76a3ad9a7c278548$export$98e628dec113755e,
    pattern: null,
    ping: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    placeholder: null,
    playsInline: $76a3ad9a7c278548$export$4a21f16c33752377,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: $76a3ad9a7c278548$export$4a21f16c33752377,
    referrerPolicy: null,
    rel: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    required: $76a3ad9a7c278548$export$4a21f16c33752377,
    reversed: $76a3ad9a7c278548$export$4a21f16c33752377,
    rows: $76a3ad9a7c278548$export$98e628dec113755e,
    rowSpan: $76a3ad9a7c278548$export$98e628dec113755e,
    sandbox: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    scope: null,
    scoped: $76a3ad9a7c278548$export$4a21f16c33752377,
    seamless: $76a3ad9a7c278548$export$4a21f16c33752377,
    selected: $76a3ad9a7c278548$export$4a21f16c33752377,
    shadowRootDelegatesFocus: $76a3ad9a7c278548$export$4a21f16c33752377,
    shadowRootMode: null,
    shape: null,
    size: $76a3ad9a7c278548$export$98e628dec113755e,
    sizes: null,
    slot: null,
    span: $76a3ad9a7c278548$export$98e628dec113755e,
    spellCheck: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: $76a3ad9a7c278548$export$98e628dec113755e,
    step: null,
    style: null,
    tabIndex: $76a3ad9a7c278548$export$98e628dec113755e,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: $76a3ad9a7c278548$export$4a21f16c33752377,
    useMap: null,
    value: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    width: $76a3ad9a7c278548$export$98e628dec113755e,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    aLink: null,
    archive: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    axis: null,
    background: null,
    bgColor: null,
    border: $76a3ad9a7c278548$export$98e628dec113755e,
    borderColor: null,
    bottomMargin: $76a3ad9a7c278548$export$98e628dec113755e,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: $76a3ad9a7c278548$export$4a21f16c33752377,
    declare: $76a3ad9a7c278548$export$4a21f16c33752377,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: $76a3ad9a7c278548$export$98e628dec113755e,
    leftMargin: $76a3ad9a7c278548$export$98e628dec113755e,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: $76a3ad9a7c278548$export$98e628dec113755e,
    marginWidth: $76a3ad9a7c278548$export$98e628dec113755e,
    noResize: $76a3ad9a7c278548$export$4a21f16c33752377,
    noHref: $76a3ad9a7c278548$export$4a21f16c33752377,
    noShade: $76a3ad9a7c278548$export$4a21f16c33752377,
    noWrap: $76a3ad9a7c278548$export$4a21f16c33752377,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: $76a3ad9a7c278548$export$98e628dec113755e,
    rules: null,
    scheme: null,
    scrolling: $76a3ad9a7c278548$export$55e9e1fbc638dc8f,
    standby: null,
    summary: null,
    text: null,
    topMargin: $76a3ad9a7c278548$export$98e628dec113755e,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: $76a3ad9a7c278548$export$98e628dec113755e,
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: $76a3ad9a7c278548$export$4a21f16c33752377,
    disableRemotePlayback: $76a3ad9a7c278548$export$4a21f16c33752377,
    prefix: null,
    property: null,
    results: $76a3ad9a7c278548$export$98e628dec113755e,
    security: null,
    unselectable: null
  }
});
const $988b93874e014269$export$7ed1367e7fa1ad68 = $9066aadbbde7f399$export$185802fd694ee1f5({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: $83bf63b3108058a6$export$5b10b3bc32d7efbc,
  properties: {
    about: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    accentHeight: $76a3ad9a7c278548$export$98e628dec113755e,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: $76a3ad9a7c278548$export$98e628dec113755e,
    amplitude: $76a3ad9a7c278548$export$98e628dec113755e,
    arabicForm: null,
    ascent: $76a3ad9a7c278548$export$98e628dec113755e,
    attributeName: null,
    attributeType: null,
    azimuth: $76a3ad9a7c278548$export$98e628dec113755e,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: $76a3ad9a7c278548$export$98e628dec113755e,
    by: null,
    calcMode: null,
    capHeight: $76a3ad9a7c278548$export$98e628dec113755e,
    className: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: $76a3ad9a7c278548$export$98e628dec113755e,
    diffuseConstant: $76a3ad9a7c278548$export$98e628dec113755e,
    direction: null,
    display: null,
    dur: null,
    divisor: $76a3ad9a7c278548$export$98e628dec113755e,
    dominantBaseline: null,
    download: $76a3ad9a7c278548$export$4a21f16c33752377,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: $76a3ad9a7c278548$export$98e628dec113755e,
    enableBackground: null,
    end: null,
    event: null,
    exponent: $76a3ad9a7c278548$export$98e628dec113755e,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: $76a3ad9a7c278548$export$98e628dec113755e,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: $76a3ad9a7c278548$export$9c8d678629b3d3,
    g2: $76a3ad9a7c278548$export$9c8d678629b3d3,
    glyphName: $76a3ad9a7c278548$export$9c8d678629b3d3,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: $76a3ad9a7c278548$export$98e628dec113755e,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: $76a3ad9a7c278548$export$98e628dec113755e,
    horizOriginX: $76a3ad9a7c278548$export$98e628dec113755e,
    horizOriginY: $76a3ad9a7c278548$export$98e628dec113755e,
    id: null,
    ideographic: $76a3ad9a7c278548$export$98e628dec113755e,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: $76a3ad9a7c278548$export$98e628dec113755e,
    k: $76a3ad9a7c278548$export$98e628dec113755e,
    k1: $76a3ad9a7c278548$export$98e628dec113755e,
    k2: $76a3ad9a7c278548$export$98e628dec113755e,
    k3: $76a3ad9a7c278548$export$98e628dec113755e,
    k4: $76a3ad9a7c278548$export$98e628dec113755e,
    kernelMatrix: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    kernelUnitLength: null,
    keyPoints: null,
    keySplines: null,
    keyTimes: null,
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: $76a3ad9a7c278548$export$98e628dec113755e,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: $76a3ad9a7c278548$export$98e628dec113755e,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: $76a3ad9a7c278548$export$98e628dec113755e,
    overlineThickness: $76a3ad9a7c278548$export$98e628dec113755e,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: $76a3ad9a7c278548$export$98e628dec113755e,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: $76a3ad9a7c278548$export$ab8645c862eb5a3e,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: $76a3ad9a7c278548$export$98e628dec113755e,
    pointsAtY: $76a3ad9a7c278548$export$98e628dec113755e,
    pointsAtZ: $76a3ad9a7c278548$export$98e628dec113755e,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    rev: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    requiredFeatures: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    requiredFonts: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    requiredFormats: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: $76a3ad9a7c278548$export$98e628dec113755e,
    specularExponent: $76a3ad9a7c278548$export$98e628dec113755e,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: $76a3ad9a7c278548$export$98e628dec113755e,
    strikethroughThickness: $76a3ad9a7c278548$export$98e628dec113755e,
    string: null,
    stroke: null,
    strokeDashArray: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: $76a3ad9a7c278548$export$98e628dec113755e,
    strokeOpacity: $76a3ad9a7c278548$export$98e628dec113755e,
    strokeWidth: null,
    style: null,
    surfaceScale: $76a3ad9a7c278548$export$98e628dec113755e,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    tabIndex: $76a3ad9a7c278548$export$98e628dec113755e,
    tableValues: null,
    target: null,
    targetX: $76a3ad9a7c278548$export$98e628dec113755e,
    targetY: $76a3ad9a7c278548$export$98e628dec113755e,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: $76a3ad9a7c278548$export$2ad25cfebf36cacd,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: $76a3ad9a7c278548$export$98e628dec113755e,
    underlineThickness: $76a3ad9a7c278548$export$98e628dec113755e,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: $76a3ad9a7c278548$export$98e628dec113755e,
    values: null,
    vAlphabetic: $76a3ad9a7c278548$export$98e628dec113755e,
    vMathematical: $76a3ad9a7c278548$export$98e628dec113755e,
    vectorEffect: null,
    vHanging: $76a3ad9a7c278548$export$98e628dec113755e,
    vIdeographic: $76a3ad9a7c278548$export$98e628dec113755e,
    version: null,
    vertAdvY: $76a3ad9a7c278548$export$98e628dec113755e,
    vertOriginX: $76a3ad9a7c278548$export$98e628dec113755e,
    vertOriginY: $76a3ad9a7c278548$export$98e628dec113755e,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: $76a3ad9a7c278548$export$98e628dec113755e,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
const $99a18b853cde2813$var$valid = /^data[-\w.:]+$/i;
const $99a18b853cde2813$var$dash = /-[a-z]/g;
const $99a18b853cde2813$var$cap = /[A-Z]/g;
function $99a18b853cde2813$export$71aa6c912b956294(schema, value) {
  const normal = $c0cbded1258b50dd$export$a3295358bff77e(value);
  let prop = value;
  let Type = $88a04fe869d4ccb4$export$c4868e4a24d48fad;
  if (normal in schema.normal)
    return schema.property[schema.normal[normal]];
  if (normal.length > 4 && normal.slice(0, 4) === "data" && $99a18b853cde2813$var$valid.test(value)) {
    if (value.charAt(4) === "-") {
      const rest = value.slice(5).replace($99a18b853cde2813$var$dash, $99a18b853cde2813$var$camelcase);
      prop = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      const rest = value.slice(4);
      if (!$99a18b853cde2813$var$dash.test(rest)) {
        let dashes = rest.replace($99a18b853cde2813$var$cap, $99a18b853cde2813$var$kebab);
        if (dashes.charAt(0) !== "-")
          dashes = "-" + dashes;
        value = "data" + dashes;
      }
    }
    Type = $5e28067120a690f2$export$ea6b9f0064e88c9b;
  }
  return new Type(prop, value);
}
function $99a18b853cde2813$var$kebab($0) {
  return "-" + $0.toLowerCase();
}
function $99a18b853cde2813$var$camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
const $ecf66900736272d0$export$c0bb0b647f701bb5 = $ee955db8a177ae50$export$4950aa0f605343fb([
  $60f5eef93a090a30$export$f2913fe8983302e,
  $7c7bbc4118f11718$export$2bd1230ec7600845,
  $324f866611dd1b2b$export$e20c24a128671213,
  $daa3ec292e672965$export$4d2d26490572750a,
  $577b1e32f9e70a13$export$c0bb0b647f701bb5
], "html");
const $ecf66900736272d0$export$7ed1367e7fa1ad68 = $ee955db8a177ae50$export$4950aa0f605343fb([
  $60f5eef93a090a30$export$f2913fe8983302e,
  $7c7bbc4118f11718$export$2bd1230ec7600845,
  $324f866611dd1b2b$export$e20c24a128671213,
  $daa3ec292e672965$export$4d2d26490572750a,
  $988b93874e014269$export$7ed1367e7fa1ad68
], "svg");
const $4d7f0cfb8aa82529$var$rtlRange = "֑-߿יִ-﷽ﹰ-ﻼ";
const $4d7f0cfb8aa82529$var$ltrRange = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
const $4d7f0cfb8aa82529$var$rtl = new RegExp("^[^" + $4d7f0cfb8aa82529$var$ltrRange + "]*[" + $4d7f0cfb8aa82529$var$rtlRange + "]");
const $4d7f0cfb8aa82529$var$ltr = new RegExp("^[^" + $4d7f0cfb8aa82529$var$rtlRange + "]*[" + $4d7f0cfb8aa82529$var$ltrRange + "]");
function $4d7f0cfb8aa82529$export$9fddb9d0dd7d8a54(value) {
  const source = String(value || "");
  return $4d7f0cfb8aa82529$var$rtl.test(source) ? "rtl" : $4d7f0cfb8aa82529$var$ltr.test(source) ? "ltr" : "neutral";
}
function $3906261811062ae3$export$f84e8e69fd4488a5(node) {
  if ("children" in node)
    return $3906261811062ae3$var$all(node);
  return "value" in node ? node.value : "";
}
function $3906261811062ae3$var$one(node) {
  if (node.type === "text")
    return node.value;
  return "children" in node ? $3906261811062ae3$var$all(node) : "";
}
function $3906261811062ae3$var$all(node) {
  let index = -1;
  const result = [];
  while (++index < node.children.length)
    result[index] = $3906261811062ae3$var$one(node.children[index]);
  return result.join("");
}
const $f39978d975233efe$export$9c68d69a4c5bbcf9 = (
  /**
  * @type {(
  *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
  *   ((test?: Test) => AssertAnything)
  * )}
  */
  /**
  * @param {Test} [test]
  * @returns {AssertAnything}
  */
  function(test) {
    if (test === void 0 || test === null)
      return $f39978d975233efe$var$ok;
    if (typeof test === "string")
      return $f39978d975233efe$var$typeFactory(test);
    if (typeof test === "object")
      return Array.isArray(test) ? $f39978d975233efe$var$anyFactory(test) : $f39978d975233efe$var$propsFactory(test);
    if (typeof test === "function")
      return $f39978d975233efe$var$castFactory(test);
    throw new Error("Expected function, string, or object as test");
  }
);
function $f39978d975233efe$var$anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length)
    checks[index] = $f39978d975233efe$export$9c68d69a4c5bbcf9(tests[index]);
  return $f39978d975233efe$var$castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].call(this, ...parameters))
        return true;
    }
    return false;
  }
}
function $f39978d975233efe$var$propsFactory(check) {
  return $f39978d975233efe$var$castFactory(all);
  function all(node) {
    let key;
    for (key in check) {
      if (node[key] !== check[key])
        return false;
    }
    return true;
  }
}
function $f39978d975233efe$var$typeFactory(check) {
  return $f39978d975233efe$var$castFactory(type);
  function type(node) {
    return node && node.type === check;
  }
}
function $f39978d975233efe$var$castFactory(check) {
  return assertion;
  function assertion(node, ...parameters) {
    return Boolean(node && typeof node === "object" && "type" in node && // @ts-expect-error: fine.
    Boolean(check.call(this, node, ...parameters)));
  }
}
function $f39978d975233efe$var$ok() {
  return true;
}
function $f29933faf25f3a8a$export$35e9368ef982300f(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}
const $db76ae54c0965a56$export$f4d8133c446fe484 = true;
const $db76ae54c0965a56$export$7f100f842f565dc9 = false;
const $db76ae54c0965a56$export$8773f85c2fb2c116 = "skip";
const $db76ae54c0965a56$export$70008a21eb6de899 = (
  /**
  * @type {(
  *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
  *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
  * )}
  */
  /**
  * @param {Node} tree
  * @param {Test} test
  * @param {Visitor<Node>} visitor
  * @param {boolean | null | undefined} [reverse]
  * @returns {void}
  */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is = $f39978d975233efe$export$9c68d69a4c5bbcf9(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node, index, parents) {
      const value = node && typeof node === "object" ? node : {};
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0
        );
        Object.defineProperty(visit, "name", {
          value: "node (" + $f29933faf25f3a8a$export$35e9368ef982300f(node.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit;
      function visit() {
        let result = [];
        let subresult;
        let offset;
        let grandparents;
        if (!test || is(node, index, parents[parents.length - 1] || null)) {
          result = $db76ae54c0965a56$var$toResult(visitor(node, parents));
          if (result[0] === $db76ae54c0965a56$export$7f100f842f565dc9)
            return result;
        }
        if (node.children && result[0] !== $db76ae54c0965a56$export$8773f85c2fb2c116) {
          offset = (reverse ? node.children.length : -1) + step;
          grandparents = parents.concat(node);
          while (offset > -1 && offset < node.children.length) {
            subresult = factory(node.children[offset], offset, grandparents)();
            if (subresult[0] === $db76ae54c0965a56$export$7f100f842f565dc9)
              return subresult;
            offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
          }
        }
        return result;
      }
    }
  }
);
function $db76ae54c0965a56$var$toResult(value) {
  if (Array.isArray(value))
    return value;
  if (typeof value === "number")
    return [
      $db76ae54c0965a56$export$f4d8133c446fe484,
      value
    ];
  return [
    value
  ];
}
const $289d4c6ee6457b3d$export$bf638b60ea8b89b7 = (
  /**
  * @type {(
  *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
  *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
  * )}
  */
  /**
  * @param {Node} tree
  * @param {Test} test
  * @param {Visitor} visitor
  * @param {boolean | null | undefined} [reverse]
  * @returns {void}
  */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    $db76ae54c0965a56$export$70008a21eb6de899(tree, test, overload, reverse);
    function overload(node, parents) {
      const parent = parents[parents.length - 1];
      return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
    }
  }
);
function $e904230d8788bdad$export$b6a91203b6b36f(state, node) {
  const schema = state.schema;
  const language = state.language;
  const currentDirection = state.direction;
  const editableOrEditingHost = state.editableOrEditingHost;
  let dirInferred;
  if (node.type === "element" && node.properties) {
    const lang = node.properties.xmlLang || node.properties.lang;
    const type = node.properties.type || "text";
    const dir = $e904230d8788bdad$var$dirProperty(node);
    if (lang !== void 0 && lang !== null)
      state.language = String(lang);
    if (schema && schema.space === "html") {
      if (node.properties.contentEditable === "true")
        state.editableOrEditingHost = true;
      if (node.tagName === "svg")
        state.schema = $ecf66900736272d0$export$7ed1367e7fa1ad68;
      if (dir === "rtl")
        dirInferred = dir;
      else if (
        // Explicit `[dir=ltr]`.
        dir === "ltr" || // HTML with an invalid or no `[dir]`.
        dir !== "auto" && node.tagName === "html" || // `input[type=tel]` with an invalid or no `[dir]`.
        dir !== "auto" && node.tagName === "input" && type === "tel"
      )
        dirInferred = "ltr";
      else if (dir === "auto" || node.tagName === "bdi") {
        if (node.tagName === "textarea")
          dirInferred = $e904230d8788bdad$var$dirBidi($3906261811062ae3$export$f84e8e69fd4488a5(node));
        else if (node.tagName === "input" && (type === "email" || type === "search" || type === "tel" || type === "text"))
          dirInferred = node.properties.value ? $e904230d8788bdad$var$dirBidi(node.properties.value) : "ltr";
        else
          $289d4c6ee6457b3d$export$bf638b60ea8b89b7(node, inferDirectionality);
      }
      if (dirInferred)
        state.direction = dirInferred;
    } else if (state.editableOrEditingHost)
      state.editableOrEditingHost = false;
  }
  return reset;
  function reset() {
    state.schema = schema;
    state.language = language;
    state.direction = currentDirection;
    state.editableOrEditingHost = editableOrEditingHost;
  }
  function inferDirectionality(child) {
    if (child.type === "text") {
      dirInferred = $e904230d8788bdad$var$dirBidi(child.value);
      return dirInferred ? $db76ae54c0965a56$export$7f100f842f565dc9 : void 0;
    }
    if (child !== node && child.type === "element" && (child.tagName === "bdi" || child.tagName === "script" || child.tagName === "style" || child.tagName === "textare" || $e904230d8788bdad$var$dirProperty(child)))
      return $db76ae54c0965a56$export$8773f85c2fb2c116;
  }
}
function $e904230d8788bdad$var$dirBidi(value) {
  const result = $4d7f0cfb8aa82529$export$9fddb9d0dd7d8a54(value);
  return result === "neutral" ? void 0 : result;
}
function $e904230d8788bdad$var$dirProperty(node) {
  const value = node.type === "element" && node.properties && typeof node.properties.dir === "string" ? node.properties.dir.toLowerCase() : void 0;
  return value === "auto" || value === "ltr" || value === "rtl" ? value : void 0;
}
function $0c63d871a212e575$export$98e6a39c04603d36(value) {
  const tokens = [];
  const input = String(value || "");
  let index = input.indexOf(",");
  let start = 0;
  let end = false;
  while (!end) {
    if (index === -1) {
      index = input.length;
      end = true;
    }
    const token = input.slice(start, index).trim();
    if (token || !end)
      tokens.push(token);
    start = index + 1;
    index = input.indexOf(",", start);
  }
  return tokens;
}
function $0c63d871a212e575$export$fac44ee5b035f737(values, options) {
  const settings = options || {};
  const input = values[values.length - 1] === "" ? [
    ...values,
    ""
  ] : values;
  return input.join((settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")).trim();
}
const $987364a2ac7dd705$var$own = {}.hasOwnProperty;
function $987364a2ac7dd705$export$bf9617eaf5d2451(node, field) {
  const value = typeof field === "string" && $987364a2ac7dd705$var$isNode(node) && node.type === "element" && node.properties && $987364a2ac7dd705$var$own.call(node.properties, field) && node.properties[field];
  return value !== null && value !== void 0 && value !== false;
}
function $987364a2ac7dd705$var$isNode(value) {
  return Boolean(value && typeof value === "object" && "type" in value);
}
function $d4dc163a2878d994$export$fac44ee5b035f737(values) {
  return values.join(" ").trim();
}
const $4515cf84e19a07d6$var$own = {}.hasOwnProperty;
function $4515cf84e19a07d6$export$d6a12bfbbedf6185(key, options) {
  const settings = options || {};
  function one(value, ...parameters) {
    let fn = one.invalid;
    const handlers = one.handlers;
    if (value && $4515cf84e19a07d6$var$own.call(value, key)) {
      const id = String(value[key]);
      fn = $4515cf84e19a07d6$var$own.call(handlers, id) ? handlers[id] : one.unknown;
    }
    if (fn)
      return fn.call(this, value, ...parameters);
  }
  one.handlers = settings.handlers || {};
  one.invalid = settings.invalid;
  one.unknown = settings.unknown;
  return one;
}
const $f1fd158f99fe7ac5$var$handle = $4515cf84e19a07d6$export$d6a12bfbbedf6185("operator", {
  unknown: $f1fd158f99fe7ac5$var$unknownOperator,
  // @ts-expect-error: hush.
  invalid: $f1fd158f99fe7ac5$var$exists,
  handlers: {
    "=": $f1fd158f99fe7ac5$var$exact,
    "~=": $f1fd158f99fe7ac5$var$spaceSeparatedList,
    "|=": $f1fd158f99fe7ac5$var$exactOrPrefix,
    "^=": $f1fd158f99fe7ac5$var$begins,
    "$=": $f1fd158f99fe7ac5$var$ends,
    "*=": $f1fd158f99fe7ac5$var$contains
  }
});
function $f1fd158f99fe7ac5$export$af4b9a83f4b00434(query, element, schema) {
  const attrs = query.attrs;
  let index = -1;
  while (++index < attrs.length) {
    if (!$f1fd158f99fe7ac5$var$handle(attrs[index], element, $99a18b853cde2813$export$71aa6c912b956294(schema, attrs[index].name)))
      return false;
  }
  return true;
}
function $f1fd158f99fe7ac5$var$exists(_, element, info) {
  return $987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property);
}
function $f1fd158f99fe7ac5$var$exact(query, element, info) {
  return Boolean($987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && element.properties && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info) === query.value);
}
function $f1fd158f99fe7ac5$var$spaceSeparatedList(query, element, info) {
  const value = element.properties && element.properties[info.property];
  return (
    // If this is a space-separated list, and the query is contained in it, return
    // true.
    !info.commaSeparated && value && typeof value === "object" && query.value && value.includes(query.value) || // For all other values (including comma-separated lists), return whether this
    // is an exact match.
    $987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && $f1fd158f99fe7ac5$var$normalizeValue(value, info) === query.value
  );
}
function $f1fd158f99fe7ac5$var$exactOrPrefix(query, element, info) {
  const value = $f1fd158f99fe7ac5$var$normalizeValue(element.properties && element.properties[info.property], info);
  return Boolean($987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && query.value && (value === query.value || value.slice(0, query.value.length) === query.value && value.charAt(query.value.length) === "-"));
}
function $f1fd158f99fe7ac5$var$begins(query, element, info) {
  return Boolean($987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).slice(0, query.value.length) === query.value);
}
function $f1fd158f99fe7ac5$var$ends(query, element, info) {
  return Boolean($987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).slice(-query.value.length) === query.value);
}
function $f1fd158f99fe7ac5$var$contains(query, element, info) {
  return Boolean($987364a2ac7dd705$export$bf9617eaf5d2451(element, info.property) && element.properties && query.value && $f1fd158f99fe7ac5$var$normalizeValue(element.properties[info.property], info).includes(query.value));
}
function $f1fd158f99fe7ac5$var$unknownOperator(query) {
  throw new Error("Unknown operator `" + query.operator + "`");
}
function $f1fd158f99fe7ac5$var$normalizeValue(value, info) {
  if (typeof value === "boolean")
    return info.attribute;
  if (Array.isArray(value))
    return (info.commaSeparated ? $0c63d871a212e575$export$fac44ee5b035f737 : $d4dc163a2878d994$export$fac44ee5b035f737)(value);
  return String(value);
}
function $4e560857536fc474$export$2913c0c0b5623090(query, element) {
  const value = element.properties.className || [];
  let index = -1;
  if (query.classNames)
    while (++index < query.classNames.length) {
      if (!value.includes(query.classNames[index]))
        return false;
    }
  return true;
}
function $fda01db12207d90d$export$d560c7e4a29451c2(query, element) {
  return Boolean(element.properties && element.properties.id === query.id);
}
function $3bcd2419cb986896$export$a8ff84c12d48cfa6(query, element) {
  return query.tagName === "*" || query.tagName === element.tagName;
}
function $09d8790eeaaaa3c4$var$factory(check, filter) {
  return function(tags, ranges) {
    let left = $09d8790eeaaaa3c4$var$cast(tags, "tag");
    const right = $09d8790eeaaaa3c4$var$cast(ranges === null || ranges === void 0 ? "*" : ranges, "range");
    const matches = [];
    let rightIndex = -1;
    while (++rightIndex < right.length) {
      const range = right[rightIndex].toLowerCase();
      if (!filter && range === "*")
        continue;
      let leftIndex = -1;
      const next = [];
      while (++leftIndex < left.length)
        if (check(left[leftIndex].toLowerCase(), range)) {
          if (!filter)
            return (
              /** @type {IsFilter extends true ? Tags : Tag|undefined} */
              left[leftIndex]
            );
          matches.push(left[leftIndex]);
        } else
          next.push(left[leftIndex]);
      left = next;
    }
    return (
      /** @type {IsFilter extends true ? Tags : Tag|undefined} */
      filter ? matches : void 0
    );
  };
}
const $09d8790eeaaaa3c4$export$d216e65da1a9aa7e = $09d8790eeaaaa3c4$var$factory(function(tag, range) {
  const left = tag.split("-");
  const right = range.split("-");
  let leftIndex = 0;
  let rightIndex = 0;
  if (right[rightIndex] !== "*" && left[leftIndex] !== right[rightIndex])
    return false;
  leftIndex++;
  rightIndex++;
  while (rightIndex < right.length) {
    if (right[rightIndex] === "*") {
      rightIndex++;
      continue;
    }
    if (!left[leftIndex])
      return false;
    if (left[leftIndex] === right[rightIndex]) {
      leftIndex++;
      rightIndex++;
      continue;
    }
    if (left[leftIndex].length === 1)
      return false;
    leftIndex++;
  }
  return true;
}, true);
function $09d8790eeaaaa3c4$var$cast(values, name) {
  const value = values && typeof values === "string" ? [
    values
  ] : values;
  if (!value || typeof value !== "object" || !("length" in value))
    throw new Error("Invalid " + name + " `" + value + "`, expected non-empty string");
  return value;
}
function $e944ab25bc9b5b93$export$7af1228ff777d175(thing) {
  const value = (
    // @ts-expect-error looks like a node.
    thing && typeof thing === "object" && thing.type === "text" ? thing.value || "" : thing
  );
  return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
}
const $f78a485a6b780c6e$var$whitespace = /* @__PURE__ */ new Set([
  9,
  10,
  12,
  13,
  32
]);
const $f78a485a6b780c6e$var$ZERO = "0".charCodeAt(0);
const $f78a485a6b780c6e$var$NINE = "9".charCodeAt(0);
function $f78a485a6b780c6e$export$98e6a39c04603d36(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even")
    return [
      2,
      0
    ];
  else if (formula === "odd")
    return [
      2,
      1
    ];
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else
      sign = number = 0;
  }
  if (number === null || idx < formula.length)
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  return [
    a,
    sign * number
  ];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+")
      idx++;
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= $f78a485a6b780c6e$var$ZERO && formula.charCodeAt(idx) <= $f78a485a6b780c6e$var$NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - $f78a485a6b780c6e$var$ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && $f78a485a6b780c6e$var$whitespace.has(formula.charCodeAt(idx)))
      idx++;
  }
}
var $547415ca9abfdbdd$exports = {};
$547415ca9abfdbdd$exports = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  }
};
function $2623cd3fb43a925b$export$ef7acd7185315e22(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return (/* @__PURE__ */ $parcel$interopDefault($547415ca9abfdbdd$exports)).falseFunc;
  if (a === -1)
    return (index) => index <= b;
  if (a === 0)
    return (index) => index === b;
  if (a === 1)
    return b < 0 ? (/* @__PURE__ */ $parcel$interopDefault($547415ca9abfdbdd$exports)).trueFunc : (index) => index >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index) => index >= b && index % absA === bMod : (index) => index <= b && index % absA === bMod;
}
function $314464ea2a7d3765$export$2e2bcd8739ae039(formula) {
  return $2623cd3fb43a925b$export$ef7acd7185315e22($f78a485a6b780c6e$export$98e6a39c04603d36(formula));
}
const $32779e344bb57507$var$nthCheck = $314464ea2a7d3765$export$2e2bcd8739ae039.default || $314464ea2a7d3765$export$2e2bcd8739ae039;
const $32779e344bb57507$var$handle = $4515cf84e19a07d6$export$d6a12bfbbedf6185("name", {
  unknown: $32779e344bb57507$var$unknownPseudo,
  invalid: $32779e344bb57507$var$invalidPseudo,
  handlers: {
    any: $32779e344bb57507$var$matches,
    "any-link": $32779e344bb57507$var$anyLink,
    blank: $32779e344bb57507$var$blank,
    checked: $32779e344bb57507$var$checked,
    dir: $32779e344bb57507$var$dir,
    disabled: $32779e344bb57507$var$disabled,
    empty: $32779e344bb57507$var$empty,
    enabled: $32779e344bb57507$var$enabled,
    "first-child": $32779e344bb57507$var$firstChild,
    "first-of-type": $32779e344bb57507$var$firstOfType,
    has: $32779e344bb57507$var$has,
    lang: $32779e344bb57507$var$lang,
    "last-child": $32779e344bb57507$var$lastChild,
    "last-of-type": $32779e344bb57507$var$lastOfType,
    matches: $32779e344bb57507$var$matches,
    not: $32779e344bb57507$var$not,
    "nth-child": $32779e344bb57507$var$nthChild,
    "nth-last-child": $32779e344bb57507$var$nthLastChild,
    "nth-of-type": $32779e344bb57507$var$nthOfType,
    "nth-last-of-type": $32779e344bb57507$var$nthLastOfType,
    "only-child": $32779e344bb57507$var$onlyChild,
    "only-of-type": $32779e344bb57507$var$onlyOfType,
    optional: $32779e344bb57507$var$optional,
    "read-only": $32779e344bb57507$var$readOnly,
    "read-write": $32779e344bb57507$var$readWrite,
    required: $32779e344bb57507$var$required,
    root: $32779e344bb57507$var$root,
    scope: $32779e344bb57507$var$scope
  }
});
$32779e344bb57507$export$4a40d01fa098dd92.needsIndex = [
  "any",
  "first-child",
  "first-of-type",
  "last-child",
  "last-of-type",
  "matches",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-of-type",
  "nth-last-of-type",
  "only-child",
  "only-of-type"
];
function $32779e344bb57507$export$4a40d01fa098dd92(query, element, index, parent, state) {
  const pseudos = query.pseudos;
  let offset = -1;
  while (++offset < pseudos.length) {
    if (!$32779e344bb57507$var$handle(pseudos[offset], element, index, parent, state))
      return false;
  }
  return true;
}
function $32779e344bb57507$var$anyLink(_, element) {
  return (element.tagName === "a" || element.tagName === "area" || element.tagName === "link") && $987364a2ac7dd705$export$bf9617eaf5d2451(element, "href");
}
function $32779e344bb57507$var$blank(_, element) {
  return !$32779e344bb57507$var$someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text" && !$e944ab25bc9b5b93$export$7af1228ff777d175(child);
  }
}
function $32779e344bb57507$var$checked(_, element) {
  if (element.tagName === "input" || element.tagName === "menuitem")
    return Boolean(element.properties && (element.properties.type === "checkbox" || element.properties.type === "radio") && $987364a2ac7dd705$export$bf9617eaf5d2451(element, "checked"));
  if (element.tagName === "option")
    return $987364a2ac7dd705$export$bf9617eaf5d2451(element, "selected");
  return false;
}
function $32779e344bb57507$var$dir(query, _1, _2, _3, state) {
  return state.direction === query.value;
}
function $32779e344bb57507$var$disabled(_, element) {
  return (element.tagName === "button" || element.tagName === "input" || element.tagName === "select" || element.tagName === "textarea" || element.tagName === "optgroup" || element.tagName === "option" || element.tagName === "menuitem" || element.tagName === "fieldset") && $987364a2ac7dd705$export$bf9617eaf5d2451(element, "disabled");
}
function $32779e344bb57507$var$empty(_, element) {
  return !$32779e344bb57507$var$someChildren(element, check);
  function check(child) {
    return child.type === "element" || child.type === "text";
  }
}
function $32779e344bb57507$var$enabled(query, element) {
  return !$32779e344bb57507$var$disabled(query, element);
}
function $32779e344bb57507$var$firstChild(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return state.elementIndex === 0;
}
function $32779e344bb57507$var$firstOfType(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return state.typeIndex === 0;
}
function $32779e344bb57507$var$has(query, element, _1, _2, state) {
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // Do walk deep.
    shallow: false,
    // One result is enough.
    one: true,
    scopeElements: [
      element
    ],
    results: [],
    rootQuery: $daa884ef28a3b3e1$export$9141434d8c079e66(query.value)
  };
  $daa884ef28a3b3e1$export$588732934346abbf(childState, {
    type: "root",
    children: element.children
  });
  return childState.results.length > 0;
}
function $32779e344bb57507$var$lang(query, _1, _2, _3, state) {
  return state.language !== "" && state.language !== void 0 && // @ts-expect-error never `selectors`.
  $09d8790eeaaaa3c4$export$d216e65da1a9aa7e(state.language, $0c63d871a212e575$export$98e6a39c04603d36(query.value)).length > 0;
}
function $32779e344bb57507$var$lastChild(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return Boolean(state.elementCount && state.elementIndex === state.elementCount - 1);
}
function $32779e344bb57507$var$lastOfType(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return typeof state.typeIndex === "number" && typeof state.typeCount === "number" && state.typeIndex === state.typeCount - 1;
}
function $32779e344bb57507$var$matches(query, element, _, parent, state) {
  const childState = {
    ...state,
    // Not found yet.
    found: false,
    // Do walk deep.
    shallow: false,
    // One result is enough.
    one: true,
    scopeElements: [
      element
    ],
    results: [],
    rootQuery: $daa884ef28a3b3e1$export$9141434d8c079e66(query.value)
  };
  $daa884ef28a3b3e1$export$588732934346abbf(childState, element);
  return childState.results[0] === element;
}
function $32779e344bb57507$var$not(query, element, index, parent, state) {
  return !$32779e344bb57507$var$matches(query, element, index, parent, state);
}
function $32779e344bb57507$var$nthChild(query, _1, _2, _3, state) {
  const fn = $32779e344bb57507$var$getCachedNthCheck(query);
  $32779e344bb57507$var$assertDeep(state, query);
  return typeof state.elementIndex === "number" && fn(state.elementIndex);
}
function $32779e344bb57507$var$nthLastChild(query, _1, _2, _3, state) {
  const fn = $32779e344bb57507$var$getCachedNthCheck(query);
  $32779e344bb57507$var$assertDeep(state, query);
  return Boolean(typeof state.elementCount === "number" && typeof state.elementIndex === "number" && fn(state.elementCount - state.elementIndex - 1));
}
function $32779e344bb57507$var$nthLastOfType(query, _1, _2, _3, state) {
  const fn = $32779e344bb57507$var$getCachedNthCheck(query);
  $32779e344bb57507$var$assertDeep(state, query);
  return typeof state.typeCount === "number" && typeof state.typeIndex === "number" && fn(state.typeCount - 1 - state.typeIndex);
}
function $32779e344bb57507$var$nthOfType(query, _1, _2, _3, state) {
  const fn = $32779e344bb57507$var$getCachedNthCheck(query);
  $32779e344bb57507$var$assertDeep(state, query);
  return typeof state.typeIndex === "number" && fn(state.typeIndex);
}
function $32779e344bb57507$var$onlyChild(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return state.elementCount === 1;
}
function $32779e344bb57507$var$onlyOfType(query, _1, _2, _3, state) {
  $32779e344bb57507$var$assertDeep(state, query);
  return state.typeCount === 1;
}
function $32779e344bb57507$var$optional(query, element) {
  return !$32779e344bb57507$var$required(query, element);
}
function $32779e344bb57507$var$readOnly(query, element, index, parent, state) {
  return !$32779e344bb57507$var$readWrite(query, element, index, parent, state);
}
function $32779e344bb57507$var$readWrite(_, element, _1, _2, state) {
  return element.tagName === "input" || element.tagName === "textarea" ? !$987364a2ac7dd705$export$bf9617eaf5d2451(element, "readOnly") && !$987364a2ac7dd705$export$bf9617eaf5d2451(element, "disabled") : Boolean(state.editableOrEditingHost);
}
function $32779e344bb57507$var$required(_, element) {
  return (element.tagName === "input" || element.tagName === "textarea" || element.tagName === "select") && $987364a2ac7dd705$export$bf9617eaf5d2451(element, "required");
}
function $32779e344bb57507$var$root(_, element, _1, parent, state) {
  return Boolean((!parent || parent.type === "root") && state.schema && (state.schema.space === "html" || state.schema.space === "svg") && (element.tagName === "html" || element.tagName === "svg"));
}
function $32779e344bb57507$var$scope(_, element, _1, _2, state) {
  return state.scopeElements.includes(element);
}
function $32779e344bb57507$var$invalidPseudo() {
  throw new Error("Invalid pseudo-selector");
}
function $32779e344bb57507$var$unknownPseudo(query) {
  if (query.name)
    throw new Error("Unknown pseudo-selector `" + query.name + "`");
  throw new Error("Unexpected pseudo-element or empty pseudo-class");
}
function $32779e344bb57507$var$someChildren(element, check) {
  const children = element.children;
  let index = -1;
  while (++index < children.length) {
    if (check(children[index]))
      return true;
  }
  return false;
}
function $32779e344bb57507$var$assertDeep(state, query) {
  if (state.shallow)
    throw new Error("Cannot use `:" + query.name + "` without parent");
}
function $32779e344bb57507$var$getCachedNthCheck(query) {
  let fn = query._cachedFn;
  if (!fn) {
    fn = $32779e344bb57507$var$nthCheck(query.value);
    query._cachedFn = fn;
  }
  return fn;
}
function $3dcbe92ace153305$export$e0969da9b8fb378d(query, element, index, parent, state) {
  return Boolean((!query.tagName || $3bcd2419cb986896$export$a8ff84c12d48cfa6(query, element)) && (!query.classNames || $4e560857536fc474$export$2913c0c0b5623090(query, element)) && (!query.id || $fda01db12207d90d$export$d560c7e4a29451c2(query, element)) && (!query.attrs || $f1fd158f99fe7ac5$export$af4b9a83f4b00434(query, element, state.schema)) && (!query.pseudos || $32779e344bb57507$export$4a40d01fa098dd92(query, element, index, parent, state)));
}
const $daa884ef28a3b3e1$var$empty = [];
function $daa884ef28a3b3e1$export$9141434d8c079e66(query) {
  if (query === null)
    return {
      type: "selectors",
      selectors: []
    };
  if (query.type === "ruleSet")
    return {
      type: "selectors",
      selectors: [
        query
      ]
    };
  return query;
}
function $daa884ef28a3b3e1$export$588732934346abbf(state, tree) {
  if (tree)
    $daa884ef28a3b3e1$var$one(state, [], tree, void 0, void 0);
}
function $daa884ef28a3b3e1$var$one(state, currentRules, node, index, parent) {
  let nestResult = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  const exit = $e904230d8788bdad$export$b6a91203b6b36f(state, node);
  if (node.type === "element")
    nestResult = $daa884ef28a3b3e1$var$applySelectors(
      state,
      // Try the root rules for this element too.
      $daa884ef28a3b3e1$var$combine(currentRules, state.rootQuery.selectors),
      node,
      index,
      parent
    );
  if ("children" in node && !state.shallow && !(state.one && state.found))
    $daa884ef28a3b3e1$var$all(state, nestResult, node);
  exit();
  return nestResult;
}
function $daa884ef28a3b3e1$var$all(state, nest, node) {
  const fromParent = $daa884ef28a3b3e1$var$combine(nest.descendant, nest.directChild);
  let fromSibling;
  let index = -1;
  const total = {
    count: 0,
    types: /* @__PURE__ */ new Map()
  };
  const before = {
    count: 0,
    types: /* @__PURE__ */ new Map()
  };
  while (++index < node.children.length)
    $daa884ef28a3b3e1$var$count(total, node.children[index]);
  index = -1;
  while (++index < node.children.length) {
    const child = node.children[index];
    const name = child.type === "element" ? child.tagName.toUpperCase() : void 0;
    state.elementIndex = before.count;
    state.typeIndex = name ? before.types.get(name) || 0 : 0;
    state.elementCount = total.count;
    state.typeCount = name ? total.types.get(name) : 0;
    if ("children" in child) {
      const forSibling = $daa884ef28a3b3e1$var$combine(fromParent, fromSibling);
      const nest2 = $daa884ef28a3b3e1$var$one(state, forSibling, node.children[index], index, node);
      fromSibling = $daa884ef28a3b3e1$var$combine(nest2.generalSibling, nest2.adjacentSibling);
    }
    if (state.one && state.found)
      break;
    $daa884ef28a3b3e1$var$count(before, node.children[index]);
  }
}
function $daa884ef28a3b3e1$var$applySelectors(state, rules, node, index, parent) {
  const nestResult = {
    directChild: void 0,
    descendant: void 0,
    adjacentSibling: void 0,
    generalSibling: void 0
  };
  let selectorIndex = -1;
  while (++selectorIndex < rules.length) {
    const ruleSet = rules[selectorIndex];
    if (state.one && state.found)
      break;
    if (state.shallow && ruleSet.rule.rule)
      throw new Error("Expected selector without nesting");
    if ($3dcbe92ace153305$export$e0969da9b8fb378d(ruleSet.rule, node, index, parent, state)) {
      const nest = ruleSet.rule.rule;
      if (nest) {
        const rule = {
          type: "ruleSet",
          rule: nest
        };
        const label = nest.nestingOperator === "+" ? "adjacentSibling" : nest.nestingOperator === "~" ? "generalSibling" : nest.nestingOperator === ">" ? "directChild" : "descendant";
        $daa884ef28a3b3e1$var$add(nestResult, label, rule);
      } else {
        state.found = true;
        if (!state.results.includes(node))
          state.results.push(node);
      }
    }
    if (ruleSet.rule.nestingOperator === null)
      $daa884ef28a3b3e1$var$add(nestResult, "descendant", ruleSet);
    else if (ruleSet.rule.nestingOperator === "~")
      $daa884ef28a3b3e1$var$add(nestResult, "generalSibling", ruleSet);
  }
  return nestResult;
}
function $daa884ef28a3b3e1$var$combine(left, right) {
  return left && right && left.length > 0 && right.length > 0 ? [
    ...left,
    ...right
  ] : left && left.length > 0 ? left : right && right.length > 0 ? right : $daa884ef28a3b3e1$var$empty;
}
function $daa884ef28a3b3e1$var$add(nest, field, rule) {
  const list = nest[field];
  if (list)
    list.push(rule);
  else
    nest[field] = [
      rule
    ];
}
function $daa884ef28a3b3e1$var$count(counts, node) {
  if (node.type === "element") {
    const name = node.tagName.toUpperCase();
    const count = (counts.types.get(name) || 0) + 1;
    counts.count++;
    counts.types.set(name, count);
  }
}
var $79ed8fe42e9b8cf0$exports = {};
Object.defineProperty($79ed8fe42e9b8cf0$exports, "__esModule", {
  value: true
});
var $617dad7234ad1cf3$exports = {};
Object.defineProperty($617dad7234ad1cf3$exports, "__esModule", {
  value: true
});
var $92e3dae750c8c1f1$exports = {};
Object.defineProperty($92e3dae750c8c1f1$exports, "__esModule", {
  value: true
});
function $92e3dae750c8c1f1$var$isIdentStart(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "-" || c === "_";
}
$92e3dae750c8c1f1$exports.isIdentStart = $92e3dae750c8c1f1$var$isIdentStart;
function $92e3dae750c8c1f1$var$isIdent(c) {
  return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "-" || c === "_";
}
$92e3dae750c8c1f1$exports.isIdent = $92e3dae750c8c1f1$var$isIdent;
function $92e3dae750c8c1f1$var$isHex(c) {
  return c >= "a" && c <= "f" || c >= "A" && c <= "F" || c >= "0" && c <= "9";
}
$92e3dae750c8c1f1$exports.isHex = $92e3dae750c8c1f1$var$isHex;
function $92e3dae750c8c1f1$var$escapeIdentifier(s) {
  var len = s.length;
  var result = "";
  var i = 0;
  while (i < len) {
    var chr = s.charAt(i);
    if ($92e3dae750c8c1f1$exports.identSpecialChars[chr])
      result += "\\" + chr;
    else if (!(chr === "_" || chr === "-" || chr >= "A" && chr <= "Z" || chr >= "a" && chr <= "z" || i !== 0 && chr >= "0" && chr <= "9")) {
      var charCode = chr.charCodeAt(0);
      if ((charCode & 63488) === 55296) {
        var extraCharCode = s.charCodeAt(i++);
        if ((charCode & 64512) !== 55296 || (extraCharCode & 64512) !== 56320)
          throw Error("UCS-2(decode): illegal sequence");
        charCode = ((charCode & 1023) << 10) + (extraCharCode & 1023) + 65536;
      }
      result += "\\" + charCode.toString(16) + " ";
    } else
      result += chr;
    i++;
  }
  return result;
}
$92e3dae750c8c1f1$exports.escapeIdentifier = $92e3dae750c8c1f1$var$escapeIdentifier;
function $92e3dae750c8c1f1$var$escapeStr(s) {
  var len = s.length;
  var result = "";
  var i = 0;
  var replacement;
  while (i < len) {
    var chr = s.charAt(i);
    if (chr === '"')
      chr = '\\"';
    else if (chr === "\\")
      chr = "\\\\";
    else if ((replacement = $92e3dae750c8c1f1$exports.strReplacementsRev[chr]) !== void 0)
      chr = replacement;
    result += chr;
    i++;
  }
  return '"' + result + '"';
}
$92e3dae750c8c1f1$exports.escapeStr = $92e3dae750c8c1f1$var$escapeStr;
$92e3dae750c8c1f1$exports.identSpecialChars = {
  "!": true,
  '"': true,
  "#": true,
  "$": true,
  "%": true,
  "&": true,
  "'": true,
  "(": true,
  ")": true,
  "*": true,
  "+": true,
  ",": true,
  ".": true,
  "/": true,
  ";": true,
  "<": true,
  "=": true,
  ">": true,
  "?": true,
  "@": true,
  "[": true,
  "\\": true,
  "]": true,
  "^": true,
  "`": true,
  "{": true,
  "|": true,
  "}": true,
  "~": true
};
$92e3dae750c8c1f1$exports.strReplacementsRev = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\f": "\\f",
  "\v": "\\v"
};
$92e3dae750c8c1f1$exports.singleQuoteEscapeChars = {
  n: "\n",
  r: "\r",
  t: "	",
  f: "\f",
  "\\": "\\",
  "'": "'"
};
$92e3dae750c8c1f1$exports.doubleQuotesEscapeChars = {
  n: "\n",
  r: "\r",
  t: "	",
  f: "\f",
  "\\": "\\",
  '"': '"'
};
function $617dad7234ad1cf3$var$parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {
  var l = str.length;
  var chr = "";
  function getStr(quote, escapeTable) {
    var result = "";
    pos++;
    chr = str.charAt(pos);
    while (pos < l) {
      if (chr === quote) {
        pos++;
        return result;
      } else if (chr === "\\") {
        pos++;
        chr = str.charAt(pos);
        var esc = void 0;
        if (chr === quote)
          result += quote;
        else if ((esc = escapeTable[chr]) !== void 0)
          result += esc;
        else if ($92e3dae750c8c1f1$exports.isHex(chr)) {
          var hex = chr;
          pos++;
          chr = str.charAt(pos);
          while ($92e3dae750c8c1f1$exports.isHex(chr)) {
            hex += chr;
            pos++;
            chr = str.charAt(pos);
          }
          if (chr === " ") {
            pos++;
            chr = str.charAt(pos);
          }
          result += String.fromCharCode(parseInt(hex, 16));
          continue;
        } else
          result += chr;
      } else
        result += chr;
      pos++;
      chr = str.charAt(pos);
    }
    return result;
  }
  function getIdent() {
    var result = "";
    chr = str.charAt(pos);
    while (pos < l) {
      if ($92e3dae750c8c1f1$exports.isIdent(chr))
        result += chr;
      else if (chr === "\\") {
        pos++;
        if (pos >= l)
          throw Error("Expected symbol but end of file reached.");
        chr = str.charAt(pos);
        if ($92e3dae750c8c1f1$exports.identSpecialChars[chr])
          result += chr;
        else if ($92e3dae750c8c1f1$exports.isHex(chr)) {
          var hex = chr;
          pos++;
          chr = str.charAt(pos);
          while ($92e3dae750c8c1f1$exports.isHex(chr)) {
            hex += chr;
            pos++;
            chr = str.charAt(pos);
          }
          if (chr === " ") {
            pos++;
            chr = str.charAt(pos);
          }
          result += String.fromCharCode(parseInt(hex, 16));
          continue;
        } else
          result += chr;
      } else
        return result;
      pos++;
      chr = str.charAt(pos);
    }
    return result;
  }
  function skipWhitespace() {
    chr = str.charAt(pos);
    var result = false;
    while (chr === " " || chr === "	" || chr === "\n" || chr === "\r" || chr === "\f") {
      result = true;
      pos++;
      chr = str.charAt(pos);
    }
    return result;
  }
  function parse() {
    var res = parseSelector();
    if (pos < l)
      throw Error('Rule expected but "' + str.charAt(pos) + '" found.');
    return res;
  }
  function parseSelector() {
    var selector = parseSingleSelector();
    if (!selector)
      return null;
    var res = selector;
    chr = str.charAt(pos);
    while (chr === ",") {
      pos++;
      skipWhitespace();
      if (res.type !== "selectors")
        res = {
          type: "selectors",
          selectors: [
            selector
          ]
        };
      selector = parseSingleSelector();
      if (!selector)
        throw Error('Rule expected after ",".');
      res.selectors.push(selector);
    }
    return res;
  }
  function parseSingleSelector() {
    skipWhitespace();
    var selector = {
      type: "ruleSet"
    };
    var rule = parseRule();
    if (!rule)
      return null;
    var currentRule = selector;
    while (rule) {
      rule.type = "rule";
      currentRule.rule = rule;
      currentRule = rule;
      skipWhitespace();
      chr = str.charAt(pos);
      if (pos >= l || chr === "," || chr === ")")
        break;
      if (ruleNestingOperators[chr]) {
        var op = chr;
        pos++;
        skipWhitespace();
        rule = parseRule();
        if (!rule)
          throw Error('Rule expected after "' + op + '".');
        rule.nestingOperator = op;
      } else {
        rule = parseRule();
        if (rule)
          rule.nestingOperator = null;
      }
    }
    return selector;
  }
  function parseRule() {
    var rule = null;
    while (pos < l) {
      chr = str.charAt(pos);
      if (chr === "*") {
        pos++;
        (rule = rule || {}).tagName = "*";
      } else if ($92e3dae750c8c1f1$exports.isIdentStart(chr) || chr === "\\")
        (rule = rule || {}).tagName = getIdent();
      else if (chr === ".") {
        pos++;
        rule = rule || {};
        (rule.classNames = rule.classNames || []).push(getIdent());
      } else if (chr === "#") {
        pos++;
        (rule = rule || {}).id = getIdent();
      } else if (chr === "[") {
        pos++;
        skipWhitespace();
        var attr = {
          name: getIdent()
        };
        skipWhitespace();
        if (chr === "]")
          pos++;
        else {
          var operator = "";
          if (attrEqualityMods[chr]) {
            operator = chr;
            pos++;
            chr = str.charAt(pos);
          }
          if (pos >= l)
            throw Error('Expected "=" but end of file reached.');
          if (chr !== "=")
            throw Error('Expected "=" but "' + chr + '" found.');
          attr.operator = operator + "=";
          pos++;
          skipWhitespace();
          var attrValue = "";
          attr.valueType = "string";
          if (chr === '"')
            attrValue = getStr('"', $92e3dae750c8c1f1$exports.doubleQuotesEscapeChars);
          else if (chr === "'")
            attrValue = getStr("'", $92e3dae750c8c1f1$exports.singleQuoteEscapeChars);
          else if (substitutesEnabled && chr === "$") {
            pos++;
            attrValue = getIdent();
            attr.valueType = "substitute";
          } else {
            while (pos < l) {
              if (chr === "]")
                break;
              attrValue += chr;
              pos++;
              chr = str.charAt(pos);
            }
            attrValue = attrValue.trim();
          }
          skipWhitespace();
          if (pos >= l)
            throw Error('Expected "]" but end of file reached.');
          if (chr !== "]")
            throw Error('Expected "]" but "' + chr + '" found.');
          pos++;
          attr.value = attrValue;
        }
        rule = rule || {};
        (rule.attrs = rule.attrs || []).push(attr);
      } else if (chr === ":") {
        pos++;
        var pseudoName = getIdent();
        var pseudo = {
          name: pseudoName
        };
        if (chr === "(") {
          pos++;
          var value = "";
          skipWhitespace();
          if (pseudos[pseudoName] === "selector") {
            pseudo.valueType = "selector";
            value = parseSelector();
          } else {
            pseudo.valueType = pseudos[pseudoName] || "string";
            if (chr === '"')
              value = getStr('"', $92e3dae750c8c1f1$exports.doubleQuotesEscapeChars);
            else if (chr === "'")
              value = getStr("'", $92e3dae750c8c1f1$exports.singleQuoteEscapeChars);
            else if (substitutesEnabled && chr === "$") {
              pos++;
              value = getIdent();
              pseudo.valueType = "substitute";
            } else {
              while (pos < l) {
                if (chr === ")")
                  break;
                value += chr;
                pos++;
                chr = str.charAt(pos);
              }
              value = value.trim();
            }
            skipWhitespace();
          }
          if (pos >= l)
            throw Error('Expected ")" but end of file reached.');
          if (chr !== ")")
            throw Error('Expected ")" but "' + chr + '" found.');
          pos++;
          pseudo.value = value;
        }
        rule = rule || {};
        (rule.pseudos = rule.pseudos || []).push(pseudo);
      } else
        break;
    }
    return rule;
  }
  return parse();
}
$617dad7234ad1cf3$exports.parseCssSelector = $617dad7234ad1cf3$var$parseCssSelector;
var $f5d92bef1bc337ec$exports = {};
Object.defineProperty($f5d92bef1bc337ec$exports, "__esModule", {
  value: true
});
function $f5d92bef1bc337ec$var$renderEntity(entity) {
  var res = "";
  switch (entity.type) {
    case "ruleSet":
      var currentEntity = entity.rule;
      var parts = [];
      while (currentEntity) {
        if (currentEntity.nestingOperator)
          parts.push(currentEntity.nestingOperator);
        parts.push($f5d92bef1bc337ec$var$renderEntity(currentEntity));
        currentEntity = currentEntity.rule;
      }
      res = parts.join(" ");
      break;
    case "selectors":
      res = entity.selectors.map($f5d92bef1bc337ec$var$renderEntity).join(", ");
      break;
    case "rule":
      if (entity.tagName) {
        if (entity.tagName === "*")
          res = "*";
        else
          res = $92e3dae750c8c1f1$exports.escapeIdentifier(entity.tagName);
      }
      if (entity.id)
        res += "#" + $92e3dae750c8c1f1$exports.escapeIdentifier(entity.id);
      if (entity.classNames)
        res += entity.classNames.map(function(cn) {
          return "." + $92e3dae750c8c1f1$exports.escapeIdentifier(cn);
        }).join("");
      if (entity.attrs)
        res += entity.attrs.map(function(attr) {
          if ("operator" in attr) {
            if (attr.valueType === "substitute")
              return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + attr.operator + "$" + attr.value + "]";
            else
              return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + attr.operator + $92e3dae750c8c1f1$exports.escapeStr(attr.value) + "]";
          } else
            return "[" + $92e3dae750c8c1f1$exports.escapeIdentifier(attr.name) + "]";
        }).join("");
      if (entity.pseudos)
        res += entity.pseudos.map(function(pseudo) {
          if (pseudo.valueType) {
            if (pseudo.valueType === "selector")
              return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + $f5d92bef1bc337ec$var$renderEntity(pseudo.value) + ")";
            else if (pseudo.valueType === "substitute")
              return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "($" + pseudo.value + ")";
            else if (pseudo.valueType === "numeric")
              return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + pseudo.value + ")";
            else
              return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name) + "(" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.value) + ")";
          } else
            return ":" + $92e3dae750c8c1f1$exports.escapeIdentifier(pseudo.name);
        }).join("");
      break;
    default:
      throw Error('Unknown entity type: "' + entity.type + '".');
  }
  return res;
}
$f5d92bef1bc337ec$exports.renderEntity = $f5d92bef1bc337ec$var$renderEntity;
var $79ed8fe42e9b8cf0$var$CssSelectorParser = (
  /** @class */
  function() {
    function CssSelectorParser() {
      this.pseudos = {};
      this.attrEqualityMods = {};
      this.ruleNestingOperators = {};
      this.substitutesEnabled = false;
    }
    CssSelectorParser.prototype.registerSelectorPseudos = function() {
      var pseudos = [];
      for (var _i = 0; _i < arguments.length; _i++)
        pseudos[_i] = arguments[_i];
      for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {
        var pseudo = pseudos_1[_a];
        this.pseudos[pseudo] = "selector";
      }
      return this;
    };
    CssSelectorParser.prototype.unregisterSelectorPseudos = function() {
      var pseudos = [];
      for (var _i = 0; _i < arguments.length; _i++)
        pseudos[_i] = arguments[_i];
      for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {
        var pseudo = pseudos_2[_a];
        delete this.pseudos[pseudo];
      }
      return this;
    };
    CssSelectorParser.prototype.registerNumericPseudos = function() {
      var pseudos = [];
      for (var _i = 0; _i < arguments.length; _i++)
        pseudos[_i] = arguments[_i];
      for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {
        var pseudo = pseudos_3[_a];
        this.pseudos[pseudo] = "numeric";
      }
      return this;
    };
    CssSelectorParser.prototype.unregisterNumericPseudos = function() {
      var pseudos = [];
      for (var _i = 0; _i < arguments.length; _i++)
        pseudos[_i] = arguments[_i];
      for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {
        var pseudo = pseudos_4[_a];
        delete this.pseudos[pseudo];
      }
      return this;
    };
    CssSelectorParser.prototype.registerNestingOperators = function() {
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++)
        operators[_i] = arguments[_i];
      for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {
        var operator = operators_1[_a];
        this.ruleNestingOperators[operator] = true;
      }
      return this;
    };
    CssSelectorParser.prototype.unregisterNestingOperators = function() {
      var operators = [];
      for (var _i = 0; _i < arguments.length; _i++)
        operators[_i] = arguments[_i];
      for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {
        var operator = operators_2[_a];
        delete this.ruleNestingOperators[operator];
      }
      return this;
    };
    CssSelectorParser.prototype.registerAttrEqualityMods = function() {
      var mods = [];
      for (var _i = 0; _i < arguments.length; _i++)
        mods[_i] = arguments[_i];
      for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {
        var mod = mods_1[_a];
        this.attrEqualityMods[mod] = true;
      }
      return this;
    };
    CssSelectorParser.prototype.unregisterAttrEqualityMods = function() {
      var mods = [];
      for (var _i = 0; _i < arguments.length; _i++)
        mods[_i] = arguments[_i];
      for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {
        var mod = mods_2[_a];
        delete this.attrEqualityMods[mod];
      }
      return this;
    };
    CssSelectorParser.prototype.enableSubstitutes = function() {
      this.substitutesEnabled = true;
      return this;
    };
    CssSelectorParser.prototype.disableSubstitutes = function() {
      this.substitutesEnabled = false;
      return this;
    };
    CssSelectorParser.prototype.parse = function(str) {
      return $617dad7234ad1cf3$exports.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);
    };
    CssSelectorParser.prototype.render = function(path) {
      return $f5d92bef1bc337ec$exports.renderEntity(path).trim();
    };
    return CssSelectorParser;
  }()
);
$79ed8fe42e9b8cf0$exports.CssSelectorParser = $79ed8fe42e9b8cf0$var$CssSelectorParser;
const $1313968c046283b7$var$parser = new $79ed8fe42e9b8cf0$exports.CssSelectorParser();
$1313968c046283b7$var$parser.registerAttrEqualityMods("~", "|", "^", "$", "*");
$1313968c046283b7$var$parser.registerSelectorPseudos("any", "matches", "not", "has");
$1313968c046283b7$var$parser.registerNestingOperators(">", "+", "~");
function $1313968c046283b7$export$98e6a39c04603d36(selector) {
  if (typeof selector !== "string")
    throw new TypeError("Expected `string` as selector, not `" + selector + "`");
  return $1313968c046283b7$var$parser.parse(selector);
}
function $3c8bc001a91ed78a$export$de994efd351b291c(selector, node, space) {
  const state = $3c8bc001a91ed78a$var$createState(selector, node, space);
  state.one = true;
  state.shallow = true;
  $daa884ef28a3b3e1$export$588732934346abbf(state, node || void 0);
  return state.results.length > 0;
}
function $3c8bc001a91ed78a$export$2e6c959c16ff56b8(selector, tree, space) {
  const state = $3c8bc001a91ed78a$var$createState(selector, tree, space);
  state.one = true;
  $daa884ef28a3b3e1$export$588732934346abbf(state, tree || void 0);
  return state.results[0] || null;
}
function $3c8bc001a91ed78a$export$90aca4adda6ff0f5(selector, tree, space) {
  const state = $3c8bc001a91ed78a$var$createState(selector, tree, space);
  $daa884ef28a3b3e1$export$588732934346abbf(state, tree || void 0);
  return state.results;
}
function $3c8bc001a91ed78a$var$createState(selector, tree, space) {
  return {
    // State of the query.
    rootQuery: $daa884ef28a3b3e1$export$9141434d8c079e66($1313968c046283b7$export$98e6a39c04603d36(selector)),
    results: [],
    // @ts-expect-error assume elements.
    scopeElements: tree ? tree.type === "root" ? tree.children : [
      tree
    ] : [],
    one: false,
    shallow: false,
    found: false,
    // State in the tree.
    schema: space === "svg" ? $ecf66900736272d0$export$7ed1367e7fa1ad68 : $ecf66900736272d0$export$c0bb0b647f701bb5,
    language: void 0,
    direction: "ltr",
    editableOrEditingHost: false,
    typeIndex: void 0,
    elementIndex: void 0,
    typeCount: void 0,
    elementCount: void 0
  };
}
const { selectAll: $283f418c0f57366a$var$selectAll } = $eb0fced0eff13ef9$exports;
$283f418c0f57366a$exports = (additions) => {
  const adders = Object.entries(additions).map($283f418c0f57366a$var$adder);
  return (node) => adders.forEach((a) => a(node));
};
const $283f418c0f57366a$var$adder = ([selector, className]) => {
  const writer = $283f418c0f57366a$var$write(className);
  return (node) => $283f418c0f57366a$var$selectAll(selector, node).forEach(writer);
};
const $283f418c0f57366a$var$write = (className) => {
  return ({ properties }) => {
    if (!properties.className)
      properties.className = className;
    else
      properties.className += ` ${className}`;
  };
};
var $01baaa270549c889$exports = {};
$01baaa270549c889$exports = () => {
  let handleOgContent;
  return {
    markup: ({ content, filename }) => {
      if (typeof filename === "undefined")
        return;
      if (!filename.endsWith("+page.md"))
        return;
      if (!handleOgContent)
        handleOgContent = parcelRequire("6PNpJ");
      return {
        code: handleOgContent + content
      };
    },
    script: ({ content, filename, attributes }) => {
      if (typeof filename === "undefined")
        return;
      if (attributes.context !== "module")
        return;
      if (!filename.endsWith("+page.md"))
        return;
      if (!content.includes("export const metadata ="))
        return {
          code: content + ";const metadata = undefined;"
        };
      else
        return {
          code: content.replace("export const metadata =", "const metadata =")
        };
    }
  };
};
var $b3bc6995532c53ea$exports = {};
function $b3bc6995532c53ea$var$injectPartials(originalString) {
  const r = /\{@partial\s+"(.*?)"\s*\}/g;
  for (const match of originalString.matchAll(r) ?? []) {
    const filename = match[1];
    const content = readFileSync(`./partials/${filename}`).toString();
    originalString = originalString.replace(match[0], content);
  }
  return originalString;
}
$b3bc6995532c53ea$exports = {
  markup: ({ content, filename }) => {
    if (typeof filename === "undefined")
      return;
    if (!filename.endsWith("+page.md"))
      return;
    return {
      code: $b3bc6995532c53ea$var$injectPartials(content)
    };
  },
  injectPartials: $b3bc6995532c53ea$var$injectPartials
};
$3fd82c6737eb24ad$exports = function evidencePreprocess(componentDevelopmentMode = false) {
  return [
    $b3bc6995532c53ea$exports,
    $bb8aaf4d81463a1b$exports(componentDevelopmentMode),
    $560639d49e3c9a19$export$d61cf7a1924293cc({
      extensions: [
        ".md"
      ],
      smartypants: {
        quotes: false,
        ellipses: true,
        backticks: true,
        dashes: "oldschool"
      },
      highlight: {
        highlighter: $3fd82c6737eb24ad$require$highlighter
      },
      rehypePlugins: [
        [
          $283f418c0f57366a$exports,
          {
            "*": "markdown"
          }
        ]
      ]
    }),
    // Add both script tags to all markdown files, if they are missing
    $7d9f7d1f69c18b39$exports,
    $01baaa270549c889$exports()
  ];
};
$3fd82c6737eb24ad$exports.parseFrontmatter = parcelRequire("ljm8s").parseFrontmatter;
$3fd82c6737eb24ad$exports.extractQueries = $3bc517d55346f2bb$exports.extractQueries;
$3fd82c6737eb24ad$exports.getQueryIds = $3bc517d55346f2bb$exports.getQueryIds;
$3fd82c6737eb24ad$exports.injectPartials = $b3bc6995532c53ea$exports.injectPartials;
export {
  $3fd82c6737eb24ad$exports as $
};
